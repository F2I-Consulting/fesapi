/* gsoap_eml2_3Stub.h
   Generated by gSOAP 2.8.111E for eml2_3ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use, no resale/redistribution.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_resqml22	"http://www.energistics.org/energyml/data/resqmlv2"
#define SOAP_NAMESPACE_OF_eml23	"http://www.energistics.org/energyml/data/commonv2"
#include <time.h>

#ifndef gsoap_eml2_3Stub_H
#define gsoap_eml2_3Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 208111
# error "GSOAP VERSION 208111 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_eml2_3 {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* eml2_3ForGsoap.h:2259 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GrowingStatusKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__GrowingStatusKind (-941)

/* eml23:GrowingStatusKind */
enum class eml23__GrowingStatusKind {
	active = 0,
	inactive = 1
};
#endif

/* eml2_3ForGsoap.h:2285 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IndexableElement
#define SOAP_TYPE_gsoap_eml2_3_eml23__IndexableElement (-942)

/* eml23:IndexableElement */
enum class eml23__IndexableElement {
	cells = 0,
	intervals_x0020from_x0020datum = 1,
	column_x0020edges = 2,
	columns = 3,
	contacts = 4,
	coordinate_x0020lines = 5,
	edges = 6,
	edges_x0020per_x0020column = 7,
	enumerated_x0020elements = 8,
	faces = 9,
	faces_x0020per_x0020cell = 10,
	interval_x0020edges = 11,
	intervals = 12,
	I0 = 13,
	I0_x0020edges = 14,
	J0 = 15,
	J0_x0020edges = 16,
	layers = 17,
	lines = 18,
	nodes = 19,
	nodes_x0020per_x0020cell = 20,
	nodes_x0020per_x0020edge = 21,
	nodes_x0020per_x0020face = 22,
	patches = 23,
	pillars = 24,
	regions = 25,
	representation = 26,
	subnodes = 27,
	triangles = 28
};
#endif

/* eml2_3ForGsoap.h:2358 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NorthReferenceKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__NorthReferenceKind (-943)

/* eml23:NorthReferenceKind */
enum class eml23__NorthReferenceKind {
	astronomic_x0020north = 0,
	compass_x0020north = 1,
	grid_x0020north = 2,
	magnetic_x0020north = 3,
	plant_x0020north = 4,
	true_x0020north = 5
};
#endif

/* eml2_3ForGsoap.h:2386 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointType
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointType (-947)

/* eml23:FloatingPointType */
enum class eml23__FloatingPointType {
	arrayOfFloat32LE = 0,
	arrayOfDouble64LE = 1,
	arrayOfFloat32BE = 2,
	arrayOfDouble64BE = 3
};
#endif

/* eml2_3ForGsoap.h:2396 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerType
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerType (-948)

/* eml23:IntegerType */
enum class eml23__IntegerType {
	arrayOfInt8 = 0,
	arrayOfUInt8 = 1,
	arrayOfInt16LE = 2,
	arrayOfInt32LE = 3,
	arrayOfInt64LE = 4,
	arrayOfUInt16LE = 5,
	arrayOfUInt32LE = 6,
	arrayOfUInt64LE = 7,
	arrayOfInt16BE = 8,
	arrayOfInt32BE = 9,
	arrayOfInt64BE = 10,
	arrayOfUInt16BE = 11,
	arrayOfUInt32BE = 12,
	arrayOfUInt64BE = 13
};
#endif

/* eml2_3ForGsoap.h:2440 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AxisDirectionKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__AxisDirectionKind (-954)

/* eml23:AxisDirectionKind */
enum class eml23__AxisDirectionKind {
	aft = 0,
	away_from = 1,
	clockwise = 2,
	column_negative = 3,
	column_positive = 4,
	counter_clockwise = 5,
	display_down = 6,
	display_left = 7,
	display_right = 8,
	display_up = 9,
	down = 10,
	east = 11,
	east_north_east = 12,
	east_south_east = 13,
	forward = 14,
	future = 15,
	geocentric_x0020x = 16,
	geocentric_x0020y = 17,
	geocentric_x0020z = 18,
	north = 19,
	north_east = 20,
	north_north_east = 21,
	north_north_west = 22,
	north_west = 23,
	past = 24,
	port = 25,
	row_negative = 26,
	row_positive = 27,
	south = 28,
	south_east = 29,
	south_south_east = 30,
	south_south_west = 31,
	south_west = 32,
	starboard = 33,
	towards = 34,
	up = 35,
	west = 36,
	west_north_west = 37,
	west_south_west = 38
};
#endif

/* eml2_3ForGsoap.h:2536 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyUnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyUnitOfMeasure (-961)

/* eml23:LegacyUnitOfMeasure */
enum class eml23__LegacyUnitOfMeasure {
	_1000scf_x002fd = 0,
	_1000scf_x002fmo = 1,
	_1000scf_x002fstb = 2,
	_1000scm = 3,
	_1000scm_x002fd = 4,
	_1000scm_x002fmo = 5,
	_1000stb = 6,
	_1000stb_x002fd = 7,
	_1000stb_x002fmo = 8,
	_1E6scf = 9,
	_1E6scf_x002fd = 10,
	_1E6scf_x002fmo = 11,
	_1E6scf_x002fstb = 12,
	_1E6scm = 13,
	_1E6scm_x002fd = 14,
	_1E6scm_x002fmo = 15,
	_1E6stb = 16,
	_1E6stb_x002facre = 17,
	_1E6stb_x002facre_x002eft = 18,
	_1E6stb_x002fd = 19,
	_1E6stb_x002fmo = 20,
	_1E9scf = 21,
	acre_x002eft_x002f1E6stb = 22,
	bbl_x002f1000scf = 23,
	bbl_x002f1E6scf = 24,
	bbl_x002fscf = 25,
	bbl_x002fstb = 26,
	ft3_x002fscf = 27,
	ft3_x002fstb = 28,
	galUS_x002f1000scf = 29,
	kg_x002fscm = 30,
	kscf = 31,
	lbm_x002f1000scf = 32,
	lbm_x002f1E6scf = 33,
	m3_x002fscm = 34,
	ml_x002fscm = 35,
	Pa_x002fscm = 36,
	psi_x002f1000scf = 37,
	psi_x002f1E6scf = 38,
	psia = 39,
	psig = 40,
	scf = 41,
	scf_x002fbbl = 42,
	scf_x002fd = 43,
	scf_x002fft2 = 44,
	scf_x002fft3 = 45,
	scf_x002fscf = 46,
	scf_x002fstb = 47,
	scm = 48,
	scm_x002fd = 49,
	scm_x002fh = 50,
	scm_x002fm2 = 51,
	scm_x002fm3 = 52,
	scm_x002fmo = 53,
	scm_x002fs = 54,
	scm_x002fscm = 55,
	scm_x002fstb = 56,
	stb = 57,
	stb_x002f1000scf = 58,
	stb_x002f1000scm = 59,
	stb_x002f1E6scf = 60,
	stb_x002f1E6scm = 61,
	stb_x002facre = 62,
	stb_x002fbbl = 63,
	stb_x002fd = 64,
	stb_x002fmo = 'A',
	stb_x002fscm = 'B',
	stb_x002fstb = 'C'
};
#endif

/* eml2_3ForGsoap.h:2614 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasure (-962)

/* eml23:UnitOfMeasure */
enum class eml23__UnitOfMeasure {
	A = 'A',
	a = 'a',
	B = 'B',
	b = 'b',
	C = 'C',
	d = 'd',
	D = 'D',
	F = 'F',
	g = 'g',
	H = 'H',
	h = 'h',
	J = 'J',
	K = 'K',
	L = 'L',
	m = 'm',
	N = 'N',
	O = 'O',
	P = 'P',
	S = 'S',
	s = 's',
	t = 't',
	T = 'T',
	V = 'V',
	W = 'W',
	_x0025 = 'u',
	_x0025_x005barea_x005d = 'v',
	_x0025_x005bmass_x005d = 'w',
	_x0025_x005bmolar_x005d = 'x',
	_x0025_x005bvol_x005d = 'y',
	_x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 'z',
	_x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 123,
	_x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 124,
	_0_x002e001_x0020bbl_x002fft3 = 125,
	_0_x002e001_x0020bbl_x002fm3 = 126,
	_0_x002e001_x0020d_x002fft3 = 127,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 128,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 129,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 130,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 131,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 132,
	_0_x002e001_x0020h_x002fft = 133,
	_0_x002e001_x0020kPa2_x002fcP = 134,
	_0_x002e001_x0020lbm_x002fbbl = 135,
	_0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 136,
	_0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 137,
	_0_x002e001_x0020psi_x002fft = 138,
	_0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 139,
	_0_x002e001_x0020seca = 140,
	_0_x002e01_x0020bbl_x002fbbl = 141,
	_0_x002e01_x0020dega_x002fft = 142,
	_0_x002e01_x0020degF_x002fft = 143,
	_0_x002e01_x0020dm3_x002fkm = 144,
	_0_x002e01_x0020ft_x002fft = 145,
	_0_x002e01_x0020grain_x002fft3 = 146,
	_0_x002e01_x0020L_x002fkg = 147,
	_0_x002e01_x0020L_x002fkm = 148,
	_0_x002e01_x0020lbf_x002fft = 149,
	_0_x002e01_x0020lbf_x002fft2 = 150,
	_0_x002e01_x0020lbm_x002fft2 = 151,
	_0_x002e01_x0020psi_x002fft = 152,
	_0_x002e1_x0020ft = 153,
	_0_x002e1_x0020ft_x005bUS_x005d = 154,
	_0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 155,
	_0_x002e1_x0020in = 156,
	_0_x002e1_x0020L_x002fbbl = 157,
	_0_x002e1_x0020lbm_x002fbbl = 158,
	_0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 159,
	_0_x002e1_x0020yd = 160,
	_1_x002f_x0028kg_x002es_x0029 = 161,
	_1_x002f16_x0020in = 162,
	_1_x002f2_x0020ft = 163,
	_1_x002f2_x0020ms = 164,
	_1_x002f30_x0020cm3_x002fmin = 165,
	_1_x002f30_x0020dega_x002fft = 166,
	_1_x002f30_x0020dega_x002fm = 167,
	_1_x002f30_x0020lbf_x002fm = 168,
	_1_x002f30_x0020m_x002fm = 169,
	_1_x002f30_x0020N_x002fm = 170,
	_1_x002f32_x0020in = 171,
	_1_x002f64_x0020in = 172,
	_1_x002fa = 173,
	_1_x002fangstrom = 174,
	_1_x002fbar = 175,
	_1_x002fbbl = 176,
	_1_x002fcm = 177,
	_1_x002fd = 178,
	_1_x002fdegC = 179,
	_1_x002fdegF = 180,
	_1_x002fdegR = 181,
	_1_x002fft = 182,
	_1_x002fft2 = 183,
	_1_x002fft3 = 184,
	_1_x002fg = 185,
	_1_x002fgal_x005bUK_x005d = 186,
	_1_x002fgal_x005bUS_x005d = 187,
	_1_x002fH = 188,
	_1_x002fh = 189,
	_1_x002fin = 190,
	_1_x002fK = 191,
	_1_x002fkg = 192,
	_1_x002fkm2 = 193,
	_1_x002fkPa = 194,
	_1_x002fL = 195,
	_1_x002flbf = 196,
	_1_x002flbm = 197,
	_1_x002fm = 198,
	_1_x002fm2 = 199,
	_1_x002fm3 = 200,
	_1_x002fmi = 201,
	_1_x002fmi2 = 202,
	_1_x002fmin = 203,
	_1_x002fmm = 204,
	_1_x002fms = 205,
	_1_x002fN = 206,
	_1_x002fnm = 207,
	_1_x002fPa = 208,
	_1_x002fpPa = 209,
	_1_x002fpsi = 210,
	_1_x002fs = 211,
	_1_x002fupsi = 212,
	_1_x002fus = 213,
	_1_x002fuV = 214,
	_1_x002fV = 215,
	_1_x002fwk = 216,
	_1_x002fyd = 217,
	_10_x0020ft = 218,
	_10_x0020in = 219,
	_10_x0020km = 220,
	_10_x0020kN = 221,
	_10_x0020Mg_x002fm3 = 222,
	_100_x0020ft = 223,
	_100_x0020ka_x005bt_x005d = 224,
	_100_x0020km = 225,
	_1000_x0020bbl = 226,
	_1000_x0020bbl_x002eft_x002fd = 227,
	_1000_x0020bbl_x002fd = 228,
	_1000_x0020ft = 229,
	_1000_x0020ft_x002fh = 230,
	_1000_x0020ft_x002fs = 231,
	_1000_x0020ft3 = 232,
	_1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 233,
	_1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 234,
	_1000_x0020ft3_x002fbbl = 235,
	_1000_x0020ft3_x002fd = 236,
	_1000_x0020gal_x005bUK_x005d = 237,
	_1000_x0020gal_x005bUS_x005d = 238,
	_1000_x0020lbf_x002eft = 239,
	_1000_x0020m3 = 240,
	_1000_x0020m3_x002f_x0028d_x002em_x0029 = 241,
	_1000_x0020m3_x002f_x0028h_x002em_x0029 = 242,
	_1000_x0020m3_x002fd = 243,
	_1000_x0020m3_x002fh = 244,
	_1000_x0020m3_x002fm3 = 245,
	_1000_x0020m4_x002fd = 246,
	_1E12_x0020ft3 = 247,
	_1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 248,
	_1E_6_x0020acre_x002eft_x002fbbl = 249,
	_1E6_x0020bbl = 250,
	_1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 251,
	_1E6_x0020bbl_x002facre = 252,
	_1E6_x0020bbl_x002fd = 253,
	_1E_6_x0020bbl_x002fft3 = 254,
	_1E_6_x0020bbl_x002fm3 = 255,
	_1E6_x0020Btu_x005bIT_x005d = 256,
	_1E6_x0020Btu_x005bIT_x005d_x002fh = 257,
	_1E6_x0020ft3 = 258,
	_1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 259,
	_1E6_x0020ft3_x002fbbl = 260,
	_1E6_x0020ft3_x002fd = 261,
	_1E_6_x0020gal_x005bUS_x005d = 262,
	_1E6_x0020lbm_x002fa = 263,
	_1E6_x0020m3 = 264,
	_1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = 265,
	_1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = 266,
	_1E6_x0020m3_x002fd = 267,
	_1E_9_x00201_x002fft = 268,
	_1E9_x0020bbl = 269,
	_1E9_x0020ft3 = 270,
	_30_x0020ft = 271,
	_30_x0020m = 272,
	A_x002eh = 273,
	A_x002em2 = 274,
	A_x002es = 275,
	A_x002es_x002fkg = 276,
	A_x002es_x002fm3 = 277,
	A_x002fcm2 = 278,
	A_x002fft2 = 279,
	A_x002fm = 280,
	A_x002fm2 = 281,
	A_x002fmm = 282,
	A_x002fmm2 = 283,
	a_x005bt_x005d = 284,
	acre = 285,
	acre_x002eft = 286,
	ag = 287,
	aJ = 288,
	angstrom = 289,
	at = 290,
	atm = 291,
	atm_x002fft = 292,
	atm_x002fh = 293,
	atm_x002fhm = 294,
	atm_x002fm = 295,
	B_x002eW = 296,
	b_x002fcm3 = 297,
	B_x002fm = 298,
	B_x002fO = 299,
	bar = 300,
	bar_x002fh = 301,
	bar_x002fkm = 302,
	bar_x002fm = 303,
	bar2 = 304,
	bar2_x002fcP = 305,
	bbl = 306,
	bbl_x002f_x0028acre_x002eft_x0029 = 307,
	bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 308,
	bbl_x002f_x0028d_x002eft_x0029 = 309,
	bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 310,
	bbl_x002f_x0028kPa_x002ed_x0029 = 311,
	bbl_x002f_x0028psi_x002ed_x0029 = 312,
	bbl_x002facre = 313,
	bbl_x002fbbl = 314,
	bbl_x002fd = 315,
	bbl_x002fd2 = 316,
	bbl_x002fft = 317,
	bbl_x002fft3 = 318,
	bbl_x002fh = 319,
	bbl_x002fh2 = 320,
	bbl_x002fin = 321,
	bbl_x002fm3 = 322,
	bbl_x002fmi = 323,
	bbl_x002fmin = 324,
	bbl_x002fpsi = 325,
	bbl_x002fton_x005bUK_x005d = 326,
	bbl_x002fton_x005bUS_x005d = 327,
	Bd = 328,
	bit = 329,
	bit_x002fs = 330,
	Bq = 331,
	Bq_x002fkg = 332,
	Btu_x005bIT_x005d = 333,
	Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = 334,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = 335,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 336,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = 337,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = 338,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 339,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = 340,
	Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 341,
	Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 342,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = 343,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = 344,
	Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = 345,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 346,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = 347,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 348,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = 349,
	Btu_x005bIT_x005d_x002fbbl = 350,
	Btu_x005bIT_x005d_x002fft3 = 351,
	Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 352,
	Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 353,
	Btu_x005bIT_x005d_x002fh = 354,
	Btu_x005bIT_x005d_x002flbm = 355,
	Btu_x005bIT_x005d_x002flbmol = 356,
	Btu_x005bIT_x005d_x002fmin = 357,
	Btu_x005bIT_x005d_x002fs = 358,
	Btu_x005bth_x005d = 359,
	Btu_x005bUK_x005d = 360,
	byte = 361,
	byte_x002fs = 362,
	C_x002em = 363,
	C_x002fcm2 = 364,
	C_x002fcm3 = 365,
	C_x002fg = 366,
	C_x002fkg = 367,
	C_x002fm2 = 368,
	C_x002fm3 = 369,
	C_x002fmm2 = 370,
	C_x002fmm3 = 371,
	ca = 372,
	cA = 373,
	cal_x005bIT_x005d = 374,
	cal_x005bth_x005d = 375,
	cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = 376,
	cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = 377,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 378,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = 379,
	cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 380,
	cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = 381,
	cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = 382,
	cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = 383,
	cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 384,
	cal_x005bth_x005d_x002fcm3 = 385,
	cal_x005bth_x005d_x002fg = 386,
	cal_x005bth_x005d_x002fh = 387,
	cal_x005bth_x005d_x002fkg = 388,
	cal_x005bth_x005d_x002flbm = 389,
	cal_x005bth_x005d_x002fmL = 390,
	cal_x005bth_x005d_x002fmm3 = 391,
	cC = 392,
	ccal_x005bth_x005d = 393,
	ccgr = 394,
	cd = 395,
	cd_x002fm2 = 396,
	cEuc = 397,
	ceV = 398,
	cF = 399,
	cg = 400,
	cgauss = 401,
	cgr = 402,
	cGy = 403,
	cH = 404,
	chain = 405,
	chain_x005bBnA_x005d = 406,
	chain_x005bBnB_x005d = 407,
	chain_x005bCla_x005d = 408,
	chain_x005bInd37_x005d = 409,
	chain_x005bSe_x005d = 410,
	chain_x005bSeT_x005d = 411,
	chain_x005bUS_x005d = 412,
	cHz = 413,
	Ci = 414,
	cJ = 415,
	cm = 416,
	cm_x002fa = 417,
	cm_x002fs = 418,
	cm_x002fs2 = 419,
	cm2 = 420,
	cm2_x002fg = 421,
	cm2_x002fs = 422,
	cm3 = 423,
	cm3_x002fcm3 = 424,
	cm3_x002fg = 425,
	cm3_x002fh = 426,
	cm3_x002fL = 427,
	cm3_x002fm3 = 428,
	cm3_x002fmin = 429,
	cm3_x002fs = 430,
	cm4 = 431,
	cmH2O_x005b4degC_x005d = 432,
	cN = 433,
	cohm = 434,
	cP = 435,
	cPa = 436,
	crd = 437,
	cS = 438,
	cs = 439,
	cSt = 440,
	cT = 441,
	ct = 442,
	cu = 443,
	cV = 444,
	cW = 445,
	cWb = 446,
	cwt_x005bUK_x005d = 447,
	cwt_x005bUS_x005d = 448,
	D_x002eft = 449,
	D_x002em = 450,
	D_x002f_x0028Pa_x002es_x0029 = 451,
	d_x002fbbl = 452,
	D_x002fcP = 453,
	d_x002fft3 = 454,
	d_x002fm3 = 455,
	D_x005bAPI_x005d = 456,
	dA = 457,
	dam = 458,
	daN = 459,
	daN_x002em = 460,
	dAPI = 461,
	dB = 462,
	dB_x002emW = 463,
	dB_x002eMW = 464,
	dB_x002eW = 465,
	dB_x002fft = 466,
	dB_x002fkm = 467,
	dB_x002fm = 468,
	dB_x002fO = 469,
	dC = 470,
	dcal_x005bth_x005d = 471,
	dega = 472,
	dega_x002fft = 473,
	dega_x002fh = 474,
	dega_x002fm = 475,
	dega_x002fmin = 476,
	dega_x002fs = 477,
	degC = 478,
	degC_x002em2_x002eh_x002fkcal_x005bth_x005d = 479,
	degC_x002fft = 480,
	degC_x002fh = 481,
	degC_x002fhm = 482,
	degC_x002fkm = 483,
	degC_x002fkPa = 484,
	degC_x002fm = 485,
	degC_x002fmin = 486,
	degC_x002fs = 487,
	degF = 488,
	degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 489,
	degF_x002fft = 490,
	degF_x002fh = 491,
	degF_x002fm = 492,
	degF_x002fmin = 493,
	degF_x002fpsi = 494,
	degF_x002fs = 495,
	degR = 496,
	dEuc = 497,
	deV = 498,
	dF = 499,
	dgauss = 500,
	dGy = 501,
	dH = 502,
	dHz = 503,
	dJ = 504,
	dm = 505,
	dm_x002fs = 506,
	dm3 = 507,
	dm3_x002f_x0028kW_x002eh_x0029 = 508,
	dm3_x002fkg = 509,
	dm3_x002fkmol = 510,
	dm3_x002fm = 511,
	dm3_x002fm3 = 512,
	dm3_x002fMJ = 513,
	dm3_x002fs = 514,
	dm3_x002fs2 = 515,
	dm3_x002ft = 516,
	dN = 517,
	dN_x002em = 518,
	dohm = 519,
	dP = 520,
	dPa = 521,
	drd = 522,
	dS = 523,
	ds = 524,
	dT = 525,
	dV = 526,
	dW = 527,
	dWb = 528,
	dyne = 529,
	dyne_x002ecm2 = 530,
	dyne_x002es_x002fcm2 = 531,
	dyne_x002fcm = 532,
	dyne_x002fcm2 = 533,
	EA = 534,
	Ea_x005bt_x005d = 535,
	EC = 536,
	Ecal_x005bth_x005d = 537,
	EEuc = 538,
	EeV = 539,
	EF = 540,
	Eg = 541,
	Egauss = 542,
	EGy = 543,
	EH = 544,
	EHz = 545,
	EJ = 546,
	EJ_x002fa = 547,
	Em = 548,
	EN = 549,
	Eohm = 550,
	EP = 551,
	EPa = 552,
	Erd = 553,
	erg = 554,
	erg_x002fa = 555,
	erg_x002fcm2 = 556,
	erg_x002fcm3 = 557,
	erg_x002fg = 558,
	erg_x002fkg = 559,
	erg_x002fm3 = 560,
	ES = 561,
	ET = 562,
	Euc = 563,
	eV = 564,
	EW = 565,
	EWb = 566,
	F_x002fm = 567,
	fa = 568,
	fA = 569,
	fathom = 570,
	fC = 571,
	fcal_x005bth_x005d = 572,
	fEuc = 573,
	feV = 574,
	fF = 575,
	fg = 576,
	fgauss = 577,
	fGy = 578,
	fH = 579,
	fHz = 580,
	fJ = 581,
	floz_x005bUK_x005d = 582,
	floz_x005bUS_x005d = 583,
	fm = 584,
	fN = 585,
	fohm = 586,
	footcandle = 587,
	footcandle_x002es = 588,
	fP = 589,
	fPa = 590,
	frd = 591,
	fS = 592,
	ft = 593,
	fT = 594,
	ft_x002fbbl = 595,
	ft_x002fd = 596,
	ft_x002fdegF = 597,
	ft_x002fft = 598,
	ft_x002fft3 = 599,
	ft_x002fgal_x005bUS_x005d = 600,
	ft_x002fh = 601,
	ft_x002fin = 602,
	ft_x002flbm = 603,
	ft_x002fm = 604,
	ft_x002fmi = 605,
	ft_x002fmin = 606,
	ft_x002fms = 607,
	ft_x002fpsi = 608,
	ft_x002fs = 609,
	ft_x002fs2 = 610,
	ft_x002fus = 611,
	ft_x005bBnA_x005d = 612,
	ft_x005bBnB_x005d = 613,
	ft_x005bBr36_x005d = 614,
	ft_x005bBr65_x005d = 615,
	ft_x005bCla_x005d = 616,
	ft_x005bGC_x005d = 617,
	ft_x005bInd_x005d = 618,
	ft_x005bInd37_x005d = 619,
	ft_x005bInd62_x005d = 620,
	ft_x005bInd75_x005d = 621,
	ft_x005bSe_x005d = 622,
	ft_x005bSeT_x005d = 623,
	ft_x005bUS_x005d = 624,
	ft2 = 625,
	ft2_x002fh = 626,
	ft2_x002fin3 = 627,
	ft2_x002flbm = 628,
	ft2_x002fs = 629,
	ft3 = 630,
	ft3_x002f_x0028d_x002eft_x0029 = 631,
	ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 632,
	ft3_x002f_x0028min_x002eft2_x0029 = 633,
	ft3_x002f_x0028s_x002eft2_x0029 = 634,
	ft3_x002fbbl = 635,
	ft3_x002fd = 636,
	ft3_x002fd2 = 637,
	ft3_x002fft = 638,
	ft3_x002fft2 = 639,
	ft3_x002fft3 = 640,
	ft3_x002fh = 641,
	ft3_x002fh2 = 642,
	ft3_x002fkg = 643,
	ft3_x002flbm = 644,
	ft3_x002flbmol = 645,
	ft3_x002fmin = 646,
	ft3_x002fmin2 = 647,
	ft3_x002frad = 648,
	ft3_x002fs = 649,
	ft3_x002fs2 = 650,
	ft3_x002fsack_x005b94lbm_x005d = 651,
	fur_x005bUS_x005d = 652,
	fV = 653,
	fW = 654,
	fWb = 655,
	g_x002eft_x002f_x0028cm3_x002es_x0029 = 656,
	g_x002em_x002f_x0028cm3_x002es_x0029 = 657,
	g_x002fcm3 = 658,
	g_x002fcm4 = 659,
	g_x002fdm3 = 660,
	g_x002fgal_x005bUK_x005d = 661,
	g_x002fgal_x005bUS_x005d = 662,
	g_x002fkg = 663,
	g_x002fL = 664,
	g_x002fm3 = 665,
	g_x002fmol = 666,
	g_x002fs = 667,
	g_x002ft = 668,
	GA = 669,
	Ga_x005bt_x005d = 670,
	Gal = 671,
	gal_x005bUK_x005d = 672,
	gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 673,
	gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 674,
	gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 675,
	gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 676,
	gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 677,
	gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 678,
	gal_x005bUK_x005d_x002fd = 679,
	gal_x005bUK_x005d_x002fft3 = 680,
	gal_x005bUK_x005d_x002fh = 681,
	gal_x005bUK_x005d_x002fh2 = 682,
	gal_x005bUK_x005d_x002flbm = 683,
	gal_x005bUK_x005d_x002fmi = 684,
	gal_x005bUK_x005d_x002fmin = 685,
	gal_x005bUK_x005d_x002fmin2 = 686,
	gal_x005bUS_x005d = 687,
	gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 688,
	gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 689,
	gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 690,
	gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 691,
	gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 692,
	gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 693,
	gal_x005bUS_x005d_x002fbbl = 694,
	gal_x005bUS_x005d_x002fd = 695,
	gal_x005bUS_x005d_x002fft = 696,
	gal_x005bUS_x005d_x002fft3 = 697,
	gal_x005bUS_x005d_x002fh = 698,
	gal_x005bUS_x005d_x002fh2 = 699,
	gal_x005bUS_x005d_x002flbm = 700,
	gal_x005bUS_x005d_x002fmi = 701,
	gal_x005bUS_x005d_x002fmin = 702,
	gal_x005bUS_x005d_x002fmin2 = 703,
	gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 704,
	gal_x005bUS_x005d_x002fton_x005bUK_x005d = 705,
	gal_x005bUS_x005d_x002fton_x005bUS_x005d = 706,
	gAPI = 707,
	gauss = 708,
	gauss_x002fcm = 709,
	GBq = 710,
	GC = 711,
	Gcal_x005bth_x005d = 712,
	GEuc = 713,
	GeV = 714,
	gf = 715,
	GF = 716,
	Gg = 717,
	Ggauss = 718,
	GGy = 719,
	GH = 720,
	GHz = 721,
	GJ = 722,
	Gm = 723,
	GN = 724,
	gn = 725,
	Gohm = 726,
	gon = 727,
	GP = 728,
	GPa = 729,
	GPa_x002fcm = 730,
	GPa2 = 731,
	grain = 732,
	grain_x002fft3 = 733,
	grain_x002fgal_x005bUS_x005d = 734,
	Grd = 735,
	GS = 736,
	GT = 737,
	GV = 738,
	GW = 739,
	GW_x002eh = 740,
	GWb = 741,
	Gy = 742,
	h_x002fft3 = 743,
	h_x002fkm = 744,
	H_x002fm = 745,
	h_x002fm3 = 746,
	ha = 747,
	ha_x002em = 748,
	hbar = 749,
	hg = 750,
	hL = 751,
	hm = 752,
	hN = 753,
	hp = 754,
	hp_x002eh = 755,
	hp_x002eh_x002fbbl = 756,
	hp_x002eh_x002flbm = 757,
	hp_x002fft3 = 758,
	hp_x002fin2 = 759,
	hp_x005belec_x005d = 760,
	hp_x005bhyd_x005d = 761,
	hp_x005bhyd_x005d_x002fin2 = 762,
	hp_x005bmetric_x005d = 763,
	hp_x005bmetric_x005d_x002eh = 764,
	hs = 765,
	Hz = 766,
	in = 767,
	in_x002f_x0028in_x002edegF_x0029 = 768,
	in_x002fa = 769,
	in_x002fmin = 770,
	in_x002fs = 771,
	in_x002fs2 = 772,
	in_x005bUS_x005d = 773,
	in2 = 774,
	in2_x002fft2 = 775,
	in2_x002fin2 = 776,
	in2_x002fs = 777,
	in3 = 778,
	in3_x002fft = 779,
	in4 = 780,
	inH2O_x005b39degF_x005d = 781,
	inH2O_x005b60degF_x005d = 782,
	inHg_x005b32degF_x005d = 783,
	inHg_x005b60degF_x005d = 784,
	J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = 785,
	J_x002em_x002fm2 = 786,
	J_x002f_x0028g_x002eK_x0029 = 787,
	J_x002f_x0028kg_x002eK_x0029 = 788,
	J_x002f_x0028mol_x002eK_x0029 = 789,
	J_x002f_x0028s_x002em2_x002edegC_x0029 = 790,
	J_x002fcm2 = 791,
	J_x002fdm3 = 792,
	J_x002fg = 793,
	J_x002fK = 794,
	J_x002fkg = 795,
	J_x002fm = 796,
	J_x002fm2 = 797,
	J_x002fm3 = 798,
	J_x002fmol = 799,
	J_x002fs = 800,
	K_x002em2_x002fkW = 801,
	K_x002em2_x002fW = 802,
	K_x002fkm = 803,
	K_x002fm = 804,
	K_x002fPa = 805,
	K_x002fs = 806,
	K_x002fW = 807,
	kA = 808,
	ka_x005bt_x005d = 809,
	kC = 810,
	kcal_x005bth_x005d = 811,
	kcal_x005bth_x005d_x002em_x002fcm2 = 812,
	kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = 813,
	kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 814,
	kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = 815,
	kcal_x005bth_x005d_x002fcm3 = 816,
	kcal_x005bth_x005d_x002fg = 817,
	kcal_x005bth_x005d_x002fh = 818,
	kcal_x005bth_x005d_x002fkg = 819,
	kcal_x005bth_x005d_x002fm3 = 820,
	kcal_x005bth_x005d_x002fmol = 821,
	kcd = 822,
	kdyne = 823,
	kEuc = 824,
	keV = 825,
	kF = 826,
	kg = 827,
	kg_x002em = 828,
	kg_x002em_x002fcm2 = 829,
	kg_x002em_x002fs = 830,
	kg_x002em2 = 831,
	kg_x002f_x0028kW_x002eh_x0029 = 832,
	kg_x002f_x0028m_x002es_x0029 = 833,
	kg_x002f_x0028m2_x002es_x0029 = 834,
	kg_x002fd = 835,
	kg_x002fdm3 = 836,
	kg_x002fdm4 = 837,
	kg_x002fh = 838,
	kg_x002fJ = 839,
	kg_x002fkg = 840,
	kg_x002fL = 841,
	kg_x002fm = 842,
	kg_x002fm2 = 843,
	kg_x002fm3 = 844,
	kg_x002fm4 = 845,
	kg_x002fmin = 846,
	kg_x002fMJ = 847,
	kg_x002fmol = 848,
	kg_x002fs = 849,
	kg_x002fsack_x005b94lbm_x005d = 850,
	kg_x002ft = 851,
	kgauss = 852,
	kgf = 853,
	kgf_x002em = 854,
	kgf_x002em_x002fcm2 = 855,
	kgf_x002em_x002fm = 856,
	kgf_x002em2 = 857,
	kgf_x002es_x002fm2 = 858,
	kgf_x002fcm = 859,
	kgf_x002fcm2 = 860,
	kgf_x002fkgf = 861,
	kgf_x002fm2 = 862,
	kgf_x002fmm2 = 863,
	kGy = 864,
	kH = 865,
	kHz = 866,
	Kibyte = 867,
	kJ = 868,
	kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = 869,
	kJ_x002f_x0028h_x002em2_x002eK_x0029 = 870,
	kJ_x002f_x0028kg_x002eK_x0029 = 871,
	kJ_x002f_x0028kmol_x002eK_x0029 = 872,
	kJ_x002fdm3 = 873,
	kJ_x002fkg = 874,
	kJ_x002fkmol = 875,
	kJ_x002fm3 = 876,
	klbf = 877,
	klbm = 878,
	klbm_x002fin = 879,
	klx = 880,
	km = 881,
	km_x002fcm = 882,
	km_x002fdm3 = 883,
	km_x002fh = 884,
	km_x002fL = 885,
	km_x002fs = 886,
	km2 = 887,
	km3 = 888,
	kmol = 889,
	kmol_x002fh = 890,
	kmol_x002fm3 = 891,
	kmol_x002fs = 892,
	kN = 893,
	kN_x002em = 894,
	kN_x002em2 = 895,
	kN_x002fm = 896,
	kN_x002fm2 = 897,
	knot = 898,
	kohm = 899,
	kohm_x002em = 900,
	kP = 901,
	kPa = 902,
	kPa_x002es_x002fm = 903,
	kPa_x002fh = 904,
	kPa_x002fhm = 905,
	kPa_x002fm = 906,
	kPa_x002fmin = 907,
	kPa2 = 908,
	kPa2_x002fcP = 909,
	kpsi = 910,
	kpsi2 = 911,
	krad = 912,
	krd = 913,
	kS = 914,
	kS_x002fm = 915,
	kT = 916,
	kV = 917,
	kW = 918,
	kW_x002eh = 919,
	kW_x002eh_x002f_x0028kg_x002edegC_x0029 = 920,
	kW_x002eh_x002fdm3 = 921,
	kW_x002eh_x002fkg = 922,
	kW_x002eh_x002fm3 = 923,
	kW_x002f_x0028m2_x002eK_x0029 = 924,
	kW_x002f_x0028m3_x002eK_x0029 = 925,
	kW_x002fcm2 = 926,
	kW_x002fm2 = 927,
	kW_x002fm3 = 928,
	kWb = 929,
	L_x002f_x0028bar_x002emin_x0029 = 930,
	L_x002fh = 931,
	L_x002fkg = 932,
	L_x002fkmol = 933,
	L_x002fm = 934,
	L_x002fm3 = 935,
	L_x002fmin = 936,
	L_x002fmol = 937,
	L_x002fs = 938,
	L_x002fs2 = 939,
	L_x002ft = 940,
	L_x002fton_x005bUK_x005d = 941,
	lbf = 942,
	lbf_x002eft = 943,
	lbf_x002eft_x002fbbl = 944,
	lbf_x002eft_x002fgal_x005bUS_x005d = 945,
	lbf_x002eft_x002fin = 946,
	lbf_x002eft_x002fin2 = 947,
	lbf_x002eft_x002flbm = 948,
	lbf_x002eft_x002fmin = 949,
	lbf_x002eft_x002fs = 950,
	lbf_x002ein = 951,
	lbf_x002ein_x002fin = 952,
	lbf_x002ein2 = 953,
	lbf_x002es_x002fft2 = 954,
	lbf_x002es_x002fin2 = 955,
	lbf_x002fft = 956,
	lbf_x002fft2 = 957,
	lbf_x002fft3 = 958,
	lbf_x002fgal_x005bUS_x005d = 959,
	lbf_x002fin = 960,
	lbf_x002flbf = 961,
	lbm = 962,
	lbm_x002eft = 963,
	lbm_x002eft_x002fs = 964,
	lbm_x002eft2 = 965,
	lbm_x002eft2_x002fs2 = 966,
	lbm_x002f_x0028ft_x002eh_x0029 = 967,
	lbm_x002f_x0028ft_x002es_x0029 = 968,
	lbm_x002f_x0028ft2_x002eh_x0029 = 969,
	lbm_x002f_x0028ft2_x002es_x0029 = 970,
	lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 971,
	lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 972,
	lbm_x002f_x0028hp_x002eh_x0029 = 973,
	lbm_x002fbbl = 974,
	lbm_x002fd = 975,
	lbm_x002fft = 976,
	lbm_x002fft2 = 977,
	lbm_x002fft3 = 978,
	lbm_x002fft4 = 979,
	lbm_x002fgal_x005bUK_x005d = 980,
	lbm_x002fgal_x005bUS_x005d = 981,
	lbm_x002fh = 982,
	lbm_x002fin3 = 983,
	lbm_x002flbmol = 984,
	lbm_x002fmin = 985,
	lbm_x002fs = 986,
	lbmol = 987,
	lbmol_x002f_x0028h_x002eft2_x0029 = 988,
	lbmol_x002f_x0028s_x002eft2_x0029 = 989,
	lbmol_x002fft3 = 990,
	lbmol_x002fgal_x005bUK_x005d = 991,
	lbmol_x002fgal_x005bUS_x005d = 992,
	lbmol_x002fh = 993,
	lbmol_x002fs = 994,
	link = 995,
	link_x005bBnA_x005d = 996,
	link_x005bBnB_x005d = 997,
	link_x005bCla_x005d = 998,
	link_x005bSe_x005d = 999,
	link_x005bSeT_x005d = 1000,
	link_x005bUS_x005d = 1001,
	lm = 1002,
	lm_x002es = 1003,
	lm_x002fm2 = 1004,
	lm_x002fW = 1005,
	lx = 1006,
	lx_x002es = 1007,
	m_x002f_x0028m_x002eK_x0029 = 1008,
	m_x002fcm = 1009,
	m_x002fd = 1010,
	m_x002fh = 1011,
	m_x002fK = 1012,
	m_x002fkg = 1013,
	m_x002fkm = 1014,
	m_x002fkPa = 1015,
	m_x002fm = 1016,
	m_x002fm3 = 1017,
	m_x002fmin = 1018,
	m_x002fms = 1019,
	m_x002fPa = 1020,
	m_x002fs = 1021,
	m_x002fs2 = 1022,
	m_x005bGer_x005d = 1023,
	m2 = 1024,
	m2_x002f_x0028kPa_x002ed_x0029 = 1025,
	m2_x002f_x0028Pa_x002es_x0029 = 1026,
	m2_x002fcm3 = 1027,
	m2_x002fd = 1028,
	m2_x002fg = 1029,
	m2_x002fh = 1030,
	m2_x002fkg = 1031,
	m2_x002fm2 = 1032,
	m2_x002fm3 = 1033,
	m2_x002fmol = 1034,
	m2_x002fs = 1035,
	m3 = 1036,
	m3_x002f_x0028bar_x002ed_x0029 = 1037,
	m3_x002f_x0028bar_x002eh_x0029 = 1038,
	m3_x002f_x0028bar_x002emin_x0029 = 1039,
	m3_x002f_x0028d_x002em_x0029 = 1040,
	m3_x002f_x0028h_x002em_x0029 = 1041,
	m3_x002f_x0028ha_x002em_x0029 = 1042,
	m3_x002f_x0028kPa_x002ed_x0029 = 1043,
	m3_x002f_x0028kPa_x002eh_x0029 = 1044,
	m3_x002f_x0028kW_x002eh_x0029 = 1045,
	m3_x002f_x0028m3_x002eK_x0029 = 1046,
	m3_x002f_x0028Pa_x002es_x0029 = 1047,
	m3_x002f_x0028psi_x002ed_x0029 = 1048,
	m3_x002f_x0028s_x002eft_x0029 = 1049,
	m3_x002f_x0028s_x002em_x0029 = 1050,
	m3_x002f_x0028s_x002em2_x0029 = 1051,
	m3_x002f_x0028s_x002em3_x0029 = 1052,
	m3_x002fbbl = 1053,
	m3_x002fd = 1054,
	m3_x002fd2 = 1055,
	m3_x002fg = 1056,
	m3_x002fh = 1057,
	m3_x002fJ = 1058,
	m3_x002fkg = 1059,
	m3_x002fkm = 1060,
	m3_x002fkmol = 1061,
	m3_x002fkPa = 1062,
	m3_x002fm = 1063,
	m3_x002fm2 = 1064,
	m3_x002fm3 = 1065,
	m3_x002fmin = 1066,
	m3_x002fmol = 1067,
	m3_x002fPa = 1068,
	m3_x002frad = 1069,
	m3_x002frev = 1070,
	m3_x002fs = 1071,
	m3_x002fs2 = 1072,
	m3_x002ft = 1073,
	m3_x002fton_x005bUK_x005d = 1074,
	m3_x002fton_x005bUS_x005d = 1075,
	m4 = 1076,
	m4_x002fs = 1077,
	MA = 1078,
	mA = 1079,
	mA_x002fcm2 = 1080,
	mA_x002fft2 = 1081,
	Ma_x005bt_x005d = 1082,
	mbar = 1083,
	MBq = 1084,
	MC = 1085,
	mC = 1086,
	mC_x002fm2 = 1087,
	Mcal_x005bth_x005d = 1088,
	mcal_x005bth_x005d = 1089,
	mCi = 1090,
	mD = 1091,
	mD_x002eft = 1092,
	mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 1093,
	mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 1094,
	mD_x002em = 1095,
	mD_x002f_x0028Pa_x002es_x0029 = 1096,
	mD_x002fcP = 1097,
	mEuc = 1098,
	MEuc = 1099,
	MeV = 1100,
	meV = 1101,
	MF = 1102,
	mF = 1103,
	mg = 1104,
	Mg = 1105,
	Mg_x002fa = 1106,
	Mg_x002fd = 1107,
	mg_x002fdm3 = 1108,
	mg_x002fg = 1109,
	mg_x002fgal_x005bUS_x005d = 1110,
	Mg_x002fh = 1111,
	Mg_x002fin = 1112,
	mg_x002fJ = 1113,
	mg_x002fkg = 1114,
	mg_x002fL = 1115,
	Mg_x002fm2 = 1116,
	mg_x002fm3 = 1117,
	Mg_x002fm3 = 1118,
	Mg_x002fmin = 1119,
	mGal = 1120,
	mgauss = 1121,
	Mgauss = 1122,
	Mgf = 1123,
	mgn = 1124,
	MGy = 1125,
	mGy = 1126,
	MH = 1127,
	mH = 1128,
	MHz = 1129,
	mHz = 1130,
	mi = 1131,
	mi_x002fgal_x005bUK_x005d = 1132,
	mi_x002fgal_x005bUS_x005d = 1133,
	mi_x002fh = 1134,
	mi_x002fin = 1135,
	mi_x005bnaut_x005d = 1136,
	mi_x005bnautUK_x005d = 1137,
	mi_x005bUS_x005d = 1138,
	mi_x005bUS_x005d2 = 1139,
	mi2 = 1140,
	mi3 = 1141,
	Mibyte = 1142,
	mil = 1143,
	mil_x002fa = 1144,
	mila = 1145,
	min_ = 1146,
	min_x002fft = 1147,
	min_x002fm = 1148,
	mina = 1149,
	MJ = 1150,
	mJ = 1151,
	MJ_x002fa = 1152,
	mJ_x002fcm2 = 1153,
	MJ_x002fkg = 1154,
	MJ_x002fkmol = 1155,
	MJ_x002fm = 1156,
	mJ_x002fm2 = 1157,
	MJ_x002fm3 = 1158,
	mL = 1159,
	mL_x002fgal_x005bUK_x005d = 1160,
	mL_x002fgal_x005bUS_x005d = 1161,
	mL_x002fmL = 1162,
	mm = 1163,
	Mm = 1164,
	mm_x002f_x0028mm_x002eK_x0029 = 1165,
	mm_x002fa = 1166,
	mm_x002fs = 1167,
	mm2 = 1168,
	mm2_x002fmm2 = 1169,
	mm2_x002fs = 1170,
	mm3 = 1171,
	mm3_x002fJ = 1172,
	mmHg_x005b0degC_x005d = 1173,
	mmol = 1174,
	MN = 1175,
	mN = 1176,
	mN_x002em2 = 1177,
	mN_x002fkm = 1178,
	mN_x002fm = 1179,
	Mohm = 1180,
	mohm = 1181,
	mol = 1182,
	mol_x002em2_x002f_x0028mol_x002es_x0029 = 1183,
	mol_x002f_x0028s_x002em2_x0029 = 1184,
	mol_x002fm2 = 1185,
	mol_x002fm3 = 1186,
	mol_x002fmol = 1187,
	mol_x002fs = 1188,
	MP = 1189,
	mP = 1190,
	MPa = 1191,
	mPa = 1192,
	mPa_x002es = 1193,
	MPa_x002es_x002fm = 1194,
	MPa_x002fh = 1195,
	MPa_x002fm = 1196,
	Mpsi = 1197,
	mrad = 1198,
	Mrad = 1199,
	Mrd = 1200,
	mrd = 1201,
	mrem = 1202,
	mrem_x002fh = 1203,
	ms = 1204,
	MS = 1205,
	mS = 1206,
	ms_x002fcm = 1207,
	mS_x002fcm = 1208,
	ms_x002fft = 1209,
	ms_x002fin = 1210,
	mS_x002fm = 1211,
	ms_x002fm = 1212,
	ms_x002fs = 1213,
	mSv = 1214,
	mSv_x002fh = 1215,
	mT = 1216,
	mT_x002fdm = 1217,
	mV = 1218,
	MV = 1219,
	mV_x002fft = 1220,
	mV_x002fm = 1221,
	mW = 1222,
	MW = 1223,
	MW_x002eh = 1224,
	MW_x002eh_x002fkg = 1225,
	MW_x002eh_x002fm3 = 1226,
	mW_x002fm2 = 1227,
	mWb = 1228,
	MWb = 1229,
	N_x002em = 1230,
	N_x002em_x002fm = 1231,
	N_x002em2 = 1232,
	N_x002es_x002fm2 = 1233,
	N_x002fm = 1234,
	N_x002fm2 = 1235,
	N_x002fm3 = 1236,
	N_x002fmm2 = 1237,
	N_x002fN = 1238,
	nA = 1239,
	na = 1240,
	nAPI = 1241,
	nC = 1242,
	ncal_x005bth_x005d = 1243,
	nCi = 1244,
	nEuc = 1245,
	neV = 1246,
	nF = 1247,
	ng = 1248,
	ng_x002fg = 1249,
	ng_x002fmg = 1250,
	ngauss = 1251,
	nGy = 1252,
	nH = 1253,
	nHz = 1254,
	nJ = 1255,
	nm = 1256,
	nm_x002fs = 1257,
	nN = 1258,
	nohm = 1259,
	nohm_x002emil2_x002fft = 1260,
	nohm_x002emm2_x002fm = 1261,
	nP = 1262,
	nPa = 1263,
	nrd = 1264,
	nS = 1265,
	ns = 1266,
	ns_x002fft = 1267,
	ns_x002fm = 1268,
	nT = 1269,
	nV = 1270,
	nW = 1271,
	nWb = 1272,
	Oe = 1273,
	ohm = 1274,
	ohm_x002ecm = 1275,
	ohm_x002em = 1276,
	ohm_x002em2_x002fm = 1277,
	ohm_x002fm = 1278,
	ozf = 1279,
	ozm = 1280,
	ozm_x005btroy_x005d = 1281,
	pA = 1282,
	Pa = 1283,
	Pa_x002es = 1284,
	Pa_x002es_x002em3_x002fkg = 1285,
	Pa_x002es_x002fm3 = 1286,
	Pa_x002es2_x002fm3 = 1287,
	Pa_x002fh = 1288,
	Pa_x002fm = 1289,
	Pa_x002fm3 = 1290,
	Pa_x002fs = 1291,
	Pa2 = 1292,
	Pa2_x002f_x0028Pa_x002es_x0029 = 1293,
	pC = 1294,
	pcal_x005bth_x005d = 1295,
	pCi = 1296,
	pCi_x002fg = 1297,
	pdl = 1298,
	pdl_x002ecm2 = 1299,
	pdl_x002eft = 1300,
	pdl_x002fcm = 1301,
	pEuc = 1302,
	peV = 1303,
	pF = 1304,
	pg = 1305,
	pgauss = 1306,
	pGy = 1307,
	pHz = 1308,
	pJ = 1309,
	pm = 1310,
	pN = 1311,
	pohm = 1312,
	pP = 1313,
	pPa = 1314,
	ppk = 1315,
	ppm = 1316,
	ppm_x005bmass_x005d = 1317,
	ppm_x005bvol_x005d = 1318,
	ppm_x005bvol_x005d_x002fdegC = 1319,
	ppm_x005bvol_x005d_x002fdegF = 1320,
	prd = 1321,
	pS = 1322,
	ps = 1323,
	psi = 1324,
	psi_x002ed_x002fbbl = 1325,
	psi_x002es = 1326,
	psi_x002fft = 1327,
	psi_x002fh = 1328,
	psi_x002fm = 1329,
	psi_x002fmin = 1330,
	psi2 = 1331,
	psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1332,
	psi2_x002fcP = 1333,
	pT = 1334,
	pt_x005bUK_x005d = 1335,
	pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 1336,
	pt_x005bUS_x005d = 1337,
	pV = 1338,
	pW = 1339,
	pWb = 1340,
	qt_x005bUK_x005d = 1341,
	qt_x005bUS_x005d = 1342,
	quad = 1343,
	quad_x002fa = 1344,
	rad = 1345,
	rad_x002fft = 1346,
	rad_x002fft3 = 1347,
	rad_x002fm = 1348,
	rad_x002fm3 = 1349,
	rad_x002fs = 1350,
	rad_x002fs2 = 1351,
	rd = 1352,
	rem = 1353,
	rem_x002fh = 1354,
	rev = 1355,
	rev_x002fft = 1356,
	rev_x002fm = 1357,
	rev_x002fs = 1358,
	rod_x005bUS_x005d = 1359,
	rpm = 1360,
	rpm_x002fs = 1361,
	s_x002fcm = 1362,
	s_x002fft = 1363,
	s_x002fft3 = 1364,
	s_x002fin = 1365,
	s_x002fkg = 1366,
	s_x002fL = 1367,
	S_x002fm = 1368,
	s_x002fm = 1369,
	s_x002fm3 = 1370,
	s_x002fqt_x005bUK_x005d = 1371,
	s_x002fqt_x005bUS_x005d = 1372,
	s_x002fs = 1373,
	sack_x005b94lbm_x005d = 1374,
	seca = 1375,
	section = 1376,
	sr = 1377,
	St = 1378,
	Sv = 1379,
	Sv_x002fh = 1380,
	Sv_x002fs = 1381,
	t_x002fa = 1382,
	t_x002fd = 1383,
	t_x002fh = 1384,
	T_x002fm = 1385,
	t_x002fm3 = 1386,
	t_x002fmin = 1387,
	TA = 1388,
	Ta_x005bt_x005d = 1389,
	TBq = 1390,
	TC = 1391,
	Tcal_x005bth_x005d = 1392,
	TD_x005bAPI_x005d = 1393,
	TD_x005bAPI_x005d_x002em = 1394,
	TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 1395,
	TEuc = 1396,
	TeV = 1397,
	TF = 1398,
	Tg = 1399,
	Tgauss = 1400,
	TGy = 1401,
	TH = 1402,
	therm_x005bEC_x005d = 1403,
	therm_x005bUK_x005d = 1404,
	therm_x005bUS_x005d = 1405,
	THz = 1406,
	TJ = 1407,
	TJ_x002fa = 1408,
	Tm = 1409,
	TN = 1410,
	Tohm = 1411,
	ton_x005bUK_x005d = 1412,
	ton_x005bUK_x005d_x002fa = 1413,
	ton_x005bUK_x005d_x002fd = 1414,
	ton_x005bUK_x005d_x002fh = 1415,
	ton_x005bUK_x005d_x002fmin = 1416,
	ton_x005bUS_x005d = 1417,
	ton_x005bUS_x005d_x002fa = 1418,
	ton_x005bUS_x005d_x002fd = 1419,
	ton_x005bUS_x005d_x002fft2 = 1420,
	ton_x005bUS_x005d_x002fh = 1421,
	ton_x005bUS_x005d_x002fmin = 1422,
	tonf_x005bUK_x005d = 1423,
	tonf_x005bUK_x005d_x002eft2 = 1424,
	tonf_x005bUK_x005d_x002fft = 1425,
	tonf_x005bUK_x005d_x002fft2 = 1426,
	tonf_x005bUS_x005d = 1427,
	tonf_x005bUS_x005d_x002eft = 1428,
	tonf_x005bUS_x005d_x002eft2 = 1429,
	tonf_x005bUS_x005d_x002emi = 1430,
	tonf_x005bUS_x005d_x002emi_x002fbbl = 1431,
	tonf_x005bUS_x005d_x002emi_x002fft = 1432,
	tonf_x005bUS_x005d_x002fft = 1433,
	tonf_x005bUS_x005d_x002fft2 = 1434,
	tonf_x005bUS_x005d_x002fin2 = 1435,
	tonRefrig = 1436,
	torr = 1437,
	TP = 1438,
	TPa = 1439,
	Trd = 1440,
	TS = 1441,
	TT = 1442,
	TV = 1443,
	TW = 1444,
	TW_x002eh = 1445,
	TWb = 1446,
	uA = 1447,
	uA_x002fcm2 = 1448,
	uA_x002fin2 = 1449,
	ubar = 1450,
	uC = 1451,
	ucal_x005bth_x005d = 1452,
	ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 1453,
	ucal_x005bth_x005d_x002fs = 1454,
	uCi = 1455,
	uEuc = 1456,
	ueV = 1457,
	uF = 1458,
	uF_x002fm = 1459,
	ug = 1460,
	ug_x002fcm3 = 1461,
	ug_x002fg = 1462,
	ug_x002fmg = 1463,
	ugauss = 1464,
	uGy = 1465,
	uH = 1466,
	uH_x002fm = 1467,
	uHz = 1468,
	uJ = 1469,
	um = 1470,
	um_x002fs = 1471,
	um2 = 1472,
	um2_x002em = 1473,
	umHg_x005b0degC_x005d = 1474,
	umol = 1475,
	uN = 1476,
	uohm = 1477,
	uohm_x002fft = 1478,
	uohm_x002fm = 1479,
	uP = 1480,
	uPa = 1481,
	upsi = 1482,
	urad = 1483,
	urd = 1484,
	us = 1485,
	uS = 1486,
	us_x002fft = 1487,
	us_x002fin = 1488,
	us_x002fm = 1489,
	uT = 1490,
	uV = 1491,
	uV_x002fft = 1492,
	uV_x002fm = 1493,
	uW = 1494,
	uW_x002fm3 = 1495,
	uWb = 1496,
	V_x002fB = 1497,
	V_x002fdB = 1498,
	V_x002fm = 1499,
	W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = 1500,
	W_x002f_x0028m_x002eK_x0029 = 1501,
	W_x002f_x0028m2_x002eK_x0029 = 1502,
	W_x002f_x0028m2_x002esr_x0029 = 1503,
	W_x002f_x0028m3_x002eK_x0029 = 1504,
	W_x002fcm2 = 1505,
	W_x002fK = 1506,
	W_x002fkW = 1507,
	W_x002fm2 = 1508,
	W_x002fm3 = 1509,
	W_x002fmm2 = 1510,
	W_x002fsr = 1511,
	W_x002fW = 1512,
	Wb = 1513,
	Wb_x002em = 1514,
	Wb_x002fm = 1515,
	Wb_x002fmm = 1516,
	wk = 1517,
	yd = 1518,
	yd_x005bBnA_x005d = 1519,
	yd_x005bBnB_x005d = 1520,
	yd_x005bCla_x005d = 1521,
	yd_x005bInd_x005d = 1522,
	yd_x005bInd37_x005d = 1523,
	yd_x005bInd62_x005d = 1524,
	yd_x005bInd75_x005d = 1525,
	yd_x005bSe_x005d = 1526,
	yd_x005bSeT_x005d = 1527,
	yd_x005bUS_x005d = 1528,
	yd2 = 1529,
	yd3 = 1530
};
#endif

/* eml2_3ForGsoap.h:4075 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyMassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyMassPerVolumeUom (-965)

/* eml23:LegacyMassPerVolumeUom */
enum class eml23__LegacyMassPerVolumeUom {
	kg_x002fscm = 0,
	lbm_x002f1000scf = 1,
	lbm_x002f1E6scf = 2
};
#endif

/* eml2_3ForGsoap.h:4084 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressurePerVolumeUom (-966)

/* eml23:LegacyPressurePerVolumeUom */
enum class eml23__LegacyPressurePerVolumeUom {
	Pa_x002fscm = 0,
	psi_x002f1000scf = 1,
	psi_x002f1E6scf = 2
};
#endif

/* eml2_3ForGsoap.h:4093 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressureUom (-967)

/* eml23:LegacyPressureUom */
enum class eml23__LegacyPressureUom {
	psia = 0,
	psig = 1
};
#endif

/* eml2_3ForGsoap.h:4101 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerAreaUom (-968)

/* eml23:LegacyVolumePerAreaUom */
enum class eml23__LegacyVolumePerAreaUom {
	_1E6stb_x002facre = 0,
	scf_x002fft2 = 1,
	scm_x002fm2 = 2,
	stb_x002facre = 3
};
#endif

/* eml2_3ForGsoap.h:4111 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerTimeUom (-969)

/* eml23:LegacyVolumePerTimeUom */
enum class eml23__LegacyVolumePerTimeUom {
	_1000scf_x002fd = 0,
	_1000scf_x002fmo = 1,
	_1000scm_x002fd = 2,
	_1000scm_x002fmo = 3,
	_1000stb_x002fd = 4,
	_1000stb_x002fmo = 5,
	_1E6scf_x002fd = 6,
	_1E6scf_x002fmo = 7,
	_1E6scm_x002fd = 8,
	_1E6scm_x002fmo = 9,
	_1E6stb_x002fd = 10,
	_1E6stb_x002fmo = 11,
	scf_x002fd = 12,
	scm_x002fd = 13,
	scm_x002fh = 14,
	scm_x002fmo = 15,
	scm_x002fs = 16,
	stb_x002fd = 17,
	stb_x002fmo = 18
};
#endif

/* eml2_3ForGsoap.h:4136 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerVolumeUom (-970)

/* eml23:LegacyVolumePerVolumeUom */
enum class eml23__LegacyVolumePerVolumeUom {
	_1000scf_x002fstb = 0,
	_1E6scf_x002fstb = 1,
	_1E6stb_x002facre_x002eft = 2,
	acre_x002eft_x002f1E6stb = 3,
	bbl_x002f1000scf = 4,
	bbl_x002f1E6scf = 5,
	bbl_x002fscf = 6,
	bbl_x002fstb = 7,
	ft3_x002fscf = 8,
	ft3_x002fstb = 9,
	galUS_x002f1000scf = 10,
	m3_x002fscm = 11,
	ml_x002fscm = 12,
	scf_x002fbbl = 13,
	scf_x002fft3 = 14,
	scf_x002fscf = 15,
	scf_x002fstb = 16,
	scm_x002fm3 = 17,
	scm_x002fscm = 18,
	scm_x002fstb = 19,
	stb_x002f1000scf = 20,
	stb_x002f1000scm = 21,
	stb_x002f1E6scf = 22,
	stb_x002f1E6scm = 23,
	stb_x002fbbl = 24,
	stb_x002fscm = 25,
	stb_x002fstb = 26
};
#endif

/* eml2_3ForGsoap.h:4169 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumeUom (-971)

/* eml23:LegacyVolumeUom */
enum class eml23__LegacyVolumeUom {
	_1000scm = 0,
	_1000stb = 1,
	_1E6scf = 2,
	_1E6scm = 3,
	_1E6stb = 4,
	_1E9scf = 5,
	kscf = 6,
	scf = 7,
	scm = 8,
	stb = 9
};
#endif

/* eml2_3ForGsoap.h:4185 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUom (-972)

/* eml23:AbsorbedDoseUom */
enum class eml23__AbsorbedDoseUom {
	cGy = 0,
	crd = 1,
	dGy = 2,
	drd = 3,
	EGy = 4,
	Erd = 5,
	fGy = 6,
	frd = 7,
	GGy = 8,
	Grd = 9,
	Gy = 10,
	kGy = 11,
	krd = 12,
	mGy = 13,
	MGy = 14,
	Mrd = 15,
	mrd = 16,
	nGy = 17,
	nrd = 18,
	pGy = 19,
	prd = 20,
	rd = 21,
	TGy = 22,
	Trd = 23,
	uGy = 24,
	urd = 25
};
#endif

/* eml2_3ForGsoap.h:4321 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUom (-973)

/* eml23:ActivityOfRadioactivityUom */
enum class eml23__ActivityOfRadioactivityUom {
	Bq = 0,
	Ci = 1,
	GBq = 2,
	MBq = 3,
	mCi = 4,
	nCi = 5,
	pCi = 6,
	TBq = 7,
	uCi = 8
};
#endif

/* eml2_3ForGsoap.h:4372 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUom (-974)

/* eml23:AmountOfSubstancePerAmountOfSubstanceUom */
enum class eml23__AmountOfSubstancePerAmountOfSubstanceUom {
	_x0025 = 0,
	_x0025_x005bmolar_x005d = 1,
	Euc = 2,
	mol_x002fmol = 3,
	nEuc = 4,
	ppk = 5,
	ppm = 6
};
#endif

/* eml2_3ForGsoap.h:4413 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUom (-975)

/* eml23:AmountOfSubstancePerAreaUom */
enum class eml23__AmountOfSubstancePerAreaUom {
	mol_x002fm2 = 0
};
#endif

/* eml2_3ForGsoap.h:4424 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUom (-976)

/* eml23:AmountOfSubstancePerTimePerAreaUom */
enum class eml23__AmountOfSubstancePerTimePerAreaUom {
	lbmol_x002f_x0028h_x002eft2_x0029 = 0,
	lbmol_x002f_x0028s_x002eft2_x0029 = 1,
	mol_x002f_x0028s_x002em2_x0029 = 2
};
#endif

/* eml2_3ForGsoap.h:4445 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUom (-977)

/* eml23:AmountOfSubstancePerTimeUom */
enum class eml23__AmountOfSubstancePerTimeUom {
	kat = 0,
	kmol_x002fh = 1,
	kmol_x002fs = 2,
	lbmol_x002fh = 3,
	lbmol_x002fs = 4,
	mol_x002fs = 5
};
#endif

/* eml2_3ForGsoap.h:4481 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUom (-978)

/* eml23:AmountOfSubstancePerVolumeUom */
enum class eml23__AmountOfSubstancePerVolumeUom {
	kmol_x002fm3 = 0,
	lbmol_x002fft3 = 1,
	lbmol_x002fgal_x005bUK_x005d = 2,
	lbmol_x002fgal_x005bUS_x005d = 3,
	mol_x002fm3 = 4
};
#endif

/* eml2_3ForGsoap.h:4512 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUom (-979)

/* eml23:AmountOfSubstanceUom */
enum class eml23__AmountOfSubstanceUom {
	kmol = 0,
	lbmol = 1,
	mmol = 2,
	mol = 3,
	umol = 4
};
#endif

/* eml2_3ForGsoap.h:4543 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUom (-980)

/* eml23:AnglePerLengthUom */
enum class eml23__AnglePerLengthUom {
	_0_x002e01_x0020dega_x002fft = 0,
	_1_x002f30_x0020dega_x002fft = 1,
	_1_x002f30_x0020dega_x002fm = 2,
	dega_x002fft = 3,
	dega_x002fm = 4,
	rad_x002fft = 5,
	rad_x002fm = 6,
	rev_x002fft = 7,
	rev_x002fm = 8
};
#endif

/* eml2_3ForGsoap.h:4594 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUom (-981)

/* eml23:AnglePerVolumeUom */
enum class eml23__AnglePerVolumeUom {
	rad_x002fft3 = 0,
	rad_x002fm3 = 1
};
#endif

/* eml2_3ForGsoap.h:4610 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUom (-982)

/* eml23:AngularAccelerationUom */
enum class eml23__AngularAccelerationUom {
	rad_x002fs2 = 0,
	rpm_x002fs = 1
};
#endif

/* eml2_3ForGsoap.h:4626 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUom (-983)

/* eml23:AngularVelocityUom */
enum class eml23__AngularVelocityUom {
	dega_x002fh = 0,
	dega_x002fmin = 1,
	dega_x002fs = 2,
	rad_x002fs = 3,
	rev_x002fs = 4,
	rpm = 5
};
#endif

/* eml2_3ForGsoap.h:4662 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUom (-984)

/* eml23:APIGammaRayUom */
enum class eml23__APIGammaRayUom {
	gAPI = 0
};
#endif

/* eml2_3ForGsoap.h:4673 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUom (-985)

/* eml23:APIGravityUom */
enum class eml23__APIGravityUom {
	dAPI = 0
};
#endif

/* eml2_3ForGsoap.h:4684 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUom (-986)

/* eml23:APINeutronUom */
enum class eml23__APINeutronUom {
	nAPI = 0
};
#endif

/* eml2_3ForGsoap.h:4695 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUom (-987)

/* eml23:AreaPerAmountOfSubstanceUom */
enum class eml23__AreaPerAmountOfSubstanceUom {
	m2_x002fmol = 0
};
#endif

/* eml2_3ForGsoap.h:4706 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUom (-988)

/* eml23:AreaPerAreaUom */
enum class eml23__AreaPerAreaUom {
	_x0025 = 0,
	_x0025_x005barea_x005d = 1,
	cEuc = 2,
	Euc = 3,
	in2_x002fft2 = 4,
	in2_x002fin2 = 5,
	m2_x002fm2 = 6,
	mm2_x002fmm2 = 7
};
#endif

/* eml2_3ForGsoap.h:4752 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUom (-989)

/* eml23:AreaPerCountUom */
enum class eml23__AreaPerCountUom {
	b_x002felectron = 0
};
#endif

/* eml2_3ForGsoap.h:4759 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUom (-990)

/* eml23:AreaPerMassUom */
enum class eml23__AreaPerMassUom {
	cm2_x002fg = 0,
	ft2_x002flbm = 1,
	m2_x002fg = 2,
	m2_x002fkg = 3
};
#endif

/* eml2_3ForGsoap.h:4785 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUom (-991)

/* eml23:AreaPerTimeUom */
enum class eml23__AreaPerTimeUom {
	cm2_x002fs = 0,
	ft2_x002fh = 1,
	ft2_x002fs = 2,
	in2_x002fs = 3,
	m2_x002fd = 4,
	m2_x002fh = 5,
	m2_x002fs = 6,
	mm2_x002fs = 7
};
#endif

/* eml2_3ForGsoap.h:4831 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUom (-992)

/* eml23:AreaPerVolumeUom */
enum class eml23__AreaPerVolumeUom {
	_1_x002fm = 0,
	b_x002fcm3 = 1,
	cu = 2,
	ft2_x002fin3 = 3,
	m2_x002fcm3 = 4,
	m2_x002fm3 = 5
};
#endif

/* eml2_3ForGsoap.h:4867 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaUom (-993)

/* eml23:AreaUom */
enum class eml23__AreaUom {
	b = 'b',
	acre = 'c',
	cm2 = 'd',
	ft2 = 'e',
	ha = 'f',
	in2 = 'g',
	km2 = 'h',
	m2 = 'i',
	mi_x005bUS_x005d2 = 'j',
	mi2 = 'k',
	mm2 = 'l',
	section = 'm',
	um2 = 'n',
	yd2 = 'o'
};
#endif

/* eml2_3ForGsoap.h:4943 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUom (-994)

/* eml23:AttenuationPerFrequencyIntervalUom */
enum class eml23__AttenuationPerFrequencyIntervalUom {
	B_x002fO = 0,
	dB_x002fO = 1
};
#endif

/* eml2_3ForGsoap.h:4959 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUom (-995)

/* eml23:CapacitanceUom */
enum class eml23__CapacitanceUom {
	F = 'F',
	cF = 'G',
	dF = 'H',
	EF = 'I',
	fF = 'J',
	GF = 'K',
	kF = 'L',
	mF = 'M',
	MF = 'N',
	nF = 'O',
	pF = 'P',
	TF = 'Q',
	uF = 'R'
};
#endif

/* eml2_3ForGsoap.h:5030 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUom (-996)

/* eml23:CationExchangeCapacityUom */
enum class eml23__CationExchangeCapacityUom {
	_x002e01_x0020meq_x002fg = 0
};
#endif

/* eml2_3ForGsoap.h:5037 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUom (-997)

/* eml23:DataTransferSpeedUom */
enum class eml23__DataTransferSpeedUom {
	bit_x002fs = 0,
	byte_x002fs = 1
};
#endif

/* eml2_3ForGsoap.h:5053 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUom (-998)

/* eml23:DiffusionCoefficientUom */
enum class eml23__DiffusionCoefficientUom {
	m2_x002fs = 0
};
#endif

/* eml2_3ForGsoap.h:5064 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUom (-999)

/* eml23:DiffusiveTimeOfFlightUom */
enum class eml23__DiffusiveTimeOfFlightUom {
	h_x00280_x002e5_x0029 = 0,
	s_x00280_x002e5_x0029 = 1
};
#endif

/* eml2_3ForGsoap.h:5076 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUom (-1000)

/* eml23:DigitalStorageUom */
enum class eml23__DigitalStorageUom {
	bit = 0,
	byte = 1,
	Kibyte = 2,
	Mibyte = 3
};
#endif

/* eml2_3ForGsoap.h:5102 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUom (-1001)

/* eml23:DimensionlessUom */
enum class eml23__DimensionlessUom {
	_x0025 = 0,
	cEuc = 1,
	dEuc = 2,
	EEuc = 3,
	Euc = 4,
	fEuc = 5,
	GEuc = 6,
	kEuc = 7,
	MEuc = 8,
	mEuc = 9,
	nEuc = 10,
	pEuc = 11,
	ppk = 12,
	ppm = 13,
	TEuc = 14,
	uEuc = 15
};
#endif

/* eml2_3ForGsoap.h:5188 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUom (-1002)

/* eml23:DipoleMomentUom */
enum class eml23__DipoleMomentUom {
	C_x002em = 0
};
#endif

/* eml2_3ForGsoap.h:5199 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUom (-1003)

/* eml23:DoseEquivalentUom */
enum class eml23__DoseEquivalentUom {
	mrem = 0,
	mSv = 1,
	rem = 2,
	Sv = 3
};
#endif

/* eml2_3ForGsoap.h:5225 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUom (-1004)

/* eml23:DynamicViscosityUom */
enum class eml23__DynamicViscosityUom {
	P = 'P',
	cP = 'Q',
	dP = 'R',
	dyne_x002es_x002fcm2 = 'S',
	EP = 'T',
	fP = 'U',
	GP = 'V',
	kgf_x002es_x002fm2 = 'W',
	kP = 'X',
	lbf_x002es_x002fft2 = 'Y',
	lbf_x002es_x002fin2 = 'Z',
	mP = 91,
	MP = 92,
	mPa_x002es = 93,
	N_x002es_x002fm2 = 94,
	nP = 95,
	Pa_x002es = 96,
	pP = 'a',
	psi_x002es = 'b',
	TP = 'c',
	uP = 'd'
};
#endif

/* eml2_3ForGsoap.h:5336 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUom (-1005)

/* eml23:ElectricalResistivityUom */
enum class eml23__ElectricalResistivityUom {
	kohm_x002em = 0,
	nohm_x002emil2_x002fft = 1,
	nohm_x002emm2_x002fm = 2,
	ohm_x002ecm = 3,
	ohm_x002em = 4,
	ohm_x002em2_x002fm = 5
};
#endif

/* eml2_3ForGsoap.h:5372 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUom (-1006)

/* eml23:ElectricChargePerAreaUom */
enum class eml23__ElectricChargePerAreaUom {
	C_x002fcm2 = 0,
	C_x002fm2 = 1,
	C_x002fmm2 = 2,
	mC_x002fm2 = 3
};
#endif

/* eml2_3ForGsoap.h:5398 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUom (-1007)

/* eml23:ElectricChargePerMassUom */
enum class eml23__ElectricChargePerMassUom {
	A_x002es_x002fkg = 0,
	C_x002fg = 1,
	C_x002fkg = 2
};
#endif

/* eml2_3ForGsoap.h:5419 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUom (-1008)

/* eml23:ElectricChargePerVolumeUom */
enum class eml23__ElectricChargePerVolumeUom {
	A_x002es_x002fm3 = 0,
	C_x002fcm3 = 1,
	C_x002fm3 = 2,
	C_x002fmm3 = 3
};
#endif

/* eml2_3ForGsoap.h:5445 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUom (-1009)

/* eml23:ElectricChargeUom */
enum class eml23__ElectricChargeUom {
	C = 'C',
	A_x002eh = 'D',
	A_x002es = 'E',
	cC = 'F',
	dC = 'G',
	EC = 'H',
	fC = 'I',
	GC = 'J',
	kC = 'K',
	MC = 'L',
	mC = 'M',
	nC = 'N',
	pC = 'O',
	TC = 'P',
	uC = 'Q'
};
#endif

/* eml2_3ForGsoap.h:5526 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUom (-1010)

/* eml23:ElectricConductanceUom */
enum class eml23__ElectricConductanceUom {
	S = 'S',
	cS = 'T',
	dS = 'U',
	ES = 'V',
	fS = 'W',
	GS = 'X',
	kS = 'Y',
	mS = 'Z',
	MS = 91,
	nS = 92,
	pS = 93,
	TS = 94,
	uS = 95
};
#endif

/* eml2_3ForGsoap.h:5597 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUom (-1011)

/* eml23:ElectricConductivityUom */
enum class eml23__ElectricConductivityUom {
	kS_x002fm = 0,
	mS_x002fcm = 1,
	mS_x002fm = 2,
	S_x002fm = 3
};
#endif

/* eml2_3ForGsoap.h:5623 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUom (-1012)

/* eml23:ElectricCurrentDensityUom */
enum class eml23__ElectricCurrentDensityUom {
	A_x002fcm2 = 0,
	A_x002fft2 = 1,
	A_x002fm2 = 2,
	A_x002fmm2 = 3,
	mA_x002fcm2 = 4,
	mA_x002fft2 = 5,
	uA_x002fcm2 = 6,
	uA_x002fin2 = 7
};
#endif

/* eml2_3ForGsoap.h:5669 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUom (-1013)

/* eml23:ElectricCurrentUom */
enum class eml23__ElectricCurrentUom {
	A = 'A',
	cA = 'B',
	dA = 'C',
	EA = 'D',
	fA = 'E',
	GA = 'F',
	kA = 'G',
	MA = 'H',
	mA = 'I',
	nA = 'J',
	pA = 'K',
	TA = 'L',
	uA = 'M'
};
#endif

/* eml2_3ForGsoap.h:5740 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUom (-1014)

/* eml23:ElectricFieldStrengthUom */
enum class eml23__ElectricFieldStrengthUom {
	mV_x002fft = 0,
	mV_x002fm = 1,
	uV_x002fft = 2,
	uV_x002fm = 3,
	V_x002fm = 4
};
#endif

/* eml2_3ForGsoap.h:5771 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUom (-1015)

/* eml23:ElectricPotentialDifferenceUom */
enum class eml23__ElectricPotentialDifferenceUom {
	V = 'V',
	cV = 'W',
	dV = 'X',
	fV = 'Y',
	GV = 'Z',
	kV = 91,
	mV = 92,
	MV = 93,
	nV = 94,
	pV = 95,
	TV = 96,
	uV = 'a'
};
#endif

/* eml2_3ForGsoap.h:5837 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUom (-1016)

/* eml23:ElectricResistancePerLengthUom */
enum class eml23__ElectricResistancePerLengthUom {
	ohm_x002fm = 0,
	uohm_x002fft = 1,
	uohm_x002fm = 2
};
#endif

/* eml2_3ForGsoap.h:5858 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUom (-1017)

/* eml23:ElectricResistanceUom */
enum class eml23__ElectricResistanceUom {
	cohm = 0,
	dohm = 1,
	Eohm = 2,
	fohm = 3,
	Gohm = 4,
	kohm = 5,
	Mohm = 6,
	mohm = 7,
	nohm = 8,
	ohm = 9,
	pohm = 10,
	Tohm = 11,
	uohm = 12
};
#endif

/* eml2_3ForGsoap.h:5929 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUom (-1018)

/* eml23:ElectromagneticMomentUom */
enum class eml23__ElectromagneticMomentUom {
	A_x002em2 = 0
};
#endif

/* eml2_3ForGsoap.h:5940 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUom (-1019)

/* eml23:EnergyLengthPerAreaUom */
enum class eml23__EnergyLengthPerAreaUom {
	J_x002em_x002fm2 = 0,
	kcal_x005bth_x005d_x002em_x002fcm2 = 1
};
#endif

/* eml2_3ForGsoap.h:5956 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUom (-1020)

/* eml23:EnergyLengthPerTimeAreaTemperatureUom */
enum class eml23__EnergyLengthPerTimeAreaTemperatureUom {
	Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	J_x002em_x002f_x0028s_x002em2_x002edeltaK_x0029 = 1,
	kJ_x002em_x002f_x0028h_x002em2_x002edeltaK_x0029 = 2,
	W_x002f_x0028m_x002edeltaK_x0029 = 3
};
#endif

/* eml2_3ForGsoap.h:5982 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUom (-1021)

/* eml23:EnergyPerAreaUom */
enum class eml23__EnergyPerAreaUom {
	erg_x002fcm2 = 0,
	J_x002fcm2 = 1,
	J_x002fm2 = 2,
	kgf_x002em_x002fcm2 = 3,
	lbf_x002eft_x002fin2 = 4,
	mJ_x002fcm2 = 5,
	mJ_x002fm2 = 6,
	N_x002fm = 7
};
#endif

/* eml2_3ForGsoap.h:6028 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUom (-1022)

/* eml23:EnergyPerLengthUom */
enum class eml23__EnergyPerLengthUom {
	J_x002fm = 0,
	MJ_x002fm = 1
};
#endif

/* eml2_3ForGsoap.h:6044 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUom (-1023)

/* eml23:EnergyPerMassPerTimeUom */
enum class eml23__EnergyPerMassPerTimeUom {
	mrem_x002fh = 0,
	mSv_x002fh = 1,
	rem_x002fh = 2,
	Sv_x002fh = 3,
	Sv_x002fs = 4
};
#endif

/* eml2_3ForGsoap.h:6075 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUom (-1024)

/* eml23:EnergyPerMassUom */
enum class eml23__EnergyPerMassUom {
	Btu_x005bIT_x005d_x002flbm = 0,
	cal_x005bth_x005d_x002fg = 1,
	cal_x005bth_x005d_x002fkg = 2,
	cal_x005bth_x005d_x002flbm = 3,
	erg_x002fg = 4,
	erg_x002fkg = 5,
	hp_x002eh_x002flbm = 6,
	J_x002fg = 7,
	J_x002fkg = 8,
	kcal_x005bth_x005d_x002fg = 9,
	kcal_x005bth_x005d_x002fkg = 10,
	kJ_x002fkg = 11,
	kW_x002eh_x002fkg = 12,
	lbf_x002eft_x002flbm = 13,
	MJ_x002fkg = 14,
	MW_x002eh_x002fkg = 15
};
#endif

/* eml2_3ForGsoap.h:6161 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUom (-1025)

/* eml23:EnergyPerVolumeUom */
enum class eml23__EnergyPerVolumeUom {
	Btu_x005bIT_x005d_x002fbbl = 0,
	Btu_x005bIT_x005d_x002fft3 = 1,
	Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 2,
	Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 3,
	cal_x005bth_x005d_x002fcm3 = 4,
	cal_x005bth_x005d_x002fmL = 5,
	cal_x005bth_x005d_x002fmm3 = 6,
	erg_x002fcm3 = 7,
	erg_x002fm3 = 8,
	hp_x002eh_x002fbbl = 9,
	J_x002fdm3 = 10,
	J_x002fm3 = 11,
	kcal_x005bth_x005d_x002fcm3 = 12,
	kcal_x005bth_x005d_x002fm3 = 13,
	kJ_x002fdm3 = 14,
	kJ_x002fm3 = 15,
	kW_x002eh_x002fdm3 = 16,
	kW_x002eh_x002fm3 = 17,
	lbf_x002eft_x002fbbl = 18,
	lbf_x002eft_x002fgal_x005bUS_x005d = 19,
	MJ_x002fm3 = 20,
	MW_x002eh_x002fm3 = 21,
	tonf_x005bUS_x005d_x002emi_x002fbbl = 22
};
#endif

/* eml2_3ForGsoap.h:6282 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUom (-1026)

/* eml23:EnergyUom */
enum class eml23__EnergyUom {
	J = 'J',
	_1E6_x0020Btu_x005bIT_x005d = 'K',
	aJ = 'L',
	Btu_x005bIT_x005d = 'M',
	Btu_x005bth_x005d = 'N',
	Btu_x005bUK_x005d = 'O',
	cal_x005bIT_x005d = 'P',
	cal_x005bth_x005d = 'Q',
	ccal_x005bth_x005d = 'R',
	ceV = 'S',
	cJ = 'T',
	dcal_x005bth_x005d = 'U',
	deV = 'V',
	dJ = 'W',
	Ecal_x005bth_x005d = 'X',
	EeV = 'Y',
	EJ = 'Z',
	erg = 91,
	eV = 92,
	fcal_x005bth_x005d = 93,
	feV = 94,
	fJ = 95,
	Gcal_x005bth_x005d = 96,
	GeV = 'a',
	GJ = 'b',
	GW_x002eh = 'c',
	hp_x002eh = 'd',
	hp_x005bmetric_x005d_x002eh = 'e',
	kcal_x005bth_x005d = 'f',
	keV = 'g',
	kJ = 'h',
	kW_x002eh = 'i',
	mcal_x005bth_x005d = 'j',
	Mcal_x005bth_x005d = 'k',
	meV = 'l',
	MeV = 'm',
	MJ = 'n',
	mJ = 'o',
	MW_x002eh = 'p',
	ncal_x005bth_x005d = 'q',
	neV = 'r',
	nJ = 's',
	pcal_x005bth_x005d = 't',
	peV = 'u',
	pJ = 'v',
	quad = 'w',
	Tcal_x005bth_x005d = 'x',
	TeV = 'y',
	therm_x005bEC_x005d = 'z',
	therm_x005bUK_x005d = 123,
	therm_x005bUS_x005d = 124,
	TJ = 125,
	TW_x002eh = 126,
	ucal_x005bth_x005d = 127,
	ueV = 128,
	uJ = 129
};
#endif

/* eml2_3ForGsoap.h:6568 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUom (-1027)

/* eml23:ForceAreaUom */
enum class eml23__ForceAreaUom {
	dyne_x002ecm2 = 0,
	kgf_x002em2 = 1,
	kN_x002em2 = 2,
	lbf_x002ein2 = 3,
	mN_x002em2 = 4,
	N_x002em2 = 5,
	pdl_x002ecm2 = 6,
	tonf_x005bUK_x005d_x002eft2 = 7,
	tonf_x005bUS_x005d_x002eft2 = 8
};
#endif

/* eml2_3ForGsoap.h:6619 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUom (-1028)

/* eml23:ForceLengthPerLengthUom */
enum class eml23__ForceLengthPerLengthUom {
	kgf_x002em_x002fm = 0,
	lbf_x002eft_x002fin = 1,
	lbf_x002ein_x002fin = 2,
	N_x002em_x002fm = 3,
	tonf_x005bUS_x005d_x002emi_x002fft = 4
};
#endif

/* eml2_3ForGsoap.h:6650 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUom (-1029)

/* eml23:ForcePerForceUom */
enum class eml23__ForcePerForceUom {
	_x0025 = 0,
	Euc = 1,
	kgf_x002fkgf = 2,
	lbf_x002flbf = 3,
	N_x002fN = 4
};
#endif

/* eml2_3ForGsoap.h:6681 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUom (-1030)

/* eml23:ForcePerLengthUom */
enum class eml23__ForcePerLengthUom {
	_0_x002e01_x0020lbf_x002fft = 0,
	_1_x002f30_x0020lbf_x002fm = 1,
	_1_x002f30_x0020N_x002fm = 2,
	dyne_x002fcm = 3,
	kgf_x002fcm = 4,
	kN_x002fm = 5,
	lbf_x002fft = 6,
	lbf_x002fin = 7,
	mN_x002fkm = 8,
	mN_x002fm = 9,
	N_x002fm = 10,
	pdl_x002fcm = 11,
	tonf_x005bUK_x005d_x002fft = 12,
	tonf_x005bUS_x005d_x002fft = 13
};
#endif

/* eml2_3ForGsoap.h:6757 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUom (-1031)

/* eml23:ForcePerVolumeUom */
enum class eml23__ForcePerVolumeUom {
	_0_x002e001_x0020psi_x002fft = 0,
	_0_x002e01_x0020psi_x002fft = 1,
	atm_x002fft = 2,
	atm_x002fhm = 3,
	atm_x002fm = 4,
	bar_x002fkm = 5,
	bar_x002fm = 6,
	GPa_x002fcm = 7,
	kPa_x002fhm = 8,
	kPa_x002fm = 9,
	lbf_x002fft3 = 10,
	lbf_x002fgal_x005bUS_x005d = 11,
	MPa_x002fm = 12,
	N_x002fm3 = 13,
	Pa_x002fm = 14,
	psi_x002fft = 15,
	psi_x002fm = 16
};
#endif

/* eml2_3ForGsoap.h:6848 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceUom (-1032)

/* eml23:ForceUom */
enum class eml23__ForceUom {
	N = 'N',
	_10_x0020kN = 'O',
	cN = 'P',
	daN = 'Q',
	dN = 'R',
	dyne = 'S',
	EN = 'T',
	fN = 'U',
	gf = 'V',
	GN = 'W',
	hN = 'X',
	kdyne = 'Y',
	kgf = 'Z',
	klbf = 91,
	kN = 92,
	lbf = 93,
	Mgf = 94,
	mN = 95,
	MN = 96,
	nN = 'a',
	ozf = 'b',
	pdl = 'c',
	pN = 'd',
	TN = 'e',
	tonf_x005bUK_x005d = 'f',
	tonf_x005bUS_x005d = 'g',
	uN = 'h'
};
#endif

/* eml2_3ForGsoap.h:6989 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUom (-1033)

/* eml23:FrequencyIntervalUom */
enum class eml23__FrequencyIntervalUom {
	O = 'O'
};
#endif

/* eml2_3ForGsoap.h:7000 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUom (-1034)

/* eml23:FrequencyUom */
enum class eml23__FrequencyUom {
	cHz = 0,
	dHz = 1,
	EHz = 2,
	fHz = 3,
	GHz = 4,
	Hz = 5,
	kHz = 6,
	mHz = 7,
	MHz = 8,
	nHz = 9,
	pHz = 10,
	THz = 11,
	uHz = 12
};
#endif

/* eml2_3ForGsoap.h:7071 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUom (-1035)

/* eml23:HeatCapacityUom */
enum class eml23__HeatCapacityUom {
	J_x002fdeltaK = 0
};
#endif

/* eml2_3ForGsoap.h:7082 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUom (-1036)

/* eml23:HeatFlowRateUom */
enum class eml23__HeatFlowRateUom {
	W = 'W',
	_1E6_x0020Btu_x005bIT_x005d_x002fh = 'X',
	Btu_x005bIT_x005d_x002fh = 'Y',
	Btu_x005bIT_x005d_x002fmin = 'Z',
	Btu_x005bIT_x005d_x002fs = 91,
	cal_x005bth_x005d_x002fh = 92,
	EJ_x002fa = 93,
	erg_x002fa = 94,
	GW = 95,
	J_x002fs = 96,
	kcal_x005bth_x005d_x002fh = 'a',
	kW = 'b',
	lbf_x002eft_x002fmin = 'c',
	lbf_x002eft_x002fs = 'd',
	MJ_x002fa = 'e',
	mW = 'f',
	MW = 'g',
	nW = 'h',
	quad_x002fa = 'i',
	TJ_x002fa = 'j',
	TW = 'k',
	ucal_x005bth_x005d_x002fs = 'l',
	uW = 'm'
};
#endif

/* eml2_3ForGsoap.h:7203 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUom (-1037)

/* eml23:HeatTransferCoefficientUom */
enum class eml23__HeatTransferCoefficientUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaR_x0029 = 1,
	Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 2,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edeltaF_x0029 = 3,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edeltaC_x0029 = 4,
	cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edeltaC_x0029 = 5,
	J_x002f_x0028s_x002em2_x002edeltaC_x0029 = 6,
	kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 7,
	kJ_x002f_x0028h_x002em2_x002edeltaK_x0029 = 8,
	kW_x002f_x0028m2_x002edeltaK_x0029 = 9,
	W_x002f_x0028m2_x002edeltaK_x0029 = 10
};
#endif

/* eml2_3ForGsoap.h:7264 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUom (-1038)

/* eml23:IlluminanceUom */
enum class eml23__IlluminanceUom {
	footcandle = 0,
	klx = 1,
	lm_x002fm2 = 2,
	lx = 3
};
#endif

/* eml2_3ForGsoap.h:7290 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUom (-1039)

/* eml23:InductanceUom */
enum class eml23__InductanceUom {
	H = 'H',
	cH = 'I',
	dH = 'J',
	EH = 'K',
	fH = 'L',
	GH = 'M',
	kH = 'N',
	MH = 'O',
	mH = 'P',
	nH = 'Q',
	TH = 'R',
	uH = 'S'
};
#endif

/* eml2_3ForGsoap.h:7356 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUom (-1040)

/* eml23:IsothermalCompressibilityUom */
enum class eml23__IsothermalCompressibilityUom {
	dm3_x002f_x0028kW_x002eh_x0029 = 0,
	dm3_x002fMJ = 1,
	m3_x002f_x0028kW_x002eh_x0029 = 2,
	m3_x002fJ = 3,
	mm3_x002fJ = 4,
	pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 5
};
#endif

/* eml2_3ForGsoap.h:7392 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUom (-1041)

/* eml23:KinematicViscosityUom */
enum class eml23__KinematicViscosityUom {
	cm2_x002fs = 0,
	cSt = 1,
	ft2_x002fh = 2,
	ft2_x002fs = 3,
	in2_x002fs = 4,
	m2_x002fh = 5,
	m2_x002fs = 6,
	mm2_x002fs = 7,
	Pa_x002es_x002em3_x002fkg = 8,
	St = 9
};
#endif

/* eml2_3ForGsoap.h:7448 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUom (-1042)

/* eml23:LengthPerLengthUom */
enum class eml23__LengthPerLengthUom {
	_x0025 = 0,
	_0_x002e01_x0020ft_x002fft = 1,
	_1_x002f30_x0020m_x002fm = 2,
	Euc = 3,
	ft_x002fft = 4,
	ft_x002fin = 5,
	ft_x002fm = 6,
	ft_x002fmi = 7,
	km_x002fcm = 8,
	m_x002fcm = 9,
	m_x002fkm = 10,
	m_x002fm = 11,
	mi_x002fin = 12
};
#endif

/* eml2_3ForGsoap.h:7519 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUom (-1043)

/* eml23:LengthPerMassUom */
enum class eml23__LengthPerMassUom {
	ft_x002flbm = 0,
	m_x002fkg = 1
};
#endif

/* eml2_3ForGsoap.h:7535 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUom (-1044)

/* eml23:LengthPerPressureUom */
enum class eml23__LengthPerPressureUom {
	ft_x002fpsi = 0,
	m_x002fkPa = 1,
	m_x002fPa = 2
};
#endif

/* eml2_3ForGsoap.h:7556 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUom (-1045)

/* eml23:LengthPerTemperatureUom */
enum class eml23__LengthPerTemperatureUom {
	ft_x002fdeltaF = 0,
	m_x002fdeltaK = 1
};
#endif

/* eml2_3ForGsoap.h:7572 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUom (-1046)

/* eml23:LengthPerTimeUom */
enum class eml23__LengthPerTimeUom {
	_1000_x0020ft_x002fh = 0,
	_1000_x0020ft_x002fs = 1,
	cm_x002fa = 2,
	cm_x002fs = 3,
	dm_x002fs = 4,
	ft_x002fd = 5,
	ft_x002fh = 6,
	ft_x002fmin = 7,
	ft_x002fms = 8,
	ft_x002fs = 9,
	ft_x002fus = 10,
	in_x002fa = 11,
	in_x002fmin = 12,
	in_x002fs = 13,
	km_x002fh = 14,
	km_x002fs = 15,
	knot = 16,
	m_x002fd = 17,
	m_x002fh = 18,
	m_x002fmin = 19,
	m_x002fms = 20,
	m_x002fs = 21,
	mi_x002fh = 22,
	mil_x002fa = 23,
	mm_x002fa = 24,
	mm_x002fs = 25,
	nm_x002fs = 26,
	um_x002fs = 27
};
#endif

/* eml2_3ForGsoap.h:7718 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUom (-1047)

/* eml23:LengthPerVolumeUom */
enum class eml23__LengthPerVolumeUom {
	ft_x002fbbl = 0,
	ft_x002fft3 = 1,
	ft_x002fgal_x005bUS_x005d = 2,
	km_x002fdm3 = 3,
	km_x002fL = 4,
	m_x002fm3 = 5,
	mi_x002fgal_x005bUK_x005d = 6,
	mi_x002fgal_x005bUS_x005d = 7
};
#endif

/* eml2_3ForGsoap.h:7764 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthUom (-1048)

/* eml23:LengthUom */
enum class eml23__LengthUom {
	m = 'm',
	_0_x002e1_x0020ft = 'n',
	_0_x002e1_x0020ft_x005bUS_x005d = 'o',
	_0_x002e1_x0020in = 'p',
	_0_x002e1_x0020yd = 'q',
	_1_x002f16_x0020in = 'r',
	_1_x002f2_x0020ft = 's',
	_1_x002f32_x0020in = 't',
	_1_x002f64_x0020in = 'u',
	_10_x0020ft = 'v',
	_10_x0020in = 'w',
	_10_x0020km = 'x',
	_100_x0020ft = 'y',
	_100_x0020km = 'z',
	_1000_x0020ft = 123,
	_30_x0020ft = 124,
	_30_x0020m = 125,
	angstrom = 126,
	chain = 127,
	chain_x005bBnA_x005d = 128,
	chain_x005bBnB_x005d = 129,
	chain_x005bCla_x005d = 130,
	chain_x005bInd37_x005d = 131,
	chain_x005bSe_x005d = 132,
	chain_x005bSeT_x005d = 133,
	chain_x005bUS_x005d = 134,
	cm = 135,
	dam = 136,
	dm = 137,
	Em = 138,
	fathom = 139,
	fm = 140,
	ft = 141,
	ft_x005bBnA_x005d = 142,
	ft_x005bBnB_x005d = 143,
	ft_x005bBr36_x005d = 144,
	ft_x005bBr65_x005d = 145,
	ft_x005bCla_x005d = 146,
	ft_x005bGC_x005d = 147,
	ft_x005bInd_x005d = 148,
	ft_x005bInd37_x005d = 149,
	ft_x005bInd62_x005d = 150,
	ft_x005bInd75_x005d = 151,
	ft_x005bSe_x005d = 152,
	ft_x005bSeT_x005d = 153,
	ft_x005bUS_x005d = 154,
	fur_x005bUS_x005d = 155,
	Gm = 156,
	hm = 157,
	in = 158,
	in_x005bUS_x005d = 159,
	km = 160,
	link = 161,
	link_x005bBnA_x005d = 162,
	link_x005bBnB_x005d = 163,
	link_x005bCla_x005d = 164,
	link_x005bSe_x005d = 165,
	link_x005bSeT_x005d = 166,
	link_x005bUS_x005d = 167,
	m_x005bGer_x005d = 168,
	mi = 169,
	mi_x005bnaut_x005d = 170,
	mi_x005bnautUK_x005d = 171,
	mi_x005bUS_x005d = 172,
	mil = 173,
	mm = 174,
	Mm = 175,
	nm = 176,
	pm = 177,
	rod_x005bUS_x005d = 178,
	Tm = 179,
	um = 180,
	yd = 181,
	yd_x005bBnA_x005d = 182,
	yd_x005bBnB_x005d = 183,
	yd_x005bCla_x005d = 184,
	yd_x005bInd_x005d = 185,
	yd_x005bInd37_x005d = 186,
	yd_x005bInd62_x005d = 187,
	yd_x005bInd75_x005d = 188,
	yd_x005bSe_x005d = 189,
	yd_x005bSeT_x005d = 190,
	yd_x005bUS_x005d = 191
};
#endif

/* eml2_3ForGsoap.h:8185 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUom (-1049)

/* eml23:LightExposureUom */
enum class eml23__LightExposureUom {
	footcandle_x002es = 0,
	lx_x002es = 1
};
#endif

/* eml2_3ForGsoap.h:8201 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUom (-1050)

/* eml23:LinearAccelerationUom */
enum class eml23__LinearAccelerationUom {
	cm_x002fs2 = 0,
	ft_x002fs2 = 1,
	Gal = 2,
	gn = 3,
	in_x002fs2 = 4,
	m_x002fs2 = 5,
	mGal = 6,
	mgn = 7
};
#endif

/* eml2_3ForGsoap.h:8247 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUom (-1051)

/* eml23:LinearThermalExpansionUom */
enum class eml23__LinearThermalExpansionUom {
	_1_x002fdeltaK = 0,
	in_x002f_x0028in_x002edeltaF_x0029 = 1,
	m_x002f_x0028m_x002edeltaK_x0029 = 2,
	mm_x002f_x0028mm_x002edeltaK_x0029 = 3
};
#endif

/* eml2_3ForGsoap.h:8273 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUom (-1052)

/* eml23:LogarithmicPowerRatioPerLengthUom */
enum class eml23__LogarithmicPowerRatioPerLengthUom {
	B_x002fm = 0,
	dB_x002fft = 1,
	dB_x002fkm = 2,
	dB_x002fm = 3
};
#endif

/* eml2_3ForGsoap.h:8299 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUom (-1053)

/* eml23:LogarithmicPowerRatioUom */
enum class eml23__LogarithmicPowerRatioUom {
	B = 'B',
	dB = 'C'
};
#endif

/* eml2_3ForGsoap.h:8315 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUom (-1054)

/* eml23:LuminanceUom */
enum class eml23__LuminanceUom {
	cd_x002fm2 = 0
};
#endif

/* eml2_3ForGsoap.h:8326 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUom (-1055)

/* eml23:LuminousEfficacyUom */
enum class eml23__LuminousEfficacyUom {
	lm_x002fW = 0
};
#endif

/* eml2_3ForGsoap.h:8337 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUom (-1056)

/* eml23:LuminousFluxUom */
enum class eml23__LuminousFluxUom {
	lm = 0
};
#endif

/* eml2_3ForGsoap.h:8348 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUom (-1057)

/* eml23:LuminousIntensityUom */
enum class eml23__LuminousIntensityUom {
	cd = 0,
	kcd = 1
};
#endif

/* eml2_3ForGsoap.h:8364 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUom (-1058)

/* eml23:MagneticDipoleMomentUom */
enum class eml23__MagneticDipoleMomentUom {
	Wb_x002em = 0
};
#endif

/* eml2_3ForGsoap.h:8375 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUom (-1059)

/* eml23:MagneticFieldStrengthUom */
enum class eml23__MagneticFieldStrengthUom {
	A_x002fm = 0,
	A_x002fmm = 1,
	Oe = 2
};
#endif

/* eml2_3ForGsoap.h:8396 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUom (-1060)

/* eml23:MagneticFluxDensityPerLengthUom */
enum class eml23__MagneticFluxDensityPerLengthUom {
	gauss_x002fcm = 0,
	mT_x002fdm = 1,
	T_x002fm = 2
};
#endif

/* eml2_3ForGsoap.h:8417 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUom (-1061)

/* eml23:MagneticFluxDensityUom */
enum class eml23__MagneticFluxDensityUom {
	T = 'T',
	cgauss = 'U',
	cT = 'V',
	dgauss = 'W',
	dT = 'X',
	Egauss = 'Y',
	ET = 'Z',
	fgauss = 91,
	fT = 92,
	gauss = 93,
	Ggauss = 94,
	GT = 95,
	kgauss = 96,
	kT = 'a',
	mgauss = 'b',
	Mgauss = 'c',
	mT = 'd',
	ngauss = 'e',
	nT = 'f',
	pgauss = 'g',
	pT = 'h',
	Tgauss = 'i',
	TT = 'j',
	ugauss = 'k',
	uT = 'l'
};
#endif

/* eml2_3ForGsoap.h:8548 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUom (-1062)

/* eml23:MagneticFluxUom */
enum class eml23__MagneticFluxUom {
	cWb = 0,
	dWb = 1,
	EWb = 2,
	fWb = 3,
	GWb = 4,
	kWb = 5,
	mWb = 6,
	MWb = 7,
	nWb = 8,
	pWb = 9,
	TWb = 10,
	uWb = 11,
	Wb = 12
};
#endif

/* eml2_3ForGsoap.h:8619 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUom (-1063)

/* eml23:MagneticPermeabilityUom */
enum class eml23__MagneticPermeabilityUom {
	H_x002fm = 0,
	uH_x002fm = 1
};
#endif

/* eml2_3ForGsoap.h:8635 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUom (-1064)

/* eml23:MagneticVectorPotentialUom */
enum class eml23__MagneticVectorPotentialUom {
	Wb_x002fm = 0,
	Wb_x002fmm = 1
};
#endif

/* eml2_3ForGsoap.h:8651 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUom (-1065)

/* eml23:MassLengthUom */
enum class eml23__MassLengthUom {
	kg_x002em = 0,
	lbm_x002eft = 1
};
#endif

/* eml2_3ForGsoap.h:8667 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUom (-1066)

/* eml23:MassPerAreaUom */
enum class eml23__MassPerAreaUom {
	_0_x002e01_x0020lbm_x002fft2 = 0,
	kg_x002fm2 = 1,
	lbm_x002fft2 = 2,
	Mg_x002fm2 = 3,
	ton_x005bUS_x005d_x002fft2 = 4
};
#endif

/* eml2_3ForGsoap.h:8698 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUom (-1067)

/* eml23:MassPerEnergyUom */
enum class eml23__MassPerEnergyUom {
	kg_x002f_x0028kW_x002eh_x0029 = 0,
	kg_x002fJ = 1,
	kg_x002fMJ = 2,
	lbm_x002f_x0028hp_x002eh_x0029 = 3,
	mg_x002fJ = 4
};
#endif

/* eml2_3ForGsoap.h:8729 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUom (-1068)

/* eml23:MassPerLengthUom */
enum class eml23__MassPerLengthUom {
	kg_x002em_x002fcm2 = 0,
	kg_x002fm = 1,
	klbm_x002fin = 2,
	lbm_x002fft = 3,
	Mg_x002fin = 4
};
#endif

/* eml2_3ForGsoap.h:8760 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUom (-1069)

/* eml23:MassPerMassUom */
enum class eml23__MassPerMassUom {
	_x0025 = 0,
	_x0025_x005bmass_x005d = 1,
	Euc = 2,
	g_x002fkg = 3,
	g_x002ft = 4,
	kg_x002fkg = 5,
	kg_x002fsack_x005b94lbm_x005d = 6,
	kg_x002ft = 7,
	mg_x002fg = 8,
	mg_x002fkg = 9,
	ng_x002fg = 10,
	ng_x002fmg = 11,
	ppk = 12,
	ppm = 13,
	ppm_x005bmass_x005d = 14,
	ug_x002fg = 15,
	ug_x002fmg = 16
};
#endif

/* eml2_3ForGsoap.h:8851 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUom (-1070)

/* eml23:MassPerTimePerAreaUom */
enum class eml23__MassPerTimePerAreaUom {
	g_x002eft_x002f_x0028cm3_x002es_x0029 = 0,
	g_x002em_x002f_x0028cm3_x002es_x0029 = 1,
	kg_x002f_x0028m2_x002es_x0029 = 2,
	kPa_x002es_x002fm = 3,
	lbm_x002f_x0028ft2_x002eh_x0029 = 4,
	lbm_x002f_x0028ft2_x002es_x0029 = 5,
	MPa_x002es_x002fm = 6
};
#endif

/* eml2_3ForGsoap.h:8892 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUom (-1071)

/* eml23:MassPerTimePerLengthUom */
enum class eml23__MassPerTimePerLengthUom {
	kg_x002f_x0028m_x002es_x0029 = 0,
	lbm_x002f_x0028ft_x002eh_x0029 = 1,
	lbm_x002f_x0028ft_x002es_x0029 = 2,
	Pa_x002es = 3
};
#endif

/* eml2_3ForGsoap.h:8918 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUom (-1072)

/* eml23:MassPerTimeUom */
enum class eml23__MassPerTimeUom {
	_1E6_x0020lbm_x002fa = 0,
	g_x002fs = 1,
	kg_x002fd = 2,
	kg_x002fh = 3,
	kg_x002fmin = 4,
	kg_x002fs = 5,
	lbm_x002fd = 6,
	lbm_x002fh = 7,
	lbm_x002fmin = 8,
	lbm_x002fs = 9,
	Mg_x002fa = 10,
	Mg_x002fd = 11,
	Mg_x002fh = 12,
	Mg_x002fmin = 13,
	t_x002fa = 14,
	t_x002fd = 15,
	t_x002fh = 16,
	t_x002fmin = 17,
	ton_x005bUK_x005d_x002fa = 18,
	ton_x005bUK_x005d_x002fd = 19,
	ton_x005bUK_x005d_x002fh = 20,
	ton_x005bUK_x005d_x002fmin = 21,
	ton_x005bUS_x005d_x002fa = 22,
	ton_x005bUS_x005d_x002fd = 23,
	ton_x005bUS_x005d_x002fh = 24,
	ton_x005bUS_x005d_x002fmin = 25
};
#endif

/* eml2_3ForGsoap.h:9054 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUom (-1073)

/* eml23:MassPerVolumePerLengthUom */
enum class eml23__MassPerVolumePerLengthUom {
	g_x002fcm4 = 0,
	kg_x002fdm4 = 1,
	kg_x002fm4 = 2,
	lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 3,
	lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 4,
	lbm_x002fft4 = 5,
	Pa_x002es2_x002fm3 = 6
};
#endif

/* eml2_3ForGsoap.h:9095 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUom (-1074)

/* eml23:MassPerVolumePerPressureUom */
enum class eml23__MassPerVolumePerPressureUom {
	kg_x002fm3_x002ekPa = 0,
	lb_x002fft_x002epsi = 1
};
#endif

/* eml2_3ForGsoap.h:9103 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUom (-1075)

/* eml23:MassPerVolumePerTemperatureUom */
enum class eml23__MassPerVolumePerTemperatureUom {
	kg_x002fm3_x002edegC = 0,
	kg_x002fm3_x002eK = 1,
	lb_x002fft_x002edegF = 2
};
#endif

/* eml2_3ForGsoap.h:9112 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUom (-1076)

/* eml23:MassPerVolumeUom */
enum class eml23__MassPerVolumeUom {
	_0_x002e001_x0020lbm_x002fbbl = 0,
	_0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 1,
	_0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 2,
	_0_x002e01_x0020grain_x002fft3 = 3,
	_0_x002e1_x0020lbm_x002fbbl = 4,
	_10_x0020Mg_x002fm3 = 5,
	g_x002fcm3 = 6,
	g_x002fdm3 = 7,
	g_x002fgal_x005bUK_x005d = 8,
	g_x002fgal_x005bUS_x005d = 9,
	g_x002fL = 10,
	g_x002fm3 = 11,
	grain_x002fft3 = 12,
	grain_x002fgal_x005bUS_x005d = 13,
	kg_x002fdm3 = 14,
	kg_x002fL = 15,
	kg_x002fm3 = 16,
	lbm_x002fbbl = 17,
	lbm_x002fft3 = 18,
	lbm_x002fgal_x005bUK_x005d = 19,
	lbm_x002fgal_x005bUS_x005d = 20,
	lbm_x002fin3 = 21,
	mg_x002fdm3 = 22,
	mg_x002fgal_x005bUS_x005d = 23,
	mg_x002fL = 24,
	mg_x002fm3 = 25,
	Mg_x002fm3 = 26,
	t_x002fm3 = 27,
	ug_x002fcm3 = 28
};
#endif

/* eml2_3ForGsoap.h:9263 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassUom (-1077)

/* eml23:MassUom */
enum class eml23__MassUom {
	g = 'g',
	t = 't',
	ag = 'u',
	cg = 'v',
	ct = 'w',
	cwt_x005bUK_x005d = 'x',
	cwt_x005bUS_x005d = 'y',
	Eg = 'z',
	fg = 123,
	Gg = 124,
	grain = 125,
	hg = 126,
	kg = 127,
	klbm = 128,
	lbm = 129,
	mg = 130,
	Mg = 131,
	ng = 132,
	ozm = 133,
	ozm_x005btroy_x005d = 134,
	pg = 135,
	sack_x005b94lbm_x005d = 136,
	Tg = 137,
	ton_x005bUK_x005d = 138,
	ton_x005bUS_x005d = 139,
	ug = 140
};
#endif

/* eml2_3ForGsoap.h:9399 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUom (-1078)

/* eml23:MobilityUom */
enum class eml23__MobilityUom {
	D_x002f_x0028Pa_x002es_x0029 = 0,
	D_x002fcP = 1,
	mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 2,
	mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 3,
	mD_x002f_x0028Pa_x002es_x0029 = 4,
	mD_x002fcP = 5,
	TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 6
};
#endif

/* eml2_3ForGsoap.h:9440 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUom (-1079)

/* eml23:MolarEnergyUom */
enum class eml23__MolarEnergyUom {
	Btu_x005bIT_x005d_x002flbmol = 0,
	J_x002fmol = 1,
	kcal_x005bth_x005d_x002fmol = 2,
	kJ_x002fkmol = 3,
	MJ_x002fkmol = 4
};
#endif

/* eml2_3ForGsoap.h:9471 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUom (-1080)

/* eml23:MolarHeatCapacityUom */
enum class eml23__MolarHeatCapacityUom {
	Btu_x005bIT_x005d_x002f_x0028lbmol_x002edeltaF_x0029 = 0,
	cal_x005bth_x005d_x002f_x0028mol_x002edeltaC_x0029 = 1,
	J_x002f_x0028mol_x002edeltaK_x0029 = 2,
	kJ_x002f_x0028kmol_x002edeltaK_x0029 = 3
};
#endif

/* eml2_3ForGsoap.h:9497 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUom (-1081)

/* eml23:MolarVolumeUom */
enum class eml23__MolarVolumeUom {
	dm3_x002fkmol = 0,
	ft3_x002flbmol = 1,
	L_x002fkmol = 2,
	L_x002fmol = 3,
	m3_x002fkmol = 4,
	m3_x002fmol = 5
};
#endif

/* eml2_3ForGsoap.h:9533 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUom (-1082)

/* eml23:MolecularWeightUom */
enum class eml23__MolecularWeightUom {
	g_x002fmol = 0,
	kg_x002fmol = 1,
	lbm_x002flbmol = 2
};
#endif

/* eml2_3ForGsoap.h:9554 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUom (-1083)

/* eml23:MomentOfForceUom */
enum class eml23__MomentOfForceUom {
	J = 'J',
	_1000_x0020lbf_x002eft = 'K',
	daN_x002em = 'L',
	dN_x002em = 'M',
	kgf_x002em = 'N',
	kN_x002em = 'O',
	lbf_x002eft = 'P',
	lbf_x002ein = 'Q',
	lbm_x002eft2_x002fs2 = 'R',
	N_x002em = 'S',
	pdl_x002eft = 'T',
	tonf_x005bUS_x005d_x002eft = 'U',
	tonf_x005bUS_x005d_x002emi = 'V'
};
#endif

/* eml2_3ForGsoap.h:9625 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUom (-1084)

/* eml23:MomentOfInertiaUom */
enum class eml23__MomentOfInertiaUom {
	kg_x002em2 = 0,
	lbm_x002eft2 = 1
};
#endif

/* eml2_3ForGsoap.h:9641 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUom (-1085)

/* eml23:MomentumUom */
enum class eml23__MomentumUom {
	kg_x002em_x002fs = 0,
	lbm_x002eft_x002fs = 1
};
#endif

/* eml2_3ForGsoap.h:9657 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUom (-1086)

/* eml23:NormalizedPowerUom */
enum class eml23__NormalizedPowerUom {
	B_x002eW = 0,
	dB_x002emW = 1,
	dB_x002eMW = 2,
	dB_x002eW = 3
};
#endif

/* eml2_3ForGsoap.h:9683 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUom (-1087)

/* eml23:PermeabilityLengthUom */
enum class eml23__PermeabilityLengthUom {
	D_x002eft = 0,
	D_x002em = 1,
	mD_x002eft = 2,
	mD_x002em = 3,
	TD_x005bAPI_x005d_x002em = 4
};
#endif

/* eml2_3ForGsoap.h:9714 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUom (-1088)

/* eml23:PermeabilityRockUom */
enum class eml23__PermeabilityRockUom {
	D = 'D',
	D_x005bAPI_x005d = 'E',
	mD = 'F',
	TD_x005bAPI_x005d = 'G'
};
#endif

/* eml2_3ForGsoap.h:9740 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUom (-1089)

/* eml23:PermittivityUom */
enum class eml23__PermittivityUom {
	F_x002fm = 0,
	uF_x002fm = 1
};
#endif

/* eml2_3ForGsoap.h:9756 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUom (-1090)

/* eml23:PlaneAngleUom */
enum class eml23__PlaneAngleUom {
	_0_x002e001_x0020seca = 0,
	ccgr = 1,
	cgr = 2,
	dega = 3,
	gon = 4,
	krad = 5,
	mila = 6,
	mina = 7,
	Mrad = 8,
	mrad = 9,
	rad = 10,
	rev = 11,
	seca = 12,
	urad = 13
};
#endif

/* eml2_3ForGsoap.h:9832 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUom (-1091)

/* eml23:PotentialDifferencePerPowerDropUom */
enum class eml23__PotentialDifferencePerPowerDropUom {
	V_x002fB = 0,
	V_x002fdB = 1
};
#endif

/* eml2_3ForGsoap.h:9848 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUom (-1092)

/* eml23:PowerPerAreaUom */
enum class eml23__PowerPerAreaUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 2,
	hp_x002fin2 = 3,
	hp_x005bhyd_x005d_x002fin2 = 4,
	kW_x002fcm2 = 5,
	kW_x002fm2 = 6,
	mW_x002fm2 = 7,
	ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 8,
	W_x002fcm2 = 9,
	W_x002fm2 = 10,
	W_x002fmm2 = 11
};
#endif

/* eml2_3ForGsoap.h:9914 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUom (-1093)

/* eml23:PowerPerPowerUom */
enum class eml23__PowerPerPowerUom {
	_x0025 = 0,
	Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 1,
	Euc = 2,
	W_x002fkW = 3,
	W_x002fW = 4
};
#endif

/* eml2_3ForGsoap.h:9945 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUom (-1094)

/* eml23:PowerPerVolumeUom */
enum class eml23__PowerPerVolumeUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 2,
	cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 3,
	hp_x002fft3 = 4,
	kW_x002fm3 = 5,
	uW_x002fm3 = 6,
	W_x002fm3 = 7
};
#endif

/* eml2_3ForGsoap.h:9991 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerUom (-1095)

/* eml23:PowerUom */
enum class eml23__PowerUom {
	W = 'W',
	cW = 'X',
	dW = 'Y',
	EW = 'Z',
	fW = 91,
	GW = 92,
	hp = 93,
	hp_x005belec_x005d = 94,
	hp_x005bhyd_x005d = 95,
	hp_x005bmetric_x005d = 96,
	kW = 'a',
	MW = 'b',
	mW = 'c',
	nW = 'd',
	pW = 'e',
	tonRefrig = 'f',
	TW = 'g',
	uW = 'h'
};
#endif

/* eml2_3ForGsoap.h:10087 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUom (-1096)

/* eml23:PressurePerPressureUom */
enum class eml23__PressurePerPressureUom {
	atm_x002fatm = 0,
	bar_x002fbar = 1,
	Euc = 2,
	kPa_x002fkPa = 3,
	MPa_x002fMPa = 4,
	Pa_x002fPa = 5,
	psi_x002fpsi = 6
};
#endif

/* eml2_3ForGsoap.h:10128 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUom (-1097)

/* eml23:PressurePerTimeUom */
enum class eml23__PressurePerTimeUom {
	atm_x002fh = 0,
	bar_x002fh = 1,
	kPa_x002fh = 2,
	kPa_x002fmin = 3,
	MPa_x002fh = 4,
	Pa_x002fh = 5,
	Pa_x002fs = 6,
	psi_x002fh = 7,
	psi_x002fmin = 8
};
#endif

/* eml2_3ForGsoap.h:10179 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUom (-1098)

/* eml23:PressurePerVolumeUom */
enum class eml23__PressurePerVolumeUom {
	Pa_x002fm3 = 0,
	psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1
};
#endif

/* eml2_3ForGsoap.h:10195 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUom (-1099)

/* eml23:PressureSquaredPerForceTimePerAreaUom */
enum class eml23__PressureSquaredPerForceTimePerAreaUom {
	_0_x002e001_x0020kPa2_x002fcP = 0,
	bar2_x002fcP = 1,
	kPa2_x002fcP = 2,
	Pa2_x002f_x0028Pa_x002es_x0029 = 3,
	psi2_x002fcP = 4
};
#endif

/* eml2_3ForGsoap.h:10226 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUom (-1100)

/* eml23:PressureSquaredUom */
enum class eml23__PressureSquaredUom {
	bar2 = 0,
	GPa2 = 1,
	kPa2 = 2,
	kpsi2 = 3,
	Pa2 = 4,
	psi2 = 5
};
#endif

/* eml2_3ForGsoap.h:10262 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUom (-1101)

/* eml23:PressureTimePerVolumeUom */
enum class eml23__PressureTimePerVolumeUom {
	Pa_x002es_x002fm3 = 0,
	psi_x002ed_x002fbbl = 1
};
#endif

/* eml2_3ForGsoap.h:10278 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUom (-1102)

/* eml23:PressureUom */
enum class eml23__PressureUom {
	_0_x002e01_x0020lbf_x002fft2 = 0,
	at = 1,
	atm = 2,
	bar = 3,
	cmH2O_x005b4degC_x005d = 4,
	cPa = 5,
	dPa = 6,
	dyne_x002fcm2 = 7,
	EPa = 8,
	fPa = 9,
	GPa = 10,
	hbar = 11,
	inH2O_x005b39degF_x005d = 12,
	inH2O_x005b60degF_x005d = 13,
	inHg_x005b32degF_x005d = 14,
	inHg_x005b60degF_x005d = 15,
	kgf_x002fcm2 = 16,
	kgf_x002fm2 = 17,
	kgf_x002fmm2 = 18,
	kN_x002fm2 = 19,
	kPa = 20,
	kpsi = 21,
	lbf_x002fft2 = 22,
	mbar = 23,
	mmHg_x005b0degC_x005d = 24,
	mPa = 25,
	MPa = 26,
	Mpsi = 27,
	N_x002fm2 = 28,
	N_x002fmm2 = 29,
	nPa = 30,
	Pa = 31,
	pPa = 32,
	psi = 33,
	tonf_x005bUK_x005d_x002fft2 = 34,
	tonf_x005bUS_x005d_x002fft2 = 35,
	tonf_x005bUS_x005d_x002fin2 = 36,
	torr = 37,
	TPa = 38,
	ubar = 39,
	umHg_x005b0degC_x005d = 40,
	uPa = 41,
	upsi = 42
};
#endif

/* eml2_3ForGsoap.h:10499 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUom (-1103)

/* eml23:QuantityOfLightUom */
enum class eml23__QuantityOfLightUom {
	lm_x002es = 0
};
#endif

/* eml2_3ForGsoap.h:10510 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUom (-1104)

/* eml23:RadianceUom */
enum class eml23__RadianceUom {
	W_x002f_x0028m2_x002esr_x0029 = 0
};
#endif

/* eml2_3ForGsoap.h:10521 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUom (-1105)

/* eml23:RadiantIntensityUom */
enum class eml23__RadiantIntensityUom {
	W_x002fsr = 0
};
#endif

/* eml2_3ForGsoap.h:10532 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUom (-1106)

/* eml23:ReciprocalAreaUom */
enum class eml23__ReciprocalAreaUom {
	_1_x002fft2 = 0,
	_1_x002fkm2 = 1,
	_1_x002fm2 = 2,
	_1_x002fmi2 = 3
};
#endif

/* eml2_3ForGsoap.h:10558 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUom (-1107)

/* eml23:ReciprocalElectricPotentialDifferenceUom */
enum class eml23__ReciprocalElectricPotentialDifferenceUom {
	_1_x002fuV = 0,
	_1_x002fV = 1
};
#endif

/* eml2_3ForGsoap.h:10574 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUom (-1108)

/* eml23:ReciprocalForceUom */
enum class eml23__ReciprocalForceUom {
	_1_x002flbf = 0,
	_1_x002fN = 1
};
#endif

/* eml2_3ForGsoap.h:10590 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUom (-1109)

/* eml23:ReciprocalLengthUom */
enum class eml23__ReciprocalLengthUom {
	_1_x002fangstrom = 0,
	_1_x002fcm = 1,
	_1_x002fft = 2,
	_1_x002fin = 3,
	_1_x002fm = 4,
	_1_x002fmi = 5,
	_1_x002fmm = 6,
	_1_x002fnm = 7,
	_1_x002fyd = 8,
	_1E_9_x00201_x002fft = 9
};
#endif

/* eml2_3ForGsoap.h:10646 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUom (-1110)

/* eml23:ReciprocalMassTimeUom */
enum class eml23__ReciprocalMassTimeUom {
	_1_x002f_x0028kg_x002es_x0029 = 0,
	Bq_x002fkg = 1,
	pCi_x002fg = 2
};
#endif

/* eml2_3ForGsoap.h:10667 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUom (-1111)

/* eml23:ReciprocalMassUom */
enum class eml23__ReciprocalMassUom {
	_1_x002fg = 0,
	_1_x002fkg = 1,
	_1_x002flbm = 2
};
#endif

/* eml2_3ForGsoap.h:10688 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUom (-1112)

/* eml23:ReciprocalPressureUom */
enum class eml23__ReciprocalPressureUom {
	_1_x002fbar = 0,
	_1_x002fkPa = 1,
	_1_x002fPa = 2,
	_1_x002fpPa = 3,
	_1_x002fpsi = 4,
	_1_x002fupsi = 5
};
#endif

/* eml2_3ForGsoap.h:10724 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUom (-1113)

/* eml23:ReciprocalTimeUom */
enum class eml23__ReciprocalTimeUom {
	_1_x002fa = 0,
	_1_x002fd = 1,
	_1_x002fh = 2,
	_1_x002fmin = 3,
	_1_x002fms = 4,
	_1_x002fs = 5,
	_1_x002fus = 6,
	_1_x002fwk = 7
};
#endif

/* eml2_3ForGsoap.h:10770 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUom (-1114)

/* eml23:ReciprocalVolumeUom */
enum class eml23__ReciprocalVolumeUom {
	_1_x002fbbl = 0,
	_1_x002fft3 = 1,
	_1_x002fgal_x005bUK_x005d = 2,
	_1_x002fgal_x005bUS_x005d = 3,
	_1_x002fL = 4,
	_1_x002fm3 = 5
};
#endif

/* eml2_3ForGsoap.h:10806 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUom (-1115)

/* eml23:ReluctanceUom */
enum class eml23__ReluctanceUom {
	_1_x002fH = 0
};
#endif

/* eml2_3ForGsoap.h:10817 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUom (-1116)

/* eml23:SecondMomentOfAreaUom */
enum class eml23__SecondMomentOfAreaUom {
	cm4 = 0,
	in4 = 1,
	m4 = 2
};
#endif

/* eml2_3ForGsoap.h:10838 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUom (-1117)

/* eml23:SignalingEventPerTimeUom */
enum class eml23__SignalingEventPerTimeUom {
	Bd = 0
};
#endif

/* eml2_3ForGsoap.h:10849 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUom (-1118)

/* eml23:SolidAngleUom */
enum class eml23__SolidAngleUom {
	sr = 0
};
#endif

/* eml2_3ForGsoap.h:10860 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUom (-1119)

/* eml23:SpecificHeatCapacityUom */
enum class eml23__SpecificHeatCapacityUom {
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaR_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028g_x002edeltaK_x0029 = 2,
	J_x002f_x0028g_x002edeltaK_x0029 = 3,
	J_x002f_x0028kg_x002edeltaK_x0029 = 4,
	kcal_x005bth_x005d_x002f_x0028kg_x002edeltaC_x0029 = 5,
	kJ_x002f_x0028kg_x002edeltaK_x0029 = 6,
	kW_x002eh_x002f_x0028kg_x002edeltaC_x0029 = 7
};
#endif

/* eml2_3ForGsoap.h:10906 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUom (-1120)

/* eml23:TemperatureIntervalPerLengthUom */
enum class eml23__TemperatureIntervalPerLengthUom {
	_0_x002e01_x0020deltaF_x002fft = 0,
	deltaC_x002fft = 1,
	deltaC_x002fhm = 2,
	deltaC_x002fkm = 3,
	deltaC_x002fm = 4,
	deltaF_x002fft = 5,
	deltaF_x002fm = 6,
	deltaK_x002fkm = 7,
	deltaK_x002fm = 8
};
#endif

/* eml2_3ForGsoap.h:10957 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUom (-1121)

/* eml23:TemperatureIntervalPerPressureUom */
enum class eml23__TemperatureIntervalPerPressureUom {
	deltaC_x002fkPa = 0,
	deltaF_x002fpsi = 1,
	deltaK_x002fPa = 2
};
#endif

/* eml2_3ForGsoap.h:10978 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUom (-1122)

/* eml23:TemperatureIntervalPerTimeUom */
enum class eml23__TemperatureIntervalPerTimeUom {
	deltaC_x002fh = 0,
	deltaC_x002fmin = 1,
	deltaC_x002fs = 2,
	deltaF_x002fh = 3,
	deltaF_x002fmin = 4,
	deltaF_x002fs = 5,
	deltaK_x002fs = 6
};
#endif

/* eml2_3ForGsoap.h:11019 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUom (-1123)

/* eml23:TemperatureIntervalUom */
enum class eml23__TemperatureIntervalUom {
	deltaC = 0,
	deltaF = 1,
	deltaK = 2,
	deltaR = 3
};
#endif

/* eml2_3ForGsoap.h:11045 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUom (-1124)

/* eml23:ThermalConductanceUom */
enum class eml23__ThermalConductanceUom {
	W_x002fdeltaK = 0
};
#endif

/* eml2_3ForGsoap.h:11056 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUom (-1125)

/* eml23:ThermalConductivityUom */
enum class eml23__ThermalConductivityUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edeltaF_x0029 = 0,
	cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edeltaC_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edeltaC_x0029 = 2,
	kcal_x005bth_x005d_x002f_x0028h_x002em_x002edeltaC_x0029 = 3,
	W_x002f_x0028m_x002edeltaK_x0029 = 4
};
#endif

/* eml2_3ForGsoap.h:11087 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUom (-1126)

/* eml23:ThermalDiffusivityUom */
enum class eml23__ThermalDiffusivityUom {
	cm2_x002fs = 0,
	ft2_x002fh = 1,
	ft2_x002fs = 2,
	in2_x002fs = 3,
	m2_x002fh = 4,
	m2_x002fs = 5,
	mm2_x002fs = 6
};
#endif

/* eml2_3ForGsoap.h:11128 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUom (-1127)

/* eml23:ThermalInsulanceUom */
enum class eml23__ThermalInsulanceUom {
	deltaC_x002em2_x002eh_x002fkcal_x005bth_x005d = 0,
	deltaF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 1,
	deltaK_x002em2_x002fkW = 2,
	deltaK_x002em2_x002fW = 3
};
#endif

/* eml2_3ForGsoap.h:11154 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUom (-1128)

/* eml23:ThermalResistanceUom */
enum class eml23__ThermalResistanceUom {
	deltaK_x002fW = 0
};
#endif

/* eml2_3ForGsoap.h:11165 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom (-1129)

/* eml23:ThermodynamicTemperaturePerThermodynamicTemperatureUom */
enum class eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom {
	degC_x002fdegC = 0,
	degF_x002fdegF = 1,
	degR_x002fdegR = 2,
	Euc = 3,
	K_x002fK = 4
};
#endif

/* eml2_3ForGsoap.h:11196 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUom (-1130)

/* eml23:ThermodynamicTemperatureUom */
enum class eml23__ThermodynamicTemperatureUom {
	K = 'K',
	degC = 'L',
	degF = 'M',
	degR = 'N'
};
#endif

/* eml2_3ForGsoap.h:11222 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUom (-1131)

/* eml23:TimePerLengthUom */
enum class eml23__TimePerLengthUom {
	_0_x002e001_x0020h_x002fft = 0,
	h_x002fkm = 1,
	min_x002fft = 2,
	min_x002fm = 3,
	ms_x002fcm = 4,
	ms_x002fft = 5,
	ms_x002fin = 6,
	ms_x002fm = 7,
	ns_x002fft = 8,
	ns_x002fm = 9,
	s_x002fcm = 10,
	s_x002fft = 11,
	s_x002fin = 12,
	s_x002fm = 13,
	us_x002fft = 14,
	us_x002fin = 15,
	us_x002fm = 16
};
#endif

/* eml2_3ForGsoap.h:11313 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUom (-1132)

/* eml23:TimePerMassUom */
enum class eml23__TimePerMassUom {
	s_x002fkg = 0
};
#endif

/* eml2_3ForGsoap.h:11324 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUom (-1133)

/* eml23:TimePerTimeUom */
enum class eml23__TimePerTimeUom {
	_x0025 = 0,
	Euc = 1,
	ms_x002fs = 2,
	s_x002fs = 3
};
#endif

/* eml2_3ForGsoap.h:11350 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUom (-1134)

/* eml23:TimePerVolumeUom */
enum class eml23__TimePerVolumeUom {
	_0_x002e001_x0020d_x002fft3 = 0,
	d_x002fbbl = 1,
	d_x002fft3 = 2,
	d_x002fm3 = 3,
	h_x002fft3 = 4,
	h_x002fm3 = 5,
	s_x002fft3 = 6,
	s_x002fL = 7,
	s_x002fm3 = 8,
	s_x002fqt_x005bUK_x005d = 9,
	s_x002fqt_x005bUS_x005d = 10
};
#endif

/* eml2_3ForGsoap.h:11411 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeUom (-1135)

/* eml23:TimeUom */
enum class eml23__TimeUom {
	a = 'a',
	d = 'd',
	h = 'h',
	s = 's',
	_1_x002f2_x0020ms = 't',
	_100_x0020ka_x005bt_x005d = 'u',
	a_x005bt_x005d = 'v',
	ca = 'w',
	cs = 'x',
	ds = 'y',
	Ea_x005bt_x005d = 'z',
	fa = 123,
	Ga_x005bt_x005d = 124,
	hs = 125,
	ka_x005bt_x005d = 126,
	Ma_x005bt_x005d = 127,
	min_ = 128,
	ms = 129,
	na = 130,
	ns = 131,
	ps = 132,
	Ta_x005bt_x005d = 133,
	us = 134,
	wk = 135
};
#endif

/* eml2_3ForGsoap.h:11541 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUom (-1136)

/* eml23:VerticalCoordinateUom */
enum class eml23__VerticalCoordinateUom {
	m = 'm',
	ft = 'n',
	ftUS = 'o',
	ftBr_x002865_x0029 = 'p'
};
#endif

/* eml2_3ForGsoap.h:11567 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUom (-1137)

/* eml23:VolumeFlowRatePerVolumeFlowRateUom */
enum class eml23__VolumeFlowRatePerVolumeFlowRateUom {
	_x0025 = 0,
	_x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 1,
	_x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 2,
	_x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 3,
	_1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 4,
	Euc = 5
};
#endif

/* eml2_3ForGsoap.h:11603 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUom (-1138)

/* eml23:VolumePerAreaUom */
enum class eml23__VolumePerAreaUom {
	_1E6_x0020bbl_x002facre = 0,
	bbl_x002facre = 1,
	ft3_x002fft2 = 2,
	m3_x002fm2 = 3
};
#endif

/* eml2_3ForGsoap.h:11629 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUom (-1139)

/* eml23:VolumePerLengthUom */
enum class eml23__VolumePerLengthUom {
	_0_x002e01_x0020dm3_x002fkm = 0,
	_0_x002e01_x0020L_x002fkm = 1,
	bbl_x002fft = 2,
	bbl_x002fin = 3,
	bbl_x002fmi = 4,
	dm3_x002fm = 5,
	ft3_x002fft = 6,
	gal_x005bUK_x005d_x002fmi = 7,
	gal_x005bUS_x005d_x002fft = 8,
	gal_x005bUS_x005d_x002fmi = 9,
	in3_x002fft = 10,
	L_x002fm = 11,
	m3_x002fkm = 12,
	m3_x002fm = 13
};
#endif

/* eml2_3ForGsoap.h:11705 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUom (-1140)

/* eml23:VolumePerMassUom */
enum class eml23__VolumePerMassUom {
	_0_x002e01_x0020L_x002fkg = 0,
	bbl_x002fton_x005bUK_x005d = 1,
	bbl_x002fton_x005bUS_x005d = 2,
	cm3_x002fg = 3,
	dm3_x002fkg = 4,
	dm3_x002ft = 5,
	ft3_x002fkg = 6,
	ft3_x002flbm = 7,
	ft3_x002fsack_x005b94lbm_x005d = 8,
	gal_x005bUK_x005d_x002flbm = 9,
	gal_x005bUS_x005d_x002flbm = 10,
	gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 11,
	gal_x005bUS_x005d_x002fton_x005bUK_x005d = 12,
	gal_x005bUS_x005d_x002fton_x005bUS_x005d = 13,
	L_x002fkg = 14,
	L_x002ft = 15,
	L_x002fton_x005bUK_x005d = 16,
	m3_x002fg = 17,
	m3_x002fkg = 18,
	m3_x002ft = 19,
	m3_x002fton_x005bUK_x005d = 20,
	m3_x002fton_x005bUS_x005d = 21
};
#endif

/* eml2_3ForGsoap.h:11821 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUom (-1141)

/* eml23:VolumePerPressureUom */
enum class eml23__VolumePerPressureUom {
	bbl_x002fpsi = 0,
	m3_x002fkPa = 1,
	m3_x002fPa = 2
};
#endif

/* eml2_3ForGsoap.h:11842 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUom (-1142)

/* eml23:VolumePerRotationUom */
enum class eml23__VolumePerRotationUom {
	ft3_x002frad = 0,
	m3_x002frad = 1,
	m3_x002frev = 2
};
#endif

/* eml2_3ForGsoap.h:11863 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUom (-1143)

/* eml23:VolumePerTimeLengthUom */
enum class eml23__VolumePerTimeLengthUom {
	_1000_x0020bbl_x002eft_x002fd = 0,
	_1000_x0020m4_x002fd = 1,
	m4_x002fs = 2
};
#endif

/* eml2_3ForGsoap.h:11884 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUom (-1144)

/* eml23:VolumePerTimePerAreaUom */
enum class eml23__VolumePerTimePerAreaUom {
	ft3_x002f_x0028min_x002eft2_x0029 = 0,
	ft3_x002f_x0028s_x002eft2_x0029 = 1,
	gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 2,
	gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 3,
	gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 4,
	gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 5,
	gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 6,
	gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 7,
	m3_x002f_x0028s_x002em2_x0029 = 8
};
#endif

/* eml2_3ForGsoap.h:11935 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUom (-1145)

/* eml23:VolumePerTimePerLengthUom */
enum class eml23__VolumePerTimePerLengthUom {
	_1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 0,
	_1000_x0020m3_x002f_x0028d_x002em_x0029 = 1,
	_1000_x0020m3_x002f_x0028h_x002em_x0029 = 2,
	bbl_x002f_x0028d_x002eft_x0029 = 3,
	ft3_x002f_x0028d_x002eft_x0029 = 4,
	gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 5,
	gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 6,
	gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 7,
	gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 8,
	gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 9,
	gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 10,
	m3_x002f_x0028d_x002em_x0029 = 11,
	m3_x002f_x0028h_x002em_x0029 = 12,
	m3_x002f_x0028s_x002eft_x0029 = 13,
	m3_x002f_x0028s_x002em_x0029 = 14
};
#endif

/* eml2_3ForGsoap.h:12016 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUom (-1146)

/* eml23:VolumePerTimePerPressureLengthUom */
enum class eml23__VolumePerTimePerPressureLengthUom {
	bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 0,
	ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 1,
	m2_x002f_x0028kPa_x002ed_x0029 = 2,
	m2_x002f_x0028Pa_x002es_x0029 = 3
};
#endif

/* eml2_3ForGsoap.h:12042 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUom (-1147)

/* eml23:VolumePerTimePerPressureUom */
enum class eml23__VolumePerTimePerPressureUom {
	_1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 0,
	bbl_x002f_x0028kPa_x002ed_x0029 = 1,
	bbl_x002f_x0028psi_x002ed_x0029 = 2,
	L_x002f_x0028bar_x002emin_x0029 = 3,
	m3_x002f_x0028bar_x002ed_x0029 = 4,
	m3_x002f_x0028bar_x002eh_x0029 = 5,
	m3_x002f_x0028bar_x002emin_x0029 = 6,
	m3_x002f_x0028kPa_x002ed_x0029 = 7,
	m3_x002f_x0028kPa_x002eh_x0029 = 8,
	m3_x002f_x0028Pa_x002es_x0029 = 9,
	m3_x002f_x0028psi_x002ed_x0029 = 10
};
#endif

/* eml2_3ForGsoap.h:12103 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUom (-1148)

/* eml23:VolumePerTimePerTimeUom */
enum class eml23__VolumePerTimePerTimeUom {
	bbl_x002fd2 = 0,
	bbl_x002fh2 = 1,
	dm3_x002fs2 = 2,
	ft3_x002fd2 = 3,
	ft3_x002fh2 = 4,
	ft3_x002fmin2 = 5,
	ft3_x002fs2 = 6,
	gal_x005bUK_x005d_x002fh2 = 7,
	gal_x005bUK_x005d_x002fmin2 = 8,
	gal_x005bUS_x005d_x002fh2 = 9,
	gal_x005bUS_x005d_x002fmin2 = 10,
	L_x002fs2 = 11,
	m3_x002fd2 = 12,
	m3_x002fs2 = 13
};
#endif

/* eml2_3ForGsoap.h:12179 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUom (-1149)

/* eml23:VolumePerTimePerVolumeUom */
enum class eml23__VolumePerTimePerVolumeUom {
	bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 0,
	m3_x002f_x0028s_x002em3_x0029 = 1
};
#endif

/* eml2_3ForGsoap.h:12195 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUom (-1150)

/* eml23:VolumePerTimeUom */
enum class eml23__VolumePerTimeUom {
	_1_x002f30_x0020cm3_x002fmin = 0,
	_1000_x0020bbl_x002fd = 1,
	_1000_x0020ft3_x002fd = 2,
	_1000_x0020m3_x002fd = 3,
	_1000_x0020m3_x002fh = 4,
	_1E6_x0020bbl_x002fd = 5,
	_1E6_x0020ft3_x002fd = 6,
	_1E6_x0020m3_x002fd = 7,
	bbl_x002fd = 8,
	bbl_x002fh = 9,
	bbl_x002fmin = 10,
	cm3_x002fh = 11,
	cm3_x002fmin = 12,
	cm3_x002fs = 13,
	dm3_x002fs = 14,
	ft3_x002fd = 15,
	ft3_x002fh = 16,
	ft3_x002fmin = 17,
	ft3_x002fs = 18,
	gal_x005bUK_x005d_x002fd = 19,
	gal_x005bUK_x005d_x002fh = 20,
	gal_x005bUK_x005d_x002fmin = 21,
	gal_x005bUS_x005d_x002fd = 22,
	gal_x005bUS_x005d_x002fh = 23,
	gal_x005bUS_x005d_x002fmin = 24,
	L_x002fh = 25,
	L_x002fmin = 26,
	L_x002fs = 27,
	m3_x002fd = 28,
	m3_x002fh = 29,
	m3_x002fmin = 30,
	m3_x002fs = 31
};
#endif

/* eml2_3ForGsoap.h:12361 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUom (-1151)

/* eml23:VolumePerVolumeUom */
enum class eml23__VolumePerVolumeUom {
	_x0025 = 0,
	_x0025_x005bvol_x005d = 1,
	_0_x002e001_x0020bbl_x002fft3 = 2,
	_0_x002e001_x0020bbl_x002fm3 = 3,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 4,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 5,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 6,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 7,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 8,
	_0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 9,
	_0_x002e01_x0020bbl_x002fbbl = 10,
	_0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 11,
	_0_x002e1_x0020L_x002fbbl = 12,
	_0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 13,
	_1000_x0020ft3_x002fbbl = 14,
	_1000_x0020m3_x002fm3 = 15,
	_1E_6_x0020acre_x002eft_x002fbbl = 16,
	_1E_6_x0020bbl_x002fft3 = 17,
	_1E_6_x0020bbl_x002fm3 = 18,
	_1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 19,
	_1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 20,
	_1E6_x0020ft3_x002fbbl = 21,
	bbl_x002f_x0028acre_x002eft_x0029 = 22,
	bbl_x002fbbl = 23,
	bbl_x002fft3 = 24,
	bbl_x002fm3 = 25,
	cEuc = 26,
	cm3_x002fcm3 = 27,
	cm3_x002fL = 28,
	cm3_x002fm3 = 29,
	dm3_x002fm3 = 30,
	Euc = 31,
	ft3_x002fbbl = 32,
	ft3_x002fft3 = 33,
	gal_x005bUK_x005d_x002fft3 = 34,
	gal_x005bUS_x005d_x002fbbl = 35,
	gal_x005bUS_x005d_x002fft3 = 36,
	L_x002fm3 = 37,
	m3_x002f_x0028ha_x002em_x0029 = 38,
	m3_x002fbbl = 39,
	m3_x002fm3 = 40,
	mL_x002fgal_x005bUK_x005d = 41,
	mL_x002fgal_x005bUS_x005d = 42,
	mL_x002fmL = 43,
	ppk = 44,
	ppm = 45,
	ppm_x005bvol_x005d = 46
};
#endif

/* eml2_3ForGsoap.h:12602 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUom (-1152)

/* eml23:VolumetricHeatTransferCoefficientUom */
enum class eml23__VolumetricHeatTransferCoefficientUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edeltaF_x0029 = 1,
	kW_x002f_x0028m3_x002edeltaK_x0029 = 2,
	W_x002f_x0028m3_x002edeltaK_x0029 = 3
};
#endif

/* eml2_3ForGsoap.h:12628 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUom (-1153)

/* eml23:VolumetricThermalExpansionUom */
enum class eml23__VolumetricThermalExpansionUom {
	_1_x002fdeltaC = 0,
	_1_x002fdeltaF = 1,
	_1_x002fdeltaK = 2,
	_1_x002fdeltaR = 3,
	_1E_6_x0020m3_x002f_x0028m3_x002edeltaC_x0029 = 4,
	_1E_6_x0020m3_x002f_x0028m3_x002edeltaF_x0029 = 5,
	m3_x002f_x0028m3_x002edeltaK_x0029 = 6,
	ppm_x005bvol_x005d_x002fdeltaC = 7,
	ppm_x005bvol_x005d_x002fdeltaF = 8
};
#endif

/* eml2_3ForGsoap.h:12679 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUom (-1154)

/* eml23:VolumeUom */
enum class eml23__VolumeUom {
	L = 'L',
	_1000_x0020bbl = 'M',
	_1000_x0020ft3 = 'N',
	_1000_x0020gal_x005bUK_x005d = 'O',
	_1000_x0020gal_x005bUS_x005d = 'P',
	_1000_x0020m3 = 'Q',
	_1E_6_x0020gal_x005bUS_x005d = 'R',
	_1E12_x0020ft3 = 'S',
	_1E6_x0020bbl = 'T',
	_1E6_x0020ft3 = 'U',
	_1E6_x0020m3 = 'V',
	_1E9_x0020bbl = 'W',
	_1E9_x0020ft3 = 'X',
	acre_x002eft = 'Y',
	bbl = 'Z',
	cm3 = 91,
	dm3 = 92,
	floz_x005bUK_x005d = 93,
	floz_x005bUS_x005d = 94,
	ft3 = 95,
	gal_x005bUK_x005d = 96,
	gal_x005bUS_x005d = 'a',
	ha_x002em = 'b',
	hL = 'c',
	in3 = 'd',
	km3 = 'e',
	m3 = 'f',
	mi3 = 'g',
	mL = 'h',
	mm3 = 'i',
	pt_x005bUK_x005d = 'j',
	pt_x005bUS_x005d = 'k',
	qt_x005bUK_x005d = 'l',
	qt_x005bUS_x005d = 'm',
	um2_x002em = 'n',
	yd3 = 'o'
};
#endif

/* eml2_3ForGsoap.h:12896 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKind (-1158)

/* resqml22:CulturalFeatureKind */
enum class resqml22__CulturalFeatureKind {
	fieldblock = 0,
	licenses = 1,
	pipeline = 2,
	project_x0020boundaries = 3,
	model_x0020frontier = 4
};
#endif

/* eml2_3ForGsoap.h:12911 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LineRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LineRole (-1159)

/* resqml22:LineRole */
enum class resqml22__LineRole {
	fault_x0020center_x0020line = 0,
	pick = 1,
	inner_x0020ring = 2,
	outer_x0020ring = 3,
	trajectory = 4,
	interpretation_x0020line = 5,
	contact = 6,
	depositional_x0020line = 7,
	erosion_x0020line = 8,
	contour = 9,
	pillar = 10,
	break_x0020line = 11,
	structural_x0020closure = 12,
	culture = 13
};
#endif

/* eml2_3ForGsoap.h:12984 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SurfaceRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SurfaceRole (-1160)

/* resqml22:SurfaceRole */
enum class resqml22__SurfaceRole {
	map = 0,
	pick = 1
};
#endif

/* eml2_3ForGsoap.h:13004 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactMode
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactMode (-1161)

/* resqml22:ContactMode */
enum class resqml22__ContactMode {
	conformable = 0,
	extended = 1,
	unconformable = 2
};
#endif

/* eml2_3ForGsoap.h:13018 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactSide
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactSide (-1162)

/* resqml22:ContactSide */
enum class resqml22__ContactSide {
	footwall = 0,
	hanging_x0020wall = 1,
	north = 2,
	south = 3,
	east = 4,
	west = 5,
	younger = 6,
	older = 7,
	both = 8
};
#endif

/* eml2_3ForGsoap.h:13069 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactVerb
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactVerb (-1163)

/* resqml22:ContactVerb */
enum class resqml22__ContactVerb {
	stops = 0,
	splits = 1,
	crosses = 2
};
#endif

/* eml2_3ForGsoap.h:13082 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKind (-1164)

/* resqml22:DepositionalFaciesKind */
enum class resqml22__DepositionalFaciesKind {
	carbonates = 0,
	carbonates_x0020basinal = 1,
	carbonates_x0020foreslope = 2,
	carbonates_x0020foreslope_x0020pelagic = 3,
	carbonates_x0020foreslope_x0020turbidite = 4,
	carbonates_x0020highenergy = 5,
	carbonates_x0020highenergy_x0020platform = 6,
	carbonates_x0020highenergy_x0020platform_x0020interior = 7,
	carbonates_x0020highenergy_x0020platform_x0020margin = 8,
	carbonates_x0020highenergy_x0020ramp = 9,
	carbonates_x0020highenergy_x0020ramp_x0020inner = 10,
	carbonates_x0020highenergy_x0020ramp_x0020middle = 11,
	carbonates_x0020highenergy_x0020ramp_x0020outer = 12,
	carbonates_x0020highenergy_x0020shelf = 13,
	carbonates_x0020highenergy_x0020shelf_x0020interior = 14,
	carbonates_x0020highenergy_x0020shelf_x0020margin = 15,
	carbonates_x0020highenergy_x0020slope = 16,
	carbonates_x0020highenergy_x0020slope_x0020distal = 17,
	carbonates_x0020highenergy_x0020slope_x0020lower = 18,
	carbonates_x0020highenergy_x0020slope_x0020upper = 19,
	carbonates_x0020lacustrine = 20,
	carbonates_x0020lacustrine_x0020abiotic = 21,
	carbonates_x0020lacustrine_x0020basinal = 22,
	carbonates_x0020lacustrine_x0020organicbuildup = 23,
	carbonates_x0020lacustrine_x0020ramp = 24,
	carbonates_x0020lacustrine_x0020ramp_x0020inner = 25,
	carbonates_x0020lacustrine_x0020ramp_x0020middle = 26,
	carbonates_x0020lacustrine_x0020ramp_x0020outer = 27,
	carbonates_x0020lacustrine_x0020shelf = 28,
	carbonates_x0020lacustrine_x0020shelf_x0020interior = 29,
	carbonates_x0020lacustrine_x0020shelf_x0020margin = 30,
	carbonates_x0020lacustrine_x0020shelf_x0020slope = 31,
	carbonates_x0020lacustrine_x0020shelf_x0020slope_x0020distal = 32,
	carbonates_x0020lacustrine_x0020shelf_x0020slope_x0020lower = 33,
	carbonates_x0020lacustrine_x0020shelf_x0020slope_x0020upper = 34,
	carbonates_x0020lowenergy = 35,
	carbonates_x0020lowenergy_x0020ramp = 36,
	carbonates_x0020lowenergy_x0020sabkha = 37,
	carbonates_x0020lowenergy_x0020shelf = 38,
	carbonates_x0020lowenergy_x0020tidalflat = 39,
	carbonates_x0020organicbuildup = 40,
	carbonates_x0020organicbuildup_x0020bank = 41,
	carbonates_x0020organicbuildup_x0020reef = 42,
	carbonates_x0020organicbuildup_x0020reef_x0020mound = 43,
	carbonates_x0020organicbuildup_x0020reef_x0020patch = 44,
	carbonates_x0020organicbuildup_x0020reef_x0020pinnacle = 45,
	carbonates_x0020subaerial = 46,
	continental = 47,
	continental_x0020alluvial = 48,
	continental_x0020alluvial_x0020debrisflow = 49,
	continental_x0020alluvial_x0020sheetflow = 50,
	continental_x0020eolian = 51,
	continental_x0020eolian_x0020erg = 52,
	continental_x0020eolian_x0020mixedeolianfluvial = 53,
	continental_x0020eolian_x0020mixedeoliansabkha = 54,
	continental_x0020fluvial = 55,
	continental_x0020fluvial_x0020alluvialplain = 56,
	continental_x0020fluvial_x0020river = 57,
	continental_x0020fluvial_x0020river_x0020anastomosing = 58,
	continental_x0020fluvial_x0020river_x0020braided = 59,
	continental_x0020fluvial_x0020river_x0020meandering = 60,
	continental_x0020fluvial_x0020river_x0020straight = 61,
	continental_x0020glacial = 62,
	continental_x0020lacustrine = 63,
	continental_x0020lacustrine_x0020barrier = 64,
	continental_x0020lacustrine_x0020beach = 'A',
	continental_x0020lacustrine_x0020delta_x0020braided = 'B',
	continental_x0020lacustrine_x0020delta_x0020fan = 'C',
	continental_x0020lacustrine_x0020sublacustrinefan = 'D',
	deepmarine = 'E',
	deepmarine_x0020abysal = 'F',
	deepmarine_x0020channelcomplex = 'G',
	deepmarine_x0020channelcomplex_x0020confined = 'H',
	deepmarine_x0020channelcomplex_x0020confined_x0020channelfill = 'I',
	deepmarine_x0020channelcomplex_x0020confined_x0020levee = 'J',
	deepmarine_x0020channelcomplex_x0020distributary = 'K',
	deepmarine_x0020channelcomplex_x0020distributary_x0020channelfill = 'L',
	deepmarine_x0020channelcomplex_x0020distributary_x0020levee = 'M',
	deepmarine_x0020channelcomplex_x0020distributary_x0020lobe = 'N',
	deepmarine_x0020channelcomplex_x0020erosiveaggradational = 'O',
	deepmarine_x0020channelcomplex_x0020erosiveaggradational_x0020channelfill = 'P',
	deepmarine_x0020channelcomplex_x0020erosiveaggradational_x0020debrite = 'Q',
	deepmarine_x0020channelcomplex_x0020erosiveaggradational_x0020levee = 'R',
	deepmarine_x0020channelcomplex_x0020erosiveaggradational_x0020overbankdeposit = 'S',
	deepmarine_x0020conouritedrift = 'T',
	deepmarine_x0020conouritedrift_x0020moatmound = 'U',
	deepmarine_x0020conouritedrift_x0020plastered = 'V',
	deepmarine_x0020conouritedrift_x0020sheetlike = 'W',
	deepmarine_x0020injectite = 'X',
	deepmarine_x0020intraslopebasin = 'Y',
	deepmarine_x0020masstransportdeposit = 'Z',
	deepmarine_x0020pelagic = 91,
	deepmarine_x0020shelf = 92,
	deepmarine_x0020shelf_x0020edge = 93,
	deepmarine_x0020slope = 94,
	deepmarine_x0020slope_x0020lower = 95,
	deepmarine_x0020slope_x0020upper = 96,
	deepmarine_x0020turbiditecontourite = 'a',
	deepmarine_x0020turbiditecontourite_x0020confined = 'b',
	deepmarine_x0020turbiditecontourite_x0020distributary = 'c',
	marineshallow = 'd',
	marineshallow_x0020barrierisland = 'e',
	marineshallow_x0020barrierisland_x0020waveinfluenced = 'f',
	marineshallow_x0020bay = 'g',
	marineshallow_x0020coast = 'h',
	marineshallow_x0020coast_x0020tidedominated = 'i',
	marineshallow_x0020coastalplain = 'j',
	marineshallow_x0020delta = 'k',
	marineshallow_x0020delta_x0020braided = 'l',
	marineshallow_x0020delta_x0020fan = 'm',
	marineshallow_x0020delta_x0020fluvialdominated = 'n',
	marineshallow_x0020delta_x0020fluvialinfluenced = 'o',
	marineshallow_x0020delta_x0020tidedominated = 'p',
	marineshallow_x0020delta_x0020tideinfluenced = 'q',
	marineshallow_x0020delta_x0020wavedominated = 'r',
	marineshallow_x0020delta_x0020waveinfluenced = 's',
	marineshallow_x0020lagon = 't',
	marineshallow_x0020lagon_x0020wavedominated = 'u',
	marineshallow_x0020shoreline = 'v',
	marineshallow_x0020shoreline_x0020estuary = 'w',
	marineshallow_x0020shoreline_x0020estuary_x0020fluvialdominated = 'x',
	marineshallow_x0020shoreline_x0020estuary_x0020fluvialinfluenced = 'y',
	marineshallow_x0020shoreline_x0020estuary_x0020mixedinfluenced = 'z',
	marineshallow_x0020shoreline_x0020estuary_x0020tidedominated = 123,
	marineshallow_x0020shoreline_x0020estuary_x0020tideinfluenced = 124,
	marineshallow_x0020shoreline_x0020estuary_x0020wavedominated = 125,
	marineshallow_x0020shoreline_x0020estuary_x0020waveinfluenced = 126,
	marineshallow_x0020shoreline_x0020shoreface = 127,
	marineshallow_x0020shoreline_x0020shoreface_x0020foreshore = 128,
	marineshallow_x0020shoreline_x0020shoreface_x0020lower = 129,
	marineshallow_x0020shoreline_x0020shoreface_x0020middle = 130,
	marineshallow_x0020shoreline_x0020shoreface_x0020offshore = 131,
	marineshallow_x0020shoreline_x0020shoreface_x0020upper = 132,
	marineshallow_x0020shoreline_x0020shoreline_x0020fluvialdominated = 133,
	marineshallow_x0020shoreline_x0020shoreline_x0020fluvialinfluenced = 134,
	marineshallow_x0020shoreline_x0020shoreline_x0020mixedinfluenced = 135,
	marineshallow_x0020shoreline_x0020shoreline_x0020tidedominated = 136,
	marineshallow_x0020shoreline_x0020shoreline_x0020tideinfluenced = 137,
	marineshallow_x0020shoreline_x0020shoreline_x0020wavedominated = 138,
	marineshallow_x0020shoreline_x0020shoreline_x0020waveinfluenced = 139,
	marineshallow_x0020strandplain = 140,
	marineshallow_x0020tidalflat = 141
};
#endif

/* eml2_3ForGsoap.h:13234 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionMode
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionMode (-1165)

/* resqml22:DepositionMode */
enum class resqml22__DepositionMode {
	proportional_x0020between_x0020top_x0020and_x0020bottom = 0,
	parallel_x0020to_x0020bottom = 1,
	parallel_x0020to_x0020top = 2,
	parallel_x0020to_x0020another_x0020boundary = 3
};
#endif

/* eml2_3ForGsoap.h:13248 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Domain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Domain (-1166)

/* resqml22:Domain */
enum class resqml22__Domain {
	depth = 0,
	time = 1,
	mixed = 2
};
#endif

/* eml2_3ForGsoap.h:13273 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidContact (-1167)

/* resqml22:FluidContact */
enum class resqml22__FluidContact {
	free_x0020water_x0020contact = 0,
	gas_x0020oil_x0020contact = 1,
	gas_x0020water_x0020contact = 2,
	seal = 3,
	water_x0020oil_x0020contact = 4
};
#endif

/* eml2_3ForGsoap.h:13308 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitMaterialEmplacement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitMaterialEmplacement (-1168)

/* resqml22:GeologicUnitMaterialEmplacement */
enum class resqml22__GeologicUnitMaterialEmplacement {
	intrusive = 0,
	non_intrusive = 1
};
#endif

/* eml2_3ForGsoap.h:13321 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonStratigraphicRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonStratigraphicRole (-1169)

/* resqml22:HorizonStratigraphicRole */
enum class resqml22__HorizonStratigraphicRole {
	chronostratigraphic = 0,
	lithostratigraphic = 1,
	biostratigraphic = 2,
	magnetostratigraphic = 3,
	chemostratigraphic = 4,
	seismicstratigraphic = 5
};
#endif

/* eml2_3ForGsoap.h:13337 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__OrderingCriteria
#define SOAP_TYPE_gsoap_eml2_3_resqml22__OrderingCriteria (-1170)

/* resqml22:OrderingCriteria */
enum class resqml22__OrderingCriteria {
	age = 0,
	apparent_x0020depth = 1
};
#endif

/* eml2_3ForGsoap.h:13358 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Phase
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Phase (-1171)

/* resqml22:Phase */
enum class resqml22__Phase {
	aquifer = 0,
	gas_x0020cap = 1,
	oil_x0020column = 2,
	seal = 3
};
#endif

/* eml2_3ForGsoap.h:13388 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKind (-1172)

/* resqml22:SequenceStratigraphySurfaceKind */
enum class resqml22__SequenceStratigraphySurfaceKind {
	flooding = 0,
	ravinement = 1,
	maximum_x0020flooding = 2,
	transgressive = 3
};
#endif

/* eml2_3ForGsoap.h:13402 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3d (-1173)

/* resqml22:Shape3d */
enum class resqml22__Shape3d {
	sheet = 0,
	dyke = 1,
	dome = 2,
	mushroom = 3,
	channel = 4,
	delta = 5,
	dune = 6,
	fan = 7,
	reef = 8,
	wedge = 9
};
#endif

/* eml2_3ForGsoap.h:13422 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitKind (-1174)

/* resqml22:StratigraphicUnitKind */
enum class resqml22__StratigraphicUnitKind {
	chronostratigraphic = 0,
	lithostratigraphic = 1,
	biostratigraphic = 2
};
#endif

/* eml2_3ForGsoap.h:13435 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKind (-1175)

/* resqml22:ThrowKind */
enum class resqml22__ThrowKind {
	reverse = 0,
	strike_slip = 1,
	normal = 2,
	thrust = 3,
	scissor = 4,
	variable = 5
};
#endif

/* eml2_3ForGsoap.h:13455 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IdentityKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IdentityKind (-1176)

/* resqml22:IdentityKind */
enum class resqml22__IdentityKind {
	collocation = 0,
	previous_x0020collocation = 1,
	equivalence = 2,
	previous_x0020equivalence = 3
};
#endif

/* eml2_3ForGsoap.h:13487 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellShape (-1177)

/* resqml22:CellShape */
enum class resqml22__CellShape {
	tetrahedral = 0,
	pyramidal = 1,
	prism = 2,
	hexahedral = 3,
	polyhedral = 4
};
#endif

/* eml2_3ForGsoap.h:13524 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnShape (-1178)

/* resqml22:ColumnShape */
enum class resqml22__ColumnShape {
	triangular = 0,
	quadrilateral = 1,
	polygonal = 2
};
#endif

/* eml2_3ForGsoap.h:13549 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GridGeometryAttachment
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GridGeometryAttachment (-1179)

/* resqml22:GridGeometryAttachment */
enum class resqml22__GridGeometryAttachment {
	cells = 0,
	edges = 1,
	faces = 2,
	hinge_x0020node_x0020faces = 3,
	nodes = 4,
	radial_x0020origin_x0020polyline = 5,
	subnodes = 6
};
#endif

/* eml2_3ForGsoap.h:13598 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__KDirection
#define SOAP_TYPE_gsoap_eml2_3_resqml22__KDirection (-1180)

/* resqml22:KDirection */
enum class resqml22__KDirection {
	down = 0,
	up = 1,
	not_x0020monotonic = 2
};
#endif

/* eml2_3ForGsoap.h:13626 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PillarShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PillarShape (-1181)

/* resqml22:PillarShape */
enum class resqml22__PillarShape {
	vertical = 0,
	straight = 1,
	curved = 2
};
#endif

/* eml2_3ForGsoap.h:13651 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeNodeObject
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeNodeObject (-1182)

/* resqml22:SubnodeNodeObject */
enum class resqml22__SubnodeNodeObject {
	cell = 0,
	face = 1,
	edge = 2
};
#endif

/* eml2_3ForGsoap.h:13673 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DisplaySpace
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DisplaySpace (-1183)

/* resqml22:DisplaySpace */
enum class resqml22__DisplaySpace {
	device = 0,
	model = 1
};
#endif

/* eml2_3ForGsoap.h:13681 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePattern
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePattern (-1184)

/* resqml22:EdgePattern */
enum class resqml22__EdgePattern {
	dashed = 0,
	dotted = 1,
	solid = 2,
	wavy = 3
};
#endif

/* eml2_3ForGsoap.h:13691 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationDomain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationDomain (-1185)

/* resqml22:InterpolationDomain */
enum class resqml22__InterpolationDomain {
	hsv = 0,
	rgb = 1
};
#endif

/* eml2_3ForGsoap.h:13699 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationMethod
#define SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationMethod (-1186)

/* resqml22:InterpolationMethod */
enum class resqml22__InterpolationMethod {
	linear = 0,
	logarithmic = 1
};
#endif

/* eml2_3ForGsoap.h:13707 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbol
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbol (-1187)

/* resqml22:NodeSymbol */
enum class resqml22__NodeSymbol {
	circle = 0,
	cross = 1,
	cube = 2,
	diamond = 3,
	plus = 4,
	point = 5,
	pyramid = 6,
	sphere = 7,
	star = 8,
	tetrahedron = 9
};
#endif

/* eml2_3ForGsoap.h:13723 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKind (-1188)

/* resqml22:ViewerKind */
enum class resqml22__ViewerKind {
	_3d = 0,
	base_x0020map = 1,
	section = 2,
	well_x0020correlation = 3
};
#endif

/* eml2_3ForGsoap.h:13737 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFlux
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFlux (-1189)

/* resqml22:StreamlineFlux */
enum class resqml22__StreamlineFlux {
	oil = 0,
	gas = 1,
	water = 2,
	total = 3,
	other = 4
};
#endif

/* eml2_3ForGsoap.h:13773 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidMarker
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidMarker (-1190)

/* resqml22:FluidMarker */
enum class resqml22__FluidMarker {
	gas_x0020down_x0020to = 0,
	gas_x0020up_x0020to = 1,
	oil_x0020down_x0020to = 2,
	oil_x0020up_x0020to = 3,
	water_x0020down_x0020to = 4,
	water_x0020up_x0020to = 5
};
#endif

/* eml2_3ForGsoap.h:13789 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicBoundaryKind (-1191)

/* resqml22:GeologicBoundaryKind */
enum class resqml22__GeologicBoundaryKind {
	fault = 0,
	geobody = 1,
	horizon = 2
};
#endif

/* eml2_3ForGsoap.h:13802 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MdDomain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MdDomain (-1192)

/* resqml22:MdDomain */
enum class resqml22__MdDomain {
	driller = 0,
	logger = 1
};
#endif

/* eml2_3ForGsoap.h:13830 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKind (-1193)

/* eml23:ExistenceKind */
enum class eml23__ExistenceKind {
	actual = 0,
	planned = 1,
	simulated = 2,
	test = 3
};
#endif

/* eml2_3ForGsoap.h:13844 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ChannelStatusKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ChannelStatusKind (-1194)

/* eml23:ChannelStatusKind */
enum class eml23__ChannelStatusKind {
	active = 0,
	closed = 1,
	inactive = 2
};
#endif

/* eml2_3ForGsoap.h:13869 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeochronologicalRank (-1195)

/* eml23:GeochronologicalRank */
enum class eml23__GeochronologicalRank {
	eon = 0,
	era = 1,
	period = 2,
	epoch = 3,
	age = 4,
	chron = 5
};
#endif

/* eml2_3ForGsoap.h:13885 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKind (-1196)

/* eml23:LithologyKind */
enum class eml23__LithologyKind {
	alkali_x0020feldspar_x0020rhyolite = 0,
	alkali_x0020olivine_x0020basalt = 1,
	amphibolite = 2,
	andesite = 3,
	anhydrite = 4,
	anorthositic_x0020rock = 5,
	anthracite = 6,
	aplite = 7,
	arenite = 8,
	argillaceous = 9,
	arkose = 10,
	basalt = 11,
	basanite = 12,
	bauxite = 13,
	bituminous_x0020coal = 14,
	blueschist_x0020metamorphic_x0020rock = 15,
	boninite = 16,
	breccia = 17,
	carbonate_x0020ooze = 18,
	carbonatite = 19,
	chalk = 20,
	chert = 21,
	clay = 22,
	claystone = 23,
	coal = 24,
	conglomerate = 25,
	dacite = 26,
	diabase = 27,
	diamictite = 28,
	diorite = 29,
	dioritoid = 30,
	doleritic_x0020rock = 31,
	dolomite = 32,
	dolomitic = 33,
	eclogite = 34,
	exotic_x0020alkaline_x0020rock = 35,
	feldspar = 36,
	feldspathic_x0020arenite = 37,
	fine_x0020grained_x0020igneous_x0020rock = 38,
	foid_x0020dioritoid = 39,
	foid_x0020gabbroid = 40,
	foid_x0020syenitoid = 41,
	foidite = 42,
	foiditoid = 43,
	foidolite = 44,
	foliated_x0020metamorphic_x0020rock = 45,
	fragmental_x0020igneous_x0020rock = 46,
	gabbro = 47,
	gabbroic_x0020rock = 48,
	gabbroid = 49,
	glauconite = 50,
	gneiss = 51,
	granite = 52,
	granodiorite = 53,
	granofels = 54,
	granulite = 55,
	gravel = 56,
	greenstone = 57,
	gumbo = 58,
	gypsum = 59,
	halite = 60,
	hornfels = 61,
	igneous_x0020rock = 62,
	impact_x0020generated_x0020material = 63,
	impure_x0020dolomite = 64,
	impure_x0020limestone = 'A',
	intrusive_x0020rock_x0020_x0028plutonic_x0029 = 'B',
	iron_x0020rich_x0020sedimentary_x0020rock = 'C',
	kalsilitic_x0020and_x0020melilitic_x0020rocks = 'D',
	komatiitic_x0020rock = 'E',
	latitic_x0020rock = 'F',
	lignite = 'G',
	lime_x0020boundstone = 'H',
	lime_x0020framestone = 'I',
	lime_x0020grainstone = 'J',
	lime_x0020mudstone = 'K',
	lime_x0020packstone = 'L',
	lime_x0020wackestone = 'M',
	limestone = 'N',
	marble = 'O',
	marl = 'P',
	metamorphic_x0020rock = 'Q',
	mica_x0020schist = 'R',
	migmatite = 'S',
	monzogabbro = 'T',
	mud = 'U',
	mudstone = 'V',
	mylonitic_x0020rock = 'W',
	no_x0020description = 'X',
	no_x0020sample = 'Y',
	ooze = 'Z',
	ophiolite = 91,
	organic_x0020bearing_x0020mudstone = 92,
	peat = 93,
	pegmatite = 94,
	peridotite = 95,
	phaneritic_x0020igneous_x0020rock = 96,
	phonolite = 'a',
	phonolitoid = 'b',
	phosphate = 'c',
	phosphate_x0020rock = 'd',
	phyllite = 'e',
	porphyry = 'f',
	potassium_x0020and_x0020magnesium_x0020salts = 'g',
	pyroclastic_x0020breccia = 'h',
	pyroclastic_x0020rock = 'i',
	pyroxenite = 'j',
	quartz_x0020arenite = 'k',
	quartzite = 'l',
	rhyolite = 'm',
	rock_x0020salt = 'n',
	sand = 'o',
	sandstone = 'p',
	sandy = 'q',
	sapropel = 'r',
	schist = 's',
	serpentinite = 't',
	shale = 'u',
	siliceous_x0020ooze = 'v',
	silt = 'w',
	siltstone = 'x',
	skarn = 'y',
	slate = 'z',
	spilite = 123,
	syenite = 124,
	syenitoid = 125,
	sylvite = 126,
	tephrite = 127,
	tephritoid = 128,
	tholeiitic_x0020basalt = 129,
	tonalite = 130,
	trachyte = 131,
	trachytic_x0020rock = 132,
	trachytoid = 133,
	travertine = 134,
	tuff = 135,
	tuffite = 136,
	ultrabasic = 137,
	undifferentiated = 138,
	unknown = 139,
	wacke = 140
};
#endif

/* eml2_3ForGsoap.h:14032 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKind (-1197)

/* eml23:LithologyQualifierKind */
enum class eml23__LithologyQualifierKind {
	alkali_x0020feldspar_x0020rhyolite = 0,
	alkali_x0020olivine_x0020basalt = 1,
	amphibolite = 2,
	amphibolitic = 3,
	andesite = 4,
	andesitic = 5,
	anhydrite = 6,
	anhydritic = 7,
	ankerite = 8,
	ankeritic = 9,
	anorthositic_x0020rock = 10,
	anthracite = 11,
	anthracitic = 12,
	aplite = 13,
	aplitic = 14,
	arenite = 15,
	arenitic = 16,
	argillaceous = 17,
	arkose = 18,
	arkosic = 19,
	barite = 20,
	baritic = 21,
	basalt = 22,
	basaltic = 23,
	basanite = 24,
	basanitic = 25,
	bauxite = 26,
	bauxitic = 27,
	belemnites = 28,
	belemnitic = 29,
	bioturbated = 30,
	bioturbation = 31,
	bitumen = 32,
	bituminous = 33,
	bituminous_x0020coal = 34,
	blueschist_x0020metamorphic_x0020rock = 35,
	boninite = 36,
	breccia = 37,
	brecciated = 38,
	bryozoan = 39,
	bryozoans = 40,
	burrowed = 41,
	burrows = 42,
	calcareous = 43,
	calcite = 44,
	calcite_x0020concretion = 45,
	calcitic = 46,
	carbonaceous = 47,
	carbonate_x0020ooze = 48,
	carbonatite = 49,
	carbonatitic = 50,
	chalk = 51,
	chalky = 52,
	chamosite = 53,
	chamositic = 54,
	chert = 55,
	cherty = 56,
	chlorite = 57,
	chloritic = 58,
	clay = 59,
	claystone = 60,
	coal = 61,
	concretionary = 62,
	concretions = 63,
	conglomerate = 64,
	conglomeratic = 'A',
	coral_x0020fragments = 'B',
	coralline = 'C',
	crinoidal = 'D',
	crinoids = 'E',
	dacite = 'F',
	dacitic = 'G',
	diabase = 'H',
	diabasic = 'I',
	diamictite = 'J',
	diamictitic = 'K',
	diatomaceous = 'L',
	diatoms = 'M',
	diorite = 'N',
	dioritic = 'O',
	dioritoid = 'P',
	dioritoidic = 'Q',
	doleritic_x0020rock = 'R',
	dolomite = 'S',
	dolomite_x0020concretion = 'T',
	dolomite_x0020stringer = 'U',
	dolomitic = 'V',
	eclogite = 'W',
	eclogitic = 'X',
	exotic_x0020alkaline_x0020rock = 'Y',
	feldspar = 'Z',
	feldsparic = 91,
	feldspathic = 92,
	feldspathic_x0020arenite = 93,
	ferruginous = 94,
	fine_x0020grained_x0020igneous_x0020rock = 95,
	foid_x0020dioritoid = 96,
	foid_x0020gabbroid = 'a',
	foid_x0020syenitoid = 'b',
	foidite = 'c',
	foiditic = 'd',
	foiditoid = 'e',
	foidolite = 'f',
	foidolitic = 'g',
	foliated_x0020metamorphic_x0020rock = 'h',
	foraminifera = 'i',
	foraminiferous = 'j',
	forams = 'k',
	fossil_x0020fragments = 'l',
	fossiliferous = 'm',
	fossils_x0020undifferentiated = 'n',
	fragmental_x0020igneous_x0020rock = 'o',
	gabbro = 'p',
	gabbroic = 'q',
	gabbroic_x0020rock = 'r',
	gabbroid = 's',
	gabbroidic = 't',
	gilsonite = 'u',
	gilsonitic = 'v',
	glauconite = 'w',
	glauconitic = 'x',
	gneiss = 'y',
	gneissic = 'z',
	granite = 123,
	granitic = 124,
	granodiorite = 125,
	granodioritic = 126,
	granofels = 127,
	granulite = 128,
	granulitic = 129,
	gravel = 130,
	gravelly = 131,
	greenstone = 132,
	gumbo = 133,
	gypsiferous = 134,
	gypsum = 135,
	halite = 136,
	halitic = 137,
	hornfels = 138,
	hornfelsic = 139,
	igneous = 140,
	igneous_x0020rock = 141,
	illite = 142,
	illitic = 143,
	impact_x0020generated_x0020material = 144,
	impure_x0020dolomite = 145,
	impure_x0020limestone = 146,
	intrusive_x0020rock_x0020_x0028plutonic_x0029 = 147,
	iron_x0020rich_x0020sedimentary_x0020rock = 148,
	kalsilitic_x0020and_x0020melilitic_x0020rocks = 149,
	kaolinite = 150,
	kaolinitic = 151,
	komatiitic_x0020rock = 152,
	latitic_x0020rock = 153,
	lignite = 154,
	lignitic = 155,
	lime_x0020boundstone = 156,
	lime_x0020framestone = 157,
	lime_x0020grainstone = 158,
	lime_x0020mudstone = 159,
	lime_x0020packstone = 160,
	lime_x0020wackestone = 161,
	limestone = 162,
	limestone_x0020stringer = 163,
	lithic = 164,
	lithic_x0020fragments = 165,
	marble = 166,
	marcasite = 167,
	marcasitic = 168,
	marl = 169,
	marly = 170,
	metamorphic_x0020rock = 171,
	mica = 172,
	mica_x0020schist = 173,
	micaceous = 174,
	microfossiliferous = 175,
	microfossils = 176,
	migmatite = 177,
	migmatitic = 178,
	monzogabbro = 179,
	monzogabbroic = 180,
	mud = 181,
	muddy = 182,
	mudstone = 183,
	mylonitic_x0020rock = 184,
	no_x0020sample = 185,
	oncolite = 186,
	oncoliths = 187,
	oncolitic = 188,
	ooids = 189,
	ooliths = 190,
	oolitic = 191,
	ooze = 192,
	ophiolite = 193,
	ophiolitic = 194,
	organic_x0020bearing_x0020mudstone = 195,
	ostracodal = 196,
	ostracods = 197,
	peat = 198,
	peaty = 199,
	pebble = 200,
	pebbly = 201,
	pegmatite = 202,
	pegmatitic = 203,
	pelletal = 204,
	pellets = 205,
	peloidal = 206,
	peloids = 207,
	peridotite = 208,
	peridotitic = 209,
	phaneritic_x0020igneous_x0020rock = 210,
	phonolite = 211,
	phonolitic = 212,
	phonolitoid = 213,
	phosphate = 214,
	phosphate_x0020rock = 215,
	phosphatic = 216,
	phyllite = 217,
	phyllitic = 218,
	pisolite = 219,
	pisoliths = 220,
	pisolitic = 221,
	plant_x0020remains = 222,
	porphyritic = 223,
	porphyry = 224,
	potassium_x0020and_x0020magnesium_x0020salts = 225,
	pyrite = 226,
	pyritic = 227,
	pyroclastic_x0020breccia = 228,
	pyroclastic_x0020rock = 229,
	pyroxenite = 230,
	pyroxenitic = 231,
	quartiferous = 232,
	quartz = 233,
	quartz_x0020arenite = 234,
	quartzite = 235,
	quartzitic = 236,
	radiolaria = 237,
	radiolarian = 238,
	rhyolite = 239,
	rhyolitic = 240,
	rock_x0020salt = 241,
	rootlets = 242,
	salty = 243,
	sand = 244,
	sandstone = 245,
	sandy = 246,
	sapropel = 247,
	sapropelic = 248,
	schist = 249,
	schisty = 250,
	sepentinitic = 251,
	serpentinite = 252,
	shale = 253,
	shaly = 254,
	shell_x0020fragments = 255,
	shelly = 256,
	siderite = 257,
	siderite_x0020concretion = 258,
	sideritic = 259,
	siliceous_x0020ooze = 260,
	silt = 261,
	siltstone = 262,
	silty = 263,
	skarn = 264,
	skarny = 265,
	slate = 266,
	slaty = 267,
	smectite = 268,
	smectitic = 269,
	spicular = 270,
	spicules = 271,
	spilite = 272,
	spilitic = 273,
	stylolites = 274,
	stylolitic = 275,
	syenite = 276,
	syenitic = 277,
	syenitoid = 278,
	sylvite = 279,
	sylvitic = 280,
	tarry = 281,
	tephrite = 282,
	tephritic = 283,
	tephritoid = 284,
	tholeiitic_x0020basalt = 285,
	tonalite = 286,
	tonalitic = 287,
	trachyte = 288,
	trachytic = 289,
	trachytic_x0020rock = 290,
	trachytoid = 291,
	travertine = 292,
	tuff = 293,
	tuffaceous = 294,
	tuffite = 295,
	tuffitic = 296,
	ultrabasic = 297,
	undifferentiated = 298,
	unknown = 299,
	wacke = 300
};
#endif

/* eml2_3ForGsoap.h:14343 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithostratigraphicRank (-1198)

/* eml23:LithostratigraphicRank */
enum class eml23__LithostratigraphicRank {
	group = 0,
	formation = 1,
	member = 2,
	bed = 3
};
#endif

/* eml2_3ForGsoap.h:14391 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKind (-1199)

/* eml23:MatrixCementKind */
enum class eml23__MatrixCementKind {
	ankerite = 0,
	calcite = 1,
	chlorite = 2,
	dolomite = 3,
	illite = 4,
	kaolinite = 5,
	quartz = 6,
	siderite = 7,
	smectite = 8
};
#endif

/* eml2_3ForGsoap.h:14410 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MeasureClass
#define SOAP_TYPE_gsoap_eml2_3_eml23__MeasureClass (-1200)

/* eml23:MeasureClass */
enum class eml23__MeasureClass {
	absorbed_x0020dose = 0,
	activity_x0020of_x0020radioactivity = 1,
	amount_x0020of_x0020substance = 2,
	amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	amount_x0020of_x0020substance_x0020per_x0020area = 4,
	amount_x0020of_x0020substance_x0020per_x0020time = 5,
	amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	angle_x0020per_x0020length = 8,
	angle_x0020per_x0020volume = 9,
	angular_x0020acceleration = 10,
	angular_x0020velocity = 11,
	api_x0020gamma_x0020ray = 12,
	api_x0020gravity = 13,
	api_x0020neutron = 14,
	area = 15,
	area_x0020per_x0020amount_x0020of_x0020substance = 16,
	area_x0020per_x0020area = 17,
	area_x0020per_x0020count = 18,
	area_x0020per_x0020mass = 19,
	area_x0020per_x0020time = 20,
	area_x0020per_x0020volume = 21,
	attenuation_x0020per_x0020frequency_x0020interval = 22,
	capacitance = 23,
	cation_x0020exchange_x0020capacity = 24,
	data_x0020transfer_x0020speed = 25,
	diffusion_x0020coefficient = 26,
	diffusive_x0020time_x0020of_x0020flight = 27,
	digital_x0020storage = 28,
	dimensionless = 29,
	dipole_x0020moment = 30,
	dose_x0020equivalent = 31,
	dynamic_x0020viscosity = 32,
	electric_x0020charge = 33,
	electric_x0020charge_x0020per_x0020area = 34,
	electric_x0020charge_x0020per_x0020mass = 35,
	electric_x0020charge_x0020per_x0020volume = 36,
	electric_x0020conductance = 37,
	electric_x0020conductivity = 38,
	electric_x0020current = 39,
	electric_x0020current_x0020density = 40,
	electric_x0020field_x0020strength = 41,
	electric_x0020potential_x0020difference = 42,
	electric_x0020resistance = 43,
	electric_x0020resistance_x0020per_x0020length = 44,
	electrical_x0020resistivity = 45,
	electromagnetic_x0020moment = 46,
	energy = 47,
	energy_x0020length_x0020per_x0020area = 48,
	energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	energy_x0020per_x0020area = 50,
	energy_x0020per_x0020length = 51,
	energy_x0020per_x0020mass = 52,
	energy_x0020per_x0020mass_x0020per_x0020time = 53,
	energy_x0020per_x0020volume = 54,
	force = 55,
	force_x0020area = 56,
	force_x0020length_x0020per_x0020length = 57,
	force_x0020per_x0020force = 58,
	force_x0020per_x0020length = 59,
	force_x0020per_x0020volume = 60,
	frequency = 61,
	frequency_x0020interval = 62,
	heat_x0020capacity = 63,
	heat_x0020flow_x0020rate = 64,
	heat_x0020transfer_x0020coefficient = 'A',
	illuminance = 'B',
	inductance = 'C',
	isothermal_x0020compressibility = 'D',
	kinematic_x0020viscosity = 'E',
	length = 'F',
	length_x0020per_x0020length = 'G',
	length_x0020per_x0020mass = 'H',
	length_x0020per_x0020pressure = 'I',
	length_x0020per_x0020temperature = 'J',
	length_x0020per_x0020time = 'K',
	length_x0020per_x0020volume = 'L',
	light_x0020exposure = 'M',
	linear_x0020acceleration = 'N',
	linear_x0020thermal_x0020expansion = 'O',
	logarithmic_x0020power_x0020ratio = 'P',
	logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	luminance = 'R',
	luminous_x0020efficacy = 'S',
	luminous_x0020flux = 'T',
	luminous_x0020intensity = 'U',
	magnetic_x0020dipole_x0020moment = 'V',
	magnetic_x0020field_x0020strength = 'W',
	magnetic_x0020flux = 'X',
	magnetic_x0020flux_x0020density = 'Y',
	magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	magnetic_x0020permeability = 91,
	magnetic_x0020vector_x0020potential = 92,
	mass = 93,
	mass_x0020length = 94,
	mass_x0020per_x0020area = 95,
	mass_x0020per_x0020energy = 96,
	mass_x0020per_x0020length = 'a',
	mass_x0020per_x0020mass = 'b',
	mass_x0020per_x0020time = 'c',
	mass_x0020per_x0020time_x0020per_x0020area = 'd',
	mass_x0020per_x0020time_x0020per_x0020length = 'e',
	mass_x0020per_x0020volume = 'f',
	mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	mobility = 'j',
	molar_x0020energy = 'k',
	molar_x0020heat_x0020capacity = 'l',
	molar_x0020volume = 'm',
	molecular_x0020weight = 'n',
	moment_x0020of_x0020force = 'o',
	moment_x0020of_x0020inertia = 'p',
	momentum = 'q',
	normalized_x0020power = 'r',
	permeability_x0020length = 's',
	permeability_x0020rock = 't',
	permittivity = 'u',
	plane_x0020angle = 'v',
	potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	power = 'x',
	power_x0020per_x0020area = 'y',
	power_x0020per_x0020power = 'z',
	power_x0020per_x0020volume = 123,
	pressure = 124,
	pressure_x0020per_x0020pressure = 125,
	pressure_x0020per_x0020time = 126,
	pressure_x0020per_x0020volume = 127,
	pressure_x0020squared = 128,
	pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	pressure_x0020time_x0020per_x0020volume = 130,
	quantity_x0020of_x0020light = 131,
	radiance = 132,
	radiant_x0020intensity = 133,
	reciprocal_x0020area = 134,
	reciprocal_x0020electric_x0020potential_x0020difference = 135,
	reciprocal_x0020force = 136,
	reciprocal_x0020length = 137,
	reciprocal_x0020mass = 138,
	reciprocal_x0020mass_x0020time = 139,
	reciprocal_x0020pressure = 140,
	reciprocal_x0020time = 141,
	reciprocal_x0020volume = 142,
	reluctance = 143,
	second_x0020moment_x0020of_x0020area = 144,
	signaling_x0020event_x0020per_x0020time = 145,
	solid_x0020angle = 146,
	specific_x0020heat_x0020capacity = 147,
	temperature_x0020interval = 148,
	temperature_x0020interval_x0020per_x0020length = 149,
	temperature_x0020interval_x0020per_x0020pressure = 150,
	temperature_x0020interval_x0020per_x0020time = 151,
	thermal_x0020conductance = 152,
	thermal_x0020conductivity = 153,
	thermal_x0020diffusivity = 154,
	thermal_x0020insulance = 155,
	thermal_x0020resistance = 156,
	thermodynamic_x0020temperature = 157,
	thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	time = 159,
	time_x0020per_x0020length = 160,
	time_x0020per_x0020mass = 161,
	time_x0020per_x0020time = 162,
	time_x0020per_x0020volume = 163,
	vertical_x0020coordinate = 164,
	volume = 165,
	volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	volume_x0020per_x0020area = 167,
	volume_x0020per_x0020length = 168,
	volume_x0020per_x0020mass = 169,
	volume_x0020per_x0020pressure = 170,
	volume_x0020per_x0020rotation = 171,
	volume_x0020per_x0020time = 172,
	volume_x0020per_x0020time_x0020length = 173,
	volume_x0020per_x0020time_x0020per_x0020area = 174,
	volume_x0020per_x0020time_x0020per_x0020length = 175,
	volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	volume_x0020per_x0020time_x0020per_x0020time = 178,
	volume_x0020per_x0020time_x0020per_x0020volume = 179,
	volume_x0020per_x0020volume = 180,
	volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	volumetric_x0020thermal_x0020expansion = 182,
	unitless = 183
};
#endif

/* eml2_3ForGsoap.h:14600 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKind (-1201)

/* eml23:QuantityClassKind */
enum class eml23__QuantityClassKind {
	absorbed_x0020dose = 0,
	activity_x0020of_x0020radioactivity = 1,
	amount_x0020of_x0020substance = 2,
	amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	amount_x0020of_x0020substance_x0020per_x0020area = 4,
	amount_x0020of_x0020substance_x0020per_x0020time = 5,
	amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	angle_x0020per_x0020length = 8,
	angle_x0020per_x0020volume = 9,
	angular_x0020acceleration = 10,
	angular_x0020velocity = 11,
	api_x0020gamma_x0020ray = 12,
	api_x0020gravity = 13,
	api_x0020neutron = 14,
	area = 15,
	area_x0020per_x0020amount_x0020of_x0020substance = 16,
	area_x0020per_x0020area = 17,
	area_x0020per_x0020count = 18,
	area_x0020per_x0020mass = 19,
	area_x0020per_x0020time = 20,
	area_x0020per_x0020volume = 21,
	attenuation_x0020per_x0020frequency_x0020interval = 22,
	capacitance = 23,
	cation_x0020exchange_x0020capacity = 24,
	data_x0020transfer_x0020speed = 25,
	diffusion_x0020coefficient = 26,
	diffusive_x0020time_x0020of_x0020flight = 27,
	digital_x0020storage = 28,
	dimensionless = 29,
	dipole_x0020moment = 30,
	dose_x0020equivalent = 31,
	dynamic_x0020viscosity = 32,
	electric_x0020charge = 33,
	electric_x0020charge_x0020per_x0020area = 34,
	electric_x0020charge_x0020per_x0020mass = 35,
	electric_x0020charge_x0020per_x0020volume = 36,
	electric_x0020conductance = 37,
	electric_x0020conductivity = 38,
	electric_x0020current = 39,
	electric_x0020current_x0020density = 40,
	electric_x0020field_x0020strength = 41,
	electric_x0020potential_x0020difference = 42,
	electric_x0020resistance = 43,
	electric_x0020resistance_x0020per_x0020length = 44,
	electrical_x0020resistivity = 45,
	electromagnetic_x0020moment = 46,
	energy = 47,
	energy_x0020length_x0020per_x0020area = 48,
	energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	energy_x0020per_x0020area = 50,
	energy_x0020per_x0020length = 51,
	energy_x0020per_x0020mass = 52,
	energy_x0020per_x0020mass_x0020per_x0020time = 53,
	energy_x0020per_x0020volume = 54,
	force = 55,
	force_x0020area = 56,
	force_x0020length_x0020per_x0020length = 57,
	force_x0020per_x0020force = 58,
	force_x0020per_x0020length = 59,
	force_x0020per_x0020volume = 60,
	frequency = 61,
	frequency_x0020interval = 62,
	heat_x0020capacity = 63,
	heat_x0020flow_x0020rate = 64,
	heat_x0020transfer_x0020coefficient = 'A',
	illuminance = 'B',
	inductance = 'C',
	isothermal_x0020compressibility = 'D',
	kinematic_x0020viscosity = 'E',
	length = 'F',
	length_x0020per_x0020length = 'G',
	length_x0020per_x0020mass = 'H',
	length_x0020per_x0020pressure = 'I',
	length_x0020per_x0020temperature = 'J',
	length_x0020per_x0020time = 'K',
	length_x0020per_x0020volume = 'L',
	light_x0020exposure = 'M',
	linear_x0020acceleration = 'N',
	linear_x0020thermal_x0020expansion = 'O',
	logarithmic_x0020power_x0020ratio = 'P',
	logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	luminance = 'R',
	luminous_x0020efficacy = 'S',
	luminous_x0020flux = 'T',
	luminous_x0020intensity = 'U',
	magnetic_x0020dipole_x0020moment = 'V',
	magnetic_x0020field_x0020strength = 'W',
	magnetic_x0020flux = 'X',
	magnetic_x0020flux_x0020density = 'Y',
	magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	magnetic_x0020permeability = 91,
	magnetic_x0020vector_x0020potential = 92,
	mass = 93,
	mass_x0020length = 94,
	mass_x0020per_x0020area = 95,
	mass_x0020per_x0020energy = 96,
	mass_x0020per_x0020length = 'a',
	mass_x0020per_x0020mass = 'b',
	mass_x0020per_x0020time = 'c',
	mass_x0020per_x0020time_x0020per_x0020area = 'd',
	mass_x0020per_x0020time_x0020per_x0020length = 'e',
	mass_x0020per_x0020volume = 'f',
	mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	mobility = 'j',
	molar_x0020energy = 'k',
	molar_x0020heat_x0020capacity = 'l',
	molar_x0020volume = 'm',
	molecular_x0020weight = 'n',
	moment_x0020of_x0020force = 'o',
	moment_x0020of_x0020inertia = 'p',
	momentum = 'q',
	normalized_x0020power = 'r',
	permeability_x0020length = 's',
	permeability_x0020rock = 't',
	permittivity = 'u',
	plane_x0020angle = 'v',
	potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	power = 'x',
	power_x0020per_x0020area = 'y',
	power_x0020per_x0020power = 'z',
	power_x0020per_x0020volume = 123,
	pressure = 124,
	pressure_x0020per_x0020pressure = 125,
	pressure_x0020per_x0020time = 126,
	pressure_x0020per_x0020volume = 127,
	pressure_x0020squared = 128,
	pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	pressure_x0020time_x0020per_x0020volume = 130,
	quantity_x0020of_x0020light = 131,
	radiance = 132,
	radiant_x0020intensity = 133,
	reciprocal_x0020area = 134,
	reciprocal_x0020electric_x0020potential_x0020difference = 135,
	reciprocal_x0020force = 136,
	reciprocal_x0020length = 137,
	reciprocal_x0020mass = 138,
	reciprocal_x0020mass_x0020time = 139,
	reciprocal_x0020pressure = 140,
	reciprocal_x0020time = 141,
	reciprocal_x0020volume = 142,
	reluctance = 143,
	second_x0020moment_x0020of_x0020area = 144,
	signaling_x0020event_x0020per_x0020time = 145,
	solid_x0020angle = 146,
	specific_x0020heat_x0020capacity = 147,
	temperature_x0020interval = 148,
	temperature_x0020interval_x0020per_x0020length = 149,
	temperature_x0020interval_x0020per_x0020pressure = 150,
	temperature_x0020interval_x0020per_x0020time = 151,
	thermal_x0020conductance = 152,
	thermal_x0020conductivity = 153,
	thermal_x0020diffusivity = 154,
	thermal_x0020insulance = 155,
	thermal_x0020resistance = 156,
	thermodynamic_x0020temperature = 157,
	thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	time = 159,
	time_x0020per_x0020length = 160,
	time_x0020per_x0020mass = 161,
	time_x0020per_x0020time = 162,
	time_x0020per_x0020volume = 163,
	vertical_x0020coordinate = 164,
	volume = 165,
	volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	volume_x0020per_x0020area = 167,
	volume_x0020per_x0020length = 168,
	volume_x0020per_x0020mass = 169,
	volume_x0020per_x0020pressure = 170,
	volume_x0020per_x0020rotation = 171,
	volume_x0020per_x0020time = 172,
	volume_x0020per_x0020time_x0020length = 173,
	volume_x0020per_x0020time_x0020per_x0020area = 174,
	volume_x0020per_x0020time_x0020per_x0020length = 175,
	volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	volume_x0020per_x0020time_x0020per_x0020time = 178,
	volume_x0020per_x0020time_x0020per_x0020volume = 179,
	volume_x0020per_x0020volume = 180,
	volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	volumetric_x0020thermal_x0020expansion = 182,
	unitless = 183,
	not_x0020a_x0020measure = 184
};
#endif

/* eml2_3ForGsoap.h:14805 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceCondition (-1202)

/* eml23:ReferenceCondition */
enum class eml23__ReferenceCondition {
	_0_x0020degC_x00201_x0020atm = 0,
	_0_x0020degC_x00201_x0020bar = 1,
	_15_x0020degC_x00201_x0020atm = 2,
	_15_x0020degC_x00201_x0020bar = 3,
	_20_x0020degC_x00201_x0020atm = 4,
	_20_x0020degC_x00201_x0020bar = 5,
	_25_x0020degC_x00201_x0020bar = 6,
	_60_x0020degF_x00201_x0020atm = 7,
	_60_x0020degF_x002030_x0020in_x0020Hg = 8,
	ambient = 9
};
#endif

/* eml2_3ForGsoap.h:14837 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellStatus
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellStatus (-1203)

/* eml23:WellStatus */
enum class eml23__WellStatus {
	abandoned = 0,
	active = 1,
	active_x0020_x002d__x0020injecting = 2,
	active_x0020_x002d__x0020producing = 3,
	completed = 4,
	drilling = 5,
	partially_x0020plugged = 6,
	permitted = 7,
	plugged_x0020and_x0020abandoned = 8,
	proposed = 9,
	sold = 10,
	suspended = 11,
	temporarily_x0020abandoned = 12,
	testing = 13,
	tight = 14,
	working_x0020over = 15,
	unknown = 16
};
#endif

/* eml2_3ForGsoap.h:14934 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKind (-1204)

/* eml23:ReferencePointKind */
enum class eml23__ReferencePointKind {
	casing_x0020flange = 0,
	crown_x0020valve = 1,
	derrick_x0020floor = 2,
	ground_x0020level = 3,
	kelly_x0020bushing = 4,
	kickoff_x0020point = 5,
	lowest_x0020astronomical_x0020tide = 6,
	mean_x0020high_x0020water = 7,
	mean_x0020higher_x0020high_x0020water = 8,
	mean_x0020low_x0020water = 9,
	mean_x0020lower_x0020low_x0020water = 10,
	mean_x0020sea_x0020level = 11,
	mean_x0020tide_x0020level = 12,
	rotary_x0020bushing = 13,
	rotary_x0020table = 14,
	seafloor = 15,
	wellhead = 16,
	well_x0020surface_x0020location = 17
};
#endif

/* eml2_3ForGsoap.h:14963 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReference (-1205)

/* eml23:WellboreDatumReference */
enum class eml23__WellboreDatumReference {
	casing_x0020flange = 0,
	crown_x0020valve = 1,
	derrick_x0020floor = 2,
	ground_x0020level = 3,
	kelly_x0020bushing = 4,
	kickoff_x0020point = 5,
	lowest_x0020astronomical_x0020tide = 6,
	mean_x0020high_x0020water = 7,
	mean_x0020higher_x0020high_x0020water = 8,
	mean_x0020low_x0020water = 9,
	mean_x0020lower_x0020low_x0020water = 10,
	mean_x0020sea_x0020level = 11,
	mean_x0020tide_x0020level = 12,
	rotary_x0020bushing = 13,
	rotary_x0020table = 14,
	sea_x0020floor = 15
};
#endif

/* eml2_3ForGsoap.h:15025 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_3_eml23__AxisOrder2d (-1206)

/* eml23:AxisOrder2d */
enum class eml23__AxisOrder2d {
	easting_x0020northing = 0,
	easting_x0020southing = 1,
	southing_x0020easting = 2,
	northing_x0020easting = 3,
	westing_x0020southing = 4,
	southing_x0020westing = 5,
	northing_x0020westing = 6,
	westing_x0020northing = 7
};
#endif

/* eml2_3ForGsoap.h:15067 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EastOrWest
#define SOAP_TYPE_gsoap_eml2_3_eml23__EastOrWest (-1207)

/* eml23:EastOrWest */
enum class eml23__EastOrWest {
	east = 0,
	west = 1
};
#endif

/* eml2_3ForGsoap.h:15087 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_3_eml23__NorthOrSouth (-1208)

/* eml23:NorthOrSouth */
enum class eml23__NorthOrSouth {
	north = 0,
	south = 1
};
#endif

/* eml2_3ForGsoap.h:15107 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_3_eml23__PrincipalMeridian (-1209)

/* eml23:PrincipalMeridian */
enum class eml23__PrincipalMeridian {
	_1st_x0020Principal_x0020Meridian = 0,
	_2nd_x0020Principal_x0020Meridian = 1,
	_3rd_x0020Principal_x0020Meridian = 2,
	_4th_x0020Principal_x0020Meridian = 3,
	_5th_x0020Principal_x0020Meridian = 4,
	_6th_x0020Principal_x0020Meridian = 5,
	Black_x0020Hills_x0020Meridian = 6,
	Boise_x0020Meridian = 7,
	Chickasaw_x0020Meridian = 8,
	Choctaw_x0020Meridian = 9,
	Cimarron_x0020Meridian = 10,
	Copper_x0020River_x0020Meridian = 11,
	Fairbanks_x0020Meridian = 12,
	Gila_x0020and_x0020Salt_x0020River_x0020Meridian = 13,
	Humboldt_x0020Meridian = 14,
	Huntsville_x0020Meridian = 15,
	Indian_x0020Meridian = 16,
	Kateel_x0020River_x0020Meridian = 17,
	Lousiana_x0020Meridian = 18,
	Michigan_x0020Meridian = 19,
	Montana_x0020Meridian = 20,
	Mount_x0020Diablo_x0020Meridian = 21,
	Navajo_x0020Meridian = 22,
	New_x0020Mexico_x0020Meridian = 23,
	Saint_x0020Helena_x0020Meridian = 24,
	Saint_x0020Stephens_x0020Meridian = 25,
	Salt_x0020Lake_x0020Meridian = 26,
	San_x0020Bernardo_x0020Meridian = 27,
	Seward_x0020Meridian = 28,
	Tallahassee_x0020Meridian = 29,
	Uintah_x0020Meridian = 30,
	Umiat_x0020Meridian = 31,
	Ute_x0020Meridian = 32,
	Washington_x0020Meridian = 33,
	Williamette_x0020Meridian = 34,
	Wind_x0020River_x0020Meridian = 35
};
#endif

/* eml2_3ForGsoap.h:15293 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDirection (-1210)

/* eml23:VerticalDirection */
enum class eml23__VerticalDirection {
	up = 0,
	down = 1
};
#endif

/* eml2_3ForGsoap.h:15309 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Facet
#define SOAP_TYPE_gsoap_eml2_3_eml23__Facet (-1211)

/* eml23:Facet */
enum class eml23__Facet {
	I = 'I',
	J = 'J',
	K = 'K',
	X = 'X',
	Y = 'Y',
	Z = 'Z',
	I_x002b = 91,
	J_x002b = 92,
	K_x002b = 93,
	X_x002b = 94,
	Y_x002b = 95,
	Z_x002b = 96,
	I_x002d = 'a',
	J_x002d = 'b',
	K_x002d = 'c',
	X_x002d = 'd',
	Y_x002d = 'e',
	Z_x002d = 'f',
	net = 'g',
	gross = 'h',
	plus = 'i',
	minus = 'j',
	average = 'k',
	maximum = 'l',
	minimum = 'm',
	maximum_x0020threshold = 'n',
	minimum_x0020threshold = 'o',
	surface_x0020condition = 'p',
	reservoir_x0020condition = 'q',
	oil = 'r',
	water = 's',
	gas = 't',
	condensate = 'u',
	cumulative = 'v',
	fracture = 'w',
	matrix = 'x'
};
#endif

/* eml2_3ForGsoap.h:15483 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FacetKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__FacetKind (-1212)

/* eml23:FacetKind */
enum class eml23__FacetKind {
	conditions = 0,
	side = 1,
	direction = 2,
	netgross = 3,
	qualifier = 4,
	statistics = 5,
	what = 6
};
#endif

/* eml2_3ForGsoap.h:15524 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityParameterKind (-1213)

/* eml23:ActivityParameterKind */
enum class eml23__ActivityParameterKind {
	dataObject = 0,
	double_ = 1,
	integer = 2,
	string = 3,
	timestamp = 4,
	subActivity = 5
};
#endif

/* eml2_3ForGsoap.h:15540 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__AddressKindEnum (-1214)

/* eml23:AddressKindEnum */
enum class eml23__AddressKindEnum {
	both = 0,
	mailing = 1,
	physical = 2
};
#endif

/* eml2_3ForGsoap.h:15557 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_3_eml23__AddressQualifier (-1215)

/* eml23:AddressQualifier */
enum class eml23__AddressQualifier {
	permanent = 0,
	personal = 1,
	work = 2
};
#endif

/* eml2_3ForGsoap.h:15578 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PhoneType
#define SOAP_TYPE_gsoap_eml2_3_eml23__PhoneType (-1216)

/* eml23:PhoneType */
enum class eml23__PhoneType {
	fax = 0,
	mobile = 1,
	pager = 2,
	unknown = 3,
	voice = 4,
	voice_x002ffax = 5,
	voicemail = 6
};
#endif

/* eml2_3ForGsoap.h:15591 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKind (-1217)

/* eml23:CollectionKind */
enum class eml23__CollectionKind {
	folder = 0,
	project = 1,
	realization = 2,
	scenario = 3,
	study = 4
};
#endif

/* eml2_3ForGsoap.h:15606 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressureKind (-1218)

/* eml23:ReferencePressureKind */
enum class eml23__ReferencePressureKind {
	absolute = 0,
	ambient = 1,
	legal = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/struct_tm.h:67 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (-13)

typedef struct tm xsd__dateTime;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* eml2_3ForGsoap.h:137 */
class resqml22__AbstractGeometry;	/* eml2_3ForGsoap.h:173 */
class resqml22__AbstractParametricLineArray;	/* eml2_3ForGsoap.h:175 */
class resqml22__AbstractPoint3dArray;	/* eml2_3ForGsoap.h:181 */
class resqml22__ParametricLineIntersections;	/* eml2_3ForGsoap.h:195 */
class resqml22__Point3d;	/* eml2_3ForGsoap.h:199 */
class resqml22__Point3dLatticeDimension;	/* eml2_3ForGsoap.h:207 */
class resqml22__ThreePoint3d;	/* eml2_3ForGsoap.h:217 */
class resqml22__AbstractSeismicCoordinates;	/* eml2_3ForGsoap.h:221 */
class resqml22__AbstractSurfaceFrameworkContact;	/* eml2_3ForGsoap.h:245 */
class resqml22__ContactIdentity;	/* eml2_3ForGsoap.h:251 */
class resqml22__PatchBoundaries;	/* eml2_3ForGsoap.h:265 */
class resqml22__VolumeRegion;	/* eml2_3ForGsoap.h:285 */
class resqml22__VolumeShell;	/* eml2_3ForGsoap.h:287 */
class resqml22__AbstractContactInterpretationPart;	/* eml2_3ForGsoap.h:289 */
class resqml22__AbstractTimeInterval;	/* eml2_3ForGsoap.h:297 */
class resqml22__BoundaryFeatureInterpretationPlusItsRank;	/* eml2_3ForGsoap.h:303 */
class resqml22__FaultThrow;	/* eml2_3ForGsoap.h:311 */
class resqml22__ReservoirCompartmentUnitInterpretation;	/* eml2_3ForGsoap.h:335 */
class resqml22__ElementIdentity;	/* eml2_3ForGsoap.h:353 */
class resqml22__ElementIndices;	/* eml2_3ForGsoap.h:355 */
class resqml22__MarkerBoundary;	/* eml2_3ForGsoap.h:359 */
class resqml22__MarkerInterval;	/* eml2_3ForGsoap.h:361 */
class resqml22__Patch1d;	/* eml2_3ForGsoap.h:363 */
class resqml22__PolylineSetPatch;	/* eml2_3ForGsoap.h:365 */
class resqml22__RepresentationIdentity;	/* eml2_3ForGsoap.h:367 */
class resqml22__AbstractParentWindow;	/* eml2_3ForGsoap.h:389 */
class resqml22__Activation;	/* eml2_3ForGsoap.h:393 */
class resqml22__AdditionalGridPoints;	/* eml2_3ForGsoap.h:395 */
class resqml22__AdditionalGridTopology;	/* eml2_3ForGsoap.h:397 */
class resqml22__AlternateCellIndex;	/* eml2_3ForGsoap.h:399 */
class resqml22__CellFluidPhaseUnits;	/* eml2_3ForGsoap.h:401 */
class resqml22__CellOverlap;	/* eml2_3ForGsoap.h:403 */
class resqml22__ColumnLayerGpGrid;	/* eml2_3ForGsoap.h:407 */
class resqml22__ColumnLayerSplitCoordinateLines;	/* eml2_3ForGsoap.h:411 */
class resqml22__ConnectionInterpretations;	/* eml2_3ForGsoap.h:417 */
class resqml22__Edges;	/* eml2_3ForGsoap.h:419 */
class resqml22__IjGaps;	/* eml2_3ForGsoap.h:427 */
class resqml22__IjkGpGridPatch;	/* eml2_3ForGsoap.h:429 */
class resqml22__IntervalGridCells;	/* eml2_3ForGsoap.h:437 */
class resqml22__Intervals;	/* eml2_3ForGsoap.h:439 */
class resqml22__IntervalStratigraphicUnits;	/* eml2_3ForGsoap.h:441 */
class resqml22__KGaps;	/* eml2_3ForGsoap.h:443 */
class resqml22__OverlapVolume;	/* eml2_3ForGsoap.h:447 */
class resqml22__Regrid;	/* eml2_3ForGsoap.h:449 */
class resqml22__SplitColumnEdges;	/* eml2_3ForGsoap.h:451 */
class resqml22__SplitEdges;	/* eml2_3ForGsoap.h:453 */
class resqml22__SplitFaces;	/* eml2_3ForGsoap.h:455 */
class resqml22__SplitNodePatch;	/* eml2_3ForGsoap.h:457 */
class resqml22__SubnodePatch;	/* eml2_3ForGsoap.h:459 */
class resqml22__SubnodeTopology;	/* eml2_3ForGsoap.h:461 */
class resqml22__TruncationCellPatch;	/* eml2_3ForGsoap.h:467 */
class resqml22__UnstructuredColumnEdges;	/* eml2_3ForGsoap.h:471 */
class resqml22__UnstructuredColumnLayerGpGridPatch;	/* eml2_3ForGsoap.h:473 */
class resqml22__UnstructuredGpGridPatch;	/* eml2_3ForGsoap.h:479 */
class resqml22__UnstructuredGridHingeNodeFaces;	/* eml2_3ForGsoap.h:483 */
class resqml22__AbstractGraphicalInformationForIndexableElement;	/* eml2_3ForGsoap.h:493 */
class resqml22__ContinuousColorMapEntry;	/* eml2_3ForGsoap.h:505 */
class resqml22__DiscreteColorMapEntry;	/* eml2_3ForGsoap.h:513 */
class resqml22__HsvColor;	/* eml2_3ForGsoap.h:525 */
class resqml22__MinMax;	/* eml2_3ForGsoap.h:527 */
class resqml22__StreamlineWellbores;	/* eml2_3ForGsoap.h:553 */
class resqml22__CorrectionInformation;	/* eml2_3ForGsoap.h:557 */
class resqml22__TvdInformation;	/* eml2_3ForGsoap.h:561 */
class resqml22__WellboreTrajectoryParentIntersection;	/* eml2_3ForGsoap.h:573 */
class resqml22__WitsmlWellWellbore;	/* eml2_3ForGsoap.h:577 */
class eml23__AbstractGrowingObjectPart;	/* eml2_3ForGsoap.h:581 */
class eml23__AbstractObject;	/* eml2_3ForGsoap.h:587 */
class eml23__Citation;	/* eml2_3ForGsoap.h:593 */
class eml23__CustomData;	/* eml2_3ForGsoap.h:595 */
class eml23__ExtensionNameValue;	/* eml2_3ForGsoap.h:597 */
class eml23__ObjectAlias;	/* eml2_3ForGsoap.h:599 */
class eml23__AbstractValueArray;	/* eml2_3ForGsoap.h:611 */
class eml23__JaggedArray;	/* eml2_3ForGsoap.h:641 */
class eml23__MdInterval;	/* eml2_3ForGsoap.h:643 */
class eml23__MeasuredDepthCoord;	/* eml2_3ForGsoap.h:645 */
class eml23__TvdInterval;	/* eml2_3ForGsoap.h:655 */
class eml23__VerticalDepthCoord;	/* eml2_3ForGsoap.h:657 */
class eml23__AbstractHorizontalCoordinates;	/* eml2_3ForGsoap.h:659 */
class eml23__HorizontalCoordinates;	/* eml2_3ForGsoap.h:665 */
class eml23__DataObjectReference;	/* eml2_3ForGsoap.h:679 */
class eml23__ExternalDataArray;	/* eml2_3ForGsoap.h:681 */
class eml23__ExternalDataArrayPart;	/* eml2_3ForGsoap.h:683 */
class eml23__AbstractGeodeticCrs;	/* eml2_3ForGsoap.h:1421 */
class eml23__AbstractProjectedCrs;	/* eml2_3ForGsoap.h:1423 */
class eml23__AbstractVerticalCrs;	/* eml2_3ForGsoap.h:1425 */
class eml23__HorizontalAxes;	/* eml2_3ForGsoap.h:1437 */
class eml23__PublicLandSurveySystem;	/* eml2_3ForGsoap.h:1451 */
class eml23__Vector;	/* eml2_3ForGsoap.h:1453 */
class eml23__VerticalAxis;	/* eml2_3ForGsoap.h:1455 */
class eml23__DateTimeInterval;	/* eml2_3ForGsoap.h:1467 */
class eml23__GeologicTime;	/* eml2_3ForGsoap.h:1469 */
class eml23__PropertyKindFacet;	/* eml2_3ForGsoap.h:1475 */
class eml23__TimeIndex;	/* eml2_3ForGsoap.h:1477 */
class eml23__TimeOrIntervalSeries;	/* eml2_3ForGsoap.h:1479 */
class eml23__TimeSeriesParentage;	/* eml2_3ForGsoap.h:1483 */
class eml23__OSDUIntegration;	/* eml2_3ForGsoap.h:1485 */
class eml23__AbstractActivityParameter;	/* eml2_3ForGsoap.h:1487 */
class eml23__AbstractParameterKey;	/* eml2_3ForGsoap.h:1489 */
class eml23__ParameterTemplate;	/* eml2_3ForGsoap.h:1503 */
class eml23__GeneralAddress;	/* eml2_3ForGsoap.h:1519 */
class eml23__PersonName;	/* eml2_3ForGsoap.h:1523 */
class eml23__PhoneNumberStruct;	/* eml2_3ForGsoap.h:1525 */
class eml23__SingleCollectionAssociation;	/* eml2_3ForGsoap.h:1531 */
class eml23__Column;	/* eml2_3ForGsoap.h:1533 */
class eml23__NestedColumnBasedTable;	/* eml2_3ForGsoap.h:1537 */
class eml23__FailingRule;	/* eml2_3ForGsoap.h:1541 */
class eml23__IndexRange;	/* eml2_3ForGsoap.h:1543 */
class eml23__AbstractGraphicalInformation;	/* eml2_3ForGsoap.h:1545 */
class eml23__AbstractPressureValue;	/* eml2_3ForGsoap.h:1551 */
union _eml23__union_AbstractTemperaturePressure;	/* eml2_3ForGsoap.h:19862 */
class eml23__AbstractTemperaturePressure;	/* eml2_3ForGsoap.h:1553 */
class eml23__DensityValue;	/* eml2_3ForGsoap.h:1555 */
class eml23__FlowRateValue;	/* eml2_3ForGsoap.h:1557 */
class eml23__PressureValue;	/* eml2_3ForGsoap.h:1561 */
class eml23__VolumeValue;	/* eml2_3ForGsoap.h:1571 */
class resqml22__AbstractFeature;	/* eml2_3ForGsoap.h:161 */
class resqml22__AbstractParametricLineGeometry;	/* eml2_3ForGsoap.h:177 */
class resqml22__AbstractPlaneGeometry;	/* eml2_3ForGsoap.h:179 */
class resqml22__ParametricLineArray;	/* eml2_3ForGsoap.h:187 */
class resqml22__ParametricLineFromRepresentationLatticeArray;	/* eml2_3ForGsoap.h:191 */
class resqml22__Point2dExternalArray;	/* eml2_3ForGsoap.h:197 */
class resqml22__Point3dExternalArray;	/* eml2_3ForGsoap.h:201 */
class resqml22__Point3dFromRepresentationLatticeArray;	/* eml2_3ForGsoap.h:203 */
class resqml22__Point3dLatticeArray;	/* eml2_3ForGsoap.h:205 */
class resqml22__Point3dParametricArray;	/* eml2_3ForGsoap.h:209 */
class resqml22__Point3dZValueArray;	/* eml2_3ForGsoap.h:211 */
class resqml22__PointGeometry;	/* eml2_3ForGsoap.h:213 */
class resqml22__SinglePointGeometry;	/* eml2_3ForGsoap.h:215 */
class resqml22__Seismic2dCoordinates;	/* eml2_3ForGsoap.h:229 */
class resqml22__Seismic3dCoordinates;	/* eml2_3ForGsoap.h:233 */
class resqml22__ContactPatch;	/* eml2_3ForGsoap.h:253 */
class resqml22__ContactReference;	/* eml2_3ForGsoap.h:255 */
class resqml22__EdgePatch;	/* eml2_3ForGsoap.h:257 */
class resqml22__NodePatch;	/* eml2_3ForGsoap.h:259 */
class resqml22__NonSealedContact;	/* eml2_3ForGsoap.h:261 */
class resqml22__SealedContact;	/* eml2_3ForGsoap.h:275 */
class resqml22__TrianglePatch;	/* eml2_3ForGsoap.h:281 */
class resqml22__AbstractFeatureInterpretation;	/* eml2_3ForGsoap.h:291 */
class resqml22__BinaryContactInterpretationPart;	/* eml2_3ForGsoap.h:299 */
class resqml22__ContactElement;	/* eml2_3ForGsoap.h:305 */
class resqml22__GeneticBoundaryBasedTimeInterval;	/* eml2_3ForGsoap.h:317 */
class resqml22__GeologicTimeBasedTimeInterval;	/* eml2_3ForGsoap.h:323 */
class resqml22__MultipleContactInterpretationPart;	/* eml2_3ForGsoap.h:331 */
class resqml22__StratigraphicColumn;	/* eml2_3ForGsoap.h:341 */
class resqml22__AbstractRepresentation;	/* eml2_3ForGsoap.h:351 */
class resqml22__FluidIntervalBoundary;	/* eml2_3ForGsoap.h:357 */
class resqml22__RepresentationIdentitySet;	/* eml2_3ForGsoap.h:369 */
class resqml22__StratigraphicIntervalBoundary;	/* eml2_3ForGsoap.h:373 */
class resqml22__SubRepresentationPatch;	/* eml2_3ForGsoap.h:377 */
class resqml22__CellParentWindow;	/* eml2_3ForGsoap.h:405 */
class resqml22__ColumnLayerParentWindow;	/* eml2_3ForGsoap.h:409 */
class resqml22__ColumnLayerSubnodeTopology;	/* eml2_3ForGsoap.h:413 */
class resqml22__ColumnSubnodePatch;	/* eml2_3ForGsoap.h:415 */
class resqml22__IjkParentWindow;	/* eml2_3ForGsoap.h:435 */
class resqml22__LocalGridSet;	/* eml2_3ForGsoap.h:445 */
class resqml22__UniformSubnodePatch;	/* eml2_3ForGsoap.h:469 */
class resqml22__UnstructuredSubnodeTopology;	/* eml2_3ForGsoap.h:487 */
class resqml22__VariableSubnodePatch;	/* eml2_3ForGsoap.h:489 */
class resqml22__AbstractColorMap;	/* eml2_3ForGsoap.h:491 */
class resqml22__AlphaInformation;	/* eml2_3ForGsoap.h:495 */
class resqml22__AnnotationInformation;	/* eml2_3ForGsoap.h:497 */
class resqml22__ColorInformation;	/* eml2_3ForGsoap.h:499 */
class resqml22__ColorMapDictionary;	/* eml2_3ForGsoap.h:501 */
class resqml22__ContourLineSetInformation;	/* eml2_3ForGsoap.h:507 */
class resqml22__DefaultGraphicalInformation;	/* eml2_3ForGsoap.h:509 */
class resqml22__GraphicalInformationForEdges;	/* eml2_3ForGsoap.h:515 */
class resqml22__GraphicalInformationForFaces;	/* eml2_3ForGsoap.h:517 */
class resqml22__GraphicalInformationForNodes;	/* eml2_3ForGsoap.h:519 */
class resqml22__GraphicalInformationForVolumes;	/* eml2_3ForGsoap.h:521 */
class resqml22__GraphicalInformationForWholeObject;	/* eml2_3ForGsoap.h:523 */
class resqml22__SizeInformation;	/* eml2_3ForGsoap.h:529 */
class resqml22__AbstractProperty;	/* eml2_3ForGsoap.h:531 */
class resqml22__WellboreMarker;	/* eml2_3ForGsoap.h:569 */
class eml23__AbstractGrowingObject;	/* eml2_3ForGsoap.h:579 */
class eml23__AbstractMdGrowingPart;	/* eml2_3ForGsoap.h:583 */
class eml23__AbstractMdIntervalGrowingPart;	/* eml2_3ForGsoap.h:585 */
class eml23__AbstractTimeGrowingPart;	/* eml2_3ForGsoap.h:589 */
class eml23__AbstractTimeIntervalGrowingPart;	/* eml2_3ForGsoap.h:591 */
class eml23__AbstractBooleanArray;	/* eml2_3ForGsoap.h:601 */
class eml23__AbstractNumericArray;	/* eml2_3ForGsoap.h:607 */
class eml23__AbstractStringArray;	/* eml2_3ForGsoap.h:609 */
class eml23__AbstractReferencePoint;	/* eml2_3ForGsoap.h:661 */
class eml23__GeodeticCoordinates;	/* eml2_3ForGsoap.h:663 */
class eml23__ProjectedCoordinates;	/* eml2_3ForGsoap.h:667 */
class eml23__PublicLandSurveySystemCoordinates;	/* eml2_3ForGsoap.h:669 */
class eml23__GeodeticCrs;	/* eml2_3ForGsoap.h:1427 */
class eml23__GeodeticEpsgCrs;	/* eml2_3ForGsoap.h:1429 */
class eml23__GeodeticLocalAuthorityCrs;	/* eml2_3ForGsoap.h:1431 */
class eml23__GeodeticUnknownCrs;	/* eml2_3ForGsoap.h:1433 */
class eml23__GeodeticWktCrs;	/* eml2_3ForGsoap.h:1435 */
class eml23__LocalEngineeringCompoundCrs;	/* eml2_3ForGsoap.h:1439 */
class eml23__ProjectedCrs;	/* eml2_3ForGsoap.h:1441 */
class eml23__ProjectedEpsgCrs;	/* eml2_3ForGsoap.h:1443 */
class eml23__ProjectedLocalAuthorityCrs;	/* eml2_3ForGsoap.h:1445 */
class eml23__ProjectedUnknownCrs;	/* eml2_3ForGsoap.h:1447 */
class eml23__ProjectedWktCrs;	/* eml2_3ForGsoap.h:1449 */
class eml23__VerticalCrs;	/* eml2_3ForGsoap.h:1457 */
class eml23__VerticalEpsgCrs;	/* eml2_3ForGsoap.h:1459 */
class eml23__VerticalLocalAuthorityCrs;	/* eml2_3ForGsoap.h:1461 */
class eml23__VerticalUnknownCrs;	/* eml2_3ForGsoap.h:1463 */
class eml23__VerticalWktCrs;	/* eml2_3ForGsoap.h:1465 */
class eml23__PropertyKind;	/* eml2_3ForGsoap.h:1471 */
class eml23__PropertyKindDictionary;	/* eml2_3ForGsoap.h:1473 */
class eml23__TimeSeries;	/* eml2_3ForGsoap.h:1481 */
class eml23__Activity;	/* eml2_3ForGsoap.h:1491 */
class eml23__ActivityTemplate;	/* eml2_3ForGsoap.h:1493 */
class eml23__DataObjectParameter;	/* eml2_3ForGsoap.h:1495 */
class eml23__DoubleQuantityParameter;	/* eml2_3ForGsoap.h:1497 */
class eml23__IntegerQuantityParameter;	/* eml2_3ForGsoap.h:1499 */
class eml23__ObjectParameterKey;	/* eml2_3ForGsoap.h:1501 */
class eml23__StringParameter;	/* eml2_3ForGsoap.h:1505 */
class eml23__TimeIndexParameter;	/* eml2_3ForGsoap.h:1507 */
class eml23__TimeIndexParameterKey;	/* eml2_3ForGsoap.h:1509 */
class eml23__Aggregate;	/* eml2_3ForGsoap.h:1511 */
class eml23__Attachment;	/* eml2_3ForGsoap.h:1513 */
class eml23__BusinessAssociate;	/* eml2_3ForGsoap.h:1515 */
class eml23__CollectionsToDataobjectsAssociationSet;	/* eml2_3ForGsoap.h:1527 */
class eml23__DataobjectCollection;	/* eml2_3ForGsoap.h:1529 */
class eml23__ColumnBasedTable;	/* eml2_3ForGsoap.h:1535 */
class eml23__DataAssuranceRecord;	/* eml2_3ForGsoap.h:1539 */
class eml23__GraphicalInformationSet;	/* eml2_3ForGsoap.h:1547 */
class eml23__AbsolutePressure;	/* eml2_3ForGsoap.h:1549 */
class eml23__GaugePressure;	/* eml2_3ForGsoap.h:1559 */
union _eml23__union_ReferenceTemperaturePressure_;	/* eml2_3ForGsoap.h:24727 */
class eml23__ReferenceTemperaturePressure;	/* eml2_3ForGsoap.h:1565 */
class eml23__RelativePressure;	/* eml2_3ForGsoap.h:1567 */
class eml23__TemperaturePressure;	/* eml2_3ForGsoap.h:1569 */
class resqml22__AbstractTechnicalFeature;	/* eml2_3ForGsoap.h:163 */
class resqml22__BoundaryFeature;	/* eml2_3ForGsoap.h:165 */
class resqml22__Model;	/* eml2_3ForGsoap.h:169 */
class resqml22__RockVolumeFeature;	/* eml2_3ForGsoap.h:171 */
class resqml22__Graph2dRepresentation;	/* eml2_3ForGsoap.h:183 */
class resqml22__HorizontalPlaneGeometry;	/* eml2_3ForGsoap.h:185 */
class resqml22__ParametricLineFromRepresentationGeometry;	/* eml2_3ForGsoap.h:189 */
class resqml22__ParametricLineGeometry;	/* eml2_3ForGsoap.h:193 */
class resqml22__TiltedPlaneGeometry;	/* eml2_3ForGsoap.h:219 */
class resqml22__Seismic2dPostStackRepresentation;	/* eml2_3ForGsoap.h:231 */
class resqml22__AbstractSurfaceRepresentation;	/* eml2_3ForGsoap.h:249 */
class resqml22__PointSetRepresentation;	/* eml2_3ForGsoap.h:269 */
class resqml22__PolylineRepresentation;	/* eml2_3ForGsoap.h:271 */
class resqml22__PolylineSetRepresentation;	/* eml2_3ForGsoap.h:273 */
class resqml22__AbstractOrganizationInterpretation;	/* eml2_3ForGsoap.h:295 */
class resqml22__BoundaryFeatureInterpretation;	/* eml2_3ForGsoap.h:301 */
class resqml22__EarthModelInterpretation;	/* eml2_3ForGsoap.h:307 */
class resqml22__GenericFeatureInterpretation;	/* eml2_3ForGsoap.h:315 */
class resqml22__GeologicUnitInterpretation;	/* eml2_3ForGsoap.h:325 */
class resqml22__RepresentationSetRepresentation;	/* eml2_3ForGsoap.h:371 */
class resqml22__SubRepresentation;	/* eml2_3ForGsoap.h:375 */
class resqml22__WellboreIntervalSet;	/* eml2_3ForGsoap.h:379 */
class resqml22__AbstractGridGeometry;	/* eml2_3ForGsoap.h:385 */
class resqml22__AbstractGridRepresentation;	/* eml2_3ForGsoap.h:387 */
class resqml22__GridConnectionSetRepresentation;	/* eml2_3ForGsoap.h:425 */
class resqml22__ContinuousColorMap;	/* eml2_3ForGsoap.h:503 */
class resqml22__DiscreteColorMap;	/* eml2_3ForGsoap.h:511 */
class resqml22__AbstractValuesProperty;	/* eml2_3ForGsoap.h:533 */
class resqml22__BooleanArrayFromDiscretePropertyArray;	/* eml2_3ForGsoap.h:535 */
class resqml22__PointsProperty;	/* eml2_3ForGsoap.h:547 */
class resqml22__StreamlinesRepresentation;	/* eml2_3ForGsoap.h:551 */
class resqml22__WellboreFrameRepresentation;	/* eml2_3ForGsoap.h:565 */
class resqml22__WellboreInterpretation;	/* eml2_3ForGsoap.h:567 */
class resqml22__WellboreTrajectoryRepresentation;	/* eml2_3ForGsoap.h:575 */
class eml23__AbstractFloatingPointArray;	/* eml2_3ForGsoap.h:603 */
class eml23__AbstractIntegerArray;	/* eml2_3ForGsoap.h:605 */
class eml23__BooleanArrayFromIndexArray;	/* eml2_3ForGsoap.h:615 */
class eml23__BooleanConstantArray;	/* eml2_3ForGsoap.h:617 */
class eml23__BooleanExternalArray;	/* eml2_3ForGsoap.h:619 */
class eml23__Cost;	/* eml2_3ForGsoap.h:621 */
class eml23__GenericMeasure;	/* eml2_3ForGsoap.h:631 */
class eml23__StringConstantArray;	/* eml2_3ForGsoap.h:647 */
class eml23__StringExternalArray;	/* eml2_3ForGsoap.h:649 */
class eml23__StringXmlArray;	/* eml2_3ForGsoap.h:653 */
class eml23__RecursiveReferencePoint;	/* eml2_3ForGsoap.h:671 */
class eml23__ReferencePointInACrs;	/* eml2_3ForGsoap.h:673 */
class eml23__ReferencePointInALocalEngineeringCompoundCrs;	/* eml2_3ForGsoap.h:675 */
class eml23__AbsorbedDoseMeasure;	/* eml2_3ForGsoap.h:685 */
class eml23__AbsorbedDoseMeasureExt;	/* eml2_3ForGsoap.h:687 */
class eml23__ActivityOfRadioactivityMeasure;	/* eml2_3ForGsoap.h:689 */
class eml23__ActivityOfRadioactivityMeasureExt;	/* eml2_3ForGsoap.h:691 */
class eml23__AmountOfSubstanceMeasure;	/* eml2_3ForGsoap.h:693 */
class eml23__AmountOfSubstanceMeasureExt;	/* eml2_3ForGsoap.h:695 */
class eml23__AmountOfSubstancePerAmountOfSubstanceMeasure;	/* eml2_3ForGsoap.h:697 */
class eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt;	/* eml2_3ForGsoap.h:699 */
class eml23__AmountOfSubstancePerAreaMeasure;	/* eml2_3ForGsoap.h:701 */
class eml23__AmountOfSubstancePerAreaMeasureExt;	/* eml2_3ForGsoap.h:703 */
class eml23__AmountOfSubstancePerTimeMeasure;	/* eml2_3ForGsoap.h:705 */
class eml23__AmountOfSubstancePerTimeMeasureExt;	/* eml2_3ForGsoap.h:707 */
class eml23__AmountOfSubstancePerTimePerAreaMeasure;	/* eml2_3ForGsoap.h:709 */
class eml23__AmountOfSubstancePerTimePerAreaMeasureExt;	/* eml2_3ForGsoap.h:711 */
class eml23__AmountOfSubstancePerVolumeMeasure;	/* eml2_3ForGsoap.h:713 */
class eml23__AmountOfSubstancePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:715 */
class eml23__AnglePerLengthMeasure;	/* eml2_3ForGsoap.h:717 */
class eml23__AnglePerLengthMeasureExt;	/* eml2_3ForGsoap.h:719 */
class eml23__AnglePerVolumeMeasure;	/* eml2_3ForGsoap.h:721 */
class eml23__AnglePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:723 */
class eml23__AngularAccelerationMeasure;	/* eml2_3ForGsoap.h:725 */
class eml23__AngularAccelerationMeasureExt;	/* eml2_3ForGsoap.h:727 */
class eml23__AngularVelocityMeasure;	/* eml2_3ForGsoap.h:729 */
class eml23__AngularVelocityMeasureExt;	/* eml2_3ForGsoap.h:731 */
class eml23__APIGammaRayMeasure;	/* eml2_3ForGsoap.h:733 */
class eml23__APIGammaRayMeasureExt;	/* eml2_3ForGsoap.h:735 */
class eml23__APIGravityMeasure;	/* eml2_3ForGsoap.h:737 */
class eml23__APIGravityMeasureExt;	/* eml2_3ForGsoap.h:739 */
class eml23__APINeutronMeasure;	/* eml2_3ForGsoap.h:741 */
class eml23__APINeutronMeasureExt;	/* eml2_3ForGsoap.h:743 */
class eml23__AreaMeasure;	/* eml2_3ForGsoap.h:745 */
class eml23__AreaMeasureExt;	/* eml2_3ForGsoap.h:747 */
class eml23__AreaPerAmountOfSubstanceMeasure;	/* eml2_3ForGsoap.h:749 */
class eml23__AreaPerAmountOfSubstanceMeasureExt;	/* eml2_3ForGsoap.h:751 */
class eml23__AreaPerAreaMeasure;	/* eml2_3ForGsoap.h:753 */
class eml23__AreaPerAreaMeasureExt;	/* eml2_3ForGsoap.h:755 */
class eml23__AreaPerCountMeasure;	/* eml2_3ForGsoap.h:757 */
class eml23__AreaPerCountMeasureExt;	/* eml2_3ForGsoap.h:759 */
class eml23__AreaPerMassMeasure;	/* eml2_3ForGsoap.h:761 */
class eml23__AreaPerMassMeasureExt;	/* eml2_3ForGsoap.h:763 */
class eml23__AreaPerTimeMeasure;	/* eml2_3ForGsoap.h:765 */
class eml23__AreaPerTimeMeasureExt;	/* eml2_3ForGsoap.h:767 */
class eml23__AreaPerVolumeMeasure;	/* eml2_3ForGsoap.h:769 */
class eml23__AreaPerVolumeMeasureExt;	/* eml2_3ForGsoap.h:771 */
class eml23__AttenuationPerFrequencyIntervalMeasure;	/* eml2_3ForGsoap.h:773 */
class eml23__AttenuationPerFrequencyIntervalMeasureExt;	/* eml2_3ForGsoap.h:775 */
class eml23__CapacitanceMeasure;	/* eml2_3ForGsoap.h:777 */
class eml23__CapacitanceMeasureExt;	/* eml2_3ForGsoap.h:779 */
class eml23__CationExchangeCapacityMeasure;	/* eml2_3ForGsoap.h:781 */
class eml23__CationExchangeCapacityMeasureExt;	/* eml2_3ForGsoap.h:783 */
class eml23__DataTransferSpeedMeasure;	/* eml2_3ForGsoap.h:785 */
class eml23__DataTransferSpeedMeasureExt;	/* eml2_3ForGsoap.h:787 */
class eml23__DiffusionCoefficientMeasure;	/* eml2_3ForGsoap.h:789 */
class eml23__DiffusionCoefficientMeasureExt;	/* eml2_3ForGsoap.h:791 */
class eml23__DiffusiveTimeOfFlightMeasure;	/* eml2_3ForGsoap.h:793 */
class eml23__DiffusiveTimeOfFlightMeasureExt;	/* eml2_3ForGsoap.h:795 */
class eml23__DigitalStorageMeasure;	/* eml2_3ForGsoap.h:797 */
class eml23__DigitalStorageMeasureExt;	/* eml2_3ForGsoap.h:799 */
class eml23__DimensionlessMeasure;	/* eml2_3ForGsoap.h:801 */
class eml23__DimensionlessMeasureExt;	/* eml2_3ForGsoap.h:803 */
class eml23__DipoleMomentMeasure;	/* eml2_3ForGsoap.h:805 */
class eml23__DipoleMomentMeasureExt;	/* eml2_3ForGsoap.h:807 */
class eml23__DoseEquivalentMeasure;	/* eml2_3ForGsoap.h:809 */
class eml23__DoseEquivalentMeasureExt;	/* eml2_3ForGsoap.h:811 */
class eml23__DynamicViscosityMeasure;	/* eml2_3ForGsoap.h:813 */
class eml23__DynamicViscosityMeasureExt;	/* eml2_3ForGsoap.h:815 */
class eml23__ElectricalResistivityMeasure;	/* eml2_3ForGsoap.h:817 */
class eml23__ElectricalResistivityMeasureExt;	/* eml2_3ForGsoap.h:819 */
class eml23__ElectricChargeMeasure;	/* eml2_3ForGsoap.h:821 */
class eml23__ElectricChargeMeasureExt;	/* eml2_3ForGsoap.h:823 */
class eml23__ElectricChargePerAreaMeasure;	/* eml2_3ForGsoap.h:825 */
class eml23__ElectricChargePerAreaMeasureExt;	/* eml2_3ForGsoap.h:827 */
class eml23__ElectricChargePerMassMeasure;	/* eml2_3ForGsoap.h:829 */
class eml23__ElectricChargePerMassMeasureExt;	/* eml2_3ForGsoap.h:831 */
class eml23__ElectricChargePerVolumeMeasure;	/* eml2_3ForGsoap.h:833 */
class eml23__ElectricChargePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:835 */
class eml23__ElectricConductanceMeasure;	/* eml2_3ForGsoap.h:837 */
class eml23__ElectricConductanceMeasureExt;	/* eml2_3ForGsoap.h:839 */
class eml23__ElectricConductivityMeasure;	/* eml2_3ForGsoap.h:841 */
class eml23__ElectricConductivityMeasureExt;	/* eml2_3ForGsoap.h:843 */
class eml23__ElectricCurrentDensityMeasure;	/* eml2_3ForGsoap.h:845 */
class eml23__ElectricCurrentDensityMeasureExt;	/* eml2_3ForGsoap.h:847 */
class eml23__ElectricCurrentMeasure;	/* eml2_3ForGsoap.h:849 */
class eml23__ElectricCurrentMeasureExt;	/* eml2_3ForGsoap.h:851 */
class eml23__ElectricFieldStrengthMeasure;	/* eml2_3ForGsoap.h:853 */
class eml23__ElectricFieldStrengthMeasureExt;	/* eml2_3ForGsoap.h:855 */
class eml23__ElectricPotentialDifferenceMeasure;	/* eml2_3ForGsoap.h:857 */
class eml23__ElectricPotentialDifferenceMeasureExt;	/* eml2_3ForGsoap.h:859 */
class eml23__ElectricResistanceMeasure;	/* eml2_3ForGsoap.h:861 */
class eml23__ElectricResistanceMeasureExt;	/* eml2_3ForGsoap.h:863 */
class eml23__ElectricResistancePerLengthMeasure;	/* eml2_3ForGsoap.h:865 */
class eml23__ElectricResistancePerLengthMeasureExt;	/* eml2_3ForGsoap.h:867 */
class eml23__ElectromagneticMomentMeasure;	/* eml2_3ForGsoap.h:869 */
class eml23__ElectromagneticMomentMeasureExt;	/* eml2_3ForGsoap.h:871 */
class eml23__EnergyLengthPerAreaMeasure;	/* eml2_3ForGsoap.h:873 */
class eml23__EnergyLengthPerAreaMeasureExt;	/* eml2_3ForGsoap.h:875 */
class eml23__EnergyLengthPerTimeAreaTemperatureMeasure;	/* eml2_3ForGsoap.h:877 */
class eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt;	/* eml2_3ForGsoap.h:879 */
class eml23__EnergyMeasure;	/* eml2_3ForGsoap.h:881 */
class eml23__EnergyMeasureExt;	/* eml2_3ForGsoap.h:883 */
class eml23__EnergyPerAreaMeasure;	/* eml2_3ForGsoap.h:885 */
class eml23__EnergyPerAreaMeasureExt;	/* eml2_3ForGsoap.h:887 */
class eml23__EnergyPerLengthMeasure;	/* eml2_3ForGsoap.h:889 */
class eml23__EnergyPerLengthMeasureExt;	/* eml2_3ForGsoap.h:891 */
class eml23__EnergyPerMassMeasure;	/* eml2_3ForGsoap.h:893 */
class eml23__EnergyPerMassMeasureExt;	/* eml2_3ForGsoap.h:895 */
class eml23__EnergyPerMassPerTimeMeasure;	/* eml2_3ForGsoap.h:897 */
class eml23__EnergyPerMassPerTimeMeasureExt;	/* eml2_3ForGsoap.h:899 */
class eml23__EnergyPerVolumeMeasure;	/* eml2_3ForGsoap.h:901 */
class eml23__EnergyPerVolumeMeasureExt;	/* eml2_3ForGsoap.h:903 */
class eml23__ForceAreaMeasure;	/* eml2_3ForGsoap.h:905 */
class eml23__ForceAreaMeasureExt;	/* eml2_3ForGsoap.h:907 */
class eml23__ForceLengthPerLengthMeasure;	/* eml2_3ForGsoap.h:909 */
class eml23__ForceLengthPerLengthMeasureExt;	/* eml2_3ForGsoap.h:911 */
class eml23__ForceMeasure;	/* eml2_3ForGsoap.h:913 */
class eml23__ForceMeasureExt;	/* eml2_3ForGsoap.h:915 */
class eml23__ForcePerForceMeasure;	/* eml2_3ForGsoap.h:917 */
class eml23__ForcePerForceMeasureExt;	/* eml2_3ForGsoap.h:919 */
class eml23__ForcePerLengthMeasure;	/* eml2_3ForGsoap.h:921 */
class eml23__ForcePerLengthMeasureExt;	/* eml2_3ForGsoap.h:923 */
class eml23__ForcePerVolumeMeasure;	/* eml2_3ForGsoap.h:925 */
class eml23__ForcePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:927 */
class eml23__FrequencyIntervalMeasure;	/* eml2_3ForGsoap.h:929 */
class eml23__FrequencyIntervalMeasureExt;	/* eml2_3ForGsoap.h:931 */
class eml23__FrequencyMeasure;	/* eml2_3ForGsoap.h:933 */
class eml23__FrequencyMeasureExt;	/* eml2_3ForGsoap.h:935 */
class eml23__HeatCapacityMeasure;	/* eml2_3ForGsoap.h:937 */
class eml23__HeatCapacityMeasureExt;	/* eml2_3ForGsoap.h:939 */
class eml23__HeatFlowRateMeasure;	/* eml2_3ForGsoap.h:941 */
class eml23__HeatFlowRateMeasureExt;	/* eml2_3ForGsoap.h:943 */
class eml23__HeatTransferCoefficientMeasure;	/* eml2_3ForGsoap.h:945 */
class eml23__HeatTransferCoefficientMeasureExt;	/* eml2_3ForGsoap.h:947 */
class eml23__IlluminanceMeasure;	/* eml2_3ForGsoap.h:949 */
class eml23__IlluminanceMeasureExt;	/* eml2_3ForGsoap.h:951 */
class eml23__InductanceMeasure;	/* eml2_3ForGsoap.h:953 */
class eml23__InductanceMeasureExt;	/* eml2_3ForGsoap.h:955 */
class eml23__IsothermalCompressibilityMeasure;	/* eml2_3ForGsoap.h:957 */
class eml23__IsothermalCompressibilityMeasureExt;	/* eml2_3ForGsoap.h:959 */
class eml23__KinematicViscosityMeasure;	/* eml2_3ForGsoap.h:961 */
class eml23__KinematicViscosityMeasureExt;	/* eml2_3ForGsoap.h:963 */
class eml23__LengthMeasure;	/* eml2_3ForGsoap.h:965 */
class eml23__LengthMeasureExt;	/* eml2_3ForGsoap.h:967 */
class eml23__LengthOrTimeMeasureExt;	/* eml2_3ForGsoap.h:969 */
class eml23__LengthPerLengthMeasure;	/* eml2_3ForGsoap.h:971 */
class eml23__LengthPerLengthMeasureExt;	/* eml2_3ForGsoap.h:973 */
class eml23__LengthPerMassMeasure;	/* eml2_3ForGsoap.h:975 */
class eml23__LengthPerMassMeasureExt;	/* eml2_3ForGsoap.h:977 */
class eml23__LengthPerPressureMeasure;	/* eml2_3ForGsoap.h:979 */
class eml23__LengthPerPressureMeasureExt;	/* eml2_3ForGsoap.h:981 */
class eml23__LengthPerTemperatureMeasure;	/* eml2_3ForGsoap.h:983 */
class eml23__LengthPerTemperatureMeasureExt;	/* eml2_3ForGsoap.h:985 */
class eml23__LengthPerTimeMeasure;	/* eml2_3ForGsoap.h:987 */
class eml23__LengthPerTimeMeasureExt;	/* eml2_3ForGsoap.h:989 */
class eml23__LengthPerVolumeMeasure;	/* eml2_3ForGsoap.h:991 */
class eml23__LengthPerVolumeMeasureExt;	/* eml2_3ForGsoap.h:993 */
class eml23__LightExposureMeasure;	/* eml2_3ForGsoap.h:995 */
class eml23__LightExposureMeasureExt;	/* eml2_3ForGsoap.h:997 */
class eml23__LinearAccelerationMeasure;	/* eml2_3ForGsoap.h:999 */
class eml23__LinearAccelerationMeasureExt;	/* eml2_3ForGsoap.h:1001 */
class eml23__LinearThermalExpansionMeasure;	/* eml2_3ForGsoap.h:1003 */
class eml23__LinearThermalExpansionMeasureExt;	/* eml2_3ForGsoap.h:1005 */
class eml23__LogarithmicPowerRatioMeasure;	/* eml2_3ForGsoap.h:1007 */
class eml23__LogarithmicPowerRatioMeasureExt;	/* eml2_3ForGsoap.h:1009 */
class eml23__LogarithmicPowerRatioPerLengthMeasure;	/* eml2_3ForGsoap.h:1011 */
class eml23__LogarithmicPowerRatioPerLengthMeasureExt;	/* eml2_3ForGsoap.h:1013 */
class eml23__LuminanceMeasure;	/* eml2_3ForGsoap.h:1015 */
class eml23__LuminanceMeasureExt;	/* eml2_3ForGsoap.h:1017 */
class eml23__LuminousEfficacyMeasure;	/* eml2_3ForGsoap.h:1019 */
class eml23__LuminousEfficacyMeasureExt;	/* eml2_3ForGsoap.h:1021 */
class eml23__LuminousFluxMeasure;	/* eml2_3ForGsoap.h:1023 */
class eml23__LuminousFluxMeasureExt;	/* eml2_3ForGsoap.h:1025 */
class eml23__LuminousIntensityMeasure;	/* eml2_3ForGsoap.h:1027 */
class eml23__LuminousIntensityMeasureExt;	/* eml2_3ForGsoap.h:1029 */
class eml23__MagneticDipoleMomentMeasure;	/* eml2_3ForGsoap.h:1031 */
class eml23__MagneticDipoleMomentMeasureExt;	/* eml2_3ForGsoap.h:1033 */
class eml23__MagneticFieldStrengthMeasure;	/* eml2_3ForGsoap.h:1035 */
class eml23__MagneticFieldStrengthMeasureExt;	/* eml2_3ForGsoap.h:1037 */
class eml23__MagneticFluxDensityMeasure;	/* eml2_3ForGsoap.h:1039 */
class eml23__MagneticFluxDensityMeasureExt;	/* eml2_3ForGsoap.h:1041 */
class eml23__MagneticFluxDensityPerLengthMeasure;	/* eml2_3ForGsoap.h:1043 */
class eml23__MagneticFluxDensityPerLengthMeasureExt;	/* eml2_3ForGsoap.h:1045 */
class eml23__MagneticFluxMeasure;	/* eml2_3ForGsoap.h:1047 */
class eml23__MagneticFluxMeasureExt;	/* eml2_3ForGsoap.h:1049 */
class eml23__MagneticPermeabilityMeasure;	/* eml2_3ForGsoap.h:1051 */
class eml23__MagneticPermeabilityMeasureExt;	/* eml2_3ForGsoap.h:1053 */
class eml23__MagneticVectorPotentialMeasure;	/* eml2_3ForGsoap.h:1055 */
class eml23__MagneticVectorPotentialMeasureExt;	/* eml2_3ForGsoap.h:1057 */
class eml23__MassLengthMeasure;	/* eml2_3ForGsoap.h:1059 */
class eml23__MassLengthMeasureExt;	/* eml2_3ForGsoap.h:1061 */
class eml23__MassMeasure;	/* eml2_3ForGsoap.h:1063 */
class eml23__MassMeasureExt;	/* eml2_3ForGsoap.h:1065 */
class eml23__MassPerAreaMeasure;	/* eml2_3ForGsoap.h:1067 */
class eml23__MassPerAreaMeasureExt;	/* eml2_3ForGsoap.h:1069 */
class eml23__MassPerEnergyMeasure;	/* eml2_3ForGsoap.h:1071 */
class eml23__MassPerEnergyMeasureExt;	/* eml2_3ForGsoap.h:1073 */
class eml23__MassPerLengthMeasure;	/* eml2_3ForGsoap.h:1075 */
class eml23__MassPerLengthMeasureExt;	/* eml2_3ForGsoap.h:1077 */
class eml23__MassPerMassMeasure;	/* eml2_3ForGsoap.h:1079 */
class eml23__MassPerMassMeasureExt;	/* eml2_3ForGsoap.h:1081 */
class eml23__MassPerTimeMeasure;	/* eml2_3ForGsoap.h:1083 */
class eml23__MassPerTimeMeasureExt;	/* eml2_3ForGsoap.h:1085 */
class eml23__MassPerTimePerAreaMeasure;	/* eml2_3ForGsoap.h:1087 */
class eml23__MassPerTimePerAreaMeasureExt;	/* eml2_3ForGsoap.h:1089 */
class eml23__MassPerTimePerLengthMeasure;	/* eml2_3ForGsoap.h:1091 */
class eml23__MassPerTimePerLengthMeasureExt;	/* eml2_3ForGsoap.h:1093 */
class eml23__MassPerVolumeMeasure;	/* eml2_3ForGsoap.h:1095 */
class eml23__MassPerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1097 */
class eml23__MassPerVolumePerLengthMeasure;	/* eml2_3ForGsoap.h:1099 */
class eml23__MassPerVolumePerLengthMeasureExt;	/* eml2_3ForGsoap.h:1101 */
class eml23__MassPerVolumePerPressureMeasure;	/* eml2_3ForGsoap.h:1103 */
class eml23__MassPerVolumePerPressureMeasureExt;	/* eml2_3ForGsoap.h:1105 */
class eml23__MassPerVolumePerTemperatureMeasure;	/* eml2_3ForGsoap.h:1107 */
class eml23__MassPerVolumePerTemperatureMeasureExt;	/* eml2_3ForGsoap.h:1109 */
class eml23__MobilityMeasure;	/* eml2_3ForGsoap.h:1111 */
class eml23__MobilityMeasureExt;	/* eml2_3ForGsoap.h:1113 */
class eml23__MolarEnergyMeasure;	/* eml2_3ForGsoap.h:1115 */
class eml23__MolarEnergyMeasureExt;	/* eml2_3ForGsoap.h:1117 */
class eml23__MolarHeatCapacityMeasure;	/* eml2_3ForGsoap.h:1119 */
class eml23__MolarHeatCapacityMeasureExt;	/* eml2_3ForGsoap.h:1121 */
class eml23__MolarVolumeMeasure;	/* eml2_3ForGsoap.h:1123 */
class eml23__MolarVolumeMeasureExt;	/* eml2_3ForGsoap.h:1125 */
class eml23__MolecularWeightMeasure;	/* eml2_3ForGsoap.h:1127 */
class eml23__MolecularWeightMeasureExt;	/* eml2_3ForGsoap.h:1129 */
class eml23__MomentOfForceMeasure;	/* eml2_3ForGsoap.h:1131 */
class eml23__MomentOfForceMeasureExt;	/* eml2_3ForGsoap.h:1133 */
class eml23__MomentOfInertiaMeasure;	/* eml2_3ForGsoap.h:1135 */
class eml23__MomentOfInertiaMeasureExt;	/* eml2_3ForGsoap.h:1137 */
class eml23__MomentumMeasure;	/* eml2_3ForGsoap.h:1139 */
class eml23__MomentumMeasureExt;	/* eml2_3ForGsoap.h:1141 */
class eml23__NormalizedPowerMeasure;	/* eml2_3ForGsoap.h:1143 */
class eml23__NormalizedPowerMeasureExt;	/* eml2_3ForGsoap.h:1145 */
class eml23__PermeabilityLengthMeasure;	/* eml2_3ForGsoap.h:1147 */
class eml23__PermeabilityLengthMeasureExt;	/* eml2_3ForGsoap.h:1149 */
class eml23__PermeabilityRockMeasure;	/* eml2_3ForGsoap.h:1151 */
class eml23__PermeabilityRockMeasureExt;	/* eml2_3ForGsoap.h:1153 */
class eml23__PermittivityMeasure;	/* eml2_3ForGsoap.h:1155 */
class eml23__PermittivityMeasureExt;	/* eml2_3ForGsoap.h:1157 */
class eml23__PlaneAngleMeasure;	/* eml2_3ForGsoap.h:1159 */
class eml23__PlaneAngleMeasureExt;	/* eml2_3ForGsoap.h:1161 */
class eml23__PotentialDifferencePerPowerDropMeasure;	/* eml2_3ForGsoap.h:1163 */
class eml23__PotentialDifferencePerPowerDropMeasureExt;	/* eml2_3ForGsoap.h:1165 */
class eml23__PowerMeasure;	/* eml2_3ForGsoap.h:1167 */
class eml23__PowerMeasureExt;	/* eml2_3ForGsoap.h:1169 */
class eml23__PowerPerAreaMeasure;	/* eml2_3ForGsoap.h:1171 */
class eml23__PowerPerAreaMeasureExt;	/* eml2_3ForGsoap.h:1173 */
class eml23__PowerPerPowerMeasure;	/* eml2_3ForGsoap.h:1175 */
class eml23__PowerPerPowerMeasureExt;	/* eml2_3ForGsoap.h:1177 */
class eml23__PowerPerVolumeMeasure;	/* eml2_3ForGsoap.h:1179 */
class eml23__PowerPerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1181 */
class eml23__PressureMeasure;	/* eml2_3ForGsoap.h:1183 */
class eml23__PressureMeasureExt;	/* eml2_3ForGsoap.h:1185 */
class eml23__PressurePerPressureMeasure;	/* eml2_3ForGsoap.h:1187 */
class eml23__PressurePerPressureMeasureExt;	/* eml2_3ForGsoap.h:1189 */
class eml23__PressurePerTimeMeasure;	/* eml2_3ForGsoap.h:1191 */
class eml23__PressurePerTimeMeasureExt;	/* eml2_3ForGsoap.h:1193 */
class eml23__PressurePerVolumeMeasure;	/* eml2_3ForGsoap.h:1195 */
class eml23__PressurePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1197 */
class eml23__PressureSquaredMeasure;	/* eml2_3ForGsoap.h:1199 */
class eml23__PressureSquaredMeasureExt;	/* eml2_3ForGsoap.h:1201 */
class eml23__PressureSquaredPerForceTimePerAreaMeasure;	/* eml2_3ForGsoap.h:1203 */
class eml23__PressureSquaredPerForceTimePerAreaMeasureExt;	/* eml2_3ForGsoap.h:1205 */
class eml23__PressureTimePerVolumeMeasure;	/* eml2_3ForGsoap.h:1207 */
class eml23__PressureTimePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1209 */
class eml23__QuantityOfLightMeasure;	/* eml2_3ForGsoap.h:1211 */
class eml23__QuantityOfLightMeasureExt;	/* eml2_3ForGsoap.h:1213 */
class eml23__RadianceMeasure;	/* eml2_3ForGsoap.h:1215 */
class eml23__RadianceMeasureExt;	/* eml2_3ForGsoap.h:1217 */
class eml23__RadiantIntensityMeasure;	/* eml2_3ForGsoap.h:1219 */
class eml23__RadiantIntensityMeasureExt;	/* eml2_3ForGsoap.h:1221 */
class eml23__ReciprocalAreaMeasure;	/* eml2_3ForGsoap.h:1223 */
class eml23__ReciprocalAreaMeasureExt;	/* eml2_3ForGsoap.h:1225 */
class eml23__ReciprocalElectricPotentialDifferenceMeasure;	/* eml2_3ForGsoap.h:1227 */
class eml23__ReciprocalElectricPotentialDifferenceMeasureExt;	/* eml2_3ForGsoap.h:1229 */
class eml23__ReciprocalForceMeasure;	/* eml2_3ForGsoap.h:1231 */
class eml23__ReciprocalForceMeasureExt;	/* eml2_3ForGsoap.h:1233 */
class eml23__ReciprocalLengthMeasure;	/* eml2_3ForGsoap.h:1235 */
class eml23__ReciprocalLengthMeasureExt;	/* eml2_3ForGsoap.h:1237 */
class eml23__ReciprocalMassMeasure;	/* eml2_3ForGsoap.h:1239 */
class eml23__ReciprocalMassMeasureExt;	/* eml2_3ForGsoap.h:1241 */
class eml23__ReciprocalMassTimeMeasure;	/* eml2_3ForGsoap.h:1243 */
class eml23__ReciprocalMassTimeMeasureExt;	/* eml2_3ForGsoap.h:1245 */
class eml23__ReciprocalPressureMeasure;	/* eml2_3ForGsoap.h:1247 */
class eml23__ReciprocalPressureMeasureExt;	/* eml2_3ForGsoap.h:1249 */
class eml23__ReciprocalTimeMeasure;	/* eml2_3ForGsoap.h:1251 */
class eml23__ReciprocalTimeMeasureExt;	/* eml2_3ForGsoap.h:1253 */
class eml23__ReciprocalVolumeMeasure;	/* eml2_3ForGsoap.h:1255 */
class eml23__ReciprocalVolumeMeasureExt;	/* eml2_3ForGsoap.h:1257 */
class eml23__ReluctanceMeasure;	/* eml2_3ForGsoap.h:1259 */
class eml23__ReluctanceMeasureExt;	/* eml2_3ForGsoap.h:1261 */
class eml23__SecondMomentOfAreaMeasure;	/* eml2_3ForGsoap.h:1263 */
class eml23__SecondMomentOfAreaMeasureExt;	/* eml2_3ForGsoap.h:1265 */
class eml23__SignalingEventPerTimeMeasure;	/* eml2_3ForGsoap.h:1267 */
class eml23__SignalingEventPerTimeMeasureExt;	/* eml2_3ForGsoap.h:1269 */
class eml23__SolidAngleMeasure;	/* eml2_3ForGsoap.h:1271 */
class eml23__SolidAngleMeasureExt;	/* eml2_3ForGsoap.h:1273 */
class eml23__SpecificHeatCapacityMeasure;	/* eml2_3ForGsoap.h:1275 */
class eml23__SpecificHeatCapacityMeasureExt;	/* eml2_3ForGsoap.h:1277 */
class eml23__TemperatureIntervalMeasure;	/* eml2_3ForGsoap.h:1279 */
class eml23__TemperatureIntervalMeasureExt;	/* eml2_3ForGsoap.h:1281 */
class eml23__TemperatureIntervalPerLengthMeasure;	/* eml2_3ForGsoap.h:1283 */
class eml23__TemperatureIntervalPerLengthMeasureExt;	/* eml2_3ForGsoap.h:1285 */
class eml23__TemperatureIntervalPerPressureMeasure;	/* eml2_3ForGsoap.h:1287 */
class eml23__TemperatureIntervalPerPressureMeasureExt;	/* eml2_3ForGsoap.h:1289 */
class eml23__TemperatureIntervalPerTimeMeasure;	/* eml2_3ForGsoap.h:1291 */
class eml23__TemperatureIntervalPerTimeMeasureExt;	/* eml2_3ForGsoap.h:1293 */
class eml23__ThermalConductanceMeasure;	/* eml2_3ForGsoap.h:1295 */
class eml23__ThermalConductanceMeasureExt;	/* eml2_3ForGsoap.h:1297 */
class eml23__ThermalConductivityMeasure;	/* eml2_3ForGsoap.h:1299 */
class eml23__ThermalConductivityMeasureExt;	/* eml2_3ForGsoap.h:1301 */
class eml23__ThermalDiffusivityMeasure;	/* eml2_3ForGsoap.h:1303 */
class eml23__ThermalDiffusivityMeasureExt;	/* eml2_3ForGsoap.h:1305 */
class eml23__ThermalInsulanceMeasure;	/* eml2_3ForGsoap.h:1307 */
class eml23__ThermalInsulanceMeasureExt;	/* eml2_3ForGsoap.h:1309 */
class eml23__ThermalResistanceMeasure;	/* eml2_3ForGsoap.h:1311 */
class eml23__ThermalResistanceMeasureExt;	/* eml2_3ForGsoap.h:1313 */
class eml23__ThermodynamicTemperatureMeasure;	/* eml2_3ForGsoap.h:1315 */
class eml23__ThermodynamicTemperatureMeasureExt;	/* eml2_3ForGsoap.h:1317 */
class eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure;	/* eml2_3ForGsoap.h:1319 */
class eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt;	/* eml2_3ForGsoap.h:1321 */
class eml23__TimeMeasure;	/* eml2_3ForGsoap.h:1323 */
class eml23__TimeMeasureExt;	/* eml2_3ForGsoap.h:1325 */
class eml23__TimePerLengthMeasure;	/* eml2_3ForGsoap.h:1327 */
class eml23__TimePerLengthMeasureExt;	/* eml2_3ForGsoap.h:1329 */
class eml23__TimePerMassMeasure;	/* eml2_3ForGsoap.h:1331 */
class eml23__TimePerMassMeasureExt;	/* eml2_3ForGsoap.h:1333 */
class eml23__TimePerTimeMeasure;	/* eml2_3ForGsoap.h:1335 */
class eml23__TimePerTimeMeasureExt;	/* eml2_3ForGsoap.h:1337 */
class eml23__TimePerVolumeMeasure;	/* eml2_3ForGsoap.h:1339 */
class eml23__TimePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1341 */
class eml23__UnitlessMeasure;	/* eml2_3ForGsoap.h:1343 */
class eml23__VerticalCoordinateMeasure;	/* eml2_3ForGsoap.h:1345 */
class eml23__VerticalCoordinateMeasureExt;	/* eml2_3ForGsoap.h:1347 */
class eml23__VolumeFlowRatePerVolumeFlowRateMeasure;	/* eml2_3ForGsoap.h:1349 */
class eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt;	/* eml2_3ForGsoap.h:1351 */
class eml23__VolumeMeasure;	/* eml2_3ForGsoap.h:1353 */
class eml23__VolumeMeasureExt;	/* eml2_3ForGsoap.h:1355 */
class eml23__VolumePerAreaMeasure;	/* eml2_3ForGsoap.h:1357 */
class eml23__VolumePerAreaMeasureExt;	/* eml2_3ForGsoap.h:1359 */
class eml23__VolumePerLengthMeasure;	/* eml2_3ForGsoap.h:1361 */
class eml23__VolumePerLengthMeasureExt;	/* eml2_3ForGsoap.h:1363 */
class eml23__VolumePerMassMeasure;	/* eml2_3ForGsoap.h:1365 */
class eml23__VolumePerMassMeasureExt;	/* eml2_3ForGsoap.h:1367 */
class eml23__VolumePerPressureMeasure;	/* eml2_3ForGsoap.h:1369 */
class eml23__VolumePerPressureMeasureExt;	/* eml2_3ForGsoap.h:1371 */
class eml23__VolumePerRotationMeasure;	/* eml2_3ForGsoap.h:1373 */
class eml23__VolumePerRotationMeasureExt;	/* eml2_3ForGsoap.h:1375 */
class eml23__VolumePerTimeLengthMeasure;	/* eml2_3ForGsoap.h:1377 */
class eml23__VolumePerTimeLengthMeasureExt;	/* eml2_3ForGsoap.h:1379 */
class eml23__VolumePerTimeMeasure;	/* eml2_3ForGsoap.h:1381 */
class eml23__VolumePerTimeMeasureExt;	/* eml2_3ForGsoap.h:1383 */
class eml23__VolumePerTimePerAreaMeasure;	/* eml2_3ForGsoap.h:1385 */
class eml23__VolumePerTimePerAreaMeasureExt;	/* eml2_3ForGsoap.h:1387 */
class eml23__VolumePerTimePerLengthMeasure;	/* eml2_3ForGsoap.h:1389 */
class eml23__VolumePerTimePerLengthMeasureExt;	/* eml2_3ForGsoap.h:1391 */
class eml23__VolumePerTimePerPressureLengthMeasure;	/* eml2_3ForGsoap.h:1393 */
class eml23__VolumePerTimePerPressureLengthMeasureExt;	/* eml2_3ForGsoap.h:1395 */
class eml23__VolumePerTimePerPressureMeasure;	/* eml2_3ForGsoap.h:1397 */
class eml23__VolumePerTimePerPressureMeasureExt;	/* eml2_3ForGsoap.h:1399 */
class eml23__VolumePerTimePerTimeMeasure;	/* eml2_3ForGsoap.h:1401 */
class eml23__VolumePerTimePerTimeMeasureExt;	/* eml2_3ForGsoap.h:1403 */
class eml23__VolumePerTimePerVolumeMeasure;	/* eml2_3ForGsoap.h:1405 */
class eml23__VolumePerTimePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1407 */
class eml23__VolumePerVolumeMeasure;	/* eml2_3ForGsoap.h:1409 */
class eml23__VolumePerVolumeMeasureExt;	/* eml2_3ForGsoap.h:1411 */
class eml23__VolumetricHeatTransferCoefficientMeasure;	/* eml2_3ForGsoap.h:1413 */
class eml23__VolumetricHeatTransferCoefficientMeasureExt;	/* eml2_3ForGsoap.h:1415 */
class eml23__VolumetricThermalExpansionMeasure;	/* eml2_3ForGsoap.h:1417 */
class eml23__VolumetricThermalExpansionMeasureExt;	/* eml2_3ForGsoap.h:1419 */
class eml23__ReferencePressure;	/* eml2_3ForGsoap.h:1563 */
class resqml22__CulturalFeature;	/* eml2_3ForGsoap.h:167 */
class resqml22__AbstractSeismicSurveyFeature;	/* eml2_3ForGsoap.h:225 */
class resqml22__Seismic3dPostStackRepresentation;	/* eml2_3ForGsoap.h:235 */
class resqml22__AbstractSurfaceFrameworkRepresentation;	/* eml2_3ForGsoap.h:247 */
class resqml22__PlaneSetRepresentation;	/* eml2_3ForGsoap.h:267 */
class resqml22__SealedVolumeFrameworkRepresentation;	/* eml2_3ForGsoap.h:279 */
class resqml22__TriangulatedSetRepresentation;	/* eml2_3ForGsoap.h:283 */
class resqml22__AbstractGeologicUnitOrganizationInterpretation;	/* eml2_3ForGsoap.h:293 */
class resqml22__FaultInterpretation;	/* eml2_3ForGsoap.h:309 */
class resqml22__FluidBoundaryInterpretation;	/* eml2_3ForGsoap.h:313 */
class resqml22__GeobodyBoundaryInterpretation;	/* eml2_3ForGsoap.h:319 */
class resqml22__GeobodyInterpretation;	/* eml2_3ForGsoap.h:321 */
class resqml22__HorizonInterpretation;	/* eml2_3ForGsoap.h:329 */
class resqml22__ReservoirCompartmentInterpretation;	/* eml2_3ForGsoap.h:333 */
class resqml22__RockFluidOrganizationInterpretation;	/* eml2_3ForGsoap.h:337 */
class resqml22__RockFluidUnitInterpretation;	/* eml2_3ForGsoap.h:339 */
class resqml22__StratigraphicUnitInterpretation;	/* eml2_3ForGsoap.h:345 */
class resqml22__StructuralOrganizationInterpretation;	/* eml2_3ForGsoap.h:347 */
class resqml22__VoidageGroupInterpretation;	/* eml2_3ForGsoap.h:349 */
class resqml22__AbstractColumnLayerGridGeometry;	/* eml2_3ForGsoap.h:381 */
class resqml22__AbstractColumnLayerGridRepresentation;	/* eml2_3ForGsoap.h:383 */
class resqml22__AbstractTruncatedColumnLayerGridRepresentation;	/* eml2_3ForGsoap.h:391 */
class resqml22__GpGridRepresentation;	/* eml2_3ForGsoap.h:421 */
class resqml22__Grid2dRepresentation;	/* eml2_3ForGsoap.h:423 */
class resqml22__UnstructuredGridGeometry;	/* eml2_3ForGsoap.h:481 */
class resqml22__UnstructuredGridRepresentation;	/* eml2_3ForGsoap.h:485 */
class resqml22__BooleanProperty;	/* eml2_3ForGsoap.h:537 */
class resqml22__CategoricalProperty;	/* eml2_3ForGsoap.h:539 */
class resqml22__CommentProperty;	/* eml2_3ForGsoap.h:541 */
class resqml22__ContinuousProperty;	/* eml2_3ForGsoap.h:543 */
class resqml22__DiscreteProperty;	/* eml2_3ForGsoap.h:545 */
class resqml22__StreamlinesFeature;	/* eml2_3ForGsoap.h:549 */
class resqml22__BlockedWellboreRepresentation;	/* eml2_3ForGsoap.h:555 */
class resqml22__SeismicWellboreFrameRepresentation;	/* eml2_3ForGsoap.h:559 */
class resqml22__WellboreFeature;	/* eml2_3ForGsoap.h:563 */
class resqml22__WellboreMarkerFrameRepresentation;	/* eml2_3ForGsoap.h:571 */
class eml23__AuthorityQualifiedName;	/* eml2_3ForGsoap.h:613 */
class eml23__FloatingPointConstantArray;	/* eml2_3ForGsoap.h:623 */
class eml23__FloatingPointExternalArray;	/* eml2_3ForGsoap.h:625 */
class eml23__FloatingPointLatticeArray;	/* eml2_3ForGsoap.h:627 */
class eml23__FloatingPointXmlArray;	/* eml2_3ForGsoap.h:629 */
class eml23__IntegerArrayFromBooleanMaskArray;	/* eml2_3ForGsoap.h:633 */
class eml23__IntegerConstantArray;	/* eml2_3ForGsoap.h:635 */
class eml23__IntegerExternalArray;	/* eml2_3ForGsoap.h:637 */
class eml23__IntegerLatticeArray;	/* eml2_3ForGsoap.h:639 */
class eml23__StringMeasure;	/* eml2_3ForGsoap.h:651 */
class eml23__ReferencePointInAWellbore;	/* eml2_3ForGsoap.h:677 */
class eml23__EmailQualifierStruct;	/* eml2_3ForGsoap.h:1517 */
class eml23__NameStruct;	/* eml2_3ForGsoap.h:1521 */
class resqml22__AbstractSeismicLineFeature;	/* eml2_3ForGsoap.h:223 */
class resqml22__SeismicLatticeFeature;	/* eml2_3ForGsoap.h:237 */
class resqml22__SeismicLatticeSetFeature;	/* eml2_3ForGsoap.h:239 */
class resqml22__SeismicLineSetFeature;	/* eml2_3ForGsoap.h:241 */
class resqml22__NonSealedSurfaceFrameworkRepresentation;	/* eml2_3ForGsoap.h:263 */
class resqml22__SealedSurfaceFrameworkRepresentation;	/* eml2_3ForGsoap.h:277 */
class resqml22__GeologicUnitOccurrenceInterpretation;	/* eml2_3ForGsoap.h:327 */
class resqml22__StratigraphicColumnRankInterpretation;	/* eml2_3ForGsoap.h:343 */
class resqml22__IjkGridGeometry;	/* eml2_3ForGsoap.h:431 */
class resqml22__IjkGridRepresentation;	/* eml2_3ForGsoap.h:433 */
class resqml22__TruncatedIjkGridRepresentation;	/* eml2_3ForGsoap.h:463 */
class resqml22__TruncatedUnstructuredColumnLayerGridRepresentation;	/* eml2_3ForGsoap.h:465 */
class resqml22__UnstructuredColumnLayerGridGeometry;	/* eml2_3ForGsoap.h:475 */
class resqml22__UnstructuredColumnLayerGridRepresentation;	/* eml2_3ForGsoap.h:477 */
class resqml22__CmpLineFeature;	/* eml2_3ForGsoap.h:227 */
class resqml22__ShotPointLineFeature;	/* eml2_3ForGsoap.h:243 */

/* eml2_3ForGsoap.h:137 */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary
#define SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary (-8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* custom/struct_tm.h:57 */
#ifndef SOAP_TYPE_gsoap_eml2_3_tm
#define SOAP_TYPE_gsoap_eml2_3_tm (-12)
#if 0 /* Volatile: declared external of the data binding interface and not redeclared here */
struct SOAP_CMAC tm {
      public:
        /** Required element 'tm-sec' of XML schema type 'xsd:int' */
        int tm_sec;
        /** Required element 'tm-min' of XML schema type 'xsd:int' */
        int tm_min;
        /** Required element 'tm-hour' of XML schema type 'xsd:int' */
        int tm_hour;
        /** Required element 'tm-mday' of XML schema type 'xsd:int' */
        int tm_mday;
        /** Required element 'tm-mon' of XML schema type 'xsd:int' */
        int tm_mon;
        /** Required element 'tm-year' of XML schema type 'xsd:int' */
        int tm_year;
        /** Required element 'tm-isdst' of XML schema type 'xsd:int' */
        int tm_isdst;
};
#endif
#endif

/* eml2_3ForGsoap.h:173 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry (-24)
/* complex XML schema type 'resqml22:AbstractGeometry': */
class SOAP_CMAC resqml22__AbstractGeometry {
      public:
        /// Optional element 'resqml22:TimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *TimeIndex;
        /// Required element 'resqml22:LocalCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalCrs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractGeometry, default initialized and not managed by a soap context
        virtual resqml22__AbstractGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractGeometry() : TimeIndex(), LocalCrs(), soap() { }
        virtual ~resqml22__AbstractGeometry() { }
        /// Friend allocator used by soap_new_resqml22__AbstractGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractGeometry * SOAP_FMAC2 soap_instantiate_resqml22__AbstractGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:175 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray (-25)
/* complex XML schema type 'resqml22:AbstractParametricLineArray': */
class SOAP_CMAC resqml22__AbstractParametricLineArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractParametricLineArray, default initialized and not managed by a soap context
        virtual resqml22__AbstractParametricLineArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractParametricLineArray); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractParametricLineArray() : soap() { }
        virtual ~resqml22__AbstractParametricLineArray() { }
        /// Friend allocator used by soap_new_resqml22__AbstractParametricLineArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractParametricLineArray * SOAP_FMAC2 soap_instantiate_resqml22__AbstractParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:181 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray (-28)
/* Type resqml22__AbstractPoint3dArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractPoint3dArray': */
class SOAP_CMAC resqml22__AbstractPoint3dArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractPoint3dArray, default initialized and not managed by a soap context
        virtual resqml22__AbstractPoint3dArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractPoint3dArray); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractPoint3dArray() : soap() { }
        virtual ~resqml22__AbstractPoint3dArray() { }
        /// Friend allocator used by soap_new_resqml22__AbstractPoint3dArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractPoint3dArray * SOAP_FMAC2 soap_instantiate_resqml22__AbstractPoint3dArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:195 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections (-35)
/* complex XML schema type 'resqml22:ParametricLineIntersections': */
class SOAP_CMAC resqml22__ParametricLineIntersections {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:IntersectionLinePairs' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *IntersectionLinePairs;
        /// Required element 'resqml22:ParameterValuePairs' of XML schema type 'eml23:AbstractValueArray'
        eml23__AbstractValueArray *ParameterValuePairs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ParametricLineIntersections, default initialized and not managed by a soap context
        virtual resqml22__ParametricLineIntersections *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ParametricLineIntersections); }
      public:
        /// Constructor with default initializations
        resqml22__ParametricLineIntersections() : Count(), IntersectionLinePairs(), ParameterValuePairs(), soap() { }
        virtual ~resqml22__ParametricLineIntersections() { }
        /// Friend allocator used by soap_new_resqml22__ParametricLineIntersections(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ParametricLineIntersections * SOAP_FMAC2 soap_instantiate_resqml22__ParametricLineIntersections(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:199 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d (-37)
/* complex XML schema type 'resqml22:Point3d': */
class SOAP_CMAC resqml22__Point3d {
      public:
        /// Required element 'resqml22:Coordinate1' of XML schema type 'xsd:double'
        double Coordinate1;
        /// Required element 'resqml22:Coordinate2' of XML schema type 'xsd:double'
        double Coordinate2;
        /// Required element 'resqml22:Coordinate3' of XML schema type 'xsd:double'
        double Coordinate3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3d, default initialized and not managed by a soap context
        virtual resqml22__Point3d *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3d); }
      public:
        /// Constructor with default initializations
        resqml22__Point3d() : Coordinate1(), Coordinate2(), Coordinate3(), soap() { }
        virtual ~resqml22__Point3d() { }
        /// Friend allocator used by soap_new_resqml22__Point3d(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3d * SOAP_FMAC2 soap_instantiate_resqml22__Point3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:207 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension (-41)
/* complex XML schema type 'resqml22:Point3dLatticeDimension': */
class SOAP_CMAC resqml22__Point3dLatticeDimension {
      public:
        /// Required element 'resqml22:Direction' of XML schema type 'resqml22:Point3d'
        resqml22__Point3d *Direction;
        /// Required element 'resqml22:Spacing' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *Spacing;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dLatticeDimension, default initialized and not managed by a soap context
        virtual resqml22__Point3dLatticeDimension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dLatticeDimension); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dLatticeDimension() : Direction(), Spacing(), soap() { }
        virtual ~resqml22__Point3dLatticeDimension() { }
        /// Friend allocator used by soap_new_resqml22__Point3dLatticeDimension(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dLatticeDimension * SOAP_FMAC2 soap_instantiate_resqml22__Point3dLatticeDimension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:217 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d (-46)
/* complex XML schema type 'resqml22:ThreePoint3d': */
class SOAP_CMAC resqml22__ThreePoint3d {
      public:
        /// Sequence of 3 to 3 elements 'resqml22:Point3d' of XML schema type 'resqml22:Point3d'
        std::vector<resqml22__Point3d *> Point3d;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ThreePoint3d, default initialized and not managed by a soap context
        virtual resqml22__ThreePoint3d *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ThreePoint3d); }
      public:
        /// Constructor with default initializations
        resqml22__ThreePoint3d() : Point3d(), soap() { }
        virtual ~resqml22__ThreePoint3d() { }
        /// Friend allocator used by soap_new_resqml22__ThreePoint3d(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ThreePoint3d * SOAP_FMAC2 soap_instantiate_resqml22__ThreePoint3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:221 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates (-48)
/* complex XML schema type 'resqml22:AbstractSeismicCoordinates': */
class SOAP_CMAC resqml22__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml22:SeismicSupport' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SeismicSupport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSeismicCoordinates, default initialized and not managed by a soap context
        virtual resqml22__AbstractSeismicCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSeismicCoordinates); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSeismicCoordinates() : SeismicSupport(), soap() { }
        virtual ~resqml22__AbstractSeismicCoordinates() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSeismicCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSeismicCoordinates * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSeismicCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:245 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact (-60)
/* complex XML schema type 'resqml22:AbstractSurfaceFrameworkContact': */
class SOAP_CMAC resqml22__AbstractSurfaceFrameworkContact {
      public:
        /// Required element 'resqml22:Index' of XML schema type 'eml23:NonNegativeLong'
        LONG64 Index;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSurfaceFrameworkContact, default initialized and not managed by a soap context
        virtual resqml22__AbstractSurfaceFrameworkContact *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSurfaceFrameworkContact); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSurfaceFrameworkContact() : Index(), soap() { }
        virtual ~resqml22__AbstractSurfaceFrameworkContact() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSurfaceFrameworkContact(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSurfaceFrameworkContact * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSurfaceFrameworkContact(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:251 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity (-63)
/* complex XML schema type 'resqml22:ContactIdentity': */
class SOAP_CMAC resqml22__ContactIdentity {
      public:
        /// Required element 'resqml22:IdentityKind' of XML schema type 'resqml22:IdentityKind'
        resqml22__IdentityKind IdentityKind;
        /// Required element 'resqml22:ContactIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ContactIndices;
        /// Optional element 'resqml22:IdenticalNodeIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *IdenticalNodeIndices;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContactIdentity, default initialized and not managed by a soap context
        virtual resqml22__ContactIdentity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContactIdentity); }
      public:
        /// Constructor with default initializations
        resqml22__ContactIdentity() : IdentityKind(), ContactIndices(), IdenticalNodeIndices(), soap() { }
        virtual ~resqml22__ContactIdentity() { }
        /// Friend allocator used by soap_new_resqml22__ContactIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContactIdentity * SOAP_FMAC2 soap_instantiate_resqml22__ContactIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:265 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries (-70)
/* complex XML schema type 'resqml22:PatchBoundaries': */
class SOAP_CMAC resqml22__PatchBoundaries {
      public:
        /// Required element 'resqml22:ReferencedPatch' of XML schema type 'eml23:NonNegativeLong'
        LONG64 ReferencedPatch;
        /// Optional element 'resqml22:InnerRing' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> InnerRing;
        /// Optional element 'resqml22:OuterRing' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *OuterRing;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PatchBoundaries, default initialized and not managed by a soap context
        virtual resqml22__PatchBoundaries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PatchBoundaries); }
      public:
        /// Constructor with default initializations
        resqml22__PatchBoundaries() : ReferencedPatch(), InnerRing(), OuterRing(), soap() { }
        virtual ~resqml22__PatchBoundaries() { }
        /// Friend allocator used by soap_new_resqml22__PatchBoundaries(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PatchBoundaries * SOAP_FMAC2 soap_instantiate_resqml22__PatchBoundaries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:285 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion (-80)
/* complex XML schema type 'resqml22:VolumeRegion': */
class SOAP_CMAC resqml22__VolumeRegion {
      public:
        /// Optional element 'resqml22:InternalShells' of XML schema type 'resqml22:VolumeShell'
        std::vector<resqml22__VolumeShell *> InternalShells;
        /// Required element 'resqml22:ExternalShell' of XML schema type 'resqml22:VolumeShell'
        resqml22__VolumeShell *ExternalShell;
        /// Required element 'resqml22:Represents' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Represents;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__VolumeRegion, default initialized and not managed by a soap context
        virtual resqml22__VolumeRegion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__VolumeRegion); }
      public:
        /// Constructor with default initializations
        resqml22__VolumeRegion() : InternalShells(), ExternalShell(), Represents(), soap() { }
        virtual ~resqml22__VolumeRegion() { }
        /// Friend allocator used by soap_new_resqml22__VolumeRegion(struct soap*, int)
        friend SOAP_FMAC1 resqml22__VolumeRegion * SOAP_FMAC2 soap_instantiate_resqml22__VolumeRegion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:287 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell (-81)
/* complex XML schema type 'resqml22:VolumeShell': */
class SOAP_CMAC resqml22__VolumeShell {
      public:
        /// Required element 'resqml22:PatchIndicesOfRepresentation' of XML schema type 'eml23:IntegerExternalArray'
        eml23__IntegerExternalArray *PatchIndicesOfRepresentation;
        /// Required element 'resqml22:RepresentationIndices' of XML schema type 'eml23:IntegerExternalArray'
        eml23__IntegerExternalArray *RepresentationIndices;
        /// Required element 'resqml22:SideIsPlus' of XML schema type 'eml23:BooleanExternalArray'
        eml23__BooleanExternalArray *SideIsPlus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__VolumeShell, default initialized and not managed by a soap context
        virtual resqml22__VolumeShell *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__VolumeShell); }
      public:
        /// Constructor with default initializations
        resqml22__VolumeShell() : PatchIndicesOfRepresentation(), RepresentationIndices(), SideIsPlus(), soap() { }
        virtual ~resqml22__VolumeShell() { }
        /// Friend allocator used by soap_new_resqml22__VolumeShell(struct soap*, int)
        friend SOAP_FMAC1 resqml22__VolumeShell * SOAP_FMAC2 soap_instantiate_resqml22__VolumeShell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:289 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart (-82)
/* complex XML schema type 'resqml22:AbstractContactInterpretationPart': */
class SOAP_CMAC resqml22__AbstractContactInterpretationPart {
      public:
        /// Optional element 'resqml22:PartOf' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *PartOf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml22__AbstractContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractContactInterpretationPart); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractContactInterpretationPart() : PartOf(), soap() { }
        virtual ~resqml22__AbstractContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml22__AbstractContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml22__AbstractContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:297 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval (-86)
/* complex XML schema type 'resqml22:AbstractTimeInterval': */
class SOAP_CMAC resqml22__AbstractTimeInterval {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractTimeInterval, default initialized and not managed by a soap context
        virtual resqml22__AbstractTimeInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractTimeInterval); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractTimeInterval() : soap() { }
        virtual ~resqml22__AbstractTimeInterval() { }
        /// Friend allocator used by soap_new_resqml22__AbstractTimeInterval(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractTimeInterval * SOAP_FMAC2 soap_instantiate_resqml22__AbstractTimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:303 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank (-89)
/* complex XML schema type 'resqml22:BoundaryFeatureInterpretationPlusItsRank': */
class SOAP_CMAC resqml22__BoundaryFeatureInterpretationPlusItsRank {
      public:
        /// Optional element 'resqml22:StratigraphicRank' of XML schema type 'eml23:NonNegativeLong'
        LONG64 *StratigraphicRank;
        /// Optional element 'resqml22:BoundaryFeatureInterpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *BoundaryFeatureInterpretation;
        /// Optional element 'resqml22:FeatureInterpretationSet' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *FeatureInterpretationSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BoundaryFeatureInterpretationPlusItsRank, default initialized and not managed by a soap context
        virtual resqml22__BoundaryFeatureInterpretationPlusItsRank *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BoundaryFeatureInterpretationPlusItsRank); }
      public:
        /// Constructor with default initializations
        resqml22__BoundaryFeatureInterpretationPlusItsRank() : StratigraphicRank(), BoundaryFeatureInterpretation(), FeatureInterpretationSet(), soap() { }
        virtual ~resqml22__BoundaryFeatureInterpretationPlusItsRank() { }
        /// Friend allocator used by soap_new_resqml22__BoundaryFeatureInterpretationPlusItsRank(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BoundaryFeatureInterpretationPlusItsRank * SOAP_FMAC2 soap_instantiate_resqml22__BoundaryFeatureInterpretationPlusItsRank(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:311 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow (-93)
/* complex XML schema type 'resqml22:FaultThrow': */
class SOAP_CMAC resqml22__FaultThrow {
      public:
        /// Required element 'resqml22:Throw' of XML schema type 'resqml22:ThrowKindExt'
        std::vector<std::string> Throw;
        /// Optional element 'resqml22:HasOccurredDuring' of XML schema type 'resqml22:AbstractTimeInterval'
        resqml22__AbstractTimeInterval *HasOccurredDuring;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__FaultThrow, default initialized and not managed by a soap context
        virtual resqml22__FaultThrow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__FaultThrow); }
      public:
        /// Constructor with default initializations
        resqml22__FaultThrow() : Throw(), HasOccurredDuring(), soap() { }
        virtual ~resqml22__FaultThrow() { }
        /// Friend allocator used by soap_new_resqml22__FaultThrow(struct soap*, int)
        friend SOAP_FMAC1 resqml22__FaultThrow * SOAP_FMAC2 soap_instantiate_resqml22__FaultThrow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:335 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation (-105)
/* complex XML schema type 'resqml22:ReservoirCompartmentUnitInterpretation': */
class SOAP_CMAC resqml22__ReservoirCompartmentUnitInterpretation {
      public:
        /// Sequence of 0 to 3 elements 'resqml22:FluidUnits' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> FluidUnits;
        /// Required element 'resqml22:ReservoirCompartment' of XML schema type 'resqml22:ReservoirCompartmentInterpretation'
        resqml22__ReservoirCompartmentInterpretation *ReservoirCompartment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ReservoirCompartmentUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml22__ReservoirCompartmentUnitInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ReservoirCompartmentUnitInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__ReservoirCompartmentUnitInterpretation() : FluidUnits(), ReservoirCompartment(), soap() { }
        virtual ~resqml22__ReservoirCompartmentUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__ReservoirCompartmentUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ReservoirCompartmentUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__ReservoirCompartmentUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:353 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity (-114)
/* complex XML schema type 'resqml22:ElementIdentity': */
class SOAP_CMAC resqml22__ElementIdentity {
      public:
        /// Optional element 'resqml22:ElementIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ElementIndices;
        /// Required element 'resqml22:IdentityKind' of XML schema type 'resqml22:IdentityKind'
        resqml22__IdentityKind IdentityKind;
        /// Required element 'resqml22:IndexableElement' of XML schema type 'eml23:IndexableElement'
        eml23__IndexableElement IndexableElement;
        /// Optional element 'resqml22:FromTimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *FromTimeIndex;
        /// Required element 'resqml22:Representation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Representation;
        /// Optional element 'resqml22:ToTimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *ToTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ElementIdentity, default initialized and not managed by a soap context
        virtual resqml22__ElementIdentity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ElementIdentity); }
      public:
        /// Constructor with default initializations
        resqml22__ElementIdentity() : ElementIndices(), IdentityKind(), IndexableElement(), FromTimeIndex(), Representation(), ToTimeIndex(), soap() { }
        virtual ~resqml22__ElementIdentity() { }
        /// Friend allocator used by soap_new_resqml22__ElementIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ElementIdentity * SOAP_FMAC2 soap_instantiate_resqml22__ElementIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:355 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices (-115)
/* complex XML schema type 'resqml22:ElementIndices': */
class SOAP_CMAC resqml22__ElementIndices {
      public:
        /// Required element 'resqml22:IndexableElement' of XML schema type 'eml23:IndexableElement'
        eml23__IndexableElement IndexableElement;
        /// Required element 'resqml22:Indices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *Indices;
        /// Optional element 'resqml22:SupportingRepresentationIndex' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *SupportingRepresentationIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ElementIndices, default initialized and not managed by a soap context
        virtual resqml22__ElementIndices *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ElementIndices); }
      public:
        /// Constructor with default initializations
        resqml22__ElementIndices() : IndexableElement(), Indices(), SupportingRepresentationIndex(), soap() { }
        virtual ~resqml22__ElementIndices() { }
        /// Friend allocator used by soap_new_resqml22__ElementIndices(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ElementIndices * SOAP_FMAC2 soap_instantiate_resqml22__ElementIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:359 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary (-117)
/* complex XML schema type 'resqml22:MarkerBoundary': */
class SOAP_CMAC resqml22__MarkerBoundary {
      public:
        /// Optional element 'resqml22:Qualifier' of XML schema type 'xsd:string'
        std::string *Qualifier;
        /// Optional element 'resqml22:MarkerSet' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *MarkerSet;
        /// Optional element 'resqml22:Marker' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Marker;
        /// Optional element 'resqml22:Interpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Interpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__MarkerBoundary, default initialized and not managed by a soap context
        virtual resqml22__MarkerBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__MarkerBoundary); }
      public:
        /// Constructor with default initializations
        resqml22__MarkerBoundary() : Qualifier(), MarkerSet(), Marker(), Interpretation(), soap() { }
        virtual ~resqml22__MarkerBoundary() { }
        /// Friend allocator used by soap_new_resqml22__MarkerBoundary(struct soap*, int)
        friend SOAP_FMAC1 resqml22__MarkerBoundary * SOAP_FMAC2 soap_instantiate_resqml22__MarkerBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:361 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval (-118)
/* complex XML schema type 'resqml22:MarkerInterval': */
class SOAP_CMAC resqml22__MarkerInterval {
      public:
        /// Optional element 'resqml22:Organization' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Organization;
        /// Optional element 'resqml22:Interpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Interpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__MarkerInterval, default initialized and not managed by a soap context
        virtual resqml22__MarkerInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__MarkerInterval); }
      public:
        /// Constructor with default initializations
        resqml22__MarkerInterval() : Organization(), Interpretation(), soap() { }
        virtual ~resqml22__MarkerInterval() { }
        /// Friend allocator used by soap_new_resqml22__MarkerInterval(struct soap*, int)
        friend SOAP_FMAC1 resqml22__MarkerInterval * SOAP_FMAC2 soap_instantiate_resqml22__MarkerInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:363 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d (-119)
/* complex XML schema type 'resqml22:Patch1d': */
class SOAP_CMAC resqml22__Patch1d {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Patch1d, default initialized and not managed by a soap context
        virtual resqml22__Patch1d *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Patch1d); }
      public:
        /// Constructor with default initializations
        resqml22__Patch1d() : Count(), soap() { }
        virtual ~resqml22__Patch1d() { }
        /// Friend allocator used by soap_new_resqml22__Patch1d(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Patch1d * SOAP_FMAC2 soap_instantiate_resqml22__Patch1d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:365 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch (-120)
/* complex XML schema type 'resqml22:PolylineSetPatch': */
class SOAP_CMAC resqml22__PolylineSetPatch {
      public:
        /// Required element 'resqml22:NodeCount' of XML schema type 'eml23:PositiveLong'
        LONG64 NodeCount;
        /// Required element 'resqml22:IntervalCount' of XML schema type 'eml23:NonNegativeLong'
        LONG64 IntervalCount;
        /// Required element 'resqml22:NodeCountPerPolyline' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *NodeCountPerPolyline;
        /// Required element 'resqml22:ClosedPolylines' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *ClosedPolylines;
        /// Optional element 'resqml22:IntervalGridCells' of XML schema type 'resqml22:IntervalGridCells'
        resqml22__IntervalGridCells *IntervalGridCells;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:PointGeometry'
        resqml22__PointGeometry *Geometry;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PolylineSetPatch, default initialized and not managed by a soap context
        virtual resqml22__PolylineSetPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PolylineSetPatch); }
      public:
        /// Constructor with default initializations
        resqml22__PolylineSetPatch() : NodeCount(), IntervalCount(), NodeCountPerPolyline(), ClosedPolylines(), IntervalGridCells(), Geometry(), soap() { }
        virtual ~resqml22__PolylineSetPatch() { }
        /// Friend allocator used by soap_new_resqml22__PolylineSetPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PolylineSetPatch * SOAP_FMAC2 soap_instantiate_resqml22__PolylineSetPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:367 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity (-121)
/* complex XML schema type 'resqml22:RepresentationIdentity': */
class SOAP_CMAC resqml22__RepresentationIdentity {
      public:
        /// Required element 'resqml22:IdenticalElementCount' of XML schema type 'eml23:PositiveLong'
        LONG64 IdenticalElementCount;
        /// Required element 'resqml22:ElementIdentity' of XML schema type 'resqml22:ElementIdentity'
        std::vector<resqml22__ElementIdentity *> ElementIdentity;
        /// Optional element 'resqml22:AdditionalGridTopology' of XML schema type 'resqml22:AdditionalGridTopology'
        resqml22__AdditionalGridTopology *AdditionalGridTopology;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RepresentationIdentity, default initialized and not managed by a soap context
        virtual resqml22__RepresentationIdentity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RepresentationIdentity); }
      public:
        /// Constructor with default initializations
        resqml22__RepresentationIdentity() : IdenticalElementCount(), ElementIdentity(), AdditionalGridTopology(), soap() { }
        virtual ~resqml22__RepresentationIdentity() { }
        /// Friend allocator used by soap_new_resqml22__RepresentationIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RepresentationIdentity * SOAP_FMAC2 soap_instantiate_resqml22__RepresentationIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:389 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow (-132)
/* complex XML schema type 'resqml22:AbstractParentWindow': */
class SOAP_CMAC resqml22__AbstractParentWindow {
      public:
        /// Optional element 'resqml22:CellOverlap' of XML schema type 'resqml22:CellOverlap'
        resqml22__CellOverlap *CellOverlap;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractParentWindow, default initialized and not managed by a soap context
        virtual resqml22__AbstractParentWindow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractParentWindow); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractParentWindow() : CellOverlap(), soap() { }
        virtual ~resqml22__AbstractParentWindow() { }
        /// Friend allocator used by soap_new_resqml22__AbstractParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractParentWindow * SOAP_FMAC2 soap_instantiate_resqml22__AbstractParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:393 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Activation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Activation (-134)
/* complex XML schema type 'resqml22:Activation': */
class SOAP_CMAC resqml22__Activation {
      public:
        /// Required element 'resqml22:ActivationToggleIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ActivationToggleIndices;
        /// Required element 'resqml22:TimeSeries' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Activation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Activation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Activation, default initialized and not managed by a soap context
        virtual resqml22__Activation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Activation); }
      public:
        /// Constructor with default initializations
        resqml22__Activation() : ActivationToggleIndices(), TimeSeries(), soap() { }
        virtual ~resqml22__Activation() { }
        /// Friend allocator used by soap_new_resqml22__Activation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Activation * SOAP_FMAC2 soap_instantiate_resqml22__Activation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:395 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints (-135)
/* complex XML schema type 'resqml22:AdditionalGridPoints': */
class SOAP_CMAC resqml22__AdditionalGridPoints {
      public:
        /// Optional element 'resqml22:RepresentationPatchIndex' of XML schema type 'eml23:NonNegativeLong'
        LONG64 *RepresentationPatchIndex;
        /// Required element 'resqml22:Attachment' of XML schema type 'resqml22:GridGeometryAttachment'
        resqml22__GridGeometryAttachment Attachment;
        /// Required element 'resqml22:Points' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *Points;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AdditionalGridPoints, default initialized and not managed by a soap context
        virtual resqml22__AdditionalGridPoints *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AdditionalGridPoints); }
      public:
        /// Constructor with default initializations
        resqml22__AdditionalGridPoints() : RepresentationPatchIndex(), Attachment(), Points(), soap() { }
        virtual ~resqml22__AdditionalGridPoints() { }
        /// Friend allocator used by soap_new_resqml22__AdditionalGridPoints(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AdditionalGridPoints * SOAP_FMAC2 soap_instantiate_resqml22__AdditionalGridPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:397 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology (-136)
/* complex XML schema type 'resqml22:AdditionalGridTopology': */
class SOAP_CMAC resqml22__AdditionalGridTopology {
      public:
        /// Optional element 'resqml22:SplitEdges' of XML schema type 'resqml22:SplitEdges'
        resqml22__SplitEdges *SplitEdges;
        /// Optional element 'resqml22:SplitNodePatch' of XML schema type 'resqml22:SplitNodePatch'
        resqml22__SplitNodePatch *SplitNodePatch;
        /// Optional element 'resqml22:SplitColumnEdges' of XML schema type 'resqml22:SplitColumnEdges'
        resqml22__SplitColumnEdges *SplitColumnEdges;
        /// Optional element 'resqml22:UnstructuredColumnEdges' of XML schema type 'resqml22:UnstructuredColumnEdges'
        resqml22__UnstructuredColumnEdges *UnstructuredColumnEdges;
        /// Optional element 'resqml22:SplitFaces' of XML schema type 'resqml22:SplitFaces'
        resqml22__SplitFaces *SplitFaces;
        /// Optional element 'resqml22:UnstructuredSubnodeTopology' of XML schema type 'resqml22:UnstructuredSubnodeTopology'
        resqml22__UnstructuredSubnodeTopology *UnstructuredSubnodeTopology;
        /// Optional element 'resqml22:ColumnLayerSubnodeTopology' of XML schema type 'resqml22:ColumnLayerSubnodeTopology'
        resqml22__ColumnLayerSubnodeTopology *ColumnLayerSubnodeTopology;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AdditionalGridTopology, default initialized and not managed by a soap context
        virtual resqml22__AdditionalGridTopology *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AdditionalGridTopology); }
      public:
        /// Constructor with default initializations
        resqml22__AdditionalGridTopology() : SplitEdges(), SplitNodePatch(), SplitColumnEdges(), UnstructuredColumnEdges(), SplitFaces(), UnstructuredSubnodeTopology(), ColumnLayerSubnodeTopology(), soap() { }
        virtual ~resqml22__AdditionalGridTopology() { }
        /// Friend allocator used by soap_new_resqml22__AdditionalGridTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AdditionalGridTopology * SOAP_FMAC2 soap_instantiate_resqml22__AdditionalGridTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:399 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex (-137)
/* complex XML schema type 'resqml22:AlternateCellIndex': */
class SOAP_CMAC resqml22__AlternateCellIndex {
      public:
        /// Required element 'resqml22:CellIndex' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CellIndex;
        /// Required element 'resqml22:GridIndex' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *GridIndex;
        /// Required element 'resqml22:OriginalGrids' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> OriginalGrids;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AlternateCellIndex, default initialized and not managed by a soap context
        virtual resqml22__AlternateCellIndex *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AlternateCellIndex); }
      public:
        /// Constructor with default initializations
        resqml22__AlternateCellIndex() : CellIndex(), GridIndex(), OriginalGrids(), soap() { }
        virtual ~resqml22__AlternateCellIndex() { }
        /// Friend allocator used by soap_new_resqml22__AlternateCellIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AlternateCellIndex * SOAP_FMAC2 soap_instantiate_resqml22__AlternateCellIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:401 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits (-138)
/* complex XML schema type 'resqml22:CellFluidPhaseUnits': */
class SOAP_CMAC resqml22__CellFluidPhaseUnits {
      public:
        /// Required element 'resqml22:PhaseUnitIndices' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *PhaseUnitIndices;
        /// Required element 'resqml22:RockFluidOrganizationInterpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *RockFluidOrganizationInterpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CellFluidPhaseUnits, default initialized and not managed by a soap context
        virtual resqml22__CellFluidPhaseUnits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CellFluidPhaseUnits); }
      public:
        /// Constructor with default initializations
        resqml22__CellFluidPhaseUnits() : PhaseUnitIndices(), RockFluidOrganizationInterpretation(), soap() { }
        virtual ~resqml22__CellFluidPhaseUnits() { }
        /// Friend allocator used by soap_new_resqml22__CellFluidPhaseUnits(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CellFluidPhaseUnits * SOAP_FMAC2 soap_instantiate_resqml22__CellFluidPhaseUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:403 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap (-139)
/* complex XML schema type 'resqml22:CellOverlap': */
class SOAP_CMAC resqml22__CellOverlap {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:ParentChildCellPairs' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentChildCellPairs;
        /// Optional element 'resqml22:OverlapVolume' of XML schema type 'resqml22:OverlapVolume'
        resqml22__OverlapVolume *OverlapVolume;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CellOverlap, default initialized and not managed by a soap context
        virtual resqml22__CellOverlap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CellOverlap); }
      public:
        /// Constructor with default initializations
        resqml22__CellOverlap() : Count(), ParentChildCellPairs(), OverlapVolume(), soap() { }
        virtual ~resqml22__CellOverlap() { }
        /// Friend allocator used by soap_new_resqml22__CellOverlap(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CellOverlap * SOAP_FMAC2 soap_instantiate_resqml22__CellOverlap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:407 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid (-141)
/* complex XML schema type 'resqml22:ColumnLayerGpGrid': */
class SOAP_CMAC resqml22__ColumnLayerGpGrid {
      public:
        /// Required element 'resqml22:Nk' of XML schema type 'eml23:NonNegativeLong'
        LONG64 Nk;
        /// Optional element 'resqml22:KGaps' of XML schema type 'resqml22:KGaps'
        resqml22__KGaps *KGaps;
        /// Optional element 'resqml22:IjkGpGridPatch' of XML schema type 'resqml22:IjkGpGridPatch'
        std::vector<resqml22__IjkGpGridPatch *> IjkGpGridPatch;
        /// Optional element 'resqml22:UnstructuredColumnLayerGpGridPatch' of XML schema type 'resqml22:UnstructuredColumnLayerGpGridPatch'
        std::vector<resqml22__UnstructuredColumnLayerGpGridPatch *> UnstructuredColumnLayerGpGridPatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColumnLayerGpGrid, default initialized and not managed by a soap context
        virtual resqml22__ColumnLayerGpGrid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColumnLayerGpGrid); }
      public:
        /// Constructor with default initializations
        resqml22__ColumnLayerGpGrid() : Nk(), KGaps(), IjkGpGridPatch(), UnstructuredColumnLayerGpGridPatch(), soap() { }
        virtual ~resqml22__ColumnLayerGpGrid() { }
        /// Friend allocator used by soap_new_resqml22__ColumnLayerGpGrid(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColumnLayerGpGrid * SOAP_FMAC2 soap_instantiate_resqml22__ColumnLayerGpGrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:411 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines (-143)
/* complex XML schema type 'resqml22:ColumnLayerSplitCoordinateLines': */
class SOAP_CMAC resqml22__ColumnLayerSplitCoordinateLines {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:PillarIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *PillarIndices;
        /// Required element 'resqml22:ColumnsPerSplitCoordinateLine' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *ColumnsPerSplitCoordinateLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColumnLayerSplitCoordinateLines, default initialized and not managed by a soap context
        virtual resqml22__ColumnLayerSplitCoordinateLines *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColumnLayerSplitCoordinateLines); }
      public:
        /// Constructor with default initializations
        resqml22__ColumnLayerSplitCoordinateLines() : Count(), PillarIndices(), ColumnsPerSplitCoordinateLine(), soap() { }
        virtual ~resqml22__ColumnLayerSplitCoordinateLines() { }
        /// Friend allocator used by soap_new_resqml22__ColumnLayerSplitCoordinateLines(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColumnLayerSplitCoordinateLines * SOAP_FMAC2 soap_instantiate_resqml22__ColumnLayerSplitCoordinateLines(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:417 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations (-146)
/* complex XML schema type 'resqml22:ConnectionInterpretations': */
class SOAP_CMAC resqml22__ConnectionInterpretations {
      public:
        /// Required element 'resqml22:InterpretationIndices' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *InterpretationIndices;
        /// Required element 'resqml22:FeatureInterpretation' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> FeatureInterpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ConnectionInterpretations, default initialized and not managed by a soap context
        virtual resqml22__ConnectionInterpretations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ConnectionInterpretations); }
      public:
        /// Constructor with default initializations
        resqml22__ConnectionInterpretations() : InterpretationIndices(), FeatureInterpretation(), soap() { }
        virtual ~resqml22__ConnectionInterpretations() { }
        /// Friend allocator used by soap_new_resqml22__ConnectionInterpretations(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ConnectionInterpretations * SOAP_FMAC2 soap_instantiate_resqml22__ConnectionInterpretations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:419 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Edges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Edges (-147)
/* complex XML schema type 'resqml22:Edges': */
class SOAP_CMAC resqml22__Edges {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:NodesPerEdge' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *NodesPerEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Edges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Edges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Edges, default initialized and not managed by a soap context
        virtual resqml22__Edges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Edges); }
      public:
        /// Constructor with default initializations
        resqml22__Edges() : Count(), NodesPerEdge(), soap() { }
        virtual ~resqml22__Edges() { }
        /// Friend allocator used by soap_new_resqml22__Edges(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Edges * SOAP_FMAC2 soap_instantiate_resqml22__Edges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:427 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps (-151)
/* complex XML schema type 'resqml22:IjGaps': */
class SOAP_CMAC resqml22__IjGaps {
      public:
        /// Required element 'resqml22:SplitPillarCount' of XML schema type 'eml23:PositiveLong'
        LONG64 SplitPillarCount;
        /// Required element 'resqml22:ParentPillarIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentPillarIndices;
        /// Required element 'resqml22:ColumnsPerSplitPillar' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *ColumnsPerSplitPillar;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IjGaps, default initialized and not managed by a soap context
        virtual resqml22__IjGaps *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IjGaps); }
      public:
        /// Constructor with default initializations
        resqml22__IjGaps() : SplitPillarCount(), ParentPillarIndices(), ColumnsPerSplitPillar(), soap() { }
        virtual ~resqml22__IjGaps() { }
        /// Friend allocator used by soap_new_resqml22__IjGaps(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IjGaps * SOAP_FMAC2 soap_instantiate_resqml22__IjGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:429 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch (-152)
/* complex XML schema type 'resqml22:IjkGpGridPatch': */
class SOAP_CMAC resqml22__IjkGpGridPatch {
      public:
        /// Required element 'resqml22:Ni' of XML schema type 'eml23:NonNegativeLong'
        LONG64 Ni;
        /// Required element 'resqml22:Nj' of XML schema type 'eml23:NonNegativeLong'
        LONG64 Nj;
        /// Optional element 'resqml22:RadialGridIsComplete' of XML schema type 'xsd:boolean'
        bool *RadialGridIsComplete;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:IjkGridGeometry'
        resqml22__IjkGridGeometry *Geometry;
        /// Optional element 'resqml22:TruncationCellPatch' of XML schema type 'resqml22:TruncationCellPatch'
        resqml22__TruncationCellPatch *TruncationCellPatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IjkGpGridPatch, default initialized and not managed by a soap context
        virtual resqml22__IjkGpGridPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IjkGpGridPatch); }
      public:
        /// Constructor with default initializations
        resqml22__IjkGpGridPatch() : Ni(), Nj(), RadialGridIsComplete(), Geometry(), TruncationCellPatch(), soap() { }
        virtual ~resqml22__IjkGpGridPatch() { }
        /// Friend allocator used by soap_new_resqml22__IjkGpGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IjkGpGridPatch * SOAP_FMAC2 soap_instantiate_resqml22__IjkGpGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:437 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells (-156)
/* complex XML schema type 'resqml22:IntervalGridCells': */
class SOAP_CMAC resqml22__IntervalGridCells {
      public:
        /// Required element 'resqml22:CellCount' of XML schema type 'eml23:PositiveLong'
        LONG64 CellCount;
        /// Required element 'resqml22:GridIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *GridIndices;
        /// Required element 'resqml22:CellIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CellIndices;
        /// Required element 'resqml22:LocalFacePairPerCellIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *LocalFacePairPerCellIndices;
        /// Required element 'resqml22:Grid' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Grid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IntervalGridCells, default initialized and not managed by a soap context
        virtual resqml22__IntervalGridCells *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IntervalGridCells); }
      public:
        /// Constructor with default initializations
        resqml22__IntervalGridCells() : CellCount(), GridIndices(), CellIndices(), LocalFacePairPerCellIndices(), Grid(), soap() { }
        virtual ~resqml22__IntervalGridCells() { }
        /// Friend allocator used by soap_new_resqml22__IntervalGridCells(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IntervalGridCells * SOAP_FMAC2 soap_instantiate_resqml22__IntervalGridCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:439 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals (-157)
/* complex XML schema type 'resqml22:Intervals': */
class SOAP_CMAC resqml22__Intervals {
      public:
        /// Optional element 'resqml22:ChildCellWeights' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *ChildCellWeights;
        /// Required element 'resqml22:ChildCountPerInterval' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ChildCountPerInterval;
        /// Required element 'resqml22:IntervalCount' of XML schema type 'eml23:PositiveLong'
        LONG64 IntervalCount;
        /// Required element 'resqml22:ParentCountPerInterval' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentCountPerInterval;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Intervals, default initialized and not managed by a soap context
        virtual resqml22__Intervals *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Intervals); }
      public:
        /// Constructor with default initializations
        resqml22__Intervals() : ChildCellWeights(), ChildCountPerInterval(), IntervalCount(), ParentCountPerInterval(), soap() { }
        virtual ~resqml22__Intervals() { }
        /// Friend allocator used by soap_new_resqml22__Intervals(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Intervals * SOAP_FMAC2 soap_instantiate_resqml22__Intervals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:441 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits (-158)
/* complex XML schema type 'resqml22:IntervalStratigraphicUnits': */
class SOAP_CMAC resqml22__IntervalStratigraphicUnits {
      public:
        /// Required element 'resqml22:UnitIndices' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *UnitIndices;
        /// Required element 'resqml22:StratigraphicOrganizationInterpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *StratigraphicOrganizationInterpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IntervalStratigraphicUnits, default initialized and not managed by a soap context
        virtual resqml22__IntervalStratigraphicUnits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IntervalStratigraphicUnits); }
      public:
        /// Constructor with default initializations
        resqml22__IntervalStratigraphicUnits() : UnitIndices(), StratigraphicOrganizationInterpretation(), soap() { }
        virtual ~resqml22__IntervalStratigraphicUnits() { }
        /// Friend allocator used by soap_new_resqml22__IntervalStratigraphicUnits(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IntervalStratigraphicUnits * SOAP_FMAC2 soap_instantiate_resqml22__IntervalStratigraphicUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:443 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps
#define SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps (-159)
/* complex XML schema type 'resqml22:KGaps': */
class SOAP_CMAC resqml22__KGaps {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:GapAfterLayer' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *GapAfterLayer;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__KGaps, default initialized and not managed by a soap context
        virtual resqml22__KGaps *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__KGaps); }
      public:
        /// Constructor with default initializations
        resqml22__KGaps() : Count(), GapAfterLayer(), soap() { }
        virtual ~resqml22__KGaps() { }
        /// Friend allocator used by soap_new_resqml22__KGaps(struct soap*, int)
        friend SOAP_FMAC1 resqml22__KGaps * SOAP_FMAC2 soap_instantiate_resqml22__KGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:447 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume
#define SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume (-161)
/* complex XML schema type 'resqml22:OverlapVolume': */
class SOAP_CMAC resqml22__OverlapVolume {
      public:
        /// Required element 'resqml22:OverlapVolumes' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *OverlapVolumes;
        /// Required element 'resqml22:VolumeUom' of XML schema type 'eml23:VolumeUom'
        eml23__VolumeUom VolumeUom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__OverlapVolume, default initialized and not managed by a soap context
        virtual resqml22__OverlapVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__OverlapVolume); }
      public:
        /// Constructor with default initializations
        resqml22__OverlapVolume() : OverlapVolumes(), VolumeUom(), soap() { }
        virtual ~resqml22__OverlapVolume() { }
        /// Friend allocator used by soap_new_resqml22__OverlapVolume(struct soap*, int)
        friend SOAP_FMAC1 resqml22__OverlapVolume * SOAP_FMAC2 soap_instantiate_resqml22__OverlapVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:449 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid (-162)
/* complex XML schema type 'resqml22:Regrid': */
class SOAP_CMAC resqml22__Regrid {
      public:
        /// Required element 'resqml22:InitialIndexOnParentGrid' of XML schema type 'eml23:NonNegativeLong'
        LONG64 InitialIndexOnParentGrid;
        /// Optional element 'resqml22:Intervals' of XML schema type 'resqml22:Intervals'
        resqml22__Intervals *Intervals;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Regrid, default initialized and not managed by a soap context
        virtual resqml22__Regrid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Regrid); }
      public:
        /// Constructor with default initializations
        resqml22__Regrid() : InitialIndexOnParentGrid(), Intervals(), soap() { }
        virtual ~resqml22__Regrid() { }
        /// Friend allocator used by soap_new_resqml22__Regrid(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Regrid * SOAP_FMAC2 soap_instantiate_resqml22__Regrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:451 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges (-163)
/* complex XML schema type 'resqml22:SplitColumnEdges': */
class SOAP_CMAC resqml22__SplitColumnEdges {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:ParentColumnEdgeIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentColumnEdgeIndices;
        /// Required element 'resqml22:ColumnPerSplitColumnEdge' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ColumnPerSplitColumnEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SplitColumnEdges, default initialized and not managed by a soap context
        virtual resqml22__SplitColumnEdges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SplitColumnEdges); }
      public:
        /// Constructor with default initializations
        resqml22__SplitColumnEdges() : Count(), ParentColumnEdgeIndices(), ColumnPerSplitColumnEdge(), soap() { }
        virtual ~resqml22__SplitColumnEdges() { }
        /// Friend allocator used by soap_new_resqml22__SplitColumnEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SplitColumnEdges * SOAP_FMAC2 soap_instantiate_resqml22__SplitColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:453 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges (-164)
/* complex XML schema type 'resqml22:SplitEdges': */
class SOAP_CMAC resqml22__SplitEdges {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:ParentEdgeIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentEdgeIndices;
        /// Required element 'resqml22:FacesPerSplitEdge' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *FacesPerSplitEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SplitEdges, default initialized and not managed by a soap context
        virtual resqml22__SplitEdges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SplitEdges); }
      public:
        /// Constructor with default initializations
        resqml22__SplitEdges() : Count(), ParentEdgeIndices(), FacesPerSplitEdge(), soap() { }
        virtual ~resqml22__SplitEdges() { }
        /// Friend allocator used by soap_new_resqml22__SplitEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SplitEdges * SOAP_FMAC2 soap_instantiate_resqml22__SplitEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:455 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces (-165)
/* complex XML schema type 'resqml22:SplitFaces': */
class SOAP_CMAC resqml22__SplitFaces {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:ParentFaceIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentFaceIndices;
        /// Required element 'resqml22:CellPerSplitFace' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CellPerSplitFace;
        /// Optional element 'resqml22:SplitEdges' of XML schema type 'resqml22:SplitEdges'
        resqml22__SplitEdges *SplitEdges;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SplitFaces, default initialized and not managed by a soap context
        virtual resqml22__SplitFaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SplitFaces); }
      public:
        /// Constructor with default initializations
        resqml22__SplitFaces() : Count(), ParentFaceIndices(), CellPerSplitFace(), SplitEdges(), soap() { }
        virtual ~resqml22__SplitFaces() { }
        /// Friend allocator used by soap_new_resqml22__SplitFaces(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SplitFaces * SOAP_FMAC2 soap_instantiate_resqml22__SplitFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:457 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch (-166)
/* complex XML schema type 'resqml22:SplitNodePatch': */
class SOAP_CMAC resqml22__SplitNodePatch {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:ParentNodeIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentNodeIndices;
        /// Required element 'resqml22:CellsPerSplitNode' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *CellsPerSplitNode;
        /// Optional element 'resqml22:SplitFaces' of XML schema type 'resqml22:SplitFaces'
        resqml22__SplitFaces *SplitFaces;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SplitNodePatch, default initialized and not managed by a soap context
        virtual resqml22__SplitNodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SplitNodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__SplitNodePatch() : Count(), ParentNodeIndices(), CellsPerSplitNode(), SplitFaces(), soap() { }
        virtual ~resqml22__SplitNodePatch() { }
        /// Friend allocator used by soap_new_resqml22__SplitNodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SplitNodePatch * SOAP_FMAC2 soap_instantiate_resqml22__SplitNodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:459 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch (-167)
/* complex XML schema type 'resqml22:SubnodePatch': */
class SOAP_CMAC resqml22__SubnodePatch {
      public:
        /// Required element 'resqml22:SubnodeNodeObject' of XML schema type 'resqml22:SubnodeNodeObject'
        resqml22__SubnodeNodeObject SubnodeNodeObject;
        /// Required element 'resqml22:NodeWeightsPerSubnode' of XML schema type 'eml23:AbstractValueArray'
        eml23__AbstractValueArray *NodeWeightsPerSubnode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SubnodePatch, default initialized and not managed by a soap context
        virtual resqml22__SubnodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SubnodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__SubnodePatch() : SubnodeNodeObject(), NodeWeightsPerSubnode(), soap() { }
        virtual ~resqml22__SubnodePatch() { }
        /// Friend allocator used by soap_new_resqml22__SubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SubnodePatch * SOAP_FMAC2 soap_instantiate_resqml22__SubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:461 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology (-168)
/* complex XML schema type 'resqml22:SubnodeTopology': */
class SOAP_CMAC resqml22__SubnodeTopology {
      public:
        /// Optional element 'resqml22:VariableSubnodePatch' of XML schema type 'resqml22:VariableSubnodePatch'
        std::vector<resqml22__VariableSubnodePatch *> VariableSubnodePatch;
        /// Optional element 'resqml22:UniformSubnodePatch' of XML schema type 'resqml22:UniformSubnodePatch'
        std::vector<resqml22__UniformSubnodePatch *> UniformSubnodePatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SubnodeTopology, default initialized and not managed by a soap context
        virtual resqml22__SubnodeTopology *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SubnodeTopology); }
      public:
        /// Constructor with default initializations
        resqml22__SubnodeTopology() : VariableSubnodePatch(), UniformSubnodePatch(), soap() { }
        virtual ~resqml22__SubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml22__SubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml22__SubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:467 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch (-171)
/* complex XML schema type 'resqml22:TruncationCellPatch': */
class SOAP_CMAC resqml22__TruncationCellPatch {
      public:
        /// Required element 'resqml22:LocalFacesPerCell' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *LocalFacesPerCell;
        /// Required element 'resqml22:NodesPerTruncationFace' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *NodesPerTruncationFace;
        /// Required element 'resqml22:ParentCellIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParentCellIndices;
        /// Required element 'resqml22:TruncationCellCount' of XML schema type 'eml23:PositiveLong'
        LONG64 TruncationCellCount;
        /// Required element 'resqml22:TruncationCellFaceIsRightHanded' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *TruncationCellFaceIsRightHanded;
        /// Required element 'resqml22:TruncationFaceCount' of XML schema type 'eml23:PositiveLong'
        LONG64 TruncationFaceCount;
        /// Required element 'resqml22:TruncationFacesPerCell' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *TruncationFacesPerCell;
        /// Required element 'resqml22:TruncationNodeCount' of XML schema type 'eml23:PositiveLong'
        LONG64 TruncationNodeCount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TruncationCellPatch, default initialized and not managed by a soap context
        virtual resqml22__TruncationCellPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TruncationCellPatch); }
      public:
        /// Constructor with default initializations
        resqml22__TruncationCellPatch() : LocalFacesPerCell(), NodesPerTruncationFace(), ParentCellIndices(), TruncationCellCount(), TruncationCellFaceIsRightHanded(), TruncationFaceCount(), TruncationFacesPerCell(), TruncationNodeCount(), soap() { }
        virtual ~resqml22__TruncationCellPatch() { }
        /// Friend allocator used by soap_new_resqml22__TruncationCellPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TruncationCellPatch * SOAP_FMAC2 soap_instantiate_resqml22__TruncationCellPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:471 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges (-173)
/* complex XML schema type 'resqml22:UnstructuredColumnEdges': */
class SOAP_CMAC resqml22__UnstructuredColumnEdges {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:PillarsPerColumnEdge' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *PillarsPerColumnEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredColumnEdges, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredColumnEdges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredColumnEdges); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredColumnEdges() : Count(), PillarsPerColumnEdge(), soap() { }
        virtual ~resqml22__UnstructuredColumnEdges() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredColumnEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredColumnEdges * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:473 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch (-174)
/* complex XML schema type 'resqml22:UnstructuredColumnLayerGpGridPatch': */
class SOAP_CMAC resqml22__UnstructuredColumnLayerGpGridPatch {
      public:
        /// Required element 'resqml22:UnstructuredColumnCount' of XML schema type 'eml23:NonNegativeLong'
        LONG64 UnstructuredColumnCount;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:UnstructuredColumnLayerGridGeometry'
        resqml22__UnstructuredColumnLayerGridGeometry *Geometry;
        /// Optional element 'resqml22:TruncationCellPatch' of XML schema type 'resqml22:TruncationCellPatch'
        resqml22__TruncationCellPatch *TruncationCellPatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredColumnLayerGpGridPatch, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredColumnLayerGpGridPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredColumnLayerGpGridPatch); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredColumnLayerGpGridPatch() : UnstructuredColumnCount(), Geometry(), TruncationCellPatch(), soap() { }
        virtual ~resqml22__UnstructuredColumnLayerGpGridPatch() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredColumnLayerGpGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredColumnLayerGpGridPatch * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredColumnLayerGpGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:479 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch (-177)
/* complex XML schema type 'resqml22:UnstructuredGpGridPatch': */
class SOAP_CMAC resqml22__UnstructuredGpGridPatch {
      public:
        /// Required element 'resqml22:UnstructuredCellCount' of XML schema type 'eml23:NonNegativeLong'
        LONG64 UnstructuredCellCount;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:UnstructuredGridGeometry'
        resqml22__UnstructuredGridGeometry *Geometry;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredGpGridPatch, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredGpGridPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredGpGridPatch); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredGpGridPatch() : UnstructuredCellCount(), Geometry(), soap() { }
        virtual ~resqml22__UnstructuredGpGridPatch() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredGpGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredGpGridPatch * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredGpGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:483 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces (-179)
/* complex XML schema type 'resqml22:UnstructuredGridHingeNodeFaces': */
class SOAP_CMAC resqml22__UnstructuredGridHingeNodeFaces {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:FaceIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *FaceIndices;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredGridHingeNodeFaces, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredGridHingeNodeFaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredGridHingeNodeFaces); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredGridHingeNodeFaces() : Count(), FaceIndices(), soap() { }
        virtual ~resqml22__UnstructuredGridHingeNodeFaces() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredGridHingeNodeFaces(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredGridHingeNodeFaces * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredGridHingeNodeFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:493 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement (-184)
/* complex XML schema type 'resqml22:AbstractGraphicalInformationForIndexableElement': */
class SOAP_CMAC resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:ActiveAlphaInformationIndex' of XML schema type 'xsd:long'
        LONG64 *ActiveAlphaInformationIndex;
        /// Optional element 'resqml22:ActiveAnnotationInformationIndex' of XML schema type 'xsd:long'
        LONG64 *ActiveAnnotationInformationIndex;
        /// Optional element 'resqml22:ActiveColorInformationIndex' of XML schema type 'xsd:long'
        LONG64 *ActiveColorInformationIndex;
        /// Optional element 'resqml22:ActiveSizeInformationIndex' of XML schema type 'xsd:long'
        LONG64 *ActiveSizeInformationIndex;
        /// Optional element 'resqml22:ConstantAlpha' of XML schema type 'xsd:double'
        double *ConstantAlpha;
        /// Required element 'resqml22:IsVisible' of XML schema type 'xsd:boolean'
        bool IsVisible;
        /// Optional element 'resqml22:OverwriteColorAlpha' of XML schema type 'xsd:boolean'
        bool *OverwriteColorAlpha;
        /// Optional element 'resqml22:ConstantColor' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *ConstantColor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractGraphicalInformationForIndexableElement, default initialized and not managed by a soap context
        virtual resqml22__AbstractGraphicalInformationForIndexableElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractGraphicalInformationForIndexableElement); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractGraphicalInformationForIndexableElement() : ActiveAlphaInformationIndex(), ActiveAnnotationInformationIndex(), ActiveColorInformationIndex(), ActiveSizeInformationIndex(), ConstantAlpha(), IsVisible(), OverwriteColorAlpha(), ConstantColor(), soap() { }
        virtual ~resqml22__AbstractGraphicalInformationForIndexableElement() { }
        /// Friend allocator used by soap_new_resqml22__AbstractGraphicalInformationForIndexableElement(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractGraphicalInformationForIndexableElement * SOAP_FMAC2 soap_instantiate_resqml22__AbstractGraphicalInformationForIndexableElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:505 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry (-190)
/* complex XML schema type 'resqml22:ContinuousColorMapEntry': */
class SOAP_CMAC resqml22__ContinuousColorMapEntry {
      public:
        /// Required element 'resqml22:Index' of XML schema type 'xsd:double'
        double Index;
        /// Required element 'resqml22:Hsv' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *Hsv;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContinuousColorMapEntry, default initialized and not managed by a soap context
        virtual resqml22__ContinuousColorMapEntry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContinuousColorMapEntry); }
      public:
        /// Constructor with default initializations
        resqml22__ContinuousColorMapEntry() : Index(), Hsv(), soap() { }
        virtual ~resqml22__ContinuousColorMapEntry() { }
        /// Friend allocator used by soap_new_resqml22__ContinuousColorMapEntry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContinuousColorMapEntry * SOAP_FMAC2 soap_instantiate_resqml22__ContinuousColorMapEntry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:513 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry (-194)
/* complex XML schema type 'resqml22:DiscreteColorMapEntry': */
class SOAP_CMAC resqml22__DiscreteColorMapEntry {
      public:
        /// Required element 'resqml22:index' of XML schema type 'xsd:long'
        LONG64 index;
        /// Required element 'resqml22:Hsv' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *Hsv;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__DiscreteColorMapEntry, default initialized and not managed by a soap context
        virtual resqml22__DiscreteColorMapEntry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__DiscreteColorMapEntry); }
      public:
        /// Constructor with default initializations
        resqml22__DiscreteColorMapEntry() : index(), Hsv(), soap() { }
        virtual ~resqml22__DiscreteColorMapEntry() { }
        /// Friend allocator used by soap_new_resqml22__DiscreteColorMapEntry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__DiscreteColorMapEntry * SOAP_FMAC2 soap_instantiate_resqml22__DiscreteColorMapEntry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:525 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor (-200)
/* complex XML schema type 'resqml22:HsvColor': */
class SOAP_CMAC resqml22__HsvColor {
      public:
        /// Required element 'resqml22:Alpha' of XML schema type 'xsd:double'
        double Alpha;
        /// Required element 'resqml22:Hue' of XML schema type 'xsd:double'
        double Hue;
        /// Required element 'resqml22:Saturation' of XML schema type 'xsd:double'
        double Saturation;
        /// Optional element 'resqml22:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Required element 'resqml22:Value' of XML schema type 'xsd:double'
        double Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__HsvColor, default initialized and not managed by a soap context
        virtual resqml22__HsvColor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__HsvColor); }
      public:
        /// Constructor with default initializations
        resqml22__HsvColor() : Alpha(), Hue(), Saturation(), Title(), Value(), soap() { }
        virtual ~resqml22__HsvColor() { }
        /// Friend allocator used by soap_new_resqml22__HsvColor(struct soap*, int)
        friend SOAP_FMAC1 resqml22__HsvColor * SOAP_FMAC2 soap_instantiate_resqml22__HsvColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:527 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax (-201)
/* complex XML schema type 'resqml22:MinMax': */
class SOAP_CMAC resqml22__MinMax {
      public:
        /// Required element 'resqml22:Minimum' of XML schema type 'xsd:double'
        double Minimum;
        /// Required element 'resqml22:Maximum' of XML schema type 'xsd:double'
        double Maximum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__MinMax, default initialized and not managed by a soap context
        virtual resqml22__MinMax *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__MinMax); }
      public:
        /// Constructor with default initializations
        resqml22__MinMax() : Minimum(), Maximum(), soap() { }
        virtual ~resqml22__MinMax() { }
        /// Friend allocator used by soap_new_resqml22__MinMax(struct soap*, int)
        friend SOAP_FMAC1 resqml22__MinMax * SOAP_FMAC2 soap_instantiate_resqml22__MinMax(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:553 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores (-214)
/* complex XML schema type 'resqml22:StreamlineWellbores': */
class SOAP_CMAC resqml22__StreamlineWellbores {
      public:
        /// Required element 'resqml22:InjectorPerLine' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *InjectorPerLine;
        /// Required element 'resqml22:ProducerPerLine' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ProducerPerLine;
        /// Required element 'resqml22:WellboreTrajectoryRepresentation' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> WellboreTrajectoryRepresentation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StreamlineWellbores, default initialized and not managed by a soap context
        virtual resqml22__StreamlineWellbores *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StreamlineWellbores); }
      public:
        /// Constructor with default initializations
        resqml22__StreamlineWellbores() : InjectorPerLine(), ProducerPerLine(), WellboreTrajectoryRepresentation(), soap() { }
        virtual ~resqml22__StreamlineWellbores() { }
        /// Friend allocator used by soap_new_resqml22__StreamlineWellbores(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StreamlineWellbores * SOAP_FMAC2 soap_instantiate_resqml22__StreamlineWellbores(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:557 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation (-216)
/* complex XML schema type 'resqml22:CorrectionInformation': */
class SOAP_CMAC resqml22__CorrectionInformation {
      public:
        /// Optional attribute 'CorrectionAverageVelocity' of XML schema type 'xsd:double'
        double CorrectionAverageVelocity;	///< initialized with default value = 0
        /// Optional attribute 'CorrectionTimeShift' of XML schema type 'xsd:double'
        double CorrectionTimeShift;	///< initialized with default value = 0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CorrectionInformation, default initialized and not managed by a soap context
        virtual resqml22__CorrectionInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CorrectionInformation); }
      public:
        /// Constructor with default initializations
        resqml22__CorrectionInformation() : CorrectionAverageVelocity(0), CorrectionTimeShift(0), soap() { }
        virtual ~resqml22__CorrectionInformation() { }
        /// Friend allocator used by soap_new_resqml22__CorrectionInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CorrectionInformation * SOAP_FMAC2 soap_instantiate_resqml22__CorrectionInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:561 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation (-218)
/* complex XML schema type 'resqml22:TvdInformation': */
class SOAP_CMAC resqml22__TvdInformation {
      public:
        /// Required element 'resqml22:NodeTvdValues' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *NodeTvdValues;
        /// Required element 'resqml22:TvdDatum' of XML schema type 'xsd:double'
        double TvdDatum;
        /// Required element 'resqml22:TvdReference' of XML schema type 'eml23:AbstractReferencePoint'
        eml23__AbstractReferencePoint *TvdReference;
        /// Required element 'resqml22:LocalDepth3dCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalDepth3dCrs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TvdInformation, default initialized and not managed by a soap context
        virtual resqml22__TvdInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TvdInformation); }
      public:
        /// Constructor with default initializations
        resqml22__TvdInformation() : NodeTvdValues(), TvdDatum(), TvdReference(), LocalDepth3dCrs(), soap() { }
        virtual ~resqml22__TvdInformation() { }
        /// Friend allocator used by soap_new_resqml22__TvdInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TvdInformation * SOAP_FMAC2 soap_instantiate_resqml22__TvdInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:573 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection (-224)
/* complex XML schema type 'resqml22:WellboreTrajectoryParentIntersection': */
class SOAP_CMAC resqml22__WellboreTrajectoryParentIntersection {
      public:
        /// Required element 'resqml22:KickoffMd' of XML schema type 'xsd:double'
        double KickoffMd;
        /// Optional element 'resqml22:ParentMd' of XML schema type 'xsd:double'
        double *ParentMd;
        /// Required element 'resqml22:ParentTrajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ParentTrajectory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreTrajectoryParentIntersection, default initialized and not managed by a soap context
        virtual resqml22__WellboreTrajectoryParentIntersection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreTrajectoryParentIntersection); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreTrajectoryParentIntersection() : KickoffMd(), ParentMd(), ParentTrajectory(), soap() { }
        virtual ~resqml22__WellboreTrajectoryParentIntersection() { }
        /// Friend allocator used by soap_new_resqml22__WellboreTrajectoryParentIntersection(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreTrajectoryParentIntersection * SOAP_FMAC2 soap_instantiate_resqml22__WellboreTrajectoryParentIntersection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:577 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore (-226)
/* complex XML schema type 'resqml22:WitsmlWellWellbore': */
class SOAP_CMAC resqml22__WitsmlWellWellbore {
      public:
        /// Required element 'resqml22:WitsmlWell' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *WitsmlWell;
        /// Required element 'resqml22:WitsmlWellbore' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *WitsmlWellbore;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WitsmlWellWellbore, default initialized and not managed by a soap context
        virtual resqml22__WitsmlWellWellbore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WitsmlWellWellbore); }
      public:
        /// Constructor with default initializations
        resqml22__WitsmlWellWellbore() : WitsmlWell(), WitsmlWellbore(), soap() { }
        virtual ~resqml22__WitsmlWellWellbore() { }
        /// Friend allocator used by soap_new_resqml22__WitsmlWellWellbore(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WitsmlWellWellbore * SOAP_FMAC2 soap_instantiate_resqml22__WitsmlWellWellbore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:581 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart (-228)
/* complex XML schema type 'eml23:AbstractGrowingObjectPart': */
class SOAP_CMAC eml23__AbstractGrowingObjectPart {
      public:
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm Creation;
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm LastUpdate;
        /// Optional element 'eml23:ExtensionNameValue' of XML schema type 'eml23:ExtensionNameValue'
        eml23__ExtensionNameValue *ExtensionNameValue;
        /// Required attribute 'uid' of XML schema type 'eml23:String64'
        std::string uid;
        /// Optional attribute 'objectVersion' of XML schema type 'eml23:String64'
        std::string *objectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractGrowingObjectPart, default initialized and not managed by a soap context
        virtual eml23__AbstractGrowingObjectPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractGrowingObjectPart); }
      public:
        /// Constructor with default initializations
        eml23__AbstractGrowingObjectPart() : Creation(), LastUpdate(), ExtensionNameValue(), uid(), objectVersion(), soap() { }
        virtual ~eml23__AbstractGrowingObjectPart() { }
        /// Friend allocator used by soap_new_eml23__AbstractGrowingObjectPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractGrowingObjectPart * SOAP_FMAC2 soap_instantiate_eml23__AbstractGrowingObjectPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:587 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject (-231)
/* Type eml23__AbstractObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:AbstractObject': */
class SOAP_CMAC eml23__AbstractObject {
      public:
        /// Optional element 'eml23:Aliases' of XML schema type 'eml23:ObjectAlias'
        std::vector<eml23__ObjectAlias *> Aliases;
        /// Required element 'eml23:Citation' of XML schema type 'eml23:Citation'
        eml23__Citation *Citation;
        /// Optional element 'eml23:Existence' of XML schema type 'eml23:ExistenceKindExt'
        std::string *Existence;
        /// Optional element 'eml23:OSDUIntegration' of XML schema type 'eml23:OSDUIntegration'
        eml23__OSDUIntegration *OSDUIntegration;
        /// Optional element 'eml23:CustomData' of XML schema type 'eml23:CustomData'
        eml23__CustomData *CustomData;
        /// Optional element 'eml23:ExtensionNameValue' of XML schema type 'eml23:ExtensionNameValue'
        std::vector<eml23__ExtensionNameValue *> ExtensionNameValue;
        /// Required attribute 'uuid' of XML schema type 'eml23:UuidString'
        std::string uuid;
        /// Required attribute 'schemaVersion' of XML schema type 'eml23:String64'
        std::string schemaVersion;
        /// Optional attribute 'objectVersion' of XML schema type 'eml23:String64'
        std::string *objectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractObject, default initialized and not managed by a soap context
        virtual eml23__AbstractObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractObject); }
      public:
        /// Constructor with default initializations
        eml23__AbstractObject() : Aliases(), Citation(), Existence(), OSDUIntegration(), CustomData(), ExtensionNameValue(), uuid(), schemaVersion(), objectVersion(), soap() { }
        virtual ~eml23__AbstractObject() { }
        /// Friend allocator used by soap_new_eml23__AbstractObject(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractObject * SOAP_FMAC2 soap_instantiate_eml23__AbstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:593 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Citation
#define SOAP_TYPE_gsoap_eml2_3_eml23__Citation (-234)
/* complex XML schema type 'eml23:Citation': */
class SOAP_CMAC eml23__Citation {
      public:
        /// Required element 'eml23:Title' of XML schema type 'eml23:String256'
        std::string Title;
        /// Required element 'eml23:Originator' of XML schema type 'eml23:String64'
        std::string Originator;
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm Creation;
        /// Required element 'eml23:Format' of XML schema type 'eml23:String2000'
        std::string Format;
        /// Optional element 'eml23:Editor' of XML schema type 'eml23:String64'
        std::string *Editor;
        /// Optional element 'eml23:LastUpdate' of XML schema type 'eml23:TimeStamp'
        struct tm *LastUpdate;
        /// Optional element 'eml23:Description' of XML schema type 'eml23:String2000'
        std::string *Description;
        /// Optional element 'eml23:DescriptiveKeywords' of XML schema type 'eml23:String2000'
        std::string *DescriptiveKeywords;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Citation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Citation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Citation, default initialized and not managed by a soap context
        virtual eml23__Citation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Citation); }
      public:
        /// Constructor with default initializations
        eml23__Citation() : Title(), Originator(), Creation(), Format(), Editor(), LastUpdate(), Description(), DescriptiveKeywords(), soap() { }
        virtual ~eml23__Citation() { }
        /// Friend allocator used by soap_new_eml23__Citation(struct soap*, int)
        friend SOAP_FMAC1 eml23__Citation * SOAP_FMAC2 soap_instantiate_eml23__Citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:595 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CustomData
#define SOAP_TYPE_gsoap_eml2_3_eml23__CustomData (-235)
/* complex XML schema type 'eml23:CustomData': */
class SOAP_CMAC eml23__CustomData {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CustomData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CustomData, default initialized and not managed by a soap context
        virtual eml23__CustomData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CustomData); }
      public:
        /// Constructor with default initializations
        eml23__CustomData() : __any(), soap() { }
        virtual ~eml23__CustomData() { }
        /// Friend allocator used by soap_new_eml23__CustomData(struct soap*, int)
        friend SOAP_FMAC1 eml23__CustomData * SOAP_FMAC2 soap_instantiate_eml23__CustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:597 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue (-236)
/* complex XML schema type 'eml23:ExtensionNameValue': */
class SOAP_CMAC eml23__ExtensionNameValue {
      public:
        /// Required element 'eml23:Name' of XML schema type 'eml23:String64'
        std::string Name;
        /// Required element 'eml23:Value' of XML schema type 'eml23:StringMeasure'
        eml23__StringMeasure *Value;
        /// Optional element 'eml23:MeasureClass' of XML schema type 'eml23:MeasureClass'
        eml23__MeasureClass *MeasureClass;
        /// Optional element 'eml23:DTim' of XML schema type 'eml23:TimeStamp'
        struct tm *DTim;
        /// Optional element 'eml23:Index' of XML schema type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'eml23:Description' of XML schema type 'eml23:String2000'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ExtensionNameValue, default initialized and not managed by a soap context
        virtual eml23__ExtensionNameValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ExtensionNameValue); }
      public:
        /// Constructor with default initializations
        eml23__ExtensionNameValue() : Name(), Value(), MeasureClass(), DTim(), Index(), Description(), soap() { }
        virtual ~eml23__ExtensionNameValue() { }
        /// Friend allocator used by soap_new_eml23__ExtensionNameValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__ExtensionNameValue * SOAP_FMAC2 soap_instantiate_eml23__ExtensionNameValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:599 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias (-237)
/* complex XML schema type 'eml23:ObjectAlias': */
class SOAP_CMAC eml23__ObjectAlias {
      public:
        /// Required element 'eml23:Identifier' of XML schema type 'eml23:String64'
        std::string Identifier;
        /// Optional element 'eml23:Description' of XML schema type 'eml23:String2000'
        std::string *Description;
        /// Required attribute 'authority' of XML schema type 'eml23:String64'
        std::string authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ObjectAlias, default initialized and not managed by a soap context
        virtual eml23__ObjectAlias *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ObjectAlias); }
      public:
        /// Constructor with default initializations
        eml23__ObjectAlias() : Identifier(), Description(), authority(), soap() { }
        virtual ~eml23__ObjectAlias() { }
        /// Friend allocator used by soap_new_eml23__ObjectAlias(struct soap*, int)
        friend SOAP_FMAC1 eml23__ObjectAlias * SOAP_FMAC2 soap_instantiate_eml23__ObjectAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:611 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray (-243)
/* complex XML schema type 'eml23:AbstractValueArray': */
class SOAP_CMAC eml23__AbstractValueArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractValueArray, default initialized and not managed by a soap context
        virtual eml23__AbstractValueArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractValueArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractValueArray() : soap() { }
        virtual ~eml23__AbstractValueArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractValueArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractValueArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:641 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray (-258)
/* complex XML schema type 'eml23:JaggedArray': */
class SOAP_CMAC eml23__JaggedArray {
      public:
        /// Required element 'eml23:Elements' of XML schema type 'eml23:AbstractValueArray'
        eml23__AbstractValueArray *Elements;
        /// Required element 'eml23:CumulativeLength' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CumulativeLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__JaggedArray, default initialized and not managed by a soap context
        virtual eml23__JaggedArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__JaggedArray); }
      public:
        /// Constructor with default initializations
        eml23__JaggedArray() : Elements(), CumulativeLength(), soap() { }
        virtual ~eml23__JaggedArray() { }
        /// Friend allocator used by soap_new_eml23__JaggedArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__JaggedArray * SOAP_FMAC2 soap_instantiate_eml23__JaggedArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:643 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval (-259)
/* complex XML schema type 'eml23:MdInterval': */
class SOAP_CMAC eml23__MdInterval {
      public:
        /// Required element 'eml23:MdTop' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *MdTop;
        /// Required element 'eml23:MdBase' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *MdBase;
        /// Optional element 'eml23:Datum' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Datum;
        /// Optional element 'eml23:Comment' of XML schema type 'eml23:String2000'
        std::string *Comment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MdInterval, default initialized and not managed by a soap context
        virtual eml23__MdInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MdInterval); }
      public:
        /// Constructor with default initializations
        eml23__MdInterval() : MdTop(), MdBase(), Datum(), Comment(), soap() { }
        virtual ~eml23__MdInterval() { }
        /// Friend allocator used by soap_new_eml23__MdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml23__MdInterval * SOAP_FMAC2 soap_instantiate_eml23__MdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:645 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord (-260)
/* complex XML schema type 'eml23:MeasuredDepthCoord': */
class SOAP_CMAC eml23__MeasuredDepthCoord {
      public:
        /// Required element 'eml23:MeasuredDepth' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *MeasuredDepth;
        /// Optional element 'eml23:Datum' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MeasuredDepthCoord, default initialized and not managed by a soap context
        virtual eml23__MeasuredDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MeasuredDepthCoord); }
      public:
        /// Constructor with default initializations
        eml23__MeasuredDepthCoord() : MeasuredDepth(), Datum(), soap() { }
        virtual ~eml23__MeasuredDepthCoord() { }
        /// Friend allocator used by soap_new_eml23__MeasuredDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 eml23__MeasuredDepthCoord * SOAP_FMAC2 soap_instantiate_eml23__MeasuredDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:655 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval (-265)
/* complex XML schema type 'eml23:TvdInterval': */
class SOAP_CMAC eml23__TvdInterval {
      public:
        /// Required element 'eml23:TvdTop' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *TvdTop;
        /// Required element 'eml23:TvdBase' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *TvdBase;
        /// Optional element 'eml23:Datum' of XML schema type 'eml23:AbstractReferencePoint'
        eml23__AbstractReferencePoint *Datum;
        /// Optional element 'eml23:Trajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Trajectory;
        /// Optional element 'eml23:Comment' of XML schema type 'eml23:String2000'
        std::string *Comment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TvdInterval, default initialized and not managed by a soap context
        virtual eml23__TvdInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TvdInterval); }
      public:
        /// Constructor with default initializations
        eml23__TvdInterval() : TvdTop(), TvdBase(), Datum(), Trajectory(), Comment(), soap() { }
        virtual ~eml23__TvdInterval() { }
        /// Friend allocator used by soap_new_eml23__TvdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml23__TvdInterval * SOAP_FMAC2 soap_instantiate_eml23__TvdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:657 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord (-266)
/* complex XML schema type 'eml23:VerticalDepthCoord': */
class SOAP_CMAC eml23__VerticalDepthCoord {
      public:
        /// Required element 'eml23:VerticalDepth' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *VerticalDepth;
        /// Optional element 'eml23:Datum' of XML schema type 'eml23:AbstractReferencePoint'
        eml23__AbstractReferencePoint *Datum;
        /// Optional element 'eml23:Trajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Trajectory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalDepthCoord, default initialized and not managed by a soap context
        virtual eml23__VerticalDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalDepthCoord); }
      public:
        /// Constructor with default initializations
        eml23__VerticalDepthCoord() : VerticalDepth(), Datum(), Trajectory(), soap() { }
        virtual ~eml23__VerticalDepthCoord() { }
        /// Friend allocator used by soap_new_eml23__VerticalDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalDepthCoord * SOAP_FMAC2 soap_instantiate_eml23__VerticalDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:659 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates (-267)
/* complex XML schema type 'eml23:AbstractHorizontalCoordinates': */
class SOAP_CMAC eml23__AbstractHorizontalCoordinates {
      public:
        /// Required element 'eml23:Coordinate1' of XML schema type 'xsd:double'
        double Coordinate1;
        /// Required element 'eml23:Coordinate2' of XML schema type 'xsd:double'
        double Coordinate2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractHorizontalCoordinates, default initialized and not managed by a soap context
        virtual eml23__AbstractHorizontalCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractHorizontalCoordinates); }
      public:
        /// Constructor with default initializations
        eml23__AbstractHorizontalCoordinates() : Coordinate1(), Coordinate2(), soap() { }
        virtual ~eml23__AbstractHorizontalCoordinates() { }
        /// Friend allocator used by soap_new_eml23__AbstractHorizontalCoordinates(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractHorizontalCoordinates * SOAP_FMAC2 soap_instantiate_eml23__AbstractHorizontalCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:665 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates (-270)
/* complex XML schema type 'eml23:HorizontalCoordinates': */
class SOAP_CMAC eml23__HorizontalCoordinates {
      public:
        /// Required element 'eml23:Coordinate1' of XML schema type 'xsd:double'
        double Coordinate1;
        /// Required element 'eml23:Coordinate2' of XML schema type 'xsd:double'
        double Coordinate2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HorizontalCoordinates, default initialized and not managed by a soap context
        virtual eml23__HorizontalCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HorizontalCoordinates); }
      public:
        /// Constructor with default initializations
        eml23__HorizontalCoordinates() : Coordinate1(), Coordinate2(), soap() { }
        virtual ~eml23__HorizontalCoordinates() { }
        /// Friend allocator used by soap_new_eml23__HorizontalCoordinates(struct soap*, int)
        friend SOAP_FMAC1 eml23__HorizontalCoordinates * SOAP_FMAC2 soap_instantiate_eml23__HorizontalCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:679 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference (-277)
/* complex XML schema type 'eml23:DataObjectReference': */
class SOAP_CMAC eml23__DataObjectReference {
      public:
        /// Required element 'eml23:ContentType' of XML schema type 'eml23:String2000'
        std::string ContentType;
        /// Required element 'eml23:Title' of XML schema type 'eml23:String2000'
        std::string Title;
        /// Required element 'eml23:Uuid' of XML schema type 'eml23:UuidString'
        std::string Uuid;
        /// Optional element 'eml23:UuidAuthority' of XML schema type 'eml23:String64'
        std::string *UuidAuthority;
        /// Optional element 'eml23:Uri' of XML schema type 'xsd:anyURI'
        std::string *Uri;
        /// Optional element 'eml23:ObjectVersion' of XML schema type 'eml23:String64'
        std::string *ObjectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataObjectReference, default initialized and not managed by a soap context
        virtual eml23__DataObjectReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataObjectReference); }
      public:
        /// Constructor with default initializations
        eml23__DataObjectReference() : ContentType(), Title(), Uuid(), UuidAuthority(), Uri(), ObjectVersion(), soap() { }
        virtual ~eml23__DataObjectReference() { }
        /// Friend allocator used by soap_new_eml23__DataObjectReference(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataObjectReference * SOAP_FMAC2 soap_instantiate_eml23__DataObjectReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:681 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray (-278)
/* complex XML schema type 'eml23:ExternalDataArray': */
class SOAP_CMAC eml23__ExternalDataArray {
      public:
        /// Required element 'eml23:ExternalDataArrayPart' of XML schema type 'eml23:ExternalDataArrayPart'
        std::vector<eml23__ExternalDataArrayPart *> ExternalDataArrayPart;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ExternalDataArray, default initialized and not managed by a soap context
        virtual eml23__ExternalDataArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ExternalDataArray); }
      public:
        /// Constructor with default initializations
        eml23__ExternalDataArray() : ExternalDataArrayPart(), soap() { }
        virtual ~eml23__ExternalDataArray() { }
        /// Friend allocator used by soap_new_eml23__ExternalDataArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__ExternalDataArray * SOAP_FMAC2 soap_instantiate_eml23__ExternalDataArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:683 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart (-279)
/* complex XML schema type 'eml23:ExternalDataArrayPart': */
class SOAP_CMAC eml23__ExternalDataArrayPart {
      public:
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'eml23:PathInExternalFile' of XML schema type 'eml23:String2000'
        std::string PathInExternalFile;
        /// Required element 'eml23:StartIndex' of XML schema type 'eml23:NonNegativeLong'
        LONG64 StartIndex;
        /// Required element 'eml23:URI' of XML schema type 'eml23:String2000'
        std::string URI;
        /// Optional element 'eml23:MimeType' of XML schema type 'eml23:String2000'
        std::string *MimeType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ExternalDataArrayPart, default initialized and not managed by a soap context
        virtual eml23__ExternalDataArrayPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ExternalDataArrayPart); }
      public:
        /// Constructor with default initializations
        eml23__ExternalDataArrayPart() : Count(), PathInExternalFile(), StartIndex(), URI(), MimeType(), soap() { }
        virtual ~eml23__ExternalDataArrayPart() { }
        /// Friend allocator used by soap_new_eml23__ExternalDataArrayPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__ExternalDataArrayPart * SOAP_FMAC2 soap_instantiate_eml23__ExternalDataArrayPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1421 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs (-648)
/* complex XML schema type 'eml23:AbstractGeodeticCrs': */
class SOAP_CMAC eml23__AbstractGeodeticCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractGeodeticCrs, default initialized and not managed by a soap context
        virtual eml23__AbstractGeodeticCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractGeodeticCrs); }
      public:
        /// Constructor with default initializations
        eml23__AbstractGeodeticCrs() : soap() { }
        virtual ~eml23__AbstractGeodeticCrs() { }
        /// Friend allocator used by soap_new_eml23__AbstractGeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractGeodeticCrs * SOAP_FMAC2 soap_instantiate_eml23__AbstractGeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1423 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs (-649)
/* complex XML schema type 'eml23:AbstractProjectedCrs': */
class SOAP_CMAC eml23__AbstractProjectedCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractProjectedCrs, default initialized and not managed by a soap context
        virtual eml23__AbstractProjectedCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractProjectedCrs); }
      public:
        /// Constructor with default initializations
        eml23__AbstractProjectedCrs() : soap() { }
        virtual ~eml23__AbstractProjectedCrs() { }
        /// Friend allocator used by soap_new_eml23__AbstractProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractProjectedCrs * SOAP_FMAC2 soap_instantiate_eml23__AbstractProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1425 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs (-650)
/* complex XML schema type 'eml23:AbstractVerticalCrs': */
class SOAP_CMAC eml23__AbstractVerticalCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractVerticalCrs, default initialized and not managed by a soap context
        virtual eml23__AbstractVerticalCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractVerticalCrs); }
      public:
        /// Constructor with default initializations
        eml23__AbstractVerticalCrs() : soap() { }
        virtual ~eml23__AbstractVerticalCrs() { }
        /// Friend allocator used by soap_new_eml23__AbstractVerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractVerticalCrs * SOAP_FMAC2 soap_instantiate_eml23__AbstractVerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1437 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes (-656)
/* complex XML schema type 'eml23:HorizontalAxes': */
class SOAP_CMAC eml23__HorizontalAxes {
      public:
        /// Required element 'eml23:Direction1' of XML schema type 'eml23:AxisDirectionKind'
        eml23__AxisDirectionKind Direction1;
        /// Required element 'eml23:Direction2' of XML schema type 'eml23:AxisDirectionKind'
        eml23__AxisDirectionKind Direction2;
        /// Required element 'eml23:Uom' of XML schema type 'eml23:LengthAndTimeUomExt'
        std::string Uom;
        /// Required element 'eml23:IsTime' of XML schema type 'xsd:boolean'
        bool IsTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HorizontalAxes, default initialized and not managed by a soap context
        virtual eml23__HorizontalAxes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HorizontalAxes); }
      public:
        /// Constructor with default initializations
        eml23__HorizontalAxes() : Direction1(), Direction2(), Uom(), IsTime(), soap() { }
        virtual ~eml23__HorizontalAxes() { }
        /// Friend allocator used by soap_new_eml23__HorizontalAxes(struct soap*, int)
        friend SOAP_FMAC1 eml23__HorizontalAxes * SOAP_FMAC2 soap_instantiate_eml23__HorizontalAxes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1451 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem (-663)
/* complex XML schema type 'eml23:PublicLandSurveySystem': */
class SOAP_CMAC eml23__PublicLandSurveySystem {
      public:
        /// Optional element 'eml23:PrincipalMeridian' of XML schema type 'eml23:PrincipalMeridian'
        eml23__PrincipalMeridian *PrincipalMeridian;
        /// Optional element 'eml23:Range' of XML schema type 'xsd:int'
        int *Range;
        /// Optional element 'eml23:RangeDir' of XML schema type 'eml23:EastOrWest'
        eml23__EastOrWest *RangeDir;
        /// Optional element 'eml23:Township' of XML schema type 'xsd:int'
        int *Township;
        /// Optional element 'eml23:TownshipDir' of XML schema type 'eml23:NorthOrSouth'
        eml23__NorthOrSouth *TownshipDir;
        /// Optional element 'eml23:Section' of XML schema type 'eml23:SectionNumber'
        std::string *Section;
        /// Optional element 'eml23:QuarterSection' of XML schema type 'eml23:PublicLandSurveySystemQuarterSection'
        std::string *QuarterSection;
        /// Optional element 'eml23:QuarterTownship' of XML schema type 'eml23:PublicLandSurveySystemQuarterTownship'
        std::string *QuarterTownship;
        /// Required element 'eml23:AxisOrder' of XML schema type 'eml23:AxisOrder2d'
        eml23__AxisOrder2d AxisOrder;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PublicLandSurveySystem, default initialized and not managed by a soap context
        virtual eml23__PublicLandSurveySystem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PublicLandSurveySystem); }
      public:
        /// Constructor with default initializations
        eml23__PublicLandSurveySystem() : PrincipalMeridian(), Range(), RangeDir(), Township(), TownshipDir(), Section(), QuarterSection(), QuarterTownship(), AxisOrder(), soap() { }
        virtual ~eml23__PublicLandSurveySystem() { }
        /// Friend allocator used by soap_new_eml23__PublicLandSurveySystem(struct soap*, int)
        friend SOAP_FMAC1 eml23__PublicLandSurveySystem * SOAP_FMAC2 soap_instantiate_eml23__PublicLandSurveySystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1453 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Vector
#define SOAP_TYPE_gsoap_eml2_3_eml23__Vector (-664)
/* complex XML schema type 'eml23:Vector': */
class SOAP_CMAC eml23__Vector {
      public:
        /// Required element 'eml23:Component1' of XML schema type 'xsd:double'
        double Component1;
        /// Required element 'eml23:Component2' of XML schema type 'xsd:double'
        double Component2;
        /// Required element 'eml23:Component3' of XML schema type 'xsd:double'
        double Component3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Vector
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Vector, default initialized and not managed by a soap context
        virtual eml23__Vector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Vector); }
      public:
        /// Constructor with default initializations
        eml23__Vector() : Component1(), Component2(), Component3(), soap() { }
        virtual ~eml23__Vector() { }
        /// Friend allocator used by soap_new_eml23__Vector(struct soap*, int)
        friend SOAP_FMAC1 eml23__Vector * SOAP_FMAC2 soap_instantiate_eml23__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1455 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis (-665)
/* complex XML schema type 'eml23:VerticalAxis': */
class SOAP_CMAC eml23__VerticalAxis {
      public:
        /// Required element 'eml23:Direction' of XML schema type 'eml23:VerticalDirection'
        eml23__VerticalDirection Direction;
        /// Required element 'eml23:Uom' of XML schema type 'eml23:LengthAndTimeUomExt'
        std::string Uom;
        /// Required element 'eml23:IsTime' of XML schema type 'xsd:boolean'
        bool IsTime;	///< initialized with default value = (bool)0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalAxis, default initialized and not managed by a soap context
        virtual eml23__VerticalAxis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalAxis); }
      public:
        /// Constructor with default initializations
        eml23__VerticalAxis() : Direction(), Uom(), IsTime((bool)0), soap() { }
        virtual ~eml23__VerticalAxis() { }
        /// Friend allocator used by soap_new_eml23__VerticalAxis(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalAxis * SOAP_FMAC2 soap_instantiate_eml23__VerticalAxis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1467 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval (-671)
/* complex XML schema type 'eml23:DateTimeInterval': */
class SOAP_CMAC eml23__DateTimeInterval {
      public:
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm StartTime;
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm EndTime;
        /// Optional element 'eml23:Comment' of XML schema type 'eml23:String2000'
        std::string *Comment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DateTimeInterval, default initialized and not managed by a soap context
        virtual eml23__DateTimeInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DateTimeInterval); }
      public:
        /// Constructor with default initializations
        eml23__DateTimeInterval() : StartTime(), EndTime(), Comment(), soap() { }
        virtual ~eml23__DateTimeInterval() { }
        /// Friend allocator used by soap_new_eml23__DateTimeInterval(struct soap*, int)
        friend SOAP_FMAC1 eml23__DateTimeInterval * SOAP_FMAC2 soap_instantiate_eml23__DateTimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1469 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime (-672)
/* complex XML schema type 'eml23:GeologicTime': */
class SOAP_CMAC eml23__GeologicTime {
      public:
        /// Optional element 'eml23:AgeOffsetAttribute' of XML schema type 'xsd:long'
        LONG64 *AgeOffsetAttribute;
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm DateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeologicTime, default initialized and not managed by a soap context
        virtual eml23__GeologicTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeologicTime); }
      public:
        /// Constructor with default initializations
        eml23__GeologicTime() : AgeOffsetAttribute(), DateTime(), soap() { }
        virtual ~eml23__GeologicTime() { }
        /// Friend allocator used by soap_new_eml23__GeologicTime(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeologicTime * SOAP_FMAC2 soap_instantiate_eml23__GeologicTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1475 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet (-675)
/* complex XML schema type 'eml23:PropertyKindFacet': */
class SOAP_CMAC eml23__PropertyKindFacet {
      public:
        /// Required element 'eml23:Facet' of XML schema type 'eml23:FacetExt'
        std::string Facet;
        /// Required element 'eml23:Kind' of XML schema type 'eml23:FacetKind'
        eml23__FacetKind Kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PropertyKindFacet, default initialized and not managed by a soap context
        virtual eml23__PropertyKindFacet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PropertyKindFacet); }
      public:
        /// Constructor with default initializations
        eml23__PropertyKindFacet() : Facet(), Kind(), soap() { }
        virtual ~eml23__PropertyKindFacet() { }
        /// Friend allocator used by soap_new_eml23__PropertyKindFacet(struct soap*, int)
        friend SOAP_FMAC1 eml23__PropertyKindFacet * SOAP_FMAC2 soap_instantiate_eml23__PropertyKindFacet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1477 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex (-676)
/* complex XML schema type 'eml23:TimeIndex': */
class SOAP_CMAC eml23__TimeIndex {
      public:
        /// Required element 'eml23:Index' of XML schema type 'eml23:NonNegativeLong'
        LONG64 Index;
        /// Required element 'eml23:TimeSeries' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeIndex, default initialized and not managed by a soap context
        virtual eml23__TimeIndex *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeIndex); }
      public:
        /// Constructor with default initializations
        eml23__TimeIndex() : Index(), TimeSeries(), soap() { }
        virtual ~eml23__TimeIndex() { }
        /// Friend allocator used by soap_new_eml23__TimeIndex(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeIndex * SOAP_FMAC2 soap_instantiate_eml23__TimeIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1479 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries (-677)
/* complex XML schema type 'eml23:TimeOrIntervalSeries': */
class SOAP_CMAC eml23__TimeOrIntervalSeries {
      public:
        /// Required element 'eml23:UseInterval' of XML schema type 'xsd:boolean'
        bool UseInterval;
        /// Required element 'eml23:TimeSeries' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeOrIntervalSeries, default initialized and not managed by a soap context
        virtual eml23__TimeOrIntervalSeries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeOrIntervalSeries); }
      public:
        /// Constructor with default initializations
        eml23__TimeOrIntervalSeries() : UseInterval(), TimeSeries(), soap() { }
        virtual ~eml23__TimeOrIntervalSeries() { }
        /// Friend allocator used by soap_new_eml23__TimeOrIntervalSeries(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeOrIntervalSeries * SOAP_FMAC2 soap_instantiate_eml23__TimeOrIntervalSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1483 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage (-679)
/* complex XML schema type 'eml23:TimeSeriesParentage': */
class SOAP_CMAC eml23__TimeSeriesParentage {
      public:
        /// Required element 'eml23:HasOverlap' of XML schema type 'xsd:boolean'
        bool HasOverlap;
        /// Required element 'eml23:ParentTimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *ParentTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeSeriesParentage, default initialized and not managed by a soap context
        virtual eml23__TimeSeriesParentage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeSeriesParentage); }
      public:
        /// Constructor with default initializations
        eml23__TimeSeriesParentage() : HasOverlap(), ParentTimeIndex(), soap() { }
        virtual ~eml23__TimeSeriesParentage() { }
        /// Friend allocator used by soap_new_eml23__TimeSeriesParentage(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeSeriesParentage * SOAP_FMAC2 soap_instantiate_eml23__TimeSeriesParentage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1485 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration
#define SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration (-680)
/* complex XML schema type 'eml23:OSDUIntegration': */
class SOAP_CMAC eml23__OSDUIntegration {
      public:
        /// Optional element 'eml23:OwnerGroup' of XML schema type 'xsd:string'
        std::vector<std::string> OwnerGroup;
        /// Optional element 'eml23:ViewerGroup' of XML schema type 'xsd:string'
        std::vector<std::string> ViewerGroup;
        /// Optional element 'eml23:LegalTags' of XML schema type 'xsd:string'
        std::vector<std::string> LegalTags;
        /// Optional element 'eml23:OSDUGeoJSON' of XML schema type 'xsd:string'
        std::string *OSDUGeoJSON;
        /// Optional element 'eml23:WGS84Latitude' of XML schema type 'eml23:PlaneAngleMeasure'
        eml23__PlaneAngleMeasure *WGS84Latitude;
        /// Optional element 'eml23:WGS84Longitude' of XML schema type 'eml23:PlaneAngleMeasure'
        eml23__PlaneAngleMeasure *WGS84Longitude;
        /// Required element 'eml23:Field' of XML schema type 'xsd:string'
        std::string Field;
        /// Required element 'eml23:Country' of XML schema type 'xsd:string'
        std::string Country;
        /// Required element 'eml23:State' of XML schema type 'xsd:string'
        std::string State;
        /// Required element 'eml23:County' of XML schema type 'xsd:string'
        std::string County;
        /// Required element 'eml23:City' of XML schema type 'xsd:string'
        std::string City;
        /// Required element 'eml23:Region' of XML schema type 'xsd:string'
        std::string Region;
        /// Required element 'eml23:District' of XML schema type 'xsd:string'
        std::string District;
        /// Required element 'eml23:Block' of XML schema type 'xsd:string'
        std::string Block;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__OSDUIntegration, default initialized and not managed by a soap context
        virtual eml23__OSDUIntegration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__OSDUIntegration); }
      public:
        /// Constructor with default initializations
        eml23__OSDUIntegration() : OwnerGroup(), ViewerGroup(), LegalTags(), OSDUGeoJSON(), WGS84Latitude(), WGS84Longitude(), Field(), Country(), State(), County(), City(), Region(), District(), Block(), soap() { }
        virtual ~eml23__OSDUIntegration() { }
        /// Friend allocator used by soap_new_eml23__OSDUIntegration(struct soap*, int)
        friend SOAP_FMAC1 eml23__OSDUIntegration * SOAP_FMAC2 soap_instantiate_eml23__OSDUIntegration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1487 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter (-681)
/* complex XML schema type 'eml23:AbstractActivityParameter': */
class SOAP_CMAC eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:Title' of XML schema type 'eml23:String2000'
        std::string Title;
        /// Optional element 'eml23:Index' of XML schema type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'eml23:Selection' of XML schema type 'eml23:String2000'
        std::string *Selection;
        /// Required element 'eml23:IsUncertain' of XML schema type 'xsd:boolean'
        bool IsUncertain;
        /// Optional element 'eml23:Key' of XML schema type 'eml23:AbstractParameterKey'
        std::vector<eml23__AbstractParameterKey *> Key;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractActivityParameter, default initialized and not managed by a soap context
        virtual eml23__AbstractActivityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractActivityParameter); }
      public:
        /// Constructor with default initializations
        eml23__AbstractActivityParameter() : Title(), Index(), Selection(), IsUncertain(), Key(), soap() { }
        virtual ~eml23__AbstractActivityParameter() { }
        /// Friend allocator used by soap_new_eml23__AbstractActivityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractActivityParameter * SOAP_FMAC2 soap_instantiate_eml23__AbstractActivityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1489 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey (-682)
/* complex XML schema type 'eml23:AbstractParameterKey': */
class SOAP_CMAC eml23__AbstractParameterKey {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractParameterKey, default initialized and not managed by a soap context
        virtual eml23__AbstractParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractParameterKey); }
      public:
        /// Constructor with default initializations
        eml23__AbstractParameterKey() : soap() { }
        virtual ~eml23__AbstractParameterKey() { }
        /// Friend allocator used by soap_new_eml23__AbstractParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractParameterKey * SOAP_FMAC2 soap_instantiate_eml23__AbstractParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1503 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate (-689)
/* complex XML schema type 'eml23:ParameterTemplate': */
class SOAP_CMAC eml23__ParameterTemplate {
      public:
        /// Optional element 'eml23:AllowedKind' of XML schema type 'eml23:ActivityParameterKind'
        std::vector<eml23__ActivityParameterKind> AllowedKind;
        /// Required element 'eml23:IsInput' of XML schema type 'xsd:boolean'
        bool IsInput;
        /// Optional element 'eml23:KeyConstraint' of XML schema type 'eml23:String2000'
        std::vector<std::string> KeyConstraint;
        /// Required element 'eml23:IsOutput' of XML schema type 'xsd:boolean'
        bool IsOutput;
        /// Required element 'eml23:Title' of XML schema type 'eml23:String2000'
        std::string Title;
        /// Optional element 'eml23:DataObjectContentType' of XML schema type 'eml23:String2000'
        std::string *DataObjectContentType;
        /// Required element 'eml23:MaxOccurs' of XML schema type 'xsd:long'
        LONG64 MaxOccurs;
        /// Required element 'eml23:MinOccurs' of XML schema type 'xsd:long'
        LONG64 MinOccurs;
        /// Optional element 'eml23:Constraint' of XML schema type 'eml23:String2000'
        std::string *Constraint;
        /// Optional element 'eml23:DefaultValue' of XML schema type 'eml23:AbstractActivityParameter'
        std::vector<eml23__AbstractActivityParameter *> DefaultValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ParameterTemplate, default initialized and not managed by a soap context
        virtual eml23__ParameterTemplate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ParameterTemplate); }
      public:
        /// Constructor with default initializations
        eml23__ParameterTemplate() : AllowedKind(), IsInput(), KeyConstraint(), IsOutput(), Title(), DataObjectContentType(), MaxOccurs(), MinOccurs(), Constraint(), DefaultValue(), soap() { }
        virtual ~eml23__ParameterTemplate() { }
        /// Friend allocator used by soap_new_eml23__ParameterTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml23__ParameterTemplate * SOAP_FMAC2 soap_instantiate_eml23__ParameterTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1519 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress (-697)
/* complex XML schema type 'eml23:GeneralAddress': */
class SOAP_CMAC eml23__GeneralAddress {
      public:
        /// Optional element 'eml23:Name' of XML schema type 'eml23:String64'
        std::string *Name;
        /// Sequence of 1 to 4 elements 'eml23:Street' of XML schema type 'eml23:String64'
        std::vector<std::string> Street;
        /// Required element 'eml23:City' of XML schema type 'eml23:String64'
        std::string City;
        /// Optional element 'eml23:Country' of XML schema type 'eml23:String64'
        std::string *Country;
        /// Required element 'eml23:County' of XML schema type 'eml23:String64'
        std::string County;
        /// Optional element 'eml23:PostalCode' of XML schema type 'eml23:String64'
        std::string *PostalCode;
        /// Required element 'eml23:State' of XML schema type 'eml23:String64'
        std::string State;
        /// Required element 'eml23:Province' of XML schema type 'eml23:String64'
        std::string Province;
        /// Required attribute 'uid' of XML schema type 'eml23:String64'
        std::string uid;
        /// Optional attribute 'kind' of XML schema type 'eml23:AddressKindEnum'
        eml23__AddressKindEnum *kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeneralAddress, default initialized and not managed by a soap context
        virtual eml23__GeneralAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeneralAddress); }
      public:
        /// Constructor with default initializations
        eml23__GeneralAddress() : Name(), Street(), City(), Country(), County(), PostalCode(), State(), Province(), uid(), kind(), soap() { }
        virtual ~eml23__GeneralAddress() { }
        /// Friend allocator used by soap_new_eml23__GeneralAddress(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeneralAddress * SOAP_FMAC2 soap_instantiate_eml23__GeneralAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1523 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PersonName
#define SOAP_TYPE_gsoap_eml2_3_eml23__PersonName (-699)
/* complex XML schema type 'eml23:PersonName': */
class SOAP_CMAC eml23__PersonName {
      public:
        /// Optional element 'eml23:Prefix' of XML schema type 'eml23:String64'
        std::string *Prefix;
        /// Required element 'eml23:First' of XML schema type 'eml23:String64'
        std::string First;
        /// Optional element 'eml23:Middle' of XML schema type 'eml23:String64'
        std::string *Middle;
        /// Required element 'eml23:Last' of XML schema type 'eml23:String64'
        std::string Last;
        /// Sequence of 0 to 9 elements 'eml23:Suffix' of XML schema type 'eml23:String64'
        std::vector<std::string> Suffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PersonName
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PersonName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PersonName, default initialized and not managed by a soap context
        virtual eml23__PersonName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PersonName); }
      public:
        /// Constructor with default initializations
        eml23__PersonName() : Prefix(), First(), Middle(), Last(), Suffix(), soap() { }
        virtual ~eml23__PersonName() { }
        /// Friend allocator used by soap_new_eml23__PersonName(struct soap*, int)
        friend SOAP_FMAC1 eml23__PersonName * SOAP_FMAC2 soap_instantiate_eml23__PersonName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1525 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct (-700)
/* complex XML schema type 'eml23:PhoneNumberStruct': */
class SOAP_CMAC eml23__PhoneNumberStruct {
      public:
        /// Required attribute 'type' of XML schema type 'eml23:PhoneType'
        eml23__PhoneType type;
        /// Optional attribute 'qualifier' of XML schema type 'eml23:AddressQualifier'
        eml23__AddressQualifier *qualifier;
        /// Optional attribute 'extension' of XML schema type 'eml23:String64'
        std::string *extension;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PhoneNumberStruct, default initialized and not managed by a soap context
        virtual eml23__PhoneNumberStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PhoneNumberStruct); }
      public:
        /// Constructor with default initializations
        eml23__PhoneNumberStruct() : type(), qualifier(), extension(), __mixed(), soap() { }
        virtual ~eml23__PhoneNumberStruct() { }
        /// Friend allocator used by soap_new_eml23__PhoneNumberStruct(struct soap*, int)
        friend SOAP_FMAC1 eml23__PhoneNumberStruct * SOAP_FMAC2 soap_instantiate_eml23__PhoneNumberStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1531 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation
#define SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation (-703)
/* complex XML schema type 'eml23:SingleCollectionAssociation': */
class SOAP_CMAC eml23__SingleCollectionAssociation {
      public:
        /// Optional element 'eml23:HomogeneousDatatype' of XML schema type 'xsd:string'
        std::string *HomogeneousDatatype;
        /// Required element 'eml23:Dataobject' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Dataobject;
        /// Required element 'eml23:Collection' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Collection;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SingleCollectionAssociation, default initialized and not managed by a soap context
        virtual eml23__SingleCollectionAssociation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SingleCollectionAssociation); }
      public:
        /// Constructor with default initializations
        eml23__SingleCollectionAssociation() : HomogeneousDatatype(), Dataobject(), Collection(), soap() { }
        virtual ~eml23__SingleCollectionAssociation() { }
        /// Friend allocator used by soap_new_eml23__SingleCollectionAssociation(struct soap*, int)
        friend SOAP_FMAC1 eml23__SingleCollectionAssociation * SOAP_FMAC2 soap_instantiate_eml23__SingleCollectionAssociation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1533 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Column
#define SOAP_TYPE_gsoap_eml2_3_eml23__Column (-704)
/* complex XML schema type 'eml23:Column': */
class SOAP_CMAC eml23__Column {
      public:
        /// Optional element 'eml23:Description' of XML schema type 'eml23:String2000'
        std::string *Description;
        /// Optional element 'eml23:Title' of XML schema type 'eml23:String64'
        std::string *Title;
        /// Optional element 'eml23:Uom' of XML schema type 'eml23:UnitOfMeasureExt'
        std::string *Uom;
        /// Required element 'eml23:ValueCountPerRow' of XML schema type 'eml23:PositiveLong'
        LONG64 ValueCountPerRow;	///< initialized with default value = 1LL
        /// Required element 'eml23:PropertyKind' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *PropertyKind;
        /// Required element 'eml23:Values' of XML schema type 'eml23:AbstractValueArray'
        eml23__AbstractValueArray *Values;
        /// Optional element 'eml23:Aliases' of XML schema type 'eml23:ObjectAlias'
        std::vector<eml23__ObjectAlias *> Aliases;
        /// Optional element 'eml23:Facet' of XML schema type 'eml23:PropertyKindFacet'
        std::vector<eml23__PropertyKindFacet *> Facet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Column
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Column; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Column, default initialized and not managed by a soap context
        virtual eml23__Column *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Column); }
      public:
        /// Constructor with default initializations
        eml23__Column() : Description(), Title(), Uom(), ValueCountPerRow(1LL), PropertyKind(), Values(), Aliases(), Facet(), soap() { }
        virtual ~eml23__Column() { }
        /// Friend allocator used by soap_new_eml23__Column(struct soap*, int)
        friend SOAP_FMAC1 eml23__Column * SOAP_FMAC2 soap_instantiate_eml23__Column(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1537 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable (-706)
/* complex XML schema type 'eml23:NestedColumnBasedTable': */
class SOAP_CMAC eml23__NestedColumnBasedTable {
      public:
        /// Required element 'eml23:Title' of XML schema type 'eml23:String256'
        std::string Title;
        /// Optional element 'eml23:Description' of XML schema type 'eml23:String2000'
        std::string *Description;
        /// Optional element 'eml23:KeyColumn' of XML schema type 'eml23:Column'
        std::vector<eml23__Column *> KeyColumn;
        /// Required element 'eml23:Column' of XML schema type 'eml23:Column'
        std::vector<eml23__Column *> Column;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__NestedColumnBasedTable, default initialized and not managed by a soap context
        virtual eml23__NestedColumnBasedTable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__NestedColumnBasedTable); }
      public:
        /// Constructor with default initializations
        eml23__NestedColumnBasedTable() : Title(), Description(), KeyColumn(), Column(), soap() { }
        virtual ~eml23__NestedColumnBasedTable() { }
        /// Friend allocator used by soap_new_eml23__NestedColumnBasedTable(struct soap*, int)
        friend SOAP_FMAC1 eml23__NestedColumnBasedTable * SOAP_FMAC2 soap_instantiate_eml23__NestedColumnBasedTable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1541 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule
#define SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule (-708)
/* complex XML schema type 'eml23:FailingRule': */
class SOAP_CMAC eml23__FailingRule {
      public:
        /// Required element 'eml23:RuleId' of XML schema type 'eml23:String64'
        std::string RuleId;
        /// Optional element 'eml23:RuleName' of XML schema type 'eml23:String2000'
        std::string *RuleName;
        /// Optional element 'eml23:Severity' of XML schema type 'eml23:String64'
        std::string *Severity;
        /// Optional element 'eml23:FailingRuleExtensions' of XML schema type 'eml23:ExtensionNameValue'
        std::vector<eml23__ExtensionNameValue *> FailingRuleExtensions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FailingRule, default initialized and not managed by a soap context
        virtual eml23__FailingRule *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FailingRule); }
      public:
        /// Constructor with default initializations
        eml23__FailingRule() : RuleId(), RuleName(), Severity(), FailingRuleExtensions(), soap() { }
        virtual ~eml23__FailingRule() { }
        /// Friend allocator used by soap_new_eml23__FailingRule(struct soap*, int)
        friend SOAP_FMAC1 eml23__FailingRule * SOAP_FMAC2 soap_instantiate_eml23__FailingRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1543 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange
#define SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange (-709)
/* complex XML schema type 'eml23:IndexRange': */
class SOAP_CMAC eml23__IndexRange {
      public:
        /// Required element 'eml23:IndexMinimum' of XML schema type 'eml23:String64'
        std::string IndexMinimum;
        /// Required element 'eml23:IndexMaximum' of XML schema type 'eml23:String64'
        std::string IndexMaximum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IndexRange, default initialized and not managed by a soap context
        virtual eml23__IndexRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IndexRange); }
      public:
        /// Constructor with default initializations
        eml23__IndexRange() : IndexMinimum(), IndexMaximum(), soap() { }
        virtual ~eml23__IndexRange() { }
        /// Friend allocator used by soap_new_eml23__IndexRange(struct soap*, int)
        friend SOAP_FMAC1 eml23__IndexRange * SOAP_FMAC2 soap_instantiate_eml23__IndexRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1545 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation (-710)
/* complex XML schema type 'eml23:AbstractGraphicalInformation': */
class SOAP_CMAC eml23__AbstractGraphicalInformation {
      public:
        /// Required element 'eml23:TargetObject' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> TargetObject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractGraphicalInformation, default initialized and not managed by a soap context
        virtual eml23__AbstractGraphicalInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractGraphicalInformation); }
      public:
        /// Constructor with default initializations
        eml23__AbstractGraphicalInformation() : TargetObject(), soap() { }
        virtual ~eml23__AbstractGraphicalInformation() { }
        /// Friend allocator used by soap_new_eml23__AbstractGraphicalInformation(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractGraphicalInformation * SOAP_FMAC2 soap_instantiate_eml23__AbstractGraphicalInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1551 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue (-713)
/* complex XML schema type 'eml23:AbstractPressureValue': */
class SOAP_CMAC eml23__AbstractPressureValue {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractPressureValue, default initialized and not managed by a soap context
        virtual eml23__AbstractPressureValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractPressureValue); }
      public:
        /// Constructor with default initializations
        eml23__AbstractPressureValue() : soap() { }
        virtual ~eml23__AbstractPressureValue() { }
        /// Friend allocator used by soap_new_eml23__AbstractPressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractPressureValue * SOAP_FMAC2 soap_instantiate_eml23__AbstractPressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:19862 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__union_AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3__eml23__union_AbstractTemperaturePressure (-1315)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml23__union_AbstractTemperaturePressure
{
};
#endif

/* eml2_3ForGsoap.h:1553 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure (-714)
/* Choice: */
class SOAP_CMAC eml23__AbstractTemperaturePressure {
      public:
        /// Union with union _eml23__union_AbstractTemperaturePressure variant selector __union_AbstractTemperaturePressure set to one of:
        int __union_AbstractTemperaturePressure;
        union _eml23__union_AbstractTemperaturePressure union_AbstractTemperaturePressure;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractTemperaturePressure, default initialized and not managed by a soap context
        virtual eml23__AbstractTemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractTemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml23__AbstractTemperaturePressure() : __union_AbstractTemperaturePressure(), soap() { }
        virtual ~eml23__AbstractTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml23__AbstractTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml23__AbstractTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1555 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue (-715)
/* complex XML schema type 'eml23:DensityValue': */
class SOAP_CMAC eml23__DensityValue {
      public:
        /// Required element 'eml23:Density' of XML schema type 'eml23:MassPerVolumeMeasure'
        eml23__MassPerVolumeMeasure *Density;
        /// Optional element 'eml23:MeasurementPressureTemperature' of XML schema type 'eml23:AbstractTemperaturePressure'
        eml23__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DensityValue, default initialized and not managed by a soap context
        virtual eml23__DensityValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DensityValue); }
      public:
        /// Constructor with default initializations
        eml23__DensityValue() : Density(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml23__DensityValue() { }
        /// Friend allocator used by soap_new_eml23__DensityValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__DensityValue * SOAP_FMAC2 soap_instantiate_eml23__DensityValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1557 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue (-716)
/* complex XML schema type 'eml23:FlowRateValue': */
class SOAP_CMAC eml23__FlowRateValue {
      public:
        /// Required element 'eml23:FlowRate' of XML schema type 'eml23:VolumePerTimeMeasure'
        eml23__VolumePerTimeMeasure *FlowRate;
        /// Optional element 'eml23:MeasurementPressureTemperature' of XML schema type 'eml23:AbstractTemperaturePressure'
        eml23__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FlowRateValue, default initialized and not managed by a soap context
        virtual eml23__FlowRateValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FlowRateValue); }
      public:
        /// Constructor with default initializations
        eml23__FlowRateValue() : FlowRate(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml23__FlowRateValue() { }
        /// Friend allocator used by soap_new_eml23__FlowRateValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__FlowRateValue * SOAP_FMAC2 soap_instantiate_eml23__FlowRateValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1561 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue (-718)
/* complex XML schema type 'eml23:PressureValue': */
class SOAP_CMAC eml23__PressureValue {
      public:
        /// Required element 'eml23:AbstractPressureValue' of XML schema type 'eml23:AbstractPressureValue'
        eml23__AbstractPressureValue *AbstractPressureValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureValue, default initialized and not managed by a soap context
        virtual eml23__PressureValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureValue); }
      public:
        /// Constructor with default initializations
        eml23__PressureValue() : AbstractPressureValue(), soap() { }
        virtual ~eml23__PressureValue() { }
        /// Friend allocator used by soap_new_eml23__PressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureValue * SOAP_FMAC2 soap_instantiate_eml23__PressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1571 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue (-723)
/* complex XML schema type 'eml23:VolumeValue': */
class SOAP_CMAC eml23__VolumeValue {
      public:
        /// Required element 'eml23:Volume' of XML schema type 'eml23:VolumeMeasure'
        eml23__VolumeMeasure *Volume;
        /// Optional element 'eml23:MeasurementPressureTemperature' of XML schema type 'eml23:AbstractTemperaturePressure'
        eml23__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumeValue, default initialized and not managed by a soap context
        virtual eml23__VolumeValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumeValue); }
      public:
        /// Constructor with default initializations
        eml23__VolumeValue() : Volume(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml23__VolumeValue() { }
        /// Friend allocator used by soap_new_eml23__VolumeValue(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumeValue * SOAP_FMAC2 soap_instantiate_eml23__VolumeValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:161 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature (-18)
/* complex XML schema type 'resqml22:AbstractFeature': */
class SOAP_CMAC resqml22__AbstractFeature : public eml23__AbstractObject {
      public:
        /// Required element 'resqml22:IsWellKnown' of XML schema type 'xsd:boolean'
        bool IsWellKnown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractFeature, default initialized and not managed by a soap context
        virtual resqml22__AbstractFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractFeature); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractFeature() : IsWellKnown() { }
        virtual ~resqml22__AbstractFeature() { }
        /// Friend allocator used by soap_new_resqml22__AbstractFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractFeature * SOAP_FMAC2 soap_instantiate_resqml22__AbstractFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:177 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry (-26)
/* complex XML schema type 'resqml22:AbstractParametricLineGeometry': */
class SOAP_CMAC resqml22__AbstractParametricLineGeometry : public resqml22__AbstractGeometry {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractParametricLineGeometry, default initialized and not managed by a soap context
        virtual resqml22__AbstractParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractParametricLineGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractParametricLineGeometry() { }
        virtual ~resqml22__AbstractParametricLineGeometry() { }
        /// Friend allocator used by soap_new_resqml22__AbstractParametricLineGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractParametricLineGeometry * SOAP_FMAC2 soap_instantiate_resqml22__AbstractParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:179 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry (-27)
/* complex XML schema type 'resqml22:AbstractPlaneGeometry': */
class SOAP_CMAC resqml22__AbstractPlaneGeometry : public resqml22__AbstractGeometry {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml22__AbstractPlaneGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractPlaneGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractPlaneGeometry() { }
        virtual ~resqml22__AbstractPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml22__AbstractPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml22__AbstractPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:187 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray (-31)
/* complex XML schema type 'resqml22:ParametricLineArray': */
class SOAP_CMAC resqml22__ParametricLineArray : public resqml22__AbstractParametricLineArray {
      public:
        /// Optional element 'resqml22:ControlPointParameters' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *ControlPointParameters;
        /// Required element 'resqml22:ControlPoints' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *ControlPoints;
        /// Required element 'resqml22:KnotCount' of XML schema type 'eml23:PositiveLong'
        LONG64 KnotCount;
        /// Required element 'resqml22:LineKindIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *LineKindIndices;
        /// Optional element 'resqml22:TangentVectors' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *TangentVectors;
        /// Optional element 'resqml22:ParametricLineIntersections' of XML schema type 'resqml22:ParametricLineIntersections'
        resqml22__ParametricLineIntersections *ParametricLineIntersections;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ParametricLineArray, default initialized and not managed by a soap context
        virtual resqml22__ParametricLineArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ParametricLineArray); }
      public:
        /// Constructor with default initializations
        resqml22__ParametricLineArray() : ControlPointParameters(), ControlPoints(), KnotCount(), LineKindIndices(), TangentVectors(), ParametricLineIntersections() { }
        virtual ~resqml22__ParametricLineArray() { }
        /// Friend allocator used by soap_new_resqml22__ParametricLineArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ParametricLineArray * SOAP_FMAC2 soap_instantiate_resqml22__ParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:191 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray (-33)
/* complex XML schema type 'resqml22:ParametricLineFromRepresentationLatticeArray': */
class SOAP_CMAC resqml22__ParametricLineFromRepresentationLatticeArray : public resqml22__AbstractParametricLineArray {
      public:
        /// Required element 'resqml22:LineIndicesOnSupportingRepresentation' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *LineIndicesOnSupportingRepresentation;
        /// Required element 'resqml22:SupportingRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ParametricLineFromRepresentationLatticeArray, default initialized and not managed by a soap context
        virtual resqml22__ParametricLineFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ParametricLineFromRepresentationLatticeArray); }
      public:
        /// Constructor with default initializations
        resqml22__ParametricLineFromRepresentationLatticeArray() : LineIndicesOnSupportingRepresentation(), SupportingRepresentation() { }
        virtual ~resqml22__ParametricLineFromRepresentationLatticeArray() { }
        /// Friend allocator used by soap_new_resqml22__ParametricLineFromRepresentationLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ParametricLineFromRepresentationLatticeArray * SOAP_FMAC2 soap_instantiate_resqml22__ParametricLineFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:197 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray (-36)
/* Type resqml22__Point2dExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point2dExternalArray': */
class SOAP_CMAC resqml22__Point2dExternalArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Required element 'resqml22:Coordinates' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Coordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point2dExternalArray, default initialized and not managed by a soap context
        virtual resqml22__Point2dExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point2dExternalArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point2dExternalArray() : Coordinates() { }
        virtual ~resqml22__Point2dExternalArray() { }
        /// Friend allocator used by soap_new_resqml22__Point2dExternalArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point2dExternalArray * SOAP_FMAC2 soap_instantiate_resqml22__Point2dExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:201 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray (-38)
/* Type resqml22__Point3dExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point3dExternalArray': */
class SOAP_CMAC resqml22__Point3dExternalArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Required element 'resqml22:Coordinates' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Coordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dExternalArray, default initialized and not managed by a soap context
        virtual resqml22__Point3dExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dExternalArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dExternalArray() : Coordinates() { }
        virtual ~resqml22__Point3dExternalArray() { }
        /// Friend allocator used by soap_new_resqml22__Point3dExternalArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dExternalArray * SOAP_FMAC2 soap_instantiate_resqml22__Point3dExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:203 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray (-39)
/* Type resqml22__Point3dFromRepresentationLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point3dFromRepresentationLatticeArray': */
class SOAP_CMAC resqml22__Point3dFromRepresentationLatticeArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Required element 'resqml22:NodeIndicesOnSupportingRepresentation' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *NodeIndicesOnSupportingRepresentation;
        /// Required element 'resqml22:SupportingRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dFromRepresentationLatticeArray, default initialized and not managed by a soap context
        virtual resqml22__Point3dFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dFromRepresentationLatticeArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dFromRepresentationLatticeArray() : NodeIndicesOnSupportingRepresentation(), SupportingRepresentation() { }
        virtual ~resqml22__Point3dFromRepresentationLatticeArray() { }
        /// Friend allocator used by soap_new_resqml22__Point3dFromRepresentationLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dFromRepresentationLatticeArray * SOAP_FMAC2 soap_instantiate_resqml22__Point3dFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:205 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray (-40)
/* Type resqml22__Point3dLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point3dLatticeArray': */
class SOAP_CMAC resqml22__Point3dLatticeArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Optional element 'resqml22:AllDimensionsAreOrthogonal' of XML schema type 'xsd:boolean'
        bool *AllDimensionsAreOrthogonal;
        /// Required element 'resqml22:Origin' of XML schema type 'resqml22:Point3d'
        resqml22__Point3d *Origin;
        /// Required element 'resqml22:Dimension' of XML schema type 'resqml22:Point3dLatticeDimension'
        std::vector<resqml22__Point3dLatticeDimension *> Dimension;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dLatticeArray, default initialized and not managed by a soap context
        virtual resqml22__Point3dLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dLatticeArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dLatticeArray() : AllDimensionsAreOrthogonal(), Origin(), Dimension() { }
        virtual ~resqml22__Point3dLatticeArray() { }
        /// Friend allocator used by soap_new_resqml22__Point3dLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dLatticeArray * SOAP_FMAC2 soap_instantiate_resqml22__Point3dLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:209 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray (-42)
/* Type resqml22__Point3dParametricArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point3dParametricArray': */
class SOAP_CMAC resqml22__Point3dParametricArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Required element 'resqml22:Parameters' of XML schema type 'eml23:AbstractValueArray'
        eml23__AbstractValueArray *Parameters;
        /// Optional element 'resqml22:ParametricLineIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ParametricLineIndices;
        /// Optional element 'resqml22:TruncatedLineIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *TruncatedLineIndices;
        /// Required element 'resqml22:ParametricLines' of XML schema type 'resqml22:AbstractParametricLineArray'
        resqml22__AbstractParametricLineArray *ParametricLines;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dParametricArray, default initialized and not managed by a soap context
        virtual resqml22__Point3dParametricArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dParametricArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dParametricArray() : Parameters(), ParametricLineIndices(), TruncatedLineIndices(), ParametricLines() { }
        virtual ~resqml22__Point3dParametricArray() { }
        /// Friend allocator used by soap_new_resqml22__Point3dParametricArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dParametricArray * SOAP_FMAC2 soap_instantiate_resqml22__Point3dParametricArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:211 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray (-43)
/* Type resqml22__Point3dZValueArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Point3dZValueArray': */
class SOAP_CMAC resqml22__Point3dZValueArray : public resqml22__AbstractPoint3dArray {
      public:
        /// Required element 'resqml22:SupportingGeometry' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *SupportingGeometry;
        /// Required element 'resqml22:ZValues' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *ZValues;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Point3dZValueArray, default initialized and not managed by a soap context
        virtual resqml22__Point3dZValueArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Point3dZValueArray); }
      public:
        /// Constructor with default initializations
        resqml22__Point3dZValueArray() : SupportingGeometry(), ZValues() { }
        virtual ~resqml22__Point3dZValueArray() { }
        /// Friend allocator used by soap_new_resqml22__Point3dZValueArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Point3dZValueArray * SOAP_FMAC2 soap_instantiate_resqml22__Point3dZValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:213 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry (-44)
/* complex XML schema type 'resqml22:PointGeometry': */
class SOAP_CMAC resqml22__PointGeometry : public resqml22__AbstractGeometry {
      public:
        /// Required element 'resqml22:Points' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *Points;
        /// Optional element 'resqml22:SeismicCoordinates' of XML schema type 'resqml22:AbstractSeismicCoordinates'
        resqml22__AbstractSeismicCoordinates *SeismicCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PointGeometry, default initialized and not managed by a soap context
        virtual resqml22__PointGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PointGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__PointGeometry() : Points(), SeismicCoordinates() { }
        virtual ~resqml22__PointGeometry() { }
        /// Friend allocator used by soap_new_resqml22__PointGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PointGeometry * SOAP_FMAC2 soap_instantiate_resqml22__PointGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:215 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry (-45)
/* complex XML schema type 'resqml22:SinglePointGeometry': */
class SOAP_CMAC resqml22__SinglePointGeometry : public resqml22__AbstractGeometry {
      public:
        /// Required element 'resqml22:Point3d' of XML schema type 'resqml22:Point3d'
        resqml22__Point3d *Point3d;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SinglePointGeometry, default initialized and not managed by a soap context
        virtual resqml22__SinglePointGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SinglePointGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__SinglePointGeometry() : Point3d() { }
        virtual ~resqml22__SinglePointGeometry() { }
        /// Friend allocator used by soap_new_resqml22__SinglePointGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SinglePointGeometry * SOAP_FMAC2 soap_instantiate_resqml22__SinglePointGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:229 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates (-52)
/* complex XML schema type 'resqml22:Seismic2dCoordinates': */
class SOAP_CMAC resqml22__Seismic2dCoordinates : public resqml22__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml22:LineAbscissa' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *LineAbscissa;
        /// Optional element 'resqml22:VerticalCoordinates' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *VerticalCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Seismic2dCoordinates, default initialized and not managed by a soap context
        virtual resqml22__Seismic2dCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Seismic2dCoordinates); }
      public:
        /// Constructor with default initializations
        resqml22__Seismic2dCoordinates() : LineAbscissa(), VerticalCoordinates() { }
        virtual ~resqml22__Seismic2dCoordinates() { }
        /// Friend allocator used by soap_new_resqml22__Seismic2dCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Seismic2dCoordinates * SOAP_FMAC2 soap_instantiate_resqml22__Seismic2dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:233 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates (-54)
/* complex XML schema type 'resqml22:Seismic3dCoordinates': */
class SOAP_CMAC resqml22__Seismic3dCoordinates : public resqml22__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml22:CrosslineCoordinates' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *CrosslineCoordinates;
        /// Required element 'resqml22:InlineCoordinates' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *InlineCoordinates;
        /// Optional element 'resqml22:VerticalCoordinates' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *VerticalCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Seismic3dCoordinates, default initialized and not managed by a soap context
        virtual resqml22__Seismic3dCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Seismic3dCoordinates); }
      public:
        /// Constructor with default initializations
        resqml22__Seismic3dCoordinates() : CrosslineCoordinates(), InlineCoordinates(), VerticalCoordinates() { }
        virtual ~resqml22__Seismic3dCoordinates() { }
        /// Friend allocator used by soap_new_resqml22__Seismic3dCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Seismic3dCoordinates * SOAP_FMAC2 soap_instantiate_resqml22__Seismic3dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:253 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch (-64)
/* complex XML schema type 'resqml22:ContactPatch': */
class SOAP_CMAC resqml22__ContactPatch : public resqml22__Patch1d {
      public:
        /// Required element 'resqml22:RepresentationIndex' of XML schema type 'eml23:NonNegativeLong'
        LONG64 RepresentationIndex;
        /// Required element 'resqml22:SupportingRepresentationNodes' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *SupportingRepresentationNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContactPatch, default initialized and not managed by a soap context
        virtual resqml22__ContactPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContactPatch); }
      public:
        /// Constructor with default initializations
        resqml22__ContactPatch() : RepresentationIndex(), SupportingRepresentationNodes() { }
        virtual ~resqml22__ContactPatch() { }
        /// Friend allocator used by soap_new_resqml22__ContactPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContactPatch * SOAP_FMAC2 soap_instantiate_resqml22__ContactPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:255 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference (-65)
/* complex XML schema type 'resqml22:ContactReference': */
class SOAP_CMAC resqml22__ContactReference : public resqml22__AbstractSurfaceFrameworkContact {
      public:
        /// Required element 'resqml22:Representation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Representation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContactReference, default initialized and not managed by a soap context
        virtual resqml22__ContactReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContactReference); }
      public:
        /// Constructor with default initializations
        resqml22__ContactReference() : Representation() { }
        virtual ~resqml22__ContactReference() { }
        /// Friend allocator used by soap_new_resqml22__ContactReference(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContactReference * SOAP_FMAC2 soap_instantiate_resqml22__ContactReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:257 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch (-66)
/* complex XML schema type 'resqml22:EdgePatch': */
class SOAP_CMAC resqml22__EdgePatch : public resqml22__Patch1d {
      public:
        /// Optional element 'resqml22:SplitEdges' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *SplitEdges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__EdgePatch, default initialized and not managed by a soap context
        virtual resqml22__EdgePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__EdgePatch); }
      public:
        /// Constructor with default initializations
        resqml22__EdgePatch() : SplitEdges() { }
        virtual ~resqml22__EdgePatch() { }
        /// Friend allocator used by soap_new_resqml22__EdgePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__EdgePatch * SOAP_FMAC2 soap_instantiate_resqml22__EdgePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:259 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch (-67)
/* complex XML schema type 'resqml22:NodePatch': */
class SOAP_CMAC resqml22__NodePatch : public resqml22__Patch1d {
      public:
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:PointGeometry'
        resqml22__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__NodePatch, default initialized and not managed by a soap context
        virtual resqml22__NodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__NodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__NodePatch() : Geometry() { }
        virtual ~resqml22__NodePatch() { }
        /// Friend allocator used by soap_new_resqml22__NodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__NodePatch * SOAP_FMAC2 soap_instantiate_resqml22__NodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:261 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact (-68)
/* complex XML schema type 'resqml22:NonSealedContact': */
class SOAP_CMAC resqml22__NonSealedContact : public resqml22__AbstractSurfaceFrameworkContact {
      public:
        /// Optional element 'resqml22:Patches' of XML schema type 'resqml22:ContactPatch'
        std::vector<resqml22__ContactPatch *> Patches;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:AbstractGeometry'
        resqml22__AbstractGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__NonSealedContact, default initialized and not managed by a soap context
        virtual resqml22__NonSealedContact *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__NonSealedContact); }
      public:
        /// Constructor with default initializations
        resqml22__NonSealedContact() : Patches(), Geometry() { }
        virtual ~resqml22__NonSealedContact() { }
        /// Friend allocator used by soap_new_resqml22__NonSealedContact(struct soap*, int)
        friend SOAP_FMAC1 resqml22__NonSealedContact * SOAP_FMAC2 soap_instantiate_resqml22__NonSealedContact(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:275 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact (-75)
/* complex XML schema type 'resqml22:SealedContact': */
class SOAP_CMAC resqml22__SealedContact : public resqml22__AbstractSurfaceFrameworkContact {
      public:
        /// Optional element 'resqml22:IdenticalNodeIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *IdenticalNodeIndices;
        /// Required element 'resqml22:IdentityKind' of XML schema type 'resqml22:IdentityKind'
        resqml22__IdentityKind IdentityKind;
        /// Required element 'resqml22:Patches' of XML schema type 'resqml22:ContactPatch'
        std::vector<resqml22__ContactPatch *> Patches;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SealedContact, default initialized and not managed by a soap context
        virtual resqml22__SealedContact *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SealedContact); }
      public:
        /// Constructor with default initializations
        resqml22__SealedContact() : IdenticalNodeIndices(), IdentityKind(), Patches() { }
        virtual ~resqml22__SealedContact() { }
        /// Friend allocator used by soap_new_resqml22__SealedContact(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SealedContact * SOAP_FMAC2 soap_instantiate_resqml22__SealedContact(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:281 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch (-78)
/* complex XML schema type 'resqml22:TrianglePatch': */
class SOAP_CMAC resqml22__TrianglePatch : public resqml22__Patch1d {
      public:
        /// Required element 'resqml22:NodeCount' of XML schema type 'eml23:NonNegativeLong'
        LONG64 NodeCount;
        /// Required element 'resqml22:Triangles' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *Triangles;
        /// Optional element 'resqml22:SplitEdgePatch' of XML schema type 'resqml22:EdgePatch'
        std::vector<resqml22__EdgePatch *> SplitEdgePatch;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:PointGeometry'
        resqml22__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TrianglePatch, default initialized and not managed by a soap context
        virtual resqml22__TrianglePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TrianglePatch); }
      public:
        /// Constructor with default initializations
        resqml22__TrianglePatch() : NodeCount(), Triangles(), SplitEdgePatch(), Geometry() { }
        virtual ~resqml22__TrianglePatch() { }
        /// Friend allocator used by soap_new_resqml22__TrianglePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TrianglePatch * SOAP_FMAC2 soap_instantiate_resqml22__TrianglePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:291 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation (-83)
/* Type resqml22__AbstractFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractFeatureInterpretation': */
class SOAP_CMAC resqml22__AbstractFeatureInterpretation : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:Domain' of XML schema type 'resqml22:Domain'
        resqml22__Domain *Domain;
        /// Optional element 'resqml22:HasOccurredDuring' of XML schema type 'resqml22:AbstractTimeInterval'
        resqml22__AbstractTimeInterval *HasOccurredDuring;
        /// Required element 'resqml22:InterpretedFeature' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *InterpretedFeature;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml22__AbstractFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractFeatureInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractFeatureInterpretation() : Domain(), HasOccurredDuring(), InterpretedFeature() { }
        virtual ~resqml22__AbstractFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:299 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart (-87)
/* complex XML schema type 'resqml22:BinaryContactInterpretationPart': */
class SOAP_CMAC resqml22__BinaryContactInterpretationPart : public resqml22__AbstractContactInterpretationPart {
      public:
        /// Required element 'resqml22:DirectObject' of XML schema type 'resqml22:ContactElement'
        resqml22__ContactElement *DirectObject;
        /// Required element 'resqml22:Subject' of XML schema type 'resqml22:ContactElement'
        resqml22__ContactElement *Subject;
        /// Required element 'resqml22:Verb' of XML schema type 'resqml22:ContactVerb'
        resqml22__ContactVerb Verb;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BinaryContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml22__BinaryContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BinaryContactInterpretationPart); }
      public:
        /// Constructor with default initializations
        resqml22__BinaryContactInterpretationPart() : DirectObject(), Subject(), Verb() { }
        virtual ~resqml22__BinaryContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml22__BinaryContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BinaryContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml22__BinaryContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:305 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement (-90)
/* complex XML schema type 'resqml22:ContactElement': */
class SOAP_CMAC resqml22__ContactElement : public eml23__DataObjectReference {
      public:
        /// Optional element 'resqml22:Qualifier' of XML schema type 'resqml22:ContactSide'
        resqml22__ContactSide *Qualifier;
        /// Optional element 'resqml22:SecondaryQualifier' of XML schema type 'resqml22:ContactMode'
        resqml22__ContactMode *SecondaryQualifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContactElement, default initialized and not managed by a soap context
        virtual resqml22__ContactElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContactElement); }
      public:
        /// Constructor with default initializations
        resqml22__ContactElement() : Qualifier(), SecondaryQualifier() { }
        virtual ~resqml22__ContactElement() { }
        /// Friend allocator used by soap_new_resqml22__ContactElement(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContactElement * SOAP_FMAC2 soap_instantiate_resqml22__ContactElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:317 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval (-96)
/* complex XML schema type 'resqml22:GeneticBoundaryBasedTimeInterval': */
class SOAP_CMAC resqml22__GeneticBoundaryBasedTimeInterval : public resqml22__AbstractTimeInterval {
      public:
        /// Required element 'resqml22:ChronoBottom' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ChronoBottom;
        /// Required element 'resqml22:ChronoTop' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ChronoTop;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeneticBoundaryBasedTimeInterval, default initialized and not managed by a soap context
        virtual resqml22__GeneticBoundaryBasedTimeInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeneticBoundaryBasedTimeInterval); }
      public:
        /// Constructor with default initializations
        resqml22__GeneticBoundaryBasedTimeInterval() : ChronoBottom(), ChronoTop() { }
        virtual ~resqml22__GeneticBoundaryBasedTimeInterval() { }
        /// Friend allocator used by soap_new_resqml22__GeneticBoundaryBasedTimeInterval(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeneticBoundaryBasedTimeInterval * SOAP_FMAC2 soap_instantiate_resqml22__GeneticBoundaryBasedTimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:323 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval (-99)
/* complex XML schema type 'resqml22:GeologicTimeBasedTimeInterval': */
class SOAP_CMAC resqml22__GeologicTimeBasedTimeInterval : public resqml22__AbstractTimeInterval {
      public:
        /// Required element 'resqml22:Start' of XML schema type 'eml23:GeologicTime'
        eml23__GeologicTime *Start;
        /// Required element 'resqml22:End' of XML schema type 'eml23:GeologicTime'
        eml23__GeologicTime *End;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeologicTimeBasedTimeInterval, default initialized and not managed by a soap context
        virtual resqml22__GeologicTimeBasedTimeInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeologicTimeBasedTimeInterval); }
      public:
        /// Constructor with default initializations
        resqml22__GeologicTimeBasedTimeInterval() : Start(), End() { }
        virtual ~resqml22__GeologicTimeBasedTimeInterval() { }
        /// Friend allocator used by soap_new_resqml22__GeologicTimeBasedTimeInterval(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeologicTimeBasedTimeInterval * SOAP_FMAC2 soap_instantiate_resqml22__GeologicTimeBasedTimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:331 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart (-103)
/* complex XML schema type 'resqml22:MultipleContactInterpretationPart': */
class SOAP_CMAC resqml22__MultipleContactInterpretationPart : public resqml22__AbstractContactInterpretationPart {
      public:
        /// Required element 'resqml22:With' of XML schema type 'eml23:NonNegativeLong'
        std::vector<LONG64> With;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__MultipleContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml22__MultipleContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__MultipleContactInterpretationPart); }
      public:
        /// Constructor with default initializations
        resqml22__MultipleContactInterpretationPart() : With() { }
        virtual ~resqml22__MultipleContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml22__MultipleContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml22__MultipleContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml22__MultipleContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:341 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn (-108)
/* Type resqml22__StratigraphicColumn is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StratigraphicColumn': */
class SOAP_CMAC resqml22__StratigraphicColumn : public eml23__AbstractObject {
      public:
        /// Required element 'resqml22:Ranks' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Ranks;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StratigraphicColumn, default initialized and not managed by a soap context
        virtual resqml22__StratigraphicColumn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StratigraphicColumn); }
      public:
        /// Constructor with default initializations
        resqml22__StratigraphicColumn() : Ranks() { }
        virtual ~resqml22__StratigraphicColumn() { }
        /// Friend allocator used by soap_new_resqml22__StratigraphicColumn(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StratigraphicColumn * SOAP_FMAC2 soap_instantiate_resqml22__StratigraphicColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:351 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation (-113)
/* Type resqml22__AbstractRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractRepresentation': */
class SOAP_CMAC resqml22__AbstractRepresentation : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:RealizationIndex' of XML schema type 'eml23:PositiveLong'
        LONG64 *RealizationIndex;
        /// Optional element 'resqml22:RepresentedObject' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *RepresentedObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractRepresentation() : RealizationIndex(), RepresentedObject() { }
        virtual ~resqml22__AbstractRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:357 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary (-116)
/* complex XML schema type 'resqml22:FluidIntervalBoundary': */
class SOAP_CMAC resqml22__FluidIntervalBoundary : public resqml22__MarkerBoundary {
      public:
        /// Optional element 'resqml22:FluidContactKind' of XML schema type 'xsd:string'
        std::string *FluidContactKind;
        /// Optional element 'resqml22:FluidMarker' of XML schema type 'xsd:string'
        std::string *FluidMarker;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__FluidIntervalBoundary, default initialized and not managed by a soap context
        virtual resqml22__FluidIntervalBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__FluidIntervalBoundary); }
      public:
        /// Constructor with default initializations
        resqml22__FluidIntervalBoundary() : FluidContactKind(), FluidMarker() { }
        virtual ~resqml22__FluidIntervalBoundary() { }
        /// Friend allocator used by soap_new_resqml22__FluidIntervalBoundary(struct soap*, int)
        friend SOAP_FMAC1 resqml22__FluidIntervalBoundary * SOAP_FMAC2 soap_instantiate_resqml22__FluidIntervalBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:369 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet (-122)
/* Type resqml22__RepresentationIdentitySet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:RepresentationIdentitySet': */
class SOAP_CMAC resqml22__RepresentationIdentitySet : public eml23__AbstractObject {
      public:
        /// Required element 'resqml22:RepresentationIdentity' of XML schema type 'resqml22:RepresentationIdentity'
        std::vector<resqml22__RepresentationIdentity *> RepresentationIdentity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RepresentationIdentitySet, default initialized and not managed by a soap context
        virtual resqml22__RepresentationIdentitySet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RepresentationIdentitySet); }
      public:
        /// Constructor with default initializations
        resqml22__RepresentationIdentitySet() : RepresentationIdentity() { }
        virtual ~resqml22__RepresentationIdentitySet() { }
        /// Friend allocator used by soap_new_resqml22__RepresentationIdentitySet(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RepresentationIdentitySet * SOAP_FMAC2 soap_instantiate_resqml22__RepresentationIdentitySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:373 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary (-124)
/* complex XML schema type 'resqml22:StratigraphicIntervalBoundary': */
class SOAP_CMAC resqml22__StratigraphicIntervalBoundary : public resqml22__MarkerBoundary {
      public:
        /// Optional element 'resqml22:GeologicBoundaryKind' of XML schema type 'xsd:string'
        std::string *GeologicBoundaryKind;
        /// Optional element 'resqml22:ContactConformableAbove' of XML schema type 'xsd:boolean'
        bool *ContactConformableAbove;
        /// Optional element 'resqml22:ContactConformableBelow' of XML schema type 'xsd:boolean'
        bool *ContactConformableBelow;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StratigraphicIntervalBoundary, default initialized and not managed by a soap context
        virtual resqml22__StratigraphicIntervalBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StratigraphicIntervalBoundary); }
      public:
        /// Constructor with default initializations
        resqml22__StratigraphicIntervalBoundary() : GeologicBoundaryKind(), ContactConformableAbove(), ContactConformableBelow() { }
        virtual ~resqml22__StratigraphicIntervalBoundary() { }
        /// Friend allocator used by soap_new_resqml22__StratigraphicIntervalBoundary(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StratigraphicIntervalBoundary * SOAP_FMAC2 soap_instantiate_resqml22__StratigraphicIntervalBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:377 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch (-126)
/* complex XML schema type 'resqml22:SubRepresentationPatch': */
class SOAP_CMAC resqml22__SubRepresentationPatch : public resqml22__Patch1d {
      public:
        /// Sequence of 1 to 2 elements 'resqml22:ElementIndices' of XML schema type 'resqml22:ElementIndices'
        std::vector<resqml22__ElementIndices *> ElementIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SubRepresentationPatch, default initialized and not managed by a soap context
        virtual resqml22__SubRepresentationPatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SubRepresentationPatch); }
      public:
        /// Constructor with default initializations
        resqml22__SubRepresentationPatch() : ElementIndices() { }
        virtual ~resqml22__SubRepresentationPatch() { }
        /// Friend allocator used by soap_new_resqml22__SubRepresentationPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SubRepresentationPatch * SOAP_FMAC2 soap_instantiate_resqml22__SubRepresentationPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:405 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow (-140)
/* complex XML schema type 'resqml22:CellParentWindow': */
class SOAP_CMAC resqml22__CellParentWindow : public resqml22__AbstractParentWindow {
      public:
        /// Required element 'resqml22:CellIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CellIndices;
        /// Required element 'resqml22:ParentGridRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ParentGridRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CellParentWindow, default initialized and not managed by a soap context
        virtual resqml22__CellParentWindow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CellParentWindow); }
      public:
        /// Constructor with default initializations
        resqml22__CellParentWindow() : CellIndices(), ParentGridRepresentation() { }
        virtual ~resqml22__CellParentWindow() { }
        /// Friend allocator used by soap_new_resqml22__CellParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CellParentWindow * SOAP_FMAC2 soap_instantiate_resqml22__CellParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:409 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow (-142)
/* complex XML schema type 'resqml22:ColumnLayerParentWindow': */
class SOAP_CMAC resqml22__ColumnLayerParentWindow : public resqml22__AbstractParentWindow {
      public:
        /// Required element 'resqml22:ColumnIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ColumnIndices;
        /// Optional element 'resqml22:OmitParentCells' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *OmitParentCells;
        /// Required element 'resqml22:KRegrid' of XML schema type 'resqml22:Regrid'
        resqml22__Regrid *KRegrid;
        /// Required element 'resqml22:ParentColumnLayerGridRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ParentColumnLayerGridRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColumnLayerParentWindow, default initialized and not managed by a soap context
        virtual resqml22__ColumnLayerParentWindow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColumnLayerParentWindow); }
      public:
        /// Constructor with default initializations
        resqml22__ColumnLayerParentWindow() : ColumnIndices(), OmitParentCells(), KRegrid(), ParentColumnLayerGridRepresentation() { }
        virtual ~resqml22__ColumnLayerParentWindow() { }
        /// Friend allocator used by soap_new_resqml22__ColumnLayerParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColumnLayerParentWindow * SOAP_FMAC2 soap_instantiate_resqml22__ColumnLayerParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:413 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology (-144)
/* complex XML schema type 'resqml22:ColumnLayerSubnodeTopology': */
class SOAP_CMAC resqml22__ColumnLayerSubnodeTopology : public resqml22__SubnodeTopology {
      public:
        /// Optional element 'resqml22:ColumnSubnodePatch' of XML schema type 'resqml22:ColumnSubnodePatch'
        std::vector<resqml22__ColumnSubnodePatch *> ColumnSubnodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColumnLayerSubnodeTopology, default initialized and not managed by a soap context
        virtual resqml22__ColumnLayerSubnodeTopology *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColumnLayerSubnodeTopology); }
      public:
        /// Constructor with default initializations
        resqml22__ColumnLayerSubnodeTopology() : ColumnSubnodePatch() { }
        virtual ~resqml22__ColumnLayerSubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml22__ColumnLayerSubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColumnLayerSubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml22__ColumnLayerSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:415 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch (-145)
/* complex XML schema type 'resqml22:ColumnSubnodePatch': */
class SOAP_CMAC resqml22__ColumnSubnodePatch : public resqml22__SubnodePatch {
      public:
        /// Required element 'resqml22:SubnodeCountPerObject' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *SubnodeCountPerObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColumnSubnodePatch, default initialized and not managed by a soap context
        virtual resqml22__ColumnSubnodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColumnSubnodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__ColumnSubnodePatch() : SubnodeCountPerObject() { }
        virtual ~resqml22__ColumnSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml22__ColumnSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColumnSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml22__ColumnSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:435 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow (-155)
/* complex XML schema type 'resqml22:IjkParentWindow': */
class SOAP_CMAC resqml22__IjkParentWindow : public resqml22__AbstractParentWindow {
      public:
        /// Optional element 'resqml22:OmitParentCells' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *OmitParentCells;
        /// Required element 'resqml22:JRegrid' of XML schema type 'resqml22:Regrid'
        resqml22__Regrid *JRegrid;
        /// Required element 'resqml22:ParentIjkGridRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ParentIjkGridRepresentation;
        /// Required element 'resqml22:KRegrid' of XML schema type 'resqml22:Regrid'
        resqml22__Regrid *KRegrid;
        /// Required element 'resqml22:IRegrid' of XML schema type 'resqml22:Regrid'
        resqml22__Regrid *IRegrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IjkParentWindow, default initialized and not managed by a soap context
        virtual resqml22__IjkParentWindow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IjkParentWindow); }
      public:
        /// Constructor with default initializations
        resqml22__IjkParentWindow() : OmitParentCells(), JRegrid(), ParentIjkGridRepresentation(), KRegrid(), IRegrid() { }
        virtual ~resqml22__IjkParentWindow() { }
        /// Friend allocator used by soap_new_resqml22__IjkParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IjkParentWindow * SOAP_FMAC2 soap_instantiate_resqml22__IjkParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:445 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet (-160)
/* Type resqml22__LocalGridSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:LocalGridSet': */
class SOAP_CMAC resqml22__LocalGridSet : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:Activation' of XML schema type 'resqml22:Activation'
        resqml22__Activation *Activation;
        /// Required element 'resqml22:ChildGrid' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> ChildGrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__LocalGridSet, default initialized and not managed by a soap context
        virtual resqml22__LocalGridSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__LocalGridSet); }
      public:
        /// Constructor with default initializations
        resqml22__LocalGridSet() : Activation(), ChildGrid() { }
        virtual ~resqml22__LocalGridSet() { }
        /// Friend allocator used by soap_new_resqml22__LocalGridSet(struct soap*, int)
        friend SOAP_FMAC1 resqml22__LocalGridSet * SOAP_FMAC2 soap_instantiate_resqml22__LocalGridSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:469 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch (-172)
/* complex XML schema type 'resqml22:UniformSubnodePatch': */
class SOAP_CMAC resqml22__UniformSubnodePatch : public resqml22__SubnodePatch {
      public:
        /// Required element 'resqml22:SubnodeCountPerObject' of XML schema type 'eml23:PositiveLong'
        LONG64 SubnodeCountPerObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UniformSubnodePatch, default initialized and not managed by a soap context
        virtual resqml22__UniformSubnodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UniformSubnodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__UniformSubnodePatch() : SubnodeCountPerObject() { }
        virtual ~resqml22__UniformSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml22__UniformSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UniformSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml22__UniformSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:487 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology (-181)
/* complex XML schema type 'resqml22:UnstructuredSubnodeTopology': */
class SOAP_CMAC resqml22__UnstructuredSubnodeTopology : public resqml22__SubnodeTopology {
      public:
        /// Optional element 'resqml22:NodesPerCell' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *NodesPerCell;
        /// Optional element 'resqml22:Edges' of XML schema type 'resqml22:Edges'
        resqml22__Edges *Edges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredSubnodeTopology, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredSubnodeTopology *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredSubnodeTopology); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredSubnodeTopology() : NodesPerCell(), Edges() { }
        virtual ~resqml22__UnstructuredSubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredSubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredSubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:489 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch (-182)
/* complex XML schema type 'resqml22:VariableSubnodePatch': */
class SOAP_CMAC resqml22__VariableSubnodePatch : public resqml22__SubnodePatch {
      public:
        /// Required element 'resqml22:ObjectIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *ObjectIndices;
        /// Required element 'resqml22:SubnodeCountPerSelectedObject' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *SubnodeCountPerSelectedObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__VariableSubnodePatch, default initialized and not managed by a soap context
        virtual resqml22__VariableSubnodePatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__VariableSubnodePatch); }
      public:
        /// Constructor with default initializations
        resqml22__VariableSubnodePatch() : ObjectIndices(), SubnodeCountPerSelectedObject() { }
        virtual ~resqml22__VariableSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml22__VariableSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml22__VariableSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml22__VariableSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:491 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap (-183)
/* complex XML schema type 'resqml22:AbstractColorMap': */
class SOAP_CMAC resqml22__AbstractColorMap : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:NaNColor' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *NaNColor;
        /// Optional element 'resqml22:NullColor' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *NullColor;
        /// Optional element 'resqml22:AboveMaxColor' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *AboveMaxColor;
        /// Optional element 'resqml22:BelowMinColor' of XML schema type 'resqml22:HsvColor'
        resqml22__HsvColor *BelowMinColor;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractColorMap, default initialized and not managed by a soap context
        virtual resqml22__AbstractColorMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractColorMap); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractColorMap() : NaNColor(), NullColor(), AboveMaxColor(), BelowMinColor() { }
        virtual ~resqml22__AbstractColorMap() { }
        /// Friend allocator used by soap_new_resqml22__AbstractColorMap(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractColorMap * SOAP_FMAC2 soap_instantiate_resqml22__AbstractColorMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:495 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation (-185)
/* complex XML schema type 'resqml22:AlphaInformation': */
class SOAP_CMAC resqml22__AlphaInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Required element 'resqml22:Alpha' of XML schema type 'xsd:double'
        std::vector<double> Alpha;
        /// Required element 'resqml22:Index' of XML schema type 'xsd:string'
        std::vector<std::string> Index;
        /// Optional element 'resqml22:MinMax' of XML schema type 'resqml22:MinMax'
        resqml22__MinMax *MinMax;
        /// Required element 'resqml22:OverwriteColorAlpha' of XML schema type 'xsd:boolean'
        bool OverwriteColorAlpha;
        /// Required element 'resqml22:UseLogarithmicMapping' of XML schema type 'xsd:boolean'
        bool UseLogarithmicMapping;
        /// Required element 'resqml22:UseReverseMapping' of XML schema type 'xsd:boolean'
        bool UseReverseMapping;
        /// Optional element 'resqml22:ValueVectorIndex' of XML schema type 'xsd:long'
        LONG64 *ValueVectorIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AlphaInformation, default initialized and not managed by a soap context
        virtual resqml22__AlphaInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AlphaInformation); }
      public:
        /// Constructor with default initializations
        resqml22__AlphaInformation() : Alpha(), Index(), MinMax(), OverwriteColorAlpha(), UseLogarithmicMapping(), UseReverseMapping(), ValueVectorIndex() { }
        virtual ~resqml22__AlphaInformation() { }
        /// Friend allocator used by soap_new_resqml22__AlphaInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AlphaInformation * SOAP_FMAC2 soap_instantiate_resqml22__AlphaInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:497 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation (-186)
/* complex XML schema type 'resqml22:AnnotationInformation': */
class SOAP_CMAC resqml22__AnnotationInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Required element 'resqml22:ShowAnnotationEvery' of XML schema type 'xsd:long'
        LONG64 ShowAnnotationEvery;
        /// Required element 'resqml22:ValueVectorIndices' of XML schema type 'xsd:string'
        std::vector<std::string> ValueVectorIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AnnotationInformation, default initialized and not managed by a soap context
        virtual resqml22__AnnotationInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AnnotationInformation); }
      public:
        /// Constructor with default initializations
        resqml22__AnnotationInformation() : ShowAnnotationEvery(), ValueVectorIndices() { }
        virtual ~resqml22__AnnotationInformation() { }
        /// Friend allocator used by soap_new_resqml22__AnnotationInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AnnotationInformation * SOAP_FMAC2 soap_instantiate_resqml22__AnnotationInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:499 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation (-187)
/* complex XML schema type 'resqml22:ColorInformation': */
class SOAP_CMAC resqml22__ColorInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Optional element 'resqml22:MinMax' of XML schema type 'resqml22:MinMax'
        resqml22__MinMax *MinMax;
        /// Required element 'resqml22:UseLogarithmicMapping' of XML schema type 'xsd:boolean'
        bool UseLogarithmicMapping;
        /// Required element 'resqml22:UseReverseMapping' of XML schema type 'xsd:boolean'
        bool UseReverseMapping;
        /// Optional element 'resqml22:ValueVectorIndex' of XML schema type 'xsd:long'
        LONG64 *ValueVectorIndex;
        /// Optional element 'resqml22:ColorMap' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ColorMap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColorInformation, default initialized and not managed by a soap context
        virtual resqml22__ColorInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColorInformation); }
      public:
        /// Constructor with default initializations
        resqml22__ColorInformation() : MinMax(), UseLogarithmicMapping(), UseReverseMapping(), ValueVectorIndex(), ColorMap() { }
        virtual ~resqml22__ColorInformation() { }
        /// Friend allocator used by soap_new_resqml22__ColorInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColorInformation * SOAP_FMAC2 soap_instantiate_resqml22__ColorInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:501 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary (-188)
/* Type resqml22__ColorMapDictionary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:ColorMapDictionary': */
class SOAP_CMAC resqml22__ColorMapDictionary : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:ColorMap' of XML schema type 'resqml22:AbstractColorMap'
        std::vector<resqml22__AbstractColorMap *> ColorMap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ColorMapDictionary, default initialized and not managed by a soap context
        virtual resqml22__ColorMapDictionary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ColorMapDictionary); }
      public:
        /// Constructor with default initializations
        resqml22__ColorMapDictionary() : ColorMap() { }
        virtual ~resqml22__ColorMapDictionary() { }
        /// Friend allocator used by soap_new_resqml22__ColorMapDictionary(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ColorMapDictionary * SOAP_FMAC2 soap_instantiate_resqml22__ColorMapDictionary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:507 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation (-191)
/* complex XML schema type 'resqml22:ContourLineSetInformation': */
class SOAP_CMAC resqml22__ContourLineSetInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Optional element 'resqml22:DisplayLabelOnMajorLine' of XML schema type 'xsd:boolean'
        bool *DisplayLabelOnMajorLine;
        /// Optional element 'resqml22:DisplayLabelOnMinorLine' of XML schema type 'xsd:boolean'
        bool *DisplayLabelOnMinorLine;
        /// Optional element 'resqml22:Increment' of XML schema type 'xsd:double'
        double *Increment;
        /// Optional element 'resqml22:MajorLineGraphicalInformation' of XML schema type 'resqml22:GraphicalInformationForEdges'
        resqml22__GraphicalInformationForEdges *MajorLineGraphicalInformation;
        /// Optional element 'resqml22:MinorLineGraphicalInformation' of XML schema type 'resqml22:GraphicalInformationForEdges'
        resqml22__GraphicalInformationForEdges *MinorLineGraphicalInformation;
        /// Optional element 'resqml22:ShowMajorLineEvery' of XML schema type 'xsd:long'
        LONG64 *ShowMajorLineEvery;
        /// Optional element 'resqml22:ValueVectorIndex' of XML schema type 'xsd:long'
        LONG64 *ValueVectorIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContourLineSetInformation, default initialized and not managed by a soap context
        virtual resqml22__ContourLineSetInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContourLineSetInformation); }
      public:
        /// Constructor with default initializations
        resqml22__ContourLineSetInformation() : DisplayLabelOnMajorLine(), DisplayLabelOnMinorLine(), Increment(), MajorLineGraphicalInformation(), MinorLineGraphicalInformation(), ShowMajorLineEvery(), ValueVectorIndex() { }
        virtual ~resqml22__ContourLineSetInformation() { }
        /// Friend allocator used by soap_new_resqml22__ContourLineSetInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContourLineSetInformation * SOAP_FMAC2 soap_instantiate_resqml22__ContourLineSetInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:509 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation (-192)
/* complex XML schema type 'resqml22:DefaultGraphicalInformation': */
class SOAP_CMAC resqml22__DefaultGraphicalInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Optional element 'resqml22:ViewerId' of XML schema type 'xsd:string'
        std::string *ViewerId;
        /// Required element 'resqml22:ViewerKind' of XML schema type 'resqml22:ViewerKindExt'
        std::string ViewerKind;
        /// Required element 'resqml22:IndexableElementInfo' of XML schema type 'resqml22:AbstractGraphicalInformationForIndexableElement'
        std::vector<resqml22__AbstractGraphicalInformationForIndexableElement *> IndexableElementInfo;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__DefaultGraphicalInformation, default initialized and not managed by a soap context
        virtual resqml22__DefaultGraphicalInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__DefaultGraphicalInformation); }
      public:
        /// Constructor with default initializations
        resqml22__DefaultGraphicalInformation() : ViewerId(), ViewerKind(), IndexableElementInfo() { }
        virtual ~resqml22__DefaultGraphicalInformation() { }
        /// Friend allocator used by soap_new_resqml22__DefaultGraphicalInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__DefaultGraphicalInformation * SOAP_FMAC2 soap_instantiate_resqml22__DefaultGraphicalInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:515 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges (-195)
/* complex XML schema type 'resqml22:GraphicalInformationForEdges': */
class SOAP_CMAC resqml22__GraphicalInformationForEdges : public resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:DisplaySpace' of XML schema type 'resqml22:DisplaySpace'
        resqml22__DisplaySpace *DisplaySpace;
        /// Optional element 'resqml22:Pattern' of XML schema type 'resqml22:EdgePatternExt'
        std::string *Pattern;
        /// Optional element 'resqml22:Thickness' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *Thickness;
        /// Optional element 'resqml22:UseInterpolationBetweenNodes' of XML schema type 'xsd:boolean'
        bool *UseInterpolationBetweenNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GraphicalInformationForEdges, default initialized and not managed by a soap context
        virtual resqml22__GraphicalInformationForEdges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GraphicalInformationForEdges); }
      public:
        /// Constructor with default initializations
        resqml22__GraphicalInformationForEdges() : DisplaySpace(), Pattern(), Thickness(), UseInterpolationBetweenNodes() { }
        virtual ~resqml22__GraphicalInformationForEdges() { }
        /// Friend allocator used by soap_new_resqml22__GraphicalInformationForEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GraphicalInformationForEdges * SOAP_FMAC2 soap_instantiate_resqml22__GraphicalInformationForEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:517 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces (-196)
/* complex XML schema type 'resqml22:GraphicalInformationForFaces': */
class SOAP_CMAC resqml22__GraphicalInformationForFaces : public resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:AppliesOnRightHandedFace' of XML schema type 'xsd:boolean'
        bool *AppliesOnRightHandedFace;
        /// Optional element 'resqml22:UseInterpolationBetweenNodes' of XML schema type 'xsd:boolean'
        bool *UseInterpolationBetweenNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GraphicalInformationForFaces, default initialized and not managed by a soap context
        virtual resqml22__GraphicalInformationForFaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GraphicalInformationForFaces); }
      public:
        /// Constructor with default initializations
        resqml22__GraphicalInformationForFaces() : AppliesOnRightHandedFace(), UseInterpolationBetweenNodes() { }
        virtual ~resqml22__GraphicalInformationForFaces() { }
        /// Friend allocator used by soap_new_resqml22__GraphicalInformationForFaces(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GraphicalInformationForFaces * SOAP_FMAC2 soap_instantiate_resqml22__GraphicalInformationForFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:519 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes (-197)
/* complex XML schema type 'resqml22:GraphicalInformationForNodes': */
class SOAP_CMAC resqml22__GraphicalInformationForNodes : public resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:ConstantSize' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *ConstantSize;
        /// Optional element 'resqml22:DisplaySpace' of XML schema type 'resqml22:DisplaySpace'
        resqml22__DisplaySpace *DisplaySpace;
        /// Optional element 'resqml22:ShowSymbolEvery' of XML schema type 'xsd:long'
        LONG64 *ShowSymbolEvery;
        /// Optional element 'resqml22:Symbol' of XML schema type 'resqml22:NodeSymbolExt'
        std::string *Symbol;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GraphicalInformationForNodes, default initialized and not managed by a soap context
        virtual resqml22__GraphicalInformationForNodes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GraphicalInformationForNodes); }
      public:
        /// Constructor with default initializations
        resqml22__GraphicalInformationForNodes() : ConstantSize(), DisplaySpace(), ShowSymbolEvery(), Symbol() { }
        virtual ~resqml22__GraphicalInformationForNodes() { }
        /// Friend allocator used by soap_new_resqml22__GraphicalInformationForNodes(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GraphicalInformationForNodes * SOAP_FMAC2 soap_instantiate_resqml22__GraphicalInformationForNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:521 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes (-198)
/* complex XML schema type 'resqml22:GraphicalInformationForVolumes': */
class SOAP_CMAC resqml22__GraphicalInformationForVolumes : public resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:UseInterpolationBetweenNodes' of XML schema type 'xsd:boolean'
        bool *UseInterpolationBetweenNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GraphicalInformationForVolumes, default initialized and not managed by a soap context
        virtual resqml22__GraphicalInformationForVolumes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GraphicalInformationForVolumes); }
      public:
        /// Constructor with default initializations
        resqml22__GraphicalInformationForVolumes() : UseInterpolationBetweenNodes() { }
        virtual ~resqml22__GraphicalInformationForVolumes() { }
        /// Friend allocator used by soap_new_resqml22__GraphicalInformationForVolumes(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GraphicalInformationForVolumes * SOAP_FMAC2 soap_instantiate_resqml22__GraphicalInformationForVolumes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:523 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject (-199)
/* complex XML schema type 'resqml22:GraphicalInformationForWholeObject': */
class SOAP_CMAC resqml22__GraphicalInformationForWholeObject : public resqml22__AbstractGraphicalInformationForIndexableElement {
      public:
        /// Optional element 'resqml22:ActiveContourLineSetInformationIndex' of XML schema type 'xsd:long'
        LONG64 *ActiveContourLineSetInformationIndex;
        /// Optional element 'resqml22:DisplayTitle' of XML schema type 'xsd:boolean'
        bool *DisplayTitle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GraphicalInformationForWholeObject, default initialized and not managed by a soap context
        virtual resqml22__GraphicalInformationForWholeObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GraphicalInformationForWholeObject); }
      public:
        /// Constructor with default initializations
        resqml22__GraphicalInformationForWholeObject() : ActiveContourLineSetInformationIndex(), DisplayTitle() { }
        virtual ~resqml22__GraphicalInformationForWholeObject() { }
        /// Friend allocator used by soap_new_resqml22__GraphicalInformationForWholeObject(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GraphicalInformationForWholeObject * SOAP_FMAC2 soap_instantiate_resqml22__GraphicalInformationForWholeObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:529 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation (-202)
/* complex XML schema type 'resqml22:SizeInformation': */
class SOAP_CMAC resqml22__SizeInformation : public eml23__AbstractGraphicalInformation {
      public:
        /// Optional element 'resqml22:MinMax' of XML schema type 'resqml22:MinMax'
        resqml22__MinMax *MinMax;
        /// Required element 'resqml22:UseLogarithmicMapping' of XML schema type 'xsd:boolean'
        bool UseLogarithmicMapping;
        /// Required element 'resqml22:UseReverseMapping' of XML schema type 'xsd:boolean'
        bool UseReverseMapping;
        /// Optional element 'resqml22:ValueVectorIndex' of XML schema type 'xsd:long'
        LONG64 *ValueVectorIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SizeInformation, default initialized and not managed by a soap context
        virtual resqml22__SizeInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SizeInformation); }
      public:
        /// Constructor with default initializations
        resqml22__SizeInformation() : MinMax(), UseLogarithmicMapping(), UseReverseMapping(), ValueVectorIndex() { }
        virtual ~resqml22__SizeInformation() { }
        /// Friend allocator used by soap_new_resqml22__SizeInformation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SizeInformation * SOAP_FMAC2 soap_instantiate_resqml22__SizeInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:531 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty (-203)
/* Type resqml22__AbstractProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractProperty': */
class SOAP_CMAC resqml22__AbstractProperty : public eml23__AbstractObject {
      public:
        /// Required element 'resqml22:IndexableElement' of XML schema type 'eml23:IndexableElement'
        eml23__IndexableElement IndexableElement;
        /// Optional element 'resqml22:Time' of XML schema type 'eml23:GeologicTime'
        eml23__GeologicTime *Time;
        /// Optional element 'resqml22:RealizationIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *RealizationIndices;
        /// Required element 'resqml22:ValueCountPerIndexableElement' of XML schema type 'eml23:PositiveLong'
        std::vector<LONG64> ValueCountPerIndexableElement;
        /// Required element 'resqml22:PropertyKind' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *PropertyKind;
        /// Optional element 'resqml22:LabelPerComponent' of XML schema type 'eml23:String64'
        std::vector<std::string> LabelPerComponent;
        /// Required element 'resqml22:SupportingRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SupportingRepresentation;
        /// Optional element 'resqml22:LocalCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalCrs;
        /// Optional element 'resqml22:TimeOrIntervalSeries' of XML schema type 'eml23:TimeOrIntervalSeries'
        eml23__TimeOrIntervalSeries *TimeOrIntervalSeries;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractProperty, default initialized and not managed by a soap context
        virtual resqml22__AbstractProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractProperty); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractProperty() : IndexableElement(), Time(), RealizationIndices(), ValueCountPerIndexableElement(), PropertyKind(), LabelPerComponent(), SupportingRepresentation(), LocalCrs(), TimeOrIntervalSeries() { }
        virtual ~resqml22__AbstractProperty() { }
        /// Friend allocator used by soap_new_resqml22__AbstractProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractProperty * SOAP_FMAC2 soap_instantiate_resqml22__AbstractProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:569 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker (-222)
/* complex XML schema type 'resqml22:WellboreMarker': */
class SOAP_CMAC resqml22__WellboreMarker : public eml23__AbstractObject {
      public:
        /// Optional element 'resqml22:FluidContact' of XML schema type 'resqml22:FluidContact'
        resqml22__FluidContact *FluidContact;
        /// Optional element 'resqml22:FluidMarker' of XML schema type 'resqml22:FluidMarker'
        resqml22__FluidMarker *FluidMarker;
        /// Optional element 'resqml22:GeologicBoundaryKind' of XML schema type 'resqml22:GeologicBoundaryKind'
        resqml22__GeologicBoundaryKind *GeologicBoundaryKind;
        /// Optional element 'resqml22:WitsmlFormationMarker' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *WitsmlFormationMarker;
        /// Optional element 'resqml22:Interpretation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Interpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreMarker, default initialized and not managed by a soap context
        virtual resqml22__WellboreMarker *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreMarker); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreMarker() : FluidContact(), FluidMarker(), GeologicBoundaryKind(), WitsmlFormationMarker(), Interpretation() { }
        virtual ~resqml22__WellboreMarker() { }
        /// Friend allocator used by soap_new_resqml22__WellboreMarker(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreMarker * SOAP_FMAC2 soap_instantiate_resqml22__WellboreMarker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:579 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject (-227)
/* Type eml23__AbstractGrowingObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:AbstractGrowingObject': */
class SOAP_CMAC eml23__AbstractGrowingObject : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:GrowingStatus' of XML schema type 'eml23:GrowingStatusKind'
        eml23__GrowingStatusKind GrowingStatus;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractGrowingObject, default initialized and not managed by a soap context
        virtual eml23__AbstractGrowingObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractGrowingObject); }
      public:
        /// Constructor with default initializations
        eml23__AbstractGrowingObject() : GrowingStatus() { }
        virtual ~eml23__AbstractGrowingObject() { }
        /// Friend allocator used by soap_new_eml23__AbstractGrowingObject(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractGrowingObject * SOAP_FMAC2 soap_instantiate_eml23__AbstractGrowingObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:583 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart (-229)
/* complex XML schema type 'eml23:AbstractMdGrowingPart': */
class SOAP_CMAC eml23__AbstractMdGrowingPart : public eml23__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml23:Md' of XML schema type 'eml23:MeasuredDepthCoord'
        eml23__MeasuredDepthCoord *Md;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractMdGrowingPart, default initialized and not managed by a soap context
        virtual eml23__AbstractMdGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractMdGrowingPart); }
      public:
        /// Constructor with default initializations
        eml23__AbstractMdGrowingPart() : Md() { }
        virtual ~eml23__AbstractMdGrowingPart() { }
        /// Friend allocator used by soap_new_eml23__AbstractMdGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractMdGrowingPart * SOAP_FMAC2 soap_instantiate_eml23__AbstractMdGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:585 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart (-230)
/* complex XML schema type 'eml23:AbstractMdIntervalGrowingPart': */
class SOAP_CMAC eml23__AbstractMdIntervalGrowingPart : public eml23__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml23:MdInterval' of XML schema type 'eml23:MdInterval'
        eml23__MdInterval *MdInterval;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractMdIntervalGrowingPart, default initialized and not managed by a soap context
        virtual eml23__AbstractMdIntervalGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractMdIntervalGrowingPart); }
      public:
        /// Constructor with default initializations
        eml23__AbstractMdIntervalGrowingPart() : MdInterval() { }
        virtual ~eml23__AbstractMdIntervalGrowingPart() { }
        /// Friend allocator used by soap_new_eml23__AbstractMdIntervalGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractMdIntervalGrowingPart * SOAP_FMAC2 soap_instantiate_eml23__AbstractMdIntervalGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:589 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart (-232)
/* complex XML schema type 'eml23:AbstractTimeGrowingPart': */
class SOAP_CMAC eml23__AbstractTimeGrowingPart : public eml23__AbstractGrowingObjectPart {
      public:
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm Time;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractTimeGrowingPart, default initialized and not managed by a soap context
        virtual eml23__AbstractTimeGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractTimeGrowingPart); }
      public:
        /// Constructor with default initializations
        eml23__AbstractTimeGrowingPart() : Time() { }
        virtual ~eml23__AbstractTimeGrowingPart() { }
        /// Friend allocator used by soap_new_eml23__AbstractTimeGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractTimeGrowingPart * SOAP_FMAC2 soap_instantiate_eml23__AbstractTimeGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:591 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart (-233)
/* complex XML schema type 'eml23:AbstractTimeIntervalGrowingPart': */
class SOAP_CMAC eml23__AbstractTimeIntervalGrowingPart : public eml23__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml23:TimeInterval' of XML schema type 'eml23:DateTimeInterval'
        eml23__DateTimeInterval *TimeInterval;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractTimeIntervalGrowingPart, default initialized and not managed by a soap context
        virtual eml23__AbstractTimeIntervalGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractTimeIntervalGrowingPart); }
      public:
        /// Constructor with default initializations
        eml23__AbstractTimeIntervalGrowingPart() : TimeInterval() { }
        virtual ~eml23__AbstractTimeIntervalGrowingPart() { }
        /// Friend allocator used by soap_new_eml23__AbstractTimeIntervalGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractTimeIntervalGrowingPart * SOAP_FMAC2 soap_instantiate_eml23__AbstractTimeIntervalGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:601 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray (-238)
/* complex XML schema type 'eml23:AbstractBooleanArray': */
class SOAP_CMAC eml23__AbstractBooleanArray : public eml23__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractBooleanArray, default initialized and not managed by a soap context
        virtual eml23__AbstractBooleanArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractBooleanArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractBooleanArray() { }
        virtual ~eml23__AbstractBooleanArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractBooleanArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractBooleanArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractBooleanArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:607 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray (-241)
/* complex XML schema type 'eml23:AbstractNumericArray': */
class SOAP_CMAC eml23__AbstractNumericArray : public eml23__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractNumericArray, default initialized and not managed by a soap context
        virtual eml23__AbstractNumericArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractNumericArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractNumericArray() { }
        virtual ~eml23__AbstractNumericArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractNumericArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractNumericArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractNumericArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:609 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray (-242)
/* complex XML schema type 'eml23:AbstractStringArray': */
class SOAP_CMAC eml23__AbstractStringArray : public eml23__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractStringArray, default initialized and not managed by a soap context
        virtual eml23__AbstractStringArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractStringArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractStringArray() { }
        virtual ~eml23__AbstractStringArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractStringArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractStringArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractStringArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:661 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint (-268)
/* complex XML schema type 'eml23:AbstractReferencePoint': */
class SOAP_CMAC eml23__AbstractReferencePoint : public eml23__AbstractObject {
      public:
        /// Optional element 'eml23:Kind' of XML schema type 'eml23:ReferencePointKindExt'
        std::string *Kind;
        /// Optional element 'eml23:OriginUncertaintyVectorAtSigmaX' of XML schema type 'eml23:Vector'
        eml23__Vector *OriginUncertaintyVectorAtSigmaX;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractReferencePoint, default initialized and not managed by a soap context
        virtual eml23__AbstractReferencePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractReferencePoint); }
      public:
        /// Constructor with default initializations
        eml23__AbstractReferencePoint() : Kind(), OriginUncertaintyVectorAtSigmaX() { }
        virtual ~eml23__AbstractReferencePoint() { }
        /// Friend allocator used by soap_new_eml23__AbstractReferencePoint(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractReferencePoint * SOAP_FMAC2 soap_instantiate_eml23__AbstractReferencePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:663 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates (-269)
/* complex XML schema type 'eml23:GeodeticCoordinates': */
class SOAP_CMAC eml23__GeodeticCoordinates : public eml23__AbstractHorizontalCoordinates {
      public:
        /// Required element 'eml23:Crs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Crs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticCoordinates, default initialized and not managed by a soap context
        virtual eml23__GeodeticCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticCoordinates); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticCoordinates() : Crs() { }
        virtual ~eml23__GeodeticCoordinates() { }
        /// Friend allocator used by soap_new_eml23__GeodeticCoordinates(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticCoordinates * SOAP_FMAC2 soap_instantiate_eml23__GeodeticCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:667 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates (-271)
/* complex XML schema type 'eml23:ProjectedCoordinates': */
class SOAP_CMAC eml23__ProjectedCoordinates : public eml23__AbstractHorizontalCoordinates {
      public:
        /// Required element 'eml23:Crs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Crs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedCoordinates, default initialized and not managed by a soap context
        virtual eml23__ProjectedCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedCoordinates); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedCoordinates() : Crs() { }
        virtual ~eml23__ProjectedCoordinates() { }
        /// Friend allocator used by soap_new_eml23__ProjectedCoordinates(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedCoordinates * SOAP_FMAC2 soap_instantiate_eml23__ProjectedCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:669 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates (-272)
/* complex XML schema type 'eml23:PublicLandSurveySystemCoordinates': */
class SOAP_CMAC eml23__PublicLandSurveySystemCoordinates : public eml23__AbstractHorizontalCoordinates {
      public:
        /// Required element 'eml23:PublicLandSurveySystem' of XML schema type 'eml23:PublicLandSurveySystem'
        eml23__PublicLandSurveySystem *PublicLandSurveySystem;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PublicLandSurveySystemCoordinates, default initialized and not managed by a soap context
        virtual eml23__PublicLandSurveySystemCoordinates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PublicLandSurveySystemCoordinates); }
      public:
        /// Constructor with default initializations
        eml23__PublicLandSurveySystemCoordinates() : PublicLandSurveySystem() { }
        virtual ~eml23__PublicLandSurveySystemCoordinates() { }
        /// Friend allocator used by soap_new_eml23__PublicLandSurveySystemCoordinates(struct soap*, int)
        friend SOAP_FMAC1 eml23__PublicLandSurveySystemCoordinates * SOAP_FMAC2 soap_instantiate_eml23__PublicLandSurveySystemCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1427 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs (-651)
/* Type eml23__GeodeticCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:GeodeticCrs': */
class SOAP_CMAC eml23__GeodeticCrs : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:AbstractGeodeticCrs' of XML schema type 'eml23:AbstractGeodeticCrs'
        eml23__AbstractGeodeticCrs *AbstractGeodeticCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticCrs, default initialized and not managed by a soap context
        virtual eml23__GeodeticCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticCrs); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticCrs() : AbstractGeodeticCrs() { }
        virtual ~eml23__GeodeticCrs() { }
        /// Friend allocator used by soap_new_eml23__GeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticCrs * SOAP_FMAC2 soap_instantiate_eml23__GeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1429 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs (-652)
/* complex XML schema type 'eml23:GeodeticEpsgCrs': */
class SOAP_CMAC eml23__GeodeticEpsgCrs : public eml23__AbstractGeodeticCrs {
      public:
        /// Required element 'eml23:EpsgCode' of XML schema type 'eml23:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticEpsgCrs, default initialized and not managed by a soap context
        virtual eml23__GeodeticEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticEpsgCrs() : EpsgCode() { }
        virtual ~eml23__GeodeticEpsgCrs() { }
        /// Friend allocator used by soap_new_eml23__GeodeticEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticEpsgCrs * SOAP_FMAC2 soap_instantiate_eml23__GeodeticEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1431 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs (-653)
/* complex XML schema type 'eml23:GeodeticLocalAuthorityCrs': */
class SOAP_CMAC eml23__GeodeticLocalAuthorityCrs : public eml23__AbstractGeodeticCrs {
      public:
        /// Required element 'eml23:LocalAuthorityCrsName' of XML schema type 'eml23:AuthorityQualifiedName'
        eml23__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml23__GeodeticLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml23__GeodeticLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml23__GeodeticLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml23__GeodeticLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1433 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs (-654)
/* complex XML schema type 'eml23:GeodeticUnknownCrs': */
class SOAP_CMAC eml23__GeodeticUnknownCrs : public eml23__AbstractGeodeticCrs {
      public:
        /// Required element 'eml23:Unknown' of XML schema type 'eml23:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticUnknownCrs, default initialized and not managed by a soap context
        virtual eml23__GeodeticUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticUnknownCrs() : Unknown() { }
        virtual ~eml23__GeodeticUnknownCrs() { }
        /// Friend allocator used by soap_new_eml23__GeodeticUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticUnknownCrs * SOAP_FMAC2 soap_instantiate_eml23__GeodeticUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1435 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs (-655)
/* complex XML schema type 'eml23:GeodeticWktCrs': */
class SOAP_CMAC eml23__GeodeticWktCrs : public eml23__AbstractGeodeticCrs {
      public:
        /// Required element 'eml23:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GeodeticWktCrs, default initialized and not managed by a soap context
        virtual eml23__GeodeticWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GeodeticWktCrs); }
      public:
        /// Constructor with default initializations
        eml23__GeodeticWktCrs() : WellKnownText() { }
        virtual ~eml23__GeodeticWktCrs() { }
        /// Friend allocator used by soap_new_eml23__GeodeticWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__GeodeticWktCrs * SOAP_FMAC2 soap_instantiate_eml23__GeodeticWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1439 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs (-657)
/* Type eml23__LocalEngineeringCompoundCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:LocalEngineeringCompoundCrs': */
class SOAP_CMAC eml23__LocalEngineeringCompoundCrs : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Azimuth' of XML schema type 'eml23:PlaneAngleMeasureExt'
        eml23__PlaneAngleMeasureExt *Azimuth;
        /// Required element 'eml23:AzimuthReference' of XML schema type 'eml23:NorthReferenceKind'
        eml23__NorthReferenceKind AzimuthReference;
        /// Required element 'eml23:OriginProjectedCoordinate1' of XML schema type 'xsd:double'
        double OriginProjectedCoordinate1;
        /// Required element 'eml23:OriginProjectedCoordinate2' of XML schema type 'xsd:double'
        double OriginProjectedCoordinate2;
        /// Required element 'eml23:OriginVerticalCoordinate' of XML schema type 'xsd:double'
        double OriginVerticalCoordinate;
        /// Required element 'eml23:VerticalAxis' of XML schema type 'eml23:VerticalAxis'
        eml23__VerticalAxis *VerticalAxis;
        /// Required element 'eml23:HorizontalAxes' of XML schema type 'eml23:HorizontalAxes'
        eml23__HorizontalAxes *HorizontalAxes;
        /// Required element 'eml23:VerticalCrs' of XML schema type 'eml23:VerticalCrs'
        eml23__VerticalCrs *VerticalCrs;
        /// Optional element 'eml23:OriginUncertaintyVectorAtSigmaX' of XML schema type 'eml23:Vector'
        eml23__Vector *OriginUncertaintyVectorAtSigmaX;
        /// Required element 'eml23:ProjectedCrs' of XML schema type 'eml23:ProjectedCrs'
        eml23__ProjectedCrs *ProjectedCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LocalEngineeringCompoundCrs, default initialized and not managed by a soap context
        virtual eml23__LocalEngineeringCompoundCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LocalEngineeringCompoundCrs); }
      public:
        /// Constructor with default initializations
        eml23__LocalEngineeringCompoundCrs() : Azimuth(), AzimuthReference(), OriginProjectedCoordinate1(), OriginProjectedCoordinate2(), OriginVerticalCoordinate(), VerticalAxis(), HorizontalAxes(), VerticalCrs(), OriginUncertaintyVectorAtSigmaX(), ProjectedCrs() { }
        virtual ~eml23__LocalEngineeringCompoundCrs() { }
        /// Friend allocator used by soap_new_eml23__LocalEngineeringCompoundCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__LocalEngineeringCompoundCrs * SOAP_FMAC2 soap_instantiate_eml23__LocalEngineeringCompoundCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1441 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs (-658)
/* complex XML schema type 'eml23:ProjectedCrs': */
class SOAP_CMAC eml23__ProjectedCrs : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:AxisOrder' of XML schema type 'eml23:AxisOrder2d'
        eml23__AxisOrder2d AxisOrder;
        /// Required element 'eml23:AbstractProjectedCrs' of XML schema type 'eml23:AbstractProjectedCrs'
        eml23__AbstractProjectedCrs *AbstractProjectedCrs;
        /// Optional attribute 'uom' of XML schema type 'eml23:LengthUomExt'
        std::string *uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedCrs, default initialized and not managed by a soap context
        virtual eml23__ProjectedCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedCrs); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedCrs() : AxisOrder(), AbstractProjectedCrs(), uom() { }
        virtual ~eml23__ProjectedCrs() { }
        /// Friend allocator used by soap_new_eml23__ProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedCrs * SOAP_FMAC2 soap_instantiate_eml23__ProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1443 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs (-659)
/* complex XML schema type 'eml23:ProjectedEpsgCrs': */
class SOAP_CMAC eml23__ProjectedEpsgCrs : public eml23__AbstractProjectedCrs {
      public:
        /// Required element 'eml23:EpsgCode' of XML schema type 'eml23:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedEpsgCrs, default initialized and not managed by a soap context
        virtual eml23__ProjectedEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedEpsgCrs() : EpsgCode() { }
        virtual ~eml23__ProjectedEpsgCrs() { }
        /// Friend allocator used by soap_new_eml23__ProjectedEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedEpsgCrs * SOAP_FMAC2 soap_instantiate_eml23__ProjectedEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1445 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs (-660)
/* complex XML schema type 'eml23:ProjectedLocalAuthorityCrs': */
class SOAP_CMAC eml23__ProjectedLocalAuthorityCrs : public eml23__AbstractProjectedCrs {
      public:
        /// Required element 'eml23:LocalAuthorityCrsName' of XML schema type 'eml23:AuthorityQualifiedName'
        eml23__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml23__ProjectedLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml23__ProjectedLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml23__ProjectedLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml23__ProjectedLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1447 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs (-661)
/* complex XML schema type 'eml23:ProjectedUnknownCrs': */
class SOAP_CMAC eml23__ProjectedUnknownCrs : public eml23__AbstractProjectedCrs {
      public:
        /// Required element 'eml23:Unknown' of XML schema type 'eml23:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedUnknownCrs, default initialized and not managed by a soap context
        virtual eml23__ProjectedUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedUnknownCrs() : Unknown() { }
        virtual ~eml23__ProjectedUnknownCrs() { }
        /// Friend allocator used by soap_new_eml23__ProjectedUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedUnknownCrs * SOAP_FMAC2 soap_instantiate_eml23__ProjectedUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1449 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs (-662)
/* complex XML schema type 'eml23:ProjectedWktCrs': */
class SOAP_CMAC eml23__ProjectedWktCrs : public eml23__AbstractProjectedCrs {
      public:
        /// Required element 'eml23:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ProjectedWktCrs, default initialized and not managed by a soap context
        virtual eml23__ProjectedWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ProjectedWktCrs); }
      public:
        /// Constructor with default initializations
        eml23__ProjectedWktCrs() : WellKnownText() { }
        virtual ~eml23__ProjectedWktCrs() { }
        /// Friend allocator used by soap_new_eml23__ProjectedWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ProjectedWktCrs * SOAP_FMAC2 soap_instantiate_eml23__ProjectedWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1457 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs (-666)
/* complex XML schema type 'eml23:VerticalCrs': */
class SOAP_CMAC eml23__VerticalCrs : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Direction' of XML schema type 'eml23:VerticalDirection'
        eml23__VerticalDirection Direction;
        /// Required element 'eml23:AbstractVerticalCrs' of XML schema type 'eml23:AbstractVerticalCrs'
        eml23__AbstractVerticalCrs *AbstractVerticalCrs;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthUomExt'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalCrs, default initialized and not managed by a soap context
        virtual eml23__VerticalCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalCrs); }
      public:
        /// Constructor with default initializations
        eml23__VerticalCrs() : Direction(), AbstractVerticalCrs(), uom() { }
        virtual ~eml23__VerticalCrs() { }
        /// Friend allocator used by soap_new_eml23__VerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalCrs * SOAP_FMAC2 soap_instantiate_eml23__VerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1459 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs (-667)
/* complex XML schema type 'eml23:VerticalEpsgCrs': */
class SOAP_CMAC eml23__VerticalEpsgCrs : public eml23__AbstractVerticalCrs {
      public:
        /// Required element 'eml23:EpsgCode' of XML schema type 'eml23:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalEpsgCrs, default initialized and not managed by a soap context
        virtual eml23__VerticalEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml23__VerticalEpsgCrs() : EpsgCode() { }
        virtual ~eml23__VerticalEpsgCrs() { }
        /// Friend allocator used by soap_new_eml23__VerticalEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalEpsgCrs * SOAP_FMAC2 soap_instantiate_eml23__VerticalEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1461 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs (-668)
/* complex XML schema type 'eml23:VerticalLocalAuthorityCrs': */
class SOAP_CMAC eml23__VerticalLocalAuthorityCrs : public eml23__AbstractVerticalCrs {
      public:
        /// Required element 'eml23:LocalAuthorityCrsName' of XML schema type 'eml23:AuthorityQualifiedName'
        eml23__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml23__VerticalLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml23__VerticalLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml23__VerticalLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml23__VerticalLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml23__VerticalLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1463 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs (-669)
/* complex XML schema type 'eml23:VerticalUnknownCrs': */
class SOAP_CMAC eml23__VerticalUnknownCrs : public eml23__AbstractVerticalCrs {
      public:
        /// Required element 'eml23:Unknown' of XML schema type 'eml23:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalUnknownCrs, default initialized and not managed by a soap context
        virtual eml23__VerticalUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml23__VerticalUnknownCrs() : Unknown() { }
        virtual ~eml23__VerticalUnknownCrs() { }
        /// Friend allocator used by soap_new_eml23__VerticalUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalUnknownCrs * SOAP_FMAC2 soap_instantiate_eml23__VerticalUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1465 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs (-670)
/* complex XML schema type 'eml23:VerticalWktCrs': */
class SOAP_CMAC eml23__VerticalWktCrs : public eml23__AbstractVerticalCrs {
      public:
        /// Required element 'eml23:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalWktCrs, default initialized and not managed by a soap context
        virtual eml23__VerticalWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalWktCrs); }
      public:
        /// Constructor with default initializations
        eml23__VerticalWktCrs() : WellKnownText() { }
        virtual ~eml23__VerticalWktCrs() { }
        /// Friend allocator used by soap_new_eml23__VerticalWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalWktCrs * SOAP_FMAC2 soap_instantiate_eml23__VerticalWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1471 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind (-673)
/* complex XML schema type 'eml23:PropertyKind': */
class SOAP_CMAC eml23__PropertyKind : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:IsAbstract' of XML schema type 'xsd:boolean'
        bool IsAbstract;
        /// Optional element 'eml23:DeprecationDate' of XML schema type 'eml23:TimeStamp'
        struct tm *DeprecationDate;
        /// Required element 'eml23:QuantityClass' of XML schema type 'eml23:QuantityClassKindExt'
        std::string QuantityClass;
        /// Optional element 'eml23:Parent' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Parent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PropertyKind, default initialized and not managed by a soap context
        virtual eml23__PropertyKind *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PropertyKind); }
      public:
        /// Constructor with default initializations
        eml23__PropertyKind() : IsAbstract(), DeprecationDate(), QuantityClass(), Parent() { }
        virtual ~eml23__PropertyKind() { }
        /// Friend allocator used by soap_new_eml23__PropertyKind(struct soap*, int)
        friend SOAP_FMAC1 eml23__PropertyKind * SOAP_FMAC2 soap_instantiate_eml23__PropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1473 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary (-674)
/* Type eml23__PropertyKindDictionary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:PropertyKindDictionary': */
class SOAP_CMAC eml23__PropertyKindDictionary : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:PropertyKind' of XML schema type 'eml23:PropertyKind'
        std::vector<eml23__PropertyKind *> PropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PropertyKindDictionary, default initialized and not managed by a soap context
        virtual eml23__PropertyKindDictionary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PropertyKindDictionary); }
      public:
        /// Constructor with default initializations
        eml23__PropertyKindDictionary() : PropertyKind() { }
        virtual ~eml23__PropertyKindDictionary() { }
        /// Friend allocator used by soap_new_eml23__PropertyKindDictionary(struct soap*, int)
        friend SOAP_FMAC1 eml23__PropertyKindDictionary * SOAP_FMAC2 soap_instantiate_eml23__PropertyKindDictionary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1481 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries (-678)
/* Type eml23__TimeSeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:TimeSeries': */
class SOAP_CMAC eml23__TimeSeries : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Time' of XML schema type 'eml23:GeologicTime'
        std::vector<eml23__GeologicTime *> Time;
        /// Optional element 'eml23:TimeStep' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *TimeStep;
        /// Optional element 'eml23:TimeSeriesParentage' of XML schema type 'eml23:TimeSeriesParentage'
        eml23__TimeSeriesParentage *TimeSeriesParentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeSeries, default initialized and not managed by a soap context
        virtual eml23__TimeSeries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeSeries); }
      public:
        /// Constructor with default initializations
        eml23__TimeSeries() : Time(), TimeStep(), TimeSeriesParentage() { }
        virtual ~eml23__TimeSeries() { }
        /// Friend allocator used by soap_new_eml23__TimeSeries(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeSeries * SOAP_FMAC2 soap_instantiate_eml23__TimeSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1491 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Activity
#define SOAP_TYPE_gsoap_eml2_3_eml23__Activity (-683)
/* Type eml23__Activity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:Activity': */
class SOAP_CMAC eml23__Activity : public eml23__AbstractObject {
      public:
        /// Optional element 'eml23:Parent' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Parent;
        /// Required element 'eml23:ActivityDescriptor' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ActivityDescriptor;
        /// Required element 'eml23:Parameter' of XML schema type 'eml23:AbstractActivityParameter'
        std::vector<eml23__AbstractActivityParameter *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Activity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Activity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Activity, default initialized and not managed by a soap context
        virtual eml23__Activity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Activity); }
      public:
        /// Constructor with default initializations
        eml23__Activity() : Parent(), ActivityDescriptor(), Parameter() { }
        virtual ~eml23__Activity() { }
        /// Friend allocator used by soap_new_eml23__Activity(struct soap*, int)
        friend SOAP_FMAC1 eml23__Activity * SOAP_FMAC2 soap_instantiate_eml23__Activity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1493 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate (-684)
/* Type eml23__ActivityTemplate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:ActivityTemplate': */
class SOAP_CMAC eml23__ActivityTemplate : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Parameter' of XML schema type 'eml23:ParameterTemplate'
        std::vector<eml23__ParameterTemplate *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ActivityTemplate, default initialized and not managed by a soap context
        virtual eml23__ActivityTemplate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ActivityTemplate); }
      public:
        /// Constructor with default initializations
        eml23__ActivityTemplate() : Parameter() { }
        virtual ~eml23__ActivityTemplate() { }
        /// Friend allocator used by soap_new_eml23__ActivityTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml23__ActivityTemplate * SOAP_FMAC2 soap_instantiate_eml23__ActivityTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1495 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter (-685)
/* complex XML schema type 'eml23:DataObjectParameter': */
class SOAP_CMAC eml23__DataObjectParameter : public eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:DataObject' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataObjectParameter, default initialized and not managed by a soap context
        virtual eml23__DataObjectParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataObjectParameter); }
      public:
        /// Constructor with default initializations
        eml23__DataObjectParameter() : DataObject() { }
        virtual ~eml23__DataObjectParameter() { }
        /// Friend allocator used by soap_new_eml23__DataObjectParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataObjectParameter * SOAP_FMAC2 soap_instantiate_eml23__DataObjectParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1497 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter (-686)
/* complex XML schema type 'eml23:DoubleQuantityParameter': */
class SOAP_CMAC eml23__DoubleQuantityParameter : public eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:double'
        double Value;
        /// Required element 'eml23:Uom' of XML schema type 'eml23:UnitOfMeasureExt'
        std::string Uom;
        /// Optional element 'eml23:CustomUnitDictionary' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *CustomUnitDictionary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DoubleQuantityParameter, default initialized and not managed by a soap context
        virtual eml23__DoubleQuantityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DoubleQuantityParameter); }
      public:
        /// Constructor with default initializations
        eml23__DoubleQuantityParameter() : Value(), Uom(), CustomUnitDictionary() { }
        virtual ~eml23__DoubleQuantityParameter() { }
        /// Friend allocator used by soap_new_eml23__DoubleQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__DoubleQuantityParameter * SOAP_FMAC2 soap_instantiate_eml23__DoubleQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1499 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter (-687)
/* complex XML schema type 'eml23:IntegerQuantityParameter': */
class SOAP_CMAC eml23__IntegerQuantityParameter : public eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IntegerQuantityParameter, default initialized and not managed by a soap context
        virtual eml23__IntegerQuantityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IntegerQuantityParameter); }
      public:
        /// Constructor with default initializations
        eml23__IntegerQuantityParameter() : Value() { }
        virtual ~eml23__IntegerQuantityParameter() { }
        /// Friend allocator used by soap_new_eml23__IntegerQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__IntegerQuantityParameter * SOAP_FMAC2 soap_instantiate_eml23__IntegerQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1501 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey (-688)
/* complex XML schema type 'eml23:ObjectParameterKey': */
class SOAP_CMAC eml23__ObjectParameterKey : public eml23__AbstractParameterKey {
      public:
        /// Required element 'eml23:DataObject' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ObjectParameterKey, default initialized and not managed by a soap context
        virtual eml23__ObjectParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ObjectParameterKey); }
      public:
        /// Constructor with default initializations
        eml23__ObjectParameterKey() : DataObject() { }
        virtual ~eml23__ObjectParameterKey() { }
        /// Friend allocator used by soap_new_eml23__ObjectParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml23__ObjectParameterKey * SOAP_FMAC2 soap_instantiate_eml23__ObjectParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1505 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter (-690)
/* complex XML schema type 'eml23:StringParameter': */
class SOAP_CMAC eml23__StringParameter : public eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:Value' of XML schema type 'eml23:String2000'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__StringParameter, default initialized and not managed by a soap context
        virtual eml23__StringParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__StringParameter); }
      public:
        /// Constructor with default initializations
        eml23__StringParameter() : Value() { }
        virtual ~eml23__StringParameter() { }
        /// Friend allocator used by soap_new_eml23__StringParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__StringParameter * SOAP_FMAC2 soap_instantiate_eml23__StringParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1507 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter (-691)
/* complex XML schema type 'eml23:TimeIndexParameter': */
class SOAP_CMAC eml23__TimeIndexParameter : public eml23__AbstractActivityParameter {
      public:
        /// Required element 'eml23:TimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeIndexParameter, default initialized and not managed by a soap context
        virtual eml23__TimeIndexParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeIndexParameter); }
      public:
        /// Constructor with default initializations
        eml23__TimeIndexParameter() : TimeIndex() { }
        virtual ~eml23__TimeIndexParameter() { }
        /// Friend allocator used by soap_new_eml23__TimeIndexParameter(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeIndexParameter * SOAP_FMAC2 soap_instantiate_eml23__TimeIndexParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1509 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey (-692)
/* complex XML schema type 'eml23:TimeIndexParameterKey': */
class SOAP_CMAC eml23__TimeIndexParameterKey : public eml23__AbstractParameterKey {
      public:
        /// Required element 'eml23:TimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeIndexParameterKey, default initialized and not managed by a soap context
        virtual eml23__TimeIndexParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeIndexParameterKey); }
      public:
        /// Constructor with default initializations
        eml23__TimeIndexParameterKey() : TimeIndex() { }
        virtual ~eml23__TimeIndexParameterKey() { }
        /// Friend allocator used by soap_new_eml23__TimeIndexParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeIndexParameterKey * SOAP_FMAC2 soap_instantiate_eml23__TimeIndexParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1511 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate
#define SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate (-693)
/* Type eml23__Aggregate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:Aggregate': */
class SOAP_CMAC eml23__Aggregate : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:AggregateMember' of XML schema type 'eml23:AbstractObject'
        std::vector<eml23__AbstractObject *> AggregateMember;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Aggregate, default initialized and not managed by a soap context
        virtual eml23__Aggregate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Aggregate); }
      public:
        /// Constructor with default initializations
        eml23__Aggregate() : AggregateMember() { }
        virtual ~eml23__Aggregate() { }
        /// Friend allocator used by soap_new_eml23__Aggregate(struct soap*, int)
        friend SOAP_FMAC1 eml23__Aggregate * SOAP_FMAC2 soap_instantiate_eml23__Aggregate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1513 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Attachment
#define SOAP_TYPE_gsoap_eml2_3_eml23__Attachment (-694)
/* complex XML schema type 'eml23:Attachment': */
class SOAP_CMAC eml23__Attachment : public eml23__AbstractObject {
      public:
        /// Optional element 'eml23:Md' of XML schema type 'eml23:MeasuredDepthCoord'
        eml23__MeasuredDepthCoord *Md;
        /// Optional element 'eml23:SubObjectReference' of XML schema type 'eml23:String64'
        std::string *SubObjectReference;
        /// Optional element 'eml23:IndexableElementType' of XML schema type 'eml23:IndexableElement'
        eml23__IndexableElement *IndexableElementType;
        /// Optional element 'eml23:IndexableElementIndex' of XML schema type 'xsd:long'
        LONG64 *IndexableElementIndex;
        /// Optional element 'eml23:MdBit' of XML schema type 'eml23:MeasuredDepthCoord'
        eml23__MeasuredDepthCoord *MdBit;
        /// Optional element 'eml23:Category' of XML schema type 'eml23:String64'
        std::string *Category;
        /// Optional element 'eml23:FileName' of XML schema type 'eml23:String64'
        std::string *FileName;
        /// Optional element 'eml23:FileType' of XML schema type 'eml23:String64'
        std::string *FileType;
        /// Optional element 'eml23:ContentUri' of XML schema type 'xsd:anyURI'
        std::string *ContentUri;
        /// Required element 'eml23:Content' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary Content;
        /// Optional element 'eml23:ReferencedObject' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ReferencedObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Attachment
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Attachment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Attachment, default initialized and not managed by a soap context
        virtual eml23__Attachment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Attachment); }
      public:
        /// Constructor with default initializations
        eml23__Attachment() : Md(), SubObjectReference(), IndexableElementType(), IndexableElementIndex(), MdBit(), Category(), FileName(), FileType(), ContentUri(), Content(), ReferencedObject() { }
        virtual ~eml23__Attachment() { }
        /// Friend allocator used by soap_new_eml23__Attachment(struct soap*, int)
        friend SOAP_FMAC1 eml23__Attachment * SOAP_FMAC2 soap_instantiate_eml23__Attachment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1515 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate (-695)
/* complex XML schema type 'eml23:BusinessAssociate': */
class SOAP_CMAC eml23__BusinessAssociate : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Name' of XML schema type 'eml23:String64'
        std::string Name;
        /// Optional element 'eml23:Role' of XML schema type 'eml23:NameStruct'
        std::vector<eml23__NameStruct *> Role;
        /// Optional element 'eml23:Address' of XML schema type 'eml23:GeneralAddress'
        eml23__GeneralAddress *Address;
        /// Optional element 'eml23:Contact' of XML schema type 'eml23:String64'
        std::vector<std::string> Contact;
        /// Optional element 'eml23:PhoneNumber' of XML schema type 'eml23:PhoneNumberStruct'
        std::vector<eml23__PhoneNumberStruct *> PhoneNumber;
        /// Optional element 'eml23:Email' of XML schema type 'eml23:EmailQualifierStruct'
        std::vector<eml23__EmailQualifierStruct *> Email;
        /// Optional element 'eml23:AssociatedWith' of XML schema type 'eml23:String64'
        std::string *AssociatedWith;
        /// Optional element 'eml23:PersonnelCount' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *PersonnelCount;
        /// Optional element 'eml23:PersonName' of XML schema type 'eml23:PersonName'
        eml23__PersonName *PersonName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__BusinessAssociate, default initialized and not managed by a soap context
        virtual eml23__BusinessAssociate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__BusinessAssociate); }
      public:
        /// Constructor with default initializations
        eml23__BusinessAssociate() : Name(), Role(), Address(), Contact(), PhoneNumber(), Email(), AssociatedWith(), PersonnelCount(), PersonName() { }
        virtual ~eml23__BusinessAssociate() { }
        /// Friend allocator used by soap_new_eml23__BusinessAssociate(struct soap*, int)
        friend SOAP_FMAC1 eml23__BusinessAssociate * SOAP_FMAC2 soap_instantiate_eml23__BusinessAssociate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1527 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet (-701)
/* complex XML schema type 'eml23:CollectionsToDataobjectsAssociationSet': */
class SOAP_CMAC eml23__CollectionsToDataobjectsAssociationSet : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:SingleCollectionAssociation' of XML schema type 'eml23:SingleCollectionAssociation'
        std::vector<eml23__SingleCollectionAssociation *> SingleCollectionAssociation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CollectionsToDataobjectsAssociationSet, default initialized and not managed by a soap context
        virtual eml23__CollectionsToDataobjectsAssociationSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CollectionsToDataobjectsAssociationSet); }
      public:
        /// Constructor with default initializations
        eml23__CollectionsToDataobjectsAssociationSet() : SingleCollectionAssociation() { }
        virtual ~eml23__CollectionsToDataobjectsAssociationSet() { }
        /// Friend allocator used by soap_new_eml23__CollectionsToDataobjectsAssociationSet(struct soap*, int)
        friend SOAP_FMAC1 eml23__CollectionsToDataobjectsAssociationSet * SOAP_FMAC2 soap_instantiate_eml23__CollectionsToDataobjectsAssociationSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1529 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection (-702)
/* complex XML schema type 'eml23:DataobjectCollection': */
class SOAP_CMAC eml23__DataobjectCollection : public eml23__AbstractObject {
      public:
        /// Optional element 'eml23:Kind' of XML schema type 'eml23:CollectionKindExt'
        std::string *Kind;
        /// Optional element 'eml23:HomogeneousDatatype' of XML schema type 'xsd:string'
        std::string *HomogeneousDatatype;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataobjectCollection, default initialized and not managed by a soap context
        virtual eml23__DataobjectCollection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataobjectCollection); }
      public:
        /// Constructor with default initializations
        eml23__DataobjectCollection() : Kind(), HomogeneousDatatype() { }
        virtual ~eml23__DataobjectCollection() { }
        /// Friend allocator used by soap_new_eml23__DataobjectCollection(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataobjectCollection * SOAP_FMAC2 soap_instantiate_eml23__DataobjectCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1535 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable (-705)
/* complex XML schema type 'eml23:ColumnBasedTable': */
class SOAP_CMAC eml23__ColumnBasedTable : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:Column' of XML schema type 'eml23:Column'
        std::vector<eml23__Column *> Column;
        /// Optional element 'eml23:KeyColumn' of XML schema type 'eml23:Column'
        std::vector<eml23__Column *> KeyColumn;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ColumnBasedTable, default initialized and not managed by a soap context
        virtual eml23__ColumnBasedTable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ColumnBasedTable); }
      public:
        /// Constructor with default initializations
        eml23__ColumnBasedTable() : Column(), KeyColumn() { }
        virtual ~eml23__ColumnBasedTable() { }
        /// Friend allocator used by soap_new_eml23__ColumnBasedTable(struct soap*, int)
        friend SOAP_FMAC1 eml23__ColumnBasedTable * SOAP_FMAC2 soap_instantiate_eml23__ColumnBasedTable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1539 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord (-707)
/* complex XML schema type 'eml23:DataAssuranceRecord': */
class SOAP_CMAC eml23__DataAssuranceRecord : public eml23__AbstractObject {
      public:
        /// Required element 'eml23:PolicyId' of XML schema type 'eml23:String64'
        std::string PolicyId;
        /// Optional element 'eml23:PolicyName' of XML schema type 'eml23:String2000'
        std::string *PolicyName;
        /// Optional element 'eml23:ReferencedElementName' of XML schema type 'eml23:String64'
        std::string *ReferencedElementName;
        /// Optional element 'eml23:ReferencedElementUid' of XML schema type 'eml23:String64'
        std::string *ReferencedElementUid;
        /// Required element 'eml23:Origin' of XML schema type 'eml23:String2000'
        std::string Origin;
        /// Required element 'eml23:Conformance' of XML schema type 'xsd:boolean'
        bool Conformance;
        /// Typedef eml23__TimeStamp with custom serializer for struct tm
        struct tm Date;
        /// Optional element 'eml23:Comment' of XML schema type 'eml23:String2000'
        std::string *Comment;
        /// Optional element 'eml23:IndexRange' of XML schema type 'eml23:IndexRange'
        eml23__IndexRange *IndexRange;
        /// Optional element 'eml23:FailingRules' of XML schema type 'eml23:FailingRule'
        std::vector<eml23__FailingRule *> FailingRules;
        /// Required element 'eml23:ReferencedData' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ReferencedData;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataAssuranceRecord, default initialized and not managed by a soap context
        virtual eml23__DataAssuranceRecord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataAssuranceRecord); }
      public:
        /// Constructor with default initializations
        eml23__DataAssuranceRecord() : PolicyId(), PolicyName(), ReferencedElementName(), ReferencedElementUid(), Origin(), Conformance(), Date(), Comment(), IndexRange(), FailingRules(), ReferencedData() { }
        virtual ~eml23__DataAssuranceRecord() { }
        /// Friend allocator used by soap_new_eml23__DataAssuranceRecord(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataAssuranceRecord * SOAP_FMAC2 soap_instantiate_eml23__DataAssuranceRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1547 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet (-711)
/* complex XML schema type 'eml23:GraphicalInformationSet': */
class SOAP_CMAC eml23__GraphicalInformationSet : public eml23__AbstractObject {
      public:
        /// Optional element 'eml23:GraphicalInformation' of XML schema type 'eml23:AbstractGraphicalInformation'
        std::vector<eml23__AbstractGraphicalInformation *> GraphicalInformation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GraphicalInformationSet, default initialized and not managed by a soap context
        virtual eml23__GraphicalInformationSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GraphicalInformationSet); }
      public:
        /// Constructor with default initializations
        eml23__GraphicalInformationSet() : GraphicalInformation() { }
        virtual ~eml23__GraphicalInformationSet() { }
        /// Friend allocator used by soap_new_eml23__GraphicalInformationSet(struct soap*, int)
        friend SOAP_FMAC1 eml23__GraphicalInformationSet * SOAP_FMAC2 soap_instantiate_eml23__GraphicalInformationSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1549 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure (-712)
/* complex XML schema type 'eml23:AbsolutePressure': */
class SOAP_CMAC eml23__AbsolutePressure : public eml23__AbstractPressureValue {
      public:
        /// Required element 'eml23:AbsolutePressure' of XML schema type 'eml23:PressureMeasureExt'
        eml23__PressureMeasureExt *AbsolutePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbsolutePressure, default initialized and not managed by a soap context
        virtual eml23__AbsolutePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbsolutePressure); }
      public:
        /// Constructor with default initializations
        eml23__AbsolutePressure() : AbsolutePressure() { }
        virtual ~eml23__AbsolutePressure() { }
        /// Friend allocator used by soap_new_eml23__AbsolutePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbsolutePressure * SOAP_FMAC2 soap_instantiate_eml23__AbsolutePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1559 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure (-717)
/* complex XML schema type 'eml23:GaugePressure': */
class SOAP_CMAC eml23__GaugePressure : public eml23__AbstractPressureValue {
      public:
        /// Required element 'eml23:GaugePressure' of XML schema type 'eml23:PressureMeasureExt'
        eml23__PressureMeasureExt *GaugePressure;
        /// Optional element 'eml23:ReferencePressure' of XML schema type 'eml23:ReferencePressure'
        eml23__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GaugePressure, default initialized and not managed by a soap context
        virtual eml23__GaugePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GaugePressure); }
      public:
        /// Constructor with default initializations
        eml23__GaugePressure() : GaugePressure(), ReferencePressure() { }
        virtual ~eml23__GaugePressure() { }
        /// Friend allocator used by soap_new_eml23__GaugePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__GaugePressure * SOAP_FMAC2 soap_instantiate_eml23__GaugePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:24727 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__union_ReferenceTemperaturePressure_
#define SOAP_TYPE_gsoap_eml2_3__eml23__union_ReferenceTemperaturePressure_ (-1408)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml23__union_ReferenceTemperaturePressure_
{
        #define SOAP_UNION_gsoap_eml2_3__eml23__union_ReferenceTemperaturePressure__ReferenceTempPres	(1)	/**< union variant selector value for member ReferenceTempPres */
        std::string *ReferenceTempPres;
};
#endif

/* eml2_3ForGsoap.h:1565 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure (-720)
/* complex XML schema type 'eml23:ReferenceTemperaturePressure': */
class SOAP_CMAC eml23__ReferenceTemperaturePressure : public eml23__AbstractTemperaturePressure {
      public:
        /// Union with union _eml23__union_ReferenceTemperaturePressure_ variant selector __union_ReferenceTemperaturePressure_ set to one of: SOAP_UNION_gsoap_eml2_3__eml23__union_ReferenceTemperaturePressure__ReferenceTempPres
        int __union_ReferenceTemperaturePressure_;
        union _eml23__union_ReferenceTemperaturePressure_ union_ReferenceTemperaturePressure_;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReferenceTemperaturePressure, default initialized and not managed by a soap context
        virtual eml23__ReferenceTemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReferenceTemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml23__ReferenceTemperaturePressure() : __union_ReferenceTemperaturePressure_() { }
        virtual ~eml23__ReferenceTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml23__ReferenceTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReferenceTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml23__ReferenceTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1567 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure (-721)
/* complex XML schema type 'eml23:RelativePressure': */
class SOAP_CMAC eml23__RelativePressure : public eml23__AbstractPressureValue {
      public:
        /// Required element 'eml23:RelativePressure' of XML schema type 'eml23:PressureMeasure'
        eml23__PressureMeasure *RelativePressure;
        /// Required element 'eml23:ReferencePressure' of XML schema type 'eml23:ReferencePressure'
        eml23__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RelativePressure, default initialized and not managed by a soap context
        virtual eml23__RelativePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RelativePressure); }
      public:
        /// Constructor with default initializations
        eml23__RelativePressure() : RelativePressure(), ReferencePressure() { }
        virtual ~eml23__RelativePressure() { }
        /// Friend allocator used by soap_new_eml23__RelativePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__RelativePressure * SOAP_FMAC2 soap_instantiate_eml23__RelativePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1569 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure (-722)
/* complex XML schema type 'eml23:TemperaturePressure': */
class SOAP_CMAC eml23__TemperaturePressure : public eml23__AbstractTemperaturePressure {
      public:
        /// Required element 'eml23:Temperature' of XML schema type 'eml23:ThermodynamicTemperatureMeasure'
        eml23__ThermodynamicTemperatureMeasure *Temperature;
        /// Required element 'eml23:Pressure' of XML schema type 'eml23:PressureMeasure'
        eml23__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperaturePressure, default initialized and not managed by a soap context
        virtual eml23__TemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml23__TemperaturePressure() : Temperature(), Pressure() { }
        virtual ~eml23__TemperaturePressure() { }
        /// Friend allocator used by soap_new_eml23__TemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperaturePressure * SOAP_FMAC2 soap_instantiate_eml23__TemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:163 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature (-19)
/* complex XML schema type 'resqml22:AbstractTechnicalFeature': */
class SOAP_CMAC resqml22__AbstractTechnicalFeature : public resqml22__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractTechnicalFeature, default initialized and not managed by a soap context
        virtual resqml22__AbstractTechnicalFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractTechnicalFeature); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractTechnicalFeature() { }
        virtual ~resqml22__AbstractTechnicalFeature() { }
        /// Friend allocator used by soap_new_resqml22__AbstractTechnicalFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractTechnicalFeature * SOAP_FMAC2 soap_instantiate_resqml22__AbstractTechnicalFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:165 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature (-20)
/* Type resqml22__BoundaryFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:BoundaryFeature': */
class SOAP_CMAC resqml22__BoundaryFeature : public resqml22__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BoundaryFeature, default initialized and not managed by a soap context
        virtual resqml22__BoundaryFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BoundaryFeature); }
      public:
        /// Constructor with default initializations
        resqml22__BoundaryFeature() { }
        virtual ~resqml22__BoundaryFeature() { }
        /// Friend allocator used by soap_new_resqml22__BoundaryFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BoundaryFeature * SOAP_FMAC2 soap_instantiate_resqml22__BoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:169 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Model
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Model (-22)
/* Type resqml22__Model is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Model': */
class SOAP_CMAC resqml22__Model : public resqml22__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Model
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Model; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Model, default initialized and not managed by a soap context
        virtual resqml22__Model *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Model); }
      public:
        /// Constructor with default initializations
        resqml22__Model() { }
        virtual ~resqml22__Model() { }
        /// Friend allocator used by soap_new_resqml22__Model(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Model * SOAP_FMAC2 soap_instantiate_resqml22__Model(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:171 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature (-23)
/* Type resqml22__RockVolumeFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:RockVolumeFeature': */
class SOAP_CMAC resqml22__RockVolumeFeature : public resqml22__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RockVolumeFeature, default initialized and not managed by a soap context
        virtual resqml22__RockVolumeFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RockVolumeFeature); }
      public:
        /// Constructor with default initializations
        resqml22__RockVolumeFeature() { }
        virtual ~resqml22__RockVolumeFeature() { }
        /// Friend allocator used by soap_new_resqml22__RockVolumeFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RockVolumeFeature * SOAP_FMAC2 soap_instantiate_resqml22__RockVolumeFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:183 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation (-29)
/* Type resqml22__Graph2dRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Graph2dRepresentation': */
class SOAP_CMAC resqml22__Graph2dRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:Edges' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *Edges;
        /// Required element 'resqml22:isDirected' of XML schema type 'xsd:boolean'
        bool isDirected;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:PointGeometry'
        resqml22__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Graph2dRepresentation, default initialized and not managed by a soap context
        virtual resqml22__Graph2dRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Graph2dRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__Graph2dRepresentation() : Edges(), isDirected(), Geometry() { }
        virtual ~resqml22__Graph2dRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__Graph2dRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Graph2dRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__Graph2dRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:185 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry (-30)
/* complex XML schema type 'resqml22:HorizontalPlaneGeometry': */
class SOAP_CMAC resqml22__HorizontalPlaneGeometry : public resqml22__AbstractPlaneGeometry {
      public:
        /// Required element 'resqml22:Coordinate' of XML schema type 'xsd:double'
        double Coordinate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__HorizontalPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml22__HorizontalPlaneGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__HorizontalPlaneGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__HorizontalPlaneGeometry() : Coordinate() { }
        virtual ~resqml22__HorizontalPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml22__HorizontalPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__HorizontalPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml22__HorizontalPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:189 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry (-32)
/* complex XML schema type 'resqml22:ParametricLineFromRepresentationGeometry': */
class SOAP_CMAC resqml22__ParametricLineFromRepresentationGeometry : public resqml22__AbstractParametricLineGeometry {
      public:
        /// Required element 'resqml22:LineIndexOnSupportingRepresentation' of XML schema type 'eml23:NonNegativeLong'
        LONG64 LineIndexOnSupportingRepresentation;
        /// Required element 'resqml22:SupportingRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ParametricLineFromRepresentationGeometry, default initialized and not managed by a soap context
        virtual resqml22__ParametricLineFromRepresentationGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ParametricLineFromRepresentationGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__ParametricLineFromRepresentationGeometry() : LineIndexOnSupportingRepresentation(), SupportingRepresentation() { }
        virtual ~resqml22__ParametricLineFromRepresentationGeometry() { }
        /// Friend allocator used by soap_new_resqml22__ParametricLineFromRepresentationGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ParametricLineFromRepresentationGeometry * SOAP_FMAC2 soap_instantiate_resqml22__ParametricLineFromRepresentationGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:193 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry (-34)
/* complex XML schema type 'resqml22:ParametricLineGeometry': */
class SOAP_CMAC resqml22__ParametricLineGeometry : public resqml22__AbstractParametricLineGeometry {
      public:
        /// Optional element 'resqml22:ControlPointParameters' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *ControlPointParameters;
        /// Required element 'resqml22:ControlPoints' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *ControlPoints;
        /// Required element 'resqml22:KnotCount' of XML schema type 'eml23:PositiveLong'
        LONG64 KnotCount;
        /// Required element 'resqml22:LineKindIndex' of XML schema type 'xsd:long'
        LONG64 LineKindIndex;
        /// Optional element 'resqml22:TangentVectors' of XML schema type 'resqml22:AbstractPoint3dArray'
        resqml22__AbstractPoint3dArray *TangentVectors;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ParametricLineGeometry, default initialized and not managed by a soap context
        virtual resqml22__ParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ParametricLineGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__ParametricLineGeometry() : ControlPointParameters(), ControlPoints(), KnotCount(), LineKindIndex(), TangentVectors() { }
        virtual ~resqml22__ParametricLineGeometry() { }
        /// Friend allocator used by soap_new_resqml22__ParametricLineGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ParametricLineGeometry * SOAP_FMAC2 soap_instantiate_resqml22__ParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:219 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry (-47)
/* complex XML schema type 'resqml22:TiltedPlaneGeometry': */
class SOAP_CMAC resqml22__TiltedPlaneGeometry : public resqml22__AbstractPlaneGeometry {
      public:
        /// Required element 'resqml22:Plane' of XML schema type 'resqml22:ThreePoint3d'
        std::vector<resqml22__ThreePoint3d *> Plane;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TiltedPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml22__TiltedPlaneGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TiltedPlaneGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__TiltedPlaneGeometry() : Plane() { }
        virtual ~resqml22__TiltedPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml22__TiltedPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TiltedPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml22__TiltedPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:231 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation (-53)
/* Type resqml22__Seismic2dPostStackRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Seismic2dPostStackRepresentation': */
class SOAP_CMAC resqml22__Seismic2dPostStackRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:SeismicLineSubSampling' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *SeismicLineSubSampling;
        /// Required element 'resqml22:TraceSampling' of XML schema type 'eml23:FloatingPointLatticeArray'
        eml23__FloatingPointLatticeArray *TraceSampling;
        /// Required element 'resqml22:SeismicLineRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SeismicLineRepresentation;
        /// Required element 'resqml22:LocalCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Seismic2dPostStackRepresentation, default initialized and not managed by a soap context
        virtual resqml22__Seismic2dPostStackRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Seismic2dPostStackRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__Seismic2dPostStackRepresentation() : SeismicLineSubSampling(), TraceSampling(), SeismicLineRepresentation(), LocalCrs() { }
        virtual ~resqml22__Seismic2dPostStackRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__Seismic2dPostStackRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Seismic2dPostStackRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__Seismic2dPostStackRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:249 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation (-62)
/* Type resqml22__AbstractSurfaceRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractSurfaceRepresentation': */
class SOAP_CMAC resqml22__AbstractSurfaceRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:SurfaceRole' of XML schema type 'resqml22:SurfaceRole'
        resqml22__SurfaceRole SurfaceRole;
        /// Optional element 'resqml22:Boundaries' of XML schema type 'resqml22:PatchBoundaries'
        std::vector<resqml22__PatchBoundaries *> Boundaries;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSurfaceRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractSurfaceRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSurfaceRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSurfaceRepresentation() : SurfaceRole(), Boundaries() { }
        virtual ~resqml22__AbstractSurfaceRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSurfaceRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSurfaceRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSurfaceRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:269 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation (-72)
/* Type resqml22__PointSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:PointSetRepresentation': */
class SOAP_CMAC resqml22__PointSetRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:NodePatch' of XML schema type 'resqml22:NodePatch'
        std::vector<resqml22__NodePatch *> NodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PointSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__PointSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PointSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__PointSetRepresentation() : NodePatch() { }
        virtual ~resqml22__PointSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__PointSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PointSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__PointSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:271 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation (-73)
/* Type resqml22__PolylineRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:PolylineRepresentation': */
class SOAP_CMAC resqml22__PolylineRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Optional element 'resqml22:LineRole' of XML schema type 'resqml22:LineRoleExt'
        std::string *LineRole;
        /// Required element 'resqml22:IsClosed' of XML schema type 'xsd:boolean'
        bool IsClosed;
        /// Required element 'resqml22:NodePatch' of XML schema type 'resqml22:NodePatch'
        resqml22__NodePatch *NodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PolylineRepresentation, default initialized and not managed by a soap context
        virtual resqml22__PolylineRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PolylineRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__PolylineRepresentation() : LineRole(), IsClosed(), NodePatch() { }
        virtual ~resqml22__PolylineRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__PolylineRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PolylineRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__PolylineRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:273 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation (-74)
/* Type resqml22__PolylineSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:PolylineSetRepresentation': */
class SOAP_CMAC resqml22__PolylineSetRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Optional element 'resqml22:LineRole' of XML schema type 'resqml22:LineRoleExt'
        std::string *LineRole;
        /// Required element 'resqml22:LinePatch' of XML schema type 'resqml22:PolylineSetPatch'
        std::vector<resqml22__PolylineSetPatch *> LinePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PolylineSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__PolylineSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PolylineSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__PolylineSetRepresentation() : LineRole(), LinePatch() { }
        virtual ~resqml22__PolylineSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__PolylineSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PolylineSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__PolylineSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:295 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation (-85)
/* Type resqml22__AbstractOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractOrganizationInterpretation': */
class SOAP_CMAC resqml22__AbstractOrganizationInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml22:ContactInterpretation' of XML schema type 'resqml22:AbstractContactInterpretationPart'
        std::vector<resqml22__AbstractContactInterpretationPart *> ContactInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml22__AbstractOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractOrganizationInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractOrganizationInterpretation() : ContactInterpretation() { }
        virtual ~resqml22__AbstractOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:301 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation (-88)
/* Type resqml22__BoundaryFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:BoundaryFeatureInterpretation': */
class SOAP_CMAC resqml22__BoundaryFeatureInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml22:OlderPossibleAge' of XML schema type 'xsd:long'
        LONG64 *OlderPossibleAge;
        /// Optional element 'resqml22:YoungerPossibleAge' of XML schema type 'xsd:long'
        LONG64 *YoungerPossibleAge;
        /// Optional element 'resqml22:AbsoluteAge' of XML schema type 'eml23:GeologicTime'
        eml23__GeologicTime *AbsoluteAge;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BoundaryFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml22__BoundaryFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BoundaryFeatureInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__BoundaryFeatureInterpretation() : OlderPossibleAge(), YoungerPossibleAge(), AbsoluteAge() { }
        virtual ~resqml22__BoundaryFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__BoundaryFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BoundaryFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__BoundaryFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:307 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation (-91)
/* Type resqml22__EarthModelInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:EarthModelInterpretation': */
class SOAP_CMAC resqml22__EarthModelInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml22:StratigraphicOccurrences' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> StratigraphicOccurrences;
        /// Optional element 'resqml22:WellboreInterpretationSet' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> WellboreInterpretationSet;
        /// Optional element 'resqml22:StratigraphicColumn' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *StratigraphicColumn;
        /// Optional element 'resqml22:Structure' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Structure;
        /// Optional element 'resqml22:Fluid' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Fluid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__EarthModelInterpretation, default initialized and not managed by a soap context
        virtual resqml22__EarthModelInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__EarthModelInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__EarthModelInterpretation() : StratigraphicOccurrences(), WellboreInterpretationSet(), StratigraphicColumn(), Structure(), Fluid() { }
        virtual ~resqml22__EarthModelInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__EarthModelInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__EarthModelInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__EarthModelInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:315 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation (-95)
/* Type resqml22__GenericFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GenericFeatureInterpretation': */
class SOAP_CMAC resqml22__GenericFeatureInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GenericFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml22__GenericFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GenericFeatureInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__GenericFeatureInterpretation() { }
        virtual ~resqml22__GenericFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__GenericFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GenericFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__GenericFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:325 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation (-100)
/* Type resqml22__GeologicUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GeologicUnitInterpretation': */
class SOAP_CMAC resqml22__GeologicUnitInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml22:GeologicUnitComposition' of XML schema type 'eml23:LithologyKindExt'
        std::string *GeologicUnitComposition;
        /// Optional element 'resqml22:GeologicUnitMaterialEmplacement' of XML schema type 'resqml22:GeologicUnitMaterialEmplacement'
        resqml22__GeologicUnitMaterialEmplacement *GeologicUnitMaterialEmplacement;
        /// Optional element 'resqml22:GeologicUnit3dShape' of XML schema type 'resqml22:Shape3dExt'
        std::string *GeologicUnit3dShape;
        /// Optional element 'resqml22:DepositionalEnvironment' of XML schema type 'resqml22:DepositionalEnvironmentKind'
        std::string *DepositionalEnvironment;
        /// Optional element 'resqml22:DepositionalFacies' of XML schema type 'resqml22:DepositionalFaciesKind'
        resqml22__DepositionalFaciesKind *DepositionalFacies;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeologicUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml22__GeologicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeologicUnitInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__GeologicUnitInterpretation() : GeologicUnitComposition(), GeologicUnitMaterialEmplacement(), GeologicUnit3dShape(), DepositionalEnvironment(), DepositionalFacies() { }
        virtual ~resqml22__GeologicUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__GeologicUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeologicUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__GeologicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:371 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation (-123)
/* Type resqml22__RepresentationSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:RepresentationSetRepresentation': */
class SOAP_CMAC resqml22__RepresentationSetRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:IsHomogeneous' of XML schema type 'xsd:boolean'
        bool IsHomogeneous;
        /// Required element 'resqml22:Representation' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Representation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RepresentationSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__RepresentationSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RepresentationSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__RepresentationSetRepresentation() : IsHomogeneous(), Representation() { }
        virtual ~resqml22__RepresentationSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__RepresentationSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RepresentationSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__RepresentationSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:375 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation (-125)
/* Type resqml22__SubRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SubRepresentation': */
class SOAP_CMAC resqml22__SubRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Optional element 'resqml22:AdditionalGridTopology' of XML schema type 'resqml22:AdditionalGridTopology'
        resqml22__AdditionalGridTopology *AdditionalGridTopology;
        /// Required element 'resqml22:SupportingRepresentation' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> SupportingRepresentation;
        /// Required element 'resqml22:SubRepresentationPatch' of XML schema type 'resqml22:SubRepresentationPatch'
        std::vector<resqml22__SubRepresentationPatch *> SubRepresentationPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SubRepresentation, default initialized and not managed by a soap context
        virtual resqml22__SubRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SubRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__SubRepresentation() : AdditionalGridTopology(), SupportingRepresentation(), SubRepresentationPatch() { }
        virtual ~resqml22__SubRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__SubRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SubRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__SubRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:379 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet (-127)
/* Type resqml22__WellboreIntervalSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreIntervalSet': */
class SOAP_CMAC resqml22__WellboreIntervalSet : public resqml22__AbstractRepresentation {
      public:
        /// Optional element 'resqml22:IntervalBoundaries' of XML schema type 'resqml22:MarkerBoundary'
        std::vector<resqml22__MarkerBoundary *> IntervalBoundaries;
        /// Required element 'resqml22:MarkerInterval' of XML schema type 'resqml22:MarkerInterval'
        std::vector<resqml22__MarkerInterval *> MarkerInterval;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreIntervalSet, default initialized and not managed by a soap context
        virtual resqml22__WellboreIntervalSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreIntervalSet); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreIntervalSet() : IntervalBoundaries(), MarkerInterval() { }
        virtual ~resqml22__WellboreIntervalSet() { }
        /// Friend allocator used by soap_new_resqml22__WellboreIntervalSet(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreIntervalSet * SOAP_FMAC2 soap_instantiate_resqml22__WellboreIntervalSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:385 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry (-130)
/* complex XML schema type 'resqml22:AbstractGridGeometry': */
class SOAP_CMAC resqml22__AbstractGridGeometry : public resqml22__PointGeometry {
      public:
        /// Optional element 'resqml22:AdditionalGridPoints' of XML schema type 'resqml22:AdditionalGridPoints'
        std::vector<resqml22__AdditionalGridPoints *> AdditionalGridPoints;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractGridGeometry, default initialized and not managed by a soap context
        virtual resqml22__AbstractGridGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractGridGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractGridGeometry() : AdditionalGridPoints() { }
        virtual ~resqml22__AbstractGridGeometry() { }
        /// Friend allocator used by soap_new_resqml22__AbstractGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractGridGeometry * SOAP_FMAC2 soap_instantiate_resqml22__AbstractGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:387 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation (-131)
/* Type resqml22__AbstractGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractGridRepresentation': */
class SOAP_CMAC resqml22__AbstractGridRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Optional element 'resqml22:CellFluidPhaseUnits' of XML schema type 'resqml22:CellFluidPhaseUnits'
        resqml22__CellFluidPhaseUnits *CellFluidPhaseUnits;
        /// Optional element 'resqml22:ParentWindow' of XML schema type 'resqml22:AbstractParentWindow'
        resqml22__AbstractParentWindow *ParentWindow;
        /// Optional element 'resqml22:IntervalStratigraphicUnits' of XML schema type 'resqml22:IntervalStratigraphicUnits'
        resqml22__IntervalStratigraphicUnits *IntervalStratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractGridRepresentation() : CellFluidPhaseUnits(), ParentWindow(), IntervalStratigraphicUnits() { }
        virtual ~resqml22__AbstractGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:425 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation (-150)
/* Type resqml22__GridConnectionSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GridConnectionSetRepresentation': */
class SOAP_CMAC resqml22__GridConnectionSetRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'resqml22:CellIndexPairs' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *CellIndexPairs;
        /// Optional element 'resqml22:GridIndexPairs' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *GridIndexPairs;
        /// Optional element 'resqml22:LocalFacePerCellIndexPairs' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *LocalFacePerCellIndexPairs;
        /// Optional element 'resqml22:ConnectionInterpretations' of XML schema type 'resqml22:ConnectionInterpretations'
        resqml22__ConnectionInterpretations *ConnectionInterpretations;
        /// Required element 'resqml22:Grid' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Grid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GridConnectionSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__GridConnectionSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GridConnectionSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__GridConnectionSetRepresentation() : Count(), CellIndexPairs(), GridIndexPairs(), LocalFacePerCellIndexPairs(), ConnectionInterpretations(), Grid() { }
        virtual ~resqml22__GridConnectionSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__GridConnectionSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GridConnectionSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__GridConnectionSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:503 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap (-189)
/* Type resqml22__ContinuousColorMap is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:ContinuousColorMap': */
class SOAP_CMAC resqml22__ContinuousColorMap : public resqml22__AbstractColorMap {
      public:
        /// Required element 'resqml22:InterpolationDomain' of XML schema type 'resqml22:InterpolationDomain'
        resqml22__InterpolationDomain InterpolationDomain;
        /// Required element 'resqml22:InterpolationMethod' of XML schema type 'resqml22:InterpolationMethod'
        resqml22__InterpolationMethod InterpolationMethod;
        /// Required element 'resqml22:Entry' of XML schema type 'resqml22:ContinuousColorMapEntry'
        std::vector<resqml22__ContinuousColorMapEntry *> Entry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContinuousColorMap, default initialized and not managed by a soap context
        virtual resqml22__ContinuousColorMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContinuousColorMap); }
      public:
        /// Constructor with default initializations
        resqml22__ContinuousColorMap() : InterpolationDomain(), InterpolationMethod(), Entry() { }
        virtual ~resqml22__ContinuousColorMap() { }
        /// Friend allocator used by soap_new_resqml22__ContinuousColorMap(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContinuousColorMap * SOAP_FMAC2 soap_instantiate_resqml22__ContinuousColorMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:511 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap (-193)
/* Type resqml22__DiscreteColorMap is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:DiscreteColorMap': */
class SOAP_CMAC resqml22__DiscreteColorMap : public resqml22__AbstractColorMap {
      public:
        /// Required element 'resqml22:Entry' of XML schema type 'resqml22:DiscreteColorMapEntry'
        std::vector<resqml22__DiscreteColorMapEntry *> Entry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__DiscreteColorMap, default initialized and not managed by a soap context
        virtual resqml22__DiscreteColorMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__DiscreteColorMap); }
      public:
        /// Constructor with default initializations
        resqml22__DiscreteColorMap() : Entry() { }
        virtual ~resqml22__DiscreteColorMap() { }
        /// Friend allocator used by soap_new_resqml22__DiscreteColorMap(struct soap*, int)
        friend SOAP_FMAC1 resqml22__DiscreteColorMap * SOAP_FMAC2 soap_instantiate_resqml22__DiscreteColorMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:533 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty (-204)
/* Type resqml22__AbstractValuesProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractValuesProperty': */
class SOAP_CMAC resqml22__AbstractValuesProperty : public resqml22__AbstractProperty {
      public:
        /// Required element 'resqml22:ValuesForPatch' of XML schema type 'eml23:AbstractValueArray'
        std::vector<eml23__AbstractValueArray *> ValuesForPatch;
        /// Optional element 'resqml22:Facet' of XML schema type 'eml23:PropertyKindFacet'
        std::vector<eml23__PropertyKindFacet *> Facet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractValuesProperty, default initialized and not managed by a soap context
        virtual resqml22__AbstractValuesProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractValuesProperty); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractValuesProperty() : ValuesForPatch(), Facet() { }
        virtual ~resqml22__AbstractValuesProperty() { }
        /// Friend allocator used by soap_new_resqml22__AbstractValuesProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractValuesProperty * SOAP_FMAC2 soap_instantiate_resqml22__AbstractValuesProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:535 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray (-205)
/* complex XML schema type 'resqml22:BooleanArrayFromDiscretePropertyArray': */
class SOAP_CMAC resqml22__BooleanArrayFromDiscretePropertyArray : public eml23__AbstractBooleanArray {
      public:
        /// Required element 'resqml22:Value' of XML schema type 'xsd:long'
        LONG64 Value;
        /// Required element 'resqml22:Property' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Property;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BooleanArrayFromDiscretePropertyArray, default initialized and not managed by a soap context
        virtual resqml22__BooleanArrayFromDiscretePropertyArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BooleanArrayFromDiscretePropertyArray); }
      public:
        /// Constructor with default initializations
        resqml22__BooleanArrayFromDiscretePropertyArray() : Value(), Property() { }
        virtual ~resqml22__BooleanArrayFromDiscretePropertyArray() { }
        /// Friend allocator used by soap_new_resqml22__BooleanArrayFromDiscretePropertyArray(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BooleanArrayFromDiscretePropertyArray * SOAP_FMAC2 soap_instantiate_resqml22__BooleanArrayFromDiscretePropertyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:547 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty (-211)
/* Type resqml22__PointsProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:PointsProperty': */
class SOAP_CMAC resqml22__PointsProperty : public resqml22__AbstractProperty {
      public:
        /// Required element 'resqml22:PointsForPatch' of XML schema type 'resqml22:AbstractPoint3dArray'
        std::vector<resqml22__AbstractPoint3dArray *> PointsForPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PointsProperty, default initialized and not managed by a soap context
        virtual resqml22__PointsProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PointsProperty); }
      public:
        /// Constructor with default initializations
        resqml22__PointsProperty() : PointsForPatch() { }
        virtual ~resqml22__PointsProperty() { }
        /// Friend allocator used by soap_new_resqml22__PointsProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PointsProperty * SOAP_FMAC2 soap_instantiate_resqml22__PointsProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:551 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation (-213)
/* Type resqml22__StreamlinesRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StreamlinesRepresentation': */
class SOAP_CMAC resqml22__StreamlinesRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:LineCount' of XML schema type 'eml23:PositiveLong'
        LONG64 LineCount;
        /// Optional element 'resqml22:StreamlineWellbores' of XML schema type 'resqml22:StreamlineWellbores'
        resqml22__StreamlineWellbores *StreamlineWellbores;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:PolylineSetPatch'
        resqml22__PolylineSetPatch *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StreamlinesRepresentation, default initialized and not managed by a soap context
        virtual resqml22__StreamlinesRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StreamlinesRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__StreamlinesRepresentation() : LineCount(), StreamlineWellbores(), Geometry() { }
        virtual ~resqml22__StreamlinesRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__StreamlinesRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StreamlinesRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__StreamlinesRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:565 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation (-220)
/* Type resqml22__WellboreFrameRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreFrameRepresentation': */
class SOAP_CMAC resqml22__WellboreFrameRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:NodeCount' of XML schema type 'eml23:PositiveLong'
        LONG64 NodeCount;
        /// Required element 'resqml22:NodeMd' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *NodeMd;
        /// Optional element 'resqml22:WitsmlLog' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *WitsmlLog;
        /// Required element 'resqml22:Trajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Trajectory;
        /// Optional element 'resqml22:CellFluidPhaseUnits' of XML schema type 'resqml22:CellFluidPhaseUnits'
        resqml22__CellFluidPhaseUnits *CellFluidPhaseUnits;
        /// Optional element 'resqml22:IntervalStratigraphicUnits' of XML schema type 'resqml22:IntervalStratigraphicUnits'
        std::vector<resqml22__IntervalStratigraphicUnits *> IntervalStratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreFrameRepresentation, default initialized and not managed by a soap context
        virtual resqml22__WellboreFrameRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreFrameRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreFrameRepresentation() : NodeCount(), NodeMd(), WitsmlLog(), Trajectory(), CellFluidPhaseUnits(), IntervalStratigraphicUnits() { }
        virtual ~resqml22__WellboreFrameRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__WellboreFrameRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreFrameRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__WellboreFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:567 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation (-221)
/* Type resqml22__WellboreInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreInterpretation': */
class SOAP_CMAC resqml22__WellboreInterpretation : public resqml22__AbstractFeatureInterpretation {
      public:
        /// Required element 'resqml22:IsDrilled' of XML schema type 'xsd:boolean'
        bool IsDrilled;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreInterpretation, default initialized and not managed by a soap context
        virtual resqml22__WellboreInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreInterpretation() : IsDrilled() { }
        virtual ~resqml22__WellboreInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__WellboreInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__WellboreInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:575 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation (-225)
/* Type resqml22__WellboreTrajectoryRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreTrajectoryRepresentation': */
class SOAP_CMAC resqml22__WellboreTrajectoryRepresentation : public resqml22__AbstractRepresentation {
      public:
        /// Required element 'resqml22:StartMd' of XML schema type 'xsd:double'
        double StartMd;
        /// Required element 'resqml22:FinishMd' of XML schema type 'xsd:double'
        double FinishMd;
        /// Required element 'resqml22:MdUom' of XML schema type 'eml23:LengthUomExt'
        std::string MdUom;
        /// Optional element 'resqml22:CustomUnitDictionary' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *CustomUnitDictionary;
        /// Optional element 'resqml22:MdDomain' of XML schema type 'resqml22:MdDomain'
        resqml22__MdDomain *MdDomain;
        /// Optional element 'resqml22:WitsmlTrajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *WitsmlTrajectory;
        /// Required element 'resqml22:MdDatum' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *MdDatum;
        /// Optional element 'resqml22:ParentIntersection' of XML schema type 'resqml22:WellboreTrajectoryParentIntersection'
        resqml22__WellboreTrajectoryParentIntersection *ParentIntersection;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:AbstractParametricLineGeometry'
        resqml22__AbstractParametricLineGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreTrajectoryRepresentation, default initialized and not managed by a soap context
        virtual resqml22__WellboreTrajectoryRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreTrajectoryRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreTrajectoryRepresentation() : StartMd(), FinishMd(), MdUom(), CustomUnitDictionary(), MdDomain(), WitsmlTrajectory(), MdDatum(), ParentIntersection(), Geometry() { }
        virtual ~resqml22__WellboreTrajectoryRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__WellboreTrajectoryRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreTrajectoryRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__WellboreTrajectoryRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:603 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray (-239)
/* complex XML schema type 'eml23:AbstractFloatingPointArray': */
class SOAP_CMAC eml23__AbstractFloatingPointArray : public eml23__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractFloatingPointArray, default initialized and not managed by a soap context
        virtual eml23__AbstractFloatingPointArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractFloatingPointArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractFloatingPointArray() { }
        virtual ~eml23__AbstractFloatingPointArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractFloatingPointArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractFloatingPointArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractFloatingPointArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:605 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray (-240)
/* complex XML schema type 'eml23:AbstractIntegerArray': */
class SOAP_CMAC eml23__AbstractIntegerArray : public eml23__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbstractIntegerArray, default initialized and not managed by a soap context
        virtual eml23__AbstractIntegerArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbstractIntegerArray); }
      public:
        /// Constructor with default initializations
        eml23__AbstractIntegerArray() { }
        virtual ~eml23__AbstractIntegerArray() { }
        /// Friend allocator used by soap_new_eml23__AbstractIntegerArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbstractIntegerArray * SOAP_FMAC2 soap_instantiate_eml23__AbstractIntegerArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:615 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray (-245)
/* complex XML schema type 'eml23:BooleanArrayFromIndexArray': */
class SOAP_CMAC eml23__BooleanArrayFromIndexArray : public eml23__AbstractBooleanArray {
      public:
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
        /// Required element 'eml23:Indices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *Indices;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:boolean'
        bool *ValuesMode;
        /// Required element 'eml23:IndexIsTrue' of XML schema type 'xsd:boolean'
        bool IndexIsTrue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__BooleanArrayFromIndexArray, default initialized and not managed by a soap context
        virtual eml23__BooleanArrayFromIndexArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__BooleanArrayFromIndexArray); }
      public:
        /// Constructor with default initializations
        eml23__BooleanArrayFromIndexArray() : Count(), Indices(), ModePercentage(), ValuesMode(), IndexIsTrue() { }
        virtual ~eml23__BooleanArrayFromIndexArray() { }
        /// Friend allocator used by soap_new_eml23__BooleanArrayFromIndexArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__BooleanArrayFromIndexArray * SOAP_FMAC2 soap_instantiate_eml23__BooleanArrayFromIndexArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:617 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray (-246)
/* complex XML schema type 'eml23:BooleanConstantArray': */
class SOAP_CMAC eml23__BooleanConstantArray : public eml23__AbstractBooleanArray {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:boolean'
        bool Value;
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__BooleanConstantArray, default initialized and not managed by a soap context
        virtual eml23__BooleanConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__BooleanConstantArray); }
      public:
        /// Constructor with default initializations
        eml23__BooleanConstantArray() : Value(), Count() { }
        virtual ~eml23__BooleanConstantArray() { }
        /// Friend allocator used by soap_new_eml23__BooleanConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__BooleanConstantArray * SOAP_FMAC2 soap_instantiate_eml23__BooleanConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:619 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray (-247)
/* complex XML schema type 'eml23:BooleanExternalArray': */
class SOAP_CMAC eml23__BooleanExternalArray : public eml23__AbstractBooleanArray {
      public:
        /// Required element 'eml23:Values' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Values;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:boolean'
        bool *ValuesMode;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__BooleanExternalArray, default initialized and not managed by a soap context
        virtual eml23__BooleanExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__BooleanExternalArray); }
      public:
        /// Constructor with default initializations
        eml23__BooleanExternalArray() : Values(), ValuesMode(), ModePercentage() { }
        virtual ~eml23__BooleanExternalArray() { }
        /// Friend allocator used by soap_new_eml23__BooleanExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__BooleanExternalArray * SOAP_FMAC2 soap_instantiate_eml23__BooleanExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:621 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Cost
#define SOAP_TYPE_gsoap_eml2_3_eml23__Cost (-248)
/* simple XML schema type 'eml23:Cost': */
class SOAP_CMAC eml23__Cost {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'currency' of XML schema type 'eml23:String64'
        std::string currency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__Cost
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__Cost; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__Cost, default initialized and not managed by a soap context
        virtual eml23__Cost *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__Cost); }
      public:
        /// Constructor with default initializations
        eml23__Cost() : __item(), currency(), soap() { }
        virtual ~eml23__Cost() { }
        /// Friend allocator used by soap_new_eml23__Cost(struct soap*, int)
        friend SOAP_FMAC1 eml23__Cost * SOAP_FMAC2 soap_instantiate_eml23__Cost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:631 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure (-253)
/* simple XML schema type 'eml23:GenericMeasure': */
class SOAP_CMAC eml23__GenericMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:UomEnum'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__GenericMeasure, default initialized and not managed by a soap context
        virtual eml23__GenericMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__GenericMeasure); }
      public:
        /// Constructor with default initializations
        eml23__GenericMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__GenericMeasure() { }
        /// Friend allocator used by soap_new_eml23__GenericMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__GenericMeasure * SOAP_FMAC2 soap_instantiate_eml23__GenericMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:647 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray (-261)
/* complex XML schema type 'eml23:StringConstantArray': */
class SOAP_CMAC eml23__StringConstantArray : public eml23__AbstractStringArray {
      public:
        /// Required element 'eml23:Value' of XML schema type 'eml23:String2000'
        std::string Value;
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__StringConstantArray, default initialized and not managed by a soap context
        virtual eml23__StringConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__StringConstantArray); }
      public:
        /// Constructor with default initializations
        eml23__StringConstantArray() : Value(), Count() { }
        virtual ~eml23__StringConstantArray() { }
        /// Friend allocator used by soap_new_eml23__StringConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__StringConstantArray * SOAP_FMAC2 soap_instantiate_eml23__StringConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:649 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray (-262)
/* complex XML schema type 'eml23:StringExternalArray': */
class SOAP_CMAC eml23__StringExternalArray : public eml23__AbstractStringArray {
      public:
        /// Required element 'eml23:Values' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Values;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:string'
        std::string *ValuesMode;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__StringExternalArray, default initialized and not managed by a soap context
        virtual eml23__StringExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__StringExternalArray); }
      public:
        /// Constructor with default initializations
        eml23__StringExternalArray() : Values(), ValuesMode(), ModePercentage() { }
        virtual ~eml23__StringExternalArray() { }
        /// Friend allocator used by soap_new_eml23__StringExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__StringExternalArray * SOAP_FMAC2 soap_instantiate_eml23__StringExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:653 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray (-264)
/* complex XML schema type 'eml23:StringXmlArray': */
class SOAP_CMAC eml23__StringXmlArray : public eml23__AbstractStringArray {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:string'
        std::vector<std::string> Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__StringXmlArray, default initialized and not managed by a soap context
        virtual eml23__StringXmlArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__StringXmlArray); }
      public:
        /// Constructor with default initializations
        eml23__StringXmlArray() : Value() { }
        virtual ~eml23__StringXmlArray() { }
        /// Friend allocator used by soap_new_eml23__StringXmlArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__StringXmlArray * SOAP_FMAC2 soap_instantiate_eml23__StringXmlArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:671 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint
#define SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint (-273)
/* Type eml23__RecursiveReferencePoint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:RecursiveReferencePoint': */
class SOAP_CMAC eml23__RecursiveReferencePoint : public eml23__AbstractReferencePoint {
      public:
        /// Optional element 'eml23:VerticalCoordinate' of XML schema type 'xsd:double'
        double *VerticalCoordinate;
        /// Optional element 'eml23:HorizontalCoordinates' of XML schema type 'eml23:HorizontalCoordinates'
        eml23__HorizontalCoordinates *HorizontalCoordinates;
        /// Required element 'eml23:BaseReferencePoint' of XML schema type 'eml23:AbstractReferencePoint'
        eml23__AbstractReferencePoint *BaseReferencePoint;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RecursiveReferencePoint, default initialized and not managed by a soap context
        virtual eml23__RecursiveReferencePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RecursiveReferencePoint); }
      public:
        /// Constructor with default initializations
        eml23__RecursiveReferencePoint() : VerticalCoordinate(), HorizontalCoordinates(), BaseReferencePoint() { }
        virtual ~eml23__RecursiveReferencePoint() { }
        /// Friend allocator used by soap_new_eml23__RecursiveReferencePoint(struct soap*, int)
        friend SOAP_FMAC1 eml23__RecursiveReferencePoint * SOAP_FMAC2 soap_instantiate_eml23__RecursiveReferencePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:673 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs (-274)
/* Type eml23__ReferencePointInACrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:ReferencePointInACrs': */
class SOAP_CMAC eml23__ReferencePointInACrs : public eml23__AbstractReferencePoint {
      public:
        /// Required element 'eml23:VerticalCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *VerticalCrs;
        /// Optional element 'eml23:VerticalCoordinate' of XML schema type 'xsd:double'
        double *VerticalCoordinate;
        /// Optional element 'eml23:HorizontalCoordinates' of XML schema type 'eml23:AbstractHorizontalCoordinates'
        eml23__AbstractHorizontalCoordinates *HorizontalCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReferencePointInACrs, default initialized and not managed by a soap context
        virtual eml23__ReferencePointInACrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReferencePointInACrs); }
      public:
        /// Constructor with default initializations
        eml23__ReferencePointInACrs() : VerticalCrs(), VerticalCoordinate(), HorizontalCoordinates() { }
        virtual ~eml23__ReferencePointInACrs() { }
        /// Friend allocator used by soap_new_eml23__ReferencePointInACrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReferencePointInACrs * SOAP_FMAC2 soap_instantiate_eml23__ReferencePointInACrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:675 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs (-275)
/* Type eml23__ReferencePointInALocalEngineeringCompoundCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:ReferencePointInALocalEngineeringCompoundCrs': */
class SOAP_CMAC eml23__ReferencePointInALocalEngineeringCompoundCrs : public eml23__AbstractReferencePoint {
      public:
        /// Optional element 'eml23:Coordinates1And2' of XML schema type 'eml23:HorizontalCoordinates'
        eml23__HorizontalCoordinates *Coordinates1And2;
        /// Optional element 'eml23:Coordinate3' of XML schema type 'xsd:double'
        double *Coordinate3;
        /// Required element 'eml23:Crs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Crs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReferencePointInALocalEngineeringCompoundCrs, default initialized and not managed by a soap context
        virtual eml23__ReferencePointInALocalEngineeringCompoundCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReferencePointInALocalEngineeringCompoundCrs); }
      public:
        /// Constructor with default initializations
        eml23__ReferencePointInALocalEngineeringCompoundCrs() : Coordinates1And2(), Coordinate3(), Crs() { }
        virtual ~eml23__ReferencePointInALocalEngineeringCompoundCrs() { }
        /// Friend allocator used by soap_new_eml23__ReferencePointInALocalEngineeringCompoundCrs(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReferencePointInALocalEngineeringCompoundCrs * SOAP_FMAC2 soap_instantiate_eml23__ReferencePointInALocalEngineeringCompoundCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:685 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure (-280)
/* simple XML schema type 'eml23:AbsorbedDoseMeasure': */
class SOAP_CMAC eml23__AbsorbedDoseMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AbsorbedDoseUom'
        eml23__AbsorbedDoseUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbsorbedDoseMeasure, default initialized and not managed by a soap context
        virtual eml23__AbsorbedDoseMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbsorbedDoseMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AbsorbedDoseMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AbsorbedDoseMeasure() { }
        /// Friend allocator used by soap_new_eml23__AbsorbedDoseMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbsorbedDoseMeasure * SOAP_FMAC2 soap_instantiate_eml23__AbsorbedDoseMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:687 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt (-281)
/* simple XML schema type 'eml23:AbsorbedDoseMeasureExt': */
class SOAP_CMAC eml23__AbsorbedDoseMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AbsorbedDoseUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AbsorbedDoseMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AbsorbedDoseMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AbsorbedDoseMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AbsorbedDoseMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AbsorbedDoseMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AbsorbedDoseMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AbsorbedDoseMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AbsorbedDoseMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:689 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure (-282)
/* simple XML schema type 'eml23:ActivityOfRadioactivityMeasure': */
class SOAP_CMAC eml23__ActivityOfRadioactivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ActivityOfRadioactivityUom'
        eml23__ActivityOfRadioactivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ActivityOfRadioactivityMeasure, default initialized and not managed by a soap context
        virtual eml23__ActivityOfRadioactivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ActivityOfRadioactivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ActivityOfRadioactivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ActivityOfRadioactivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ActivityOfRadioactivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ActivityOfRadioactivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ActivityOfRadioactivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:691 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt (-283)
/* simple XML schema type 'eml23:ActivityOfRadioactivityMeasureExt': */
class SOAP_CMAC eml23__ActivityOfRadioactivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ActivityOfRadioactivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ActivityOfRadioactivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ActivityOfRadioactivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ActivityOfRadioactivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ActivityOfRadioactivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ActivityOfRadioactivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ActivityOfRadioactivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ActivityOfRadioactivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ActivityOfRadioactivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:693 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure (-284)
/* simple XML schema type 'eml23:AmountOfSubstanceMeasure': */
class SOAP_CMAC eml23__AmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstanceUom'
        eml23__AmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:695 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt (-285)
/* simple XML schema type 'eml23:AmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:697 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure (-286)
/* simple XML schema type 'eml23:AmountOfSubstancePerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml23__AmountOfSubstancePerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerAmountOfSubstanceUom'
        eml23__AmountOfSubstancePerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:699 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt (-287)
/* simple XML schema type 'eml23:AmountOfSubstancePerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:701 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure (-288)
/* simple XML schema type 'eml23:AmountOfSubstancePerAreaMeasure': */
class SOAP_CMAC eml23__AmountOfSubstancePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerAreaUom'
        eml23__AmountOfSubstancePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:703 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt (-289)
/* simple XML schema type 'eml23:AmountOfSubstancePerAreaMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstancePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:705 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure (-290)
/* simple XML schema type 'eml23:AmountOfSubstancePerTimeMeasure': */
class SOAP_CMAC eml23__AmountOfSubstancePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerTimeUom'
        eml23__AmountOfSubstancePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:707 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt (-291)
/* simple XML schema type 'eml23:AmountOfSubstancePerTimeMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstancePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:709 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure (-292)
/* simple XML schema type 'eml23:AmountOfSubstancePerTimePerAreaMeasure': */
class SOAP_CMAC eml23__AmountOfSubstancePerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerTimePerAreaUom'
        eml23__AmountOfSubstancePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:711 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt (-293)
/* simple XML schema type 'eml23:AmountOfSubstancePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstancePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:713 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure (-294)
/* simple XML schema type 'eml23:AmountOfSubstancePerVolumeMeasure': */
class SOAP_CMAC eml23__AmountOfSubstancePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerVolumeUom'
        eml23__AmountOfSubstancePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:715 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt (-295)
/* simple XML schema type 'eml23:AmountOfSubstancePerVolumeMeasureExt': */
class SOAP_CMAC eml23__AmountOfSubstancePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AmountOfSubstancePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AmountOfSubstancePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AmountOfSubstancePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AmountOfSubstancePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AmountOfSubstancePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AmountOfSubstancePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AmountOfSubstancePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:717 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure (-296)
/* simple XML schema type 'eml23:AnglePerLengthMeasure': */
class SOAP_CMAC eml23__AnglePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AnglePerLengthUom'
        eml23__AnglePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AnglePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__AnglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AnglePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AnglePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AnglePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__AnglePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AnglePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__AnglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:719 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt (-297)
/* simple XML schema type 'eml23:AnglePerLengthMeasureExt': */
class SOAP_CMAC eml23__AnglePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AnglePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AnglePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AnglePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AnglePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AnglePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AnglePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AnglePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AnglePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AnglePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:721 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure (-298)
/* simple XML schema type 'eml23:AnglePerVolumeMeasure': */
class SOAP_CMAC eml23__AnglePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AnglePerVolumeUom'
        eml23__AnglePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AnglePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__AnglePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AnglePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AnglePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AnglePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__AnglePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AnglePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__AnglePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:723 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt (-299)
/* simple XML schema type 'eml23:AnglePerVolumeMeasureExt': */
class SOAP_CMAC eml23__AnglePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AnglePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AnglePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AnglePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AnglePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AnglePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AnglePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AnglePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AnglePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AnglePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:725 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure (-300)
/* simple XML schema type 'eml23:AngularAccelerationMeasure': */
class SOAP_CMAC eml23__AngularAccelerationMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AngularAccelerationUom'
        eml23__AngularAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AngularAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml23__AngularAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AngularAccelerationMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AngularAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AngularAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml23__AngularAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AngularAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml23__AngularAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:727 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt (-301)
/* simple XML schema type 'eml23:AngularAccelerationMeasureExt': */
class SOAP_CMAC eml23__AngularAccelerationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AngularAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AngularAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AngularAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AngularAccelerationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AngularAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AngularAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AngularAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AngularAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AngularAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:729 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure (-302)
/* simple XML schema type 'eml23:AngularVelocityMeasure': */
class SOAP_CMAC eml23__AngularVelocityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AngularVelocityUom'
        eml23__AngularVelocityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AngularVelocityMeasure, default initialized and not managed by a soap context
        virtual eml23__AngularVelocityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AngularVelocityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AngularVelocityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AngularVelocityMeasure() { }
        /// Friend allocator used by soap_new_eml23__AngularVelocityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AngularVelocityMeasure * SOAP_FMAC2 soap_instantiate_eml23__AngularVelocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:731 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt (-303)
/* simple XML schema type 'eml23:AngularVelocityMeasureExt': */
class SOAP_CMAC eml23__AngularVelocityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AngularVelocityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AngularVelocityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AngularVelocityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AngularVelocityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AngularVelocityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AngularVelocityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AngularVelocityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AngularVelocityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AngularVelocityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:733 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure (-304)
/* simple XML schema type 'eml23:APIGammaRayMeasure': */
class SOAP_CMAC eml23__APIGammaRayMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APIGammaRayUom'
        eml23__APIGammaRayUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APIGammaRayMeasure, default initialized and not managed by a soap context
        virtual eml23__APIGammaRayMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APIGammaRayMeasure); }
      public:
        /// Constructor with default initializations
        eml23__APIGammaRayMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__APIGammaRayMeasure() { }
        /// Friend allocator used by soap_new_eml23__APIGammaRayMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__APIGammaRayMeasure * SOAP_FMAC2 soap_instantiate_eml23__APIGammaRayMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:735 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt (-305)
/* simple XML schema type 'eml23:APIGammaRayMeasureExt': */
class SOAP_CMAC eml23__APIGammaRayMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APIGammaRayUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APIGammaRayMeasureExt, default initialized and not managed by a soap context
        virtual eml23__APIGammaRayMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APIGammaRayMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__APIGammaRayMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__APIGammaRayMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__APIGammaRayMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__APIGammaRayMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__APIGammaRayMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:737 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure (-306)
/* simple XML schema type 'eml23:APIGravityMeasure': */
class SOAP_CMAC eml23__APIGravityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APIGravityUom'
        eml23__APIGravityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APIGravityMeasure, default initialized and not managed by a soap context
        virtual eml23__APIGravityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APIGravityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__APIGravityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__APIGravityMeasure() { }
        /// Friend allocator used by soap_new_eml23__APIGravityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__APIGravityMeasure * SOAP_FMAC2 soap_instantiate_eml23__APIGravityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:739 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt (-307)
/* simple XML schema type 'eml23:APIGravityMeasureExt': */
class SOAP_CMAC eml23__APIGravityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APIGravityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APIGravityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__APIGravityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APIGravityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__APIGravityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__APIGravityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__APIGravityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__APIGravityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__APIGravityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:741 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure (-308)
/* simple XML schema type 'eml23:APINeutronMeasure': */
class SOAP_CMAC eml23__APINeutronMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APINeutronUom'
        eml23__APINeutronUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APINeutronMeasure, default initialized and not managed by a soap context
        virtual eml23__APINeutronMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APINeutronMeasure); }
      public:
        /// Constructor with default initializations
        eml23__APINeutronMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__APINeutronMeasure() { }
        /// Friend allocator used by soap_new_eml23__APINeutronMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__APINeutronMeasure * SOAP_FMAC2 soap_instantiate_eml23__APINeutronMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:743 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt (-309)
/* simple XML schema type 'eml23:APINeutronMeasureExt': */
class SOAP_CMAC eml23__APINeutronMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:APINeutronUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__APINeutronMeasureExt, default initialized and not managed by a soap context
        virtual eml23__APINeutronMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__APINeutronMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__APINeutronMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__APINeutronMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__APINeutronMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__APINeutronMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__APINeutronMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:745 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure (-310)
/* simple XML schema type 'eml23:AreaMeasure': */
class SOAP_CMAC eml23__AreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaUom'
        eml23__AreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:747 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt (-311)
/* simple XML schema type 'eml23:AreaMeasureExt': */
class SOAP_CMAC eml23__AreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:749 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure (-312)
/* simple XML schema type 'eml23:AreaPerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml23__AreaPerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerAmountOfSubstanceUom'
        eml23__AreaPerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:751 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt (-313)
/* simple XML schema type 'eml23:AreaPerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml23__AreaPerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:753 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure (-314)
/* simple XML schema type 'eml23:AreaPerAreaMeasure': */
class SOAP_CMAC eml23__AreaPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerAreaUom'
        eml23__AreaPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:755 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt (-315)
/* simple XML schema type 'eml23:AreaPerAreaMeasureExt': */
class SOAP_CMAC eml23__AreaPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:757 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure (-316)
/* simple XML schema type 'eml23:AreaPerCountMeasure': */
class SOAP_CMAC eml23__AreaPerCountMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerCountUom'
        eml23__AreaPerCountUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerCountMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerCountMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerCountMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerCountMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerCountMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerCountMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerCountMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerCountMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:759 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt (-317)
/* simple XML schema type 'eml23:AreaPerCountMeasureExt': */
class SOAP_CMAC eml23__AreaPerCountMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerCountUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerCountMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerCountMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerCountMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerCountMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerCountMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerCountMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerCountMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerCountMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:761 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure (-318)
/* simple XML schema type 'eml23:AreaPerMassMeasure': */
class SOAP_CMAC eml23__AreaPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerMassUom'
        eml23__AreaPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:763 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt (-319)
/* simple XML schema type 'eml23:AreaPerMassMeasureExt': */
class SOAP_CMAC eml23__AreaPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:765 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure (-320)
/* simple XML schema type 'eml23:AreaPerTimeMeasure': */
class SOAP_CMAC eml23__AreaPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerTimeUom'
        eml23__AreaPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:767 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt (-321)
/* simple XML schema type 'eml23:AreaPerTimeMeasureExt': */
class SOAP_CMAC eml23__AreaPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:769 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure (-322)
/* simple XML schema type 'eml23:AreaPerVolumeMeasure': */
class SOAP_CMAC eml23__AreaPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerVolumeUom'
        eml23__AreaPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__AreaPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__AreaPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__AreaPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:771 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt (-323)
/* simple XML schema type 'eml23:AreaPerVolumeMeasureExt': */
class SOAP_CMAC eml23__AreaPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AreaPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AreaPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AreaPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AreaPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AreaPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AreaPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AreaPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AreaPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AreaPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:773 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure (-324)
/* simple XML schema type 'eml23:AttenuationPerFrequencyIntervalMeasure': */
class SOAP_CMAC eml23__AttenuationPerFrequencyIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AttenuationPerFrequencyIntervalUom'
        eml23__AttenuationPerFrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AttenuationPerFrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml23__AttenuationPerFrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AttenuationPerFrequencyIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml23__AttenuationPerFrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__AttenuationPerFrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml23__AttenuationPerFrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__AttenuationPerFrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml23__AttenuationPerFrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:775 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt (-325)
/* simple XML schema type 'eml23:AttenuationPerFrequencyIntervalMeasureExt': */
class SOAP_CMAC eml23__AttenuationPerFrequencyIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:AttenuationPerFrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AttenuationPerFrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml23__AttenuationPerFrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AttenuationPerFrequencyIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__AttenuationPerFrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__AttenuationPerFrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__AttenuationPerFrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:777 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure (-326)
/* simple XML schema type 'eml23:CapacitanceMeasure': */
class SOAP_CMAC eml23__CapacitanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:CapacitanceUom'
        eml23__CapacitanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CapacitanceMeasure, default initialized and not managed by a soap context
        virtual eml23__CapacitanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CapacitanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__CapacitanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__CapacitanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__CapacitanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__CapacitanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__CapacitanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:779 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt (-327)
/* simple XML schema type 'eml23:CapacitanceMeasureExt': */
class SOAP_CMAC eml23__CapacitanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:CapacitanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CapacitanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__CapacitanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CapacitanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__CapacitanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__CapacitanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__CapacitanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__CapacitanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__CapacitanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:781 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure (-328)
/* simple XML schema type 'eml23:CationExchangeCapacityMeasure': */
class SOAP_CMAC eml23__CationExchangeCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:CationExchangeCapacityUom'
        eml23__CationExchangeCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CationExchangeCapacityMeasure, default initialized and not managed by a soap context
        virtual eml23__CationExchangeCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CationExchangeCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__CationExchangeCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__CationExchangeCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml23__CationExchangeCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__CationExchangeCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml23__CationExchangeCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:783 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt (-329)
/* simple XML schema type 'eml23:CationExchangeCapacityMeasureExt': */
class SOAP_CMAC eml23__CationExchangeCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:CationExchangeCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__CationExchangeCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__CationExchangeCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__CationExchangeCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__CationExchangeCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__CationExchangeCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__CationExchangeCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__CationExchangeCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__CationExchangeCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:785 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure (-330)
/* simple XML schema type 'eml23:DataTransferSpeedMeasure': */
class SOAP_CMAC eml23__DataTransferSpeedMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DataTransferSpeedUom'
        eml23__DataTransferSpeedUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataTransferSpeedMeasure, default initialized and not managed by a soap context
        virtual eml23__DataTransferSpeedMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataTransferSpeedMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DataTransferSpeedMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DataTransferSpeedMeasure() { }
        /// Friend allocator used by soap_new_eml23__DataTransferSpeedMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataTransferSpeedMeasure * SOAP_FMAC2 soap_instantiate_eml23__DataTransferSpeedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:787 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt (-331)
/* simple XML schema type 'eml23:DataTransferSpeedMeasureExt': */
class SOAP_CMAC eml23__DataTransferSpeedMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DataTransferSpeedUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DataTransferSpeedMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DataTransferSpeedMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DataTransferSpeedMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DataTransferSpeedMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DataTransferSpeedMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DataTransferSpeedMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DataTransferSpeedMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DataTransferSpeedMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:789 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure (-332)
/* simple XML schema type 'eml23:DiffusionCoefficientMeasure': */
class SOAP_CMAC eml23__DiffusionCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DiffusionCoefficientUom'
        eml23__DiffusionCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DiffusionCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml23__DiffusionCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DiffusionCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DiffusionCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DiffusionCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml23__DiffusionCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DiffusionCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml23__DiffusionCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:791 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt (-333)
/* simple XML schema type 'eml23:DiffusionCoefficientMeasureExt': */
class SOAP_CMAC eml23__DiffusionCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DiffusionCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DiffusionCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DiffusionCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DiffusionCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DiffusionCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DiffusionCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DiffusionCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DiffusionCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DiffusionCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:793 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure (-334)
/* simple XML schema type 'eml23:DiffusiveTimeOfFlightMeasure': */
class SOAP_CMAC eml23__DiffusiveTimeOfFlightMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DiffusiveTimeOfFlightUom'
        eml23__DiffusiveTimeOfFlightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DiffusiveTimeOfFlightMeasure, default initialized and not managed by a soap context
        virtual eml23__DiffusiveTimeOfFlightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DiffusiveTimeOfFlightMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DiffusiveTimeOfFlightMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DiffusiveTimeOfFlightMeasure() { }
        /// Friend allocator used by soap_new_eml23__DiffusiveTimeOfFlightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DiffusiveTimeOfFlightMeasure * SOAP_FMAC2 soap_instantiate_eml23__DiffusiveTimeOfFlightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:795 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt (-335)
/* simple XML schema type 'eml23:DiffusiveTimeOfFlightMeasureExt': */
class SOAP_CMAC eml23__DiffusiveTimeOfFlightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DiffusiveTimeOfFlightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DiffusiveTimeOfFlightMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DiffusiveTimeOfFlightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DiffusiveTimeOfFlightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DiffusiveTimeOfFlightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DiffusiveTimeOfFlightMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DiffusiveTimeOfFlightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DiffusiveTimeOfFlightMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DiffusiveTimeOfFlightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:797 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure (-336)
/* simple XML schema type 'eml23:DigitalStorageMeasure': */
class SOAP_CMAC eml23__DigitalStorageMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DigitalStorageUom'
        eml23__DigitalStorageUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DigitalStorageMeasure, default initialized and not managed by a soap context
        virtual eml23__DigitalStorageMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DigitalStorageMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DigitalStorageMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DigitalStorageMeasure() { }
        /// Friend allocator used by soap_new_eml23__DigitalStorageMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DigitalStorageMeasure * SOAP_FMAC2 soap_instantiate_eml23__DigitalStorageMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:799 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt (-337)
/* simple XML schema type 'eml23:DigitalStorageMeasureExt': */
class SOAP_CMAC eml23__DigitalStorageMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DigitalStorageUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DigitalStorageMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DigitalStorageMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DigitalStorageMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DigitalStorageMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DigitalStorageMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DigitalStorageMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DigitalStorageMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DigitalStorageMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:801 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure (-338)
/* simple XML schema type 'eml23:DimensionlessMeasure': */
class SOAP_CMAC eml23__DimensionlessMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DimensionlessUom'
        eml23__DimensionlessUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DimensionlessMeasure, default initialized and not managed by a soap context
        virtual eml23__DimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DimensionlessMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DimensionlessMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DimensionlessMeasure() { }
        /// Friend allocator used by soap_new_eml23__DimensionlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DimensionlessMeasure * SOAP_FMAC2 soap_instantiate_eml23__DimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:803 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt (-339)
/* simple XML schema type 'eml23:DimensionlessMeasureExt': */
class SOAP_CMAC eml23__DimensionlessMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DimensionlessUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DimensionlessMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DimensionlessMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DimensionlessMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DimensionlessMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DimensionlessMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DimensionlessMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DimensionlessMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DimensionlessMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:805 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure (-340)
/* simple XML schema type 'eml23:DipoleMomentMeasure': */
class SOAP_CMAC eml23__DipoleMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DipoleMomentUom'
        eml23__DipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml23__DipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DipoleMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml23__DipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml23__DipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:807 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt (-341)
/* simple XML schema type 'eml23:DipoleMomentMeasureExt': */
class SOAP_CMAC eml23__DipoleMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DipoleMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:809 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure (-342)
/* simple XML schema type 'eml23:DoseEquivalentMeasure': */
class SOAP_CMAC eml23__DoseEquivalentMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DoseEquivalentUom'
        eml23__DoseEquivalentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DoseEquivalentMeasure, default initialized and not managed by a soap context
        virtual eml23__DoseEquivalentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DoseEquivalentMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DoseEquivalentMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DoseEquivalentMeasure() { }
        /// Friend allocator used by soap_new_eml23__DoseEquivalentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DoseEquivalentMeasure * SOAP_FMAC2 soap_instantiate_eml23__DoseEquivalentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:811 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt (-343)
/* simple XML schema type 'eml23:DoseEquivalentMeasureExt': */
class SOAP_CMAC eml23__DoseEquivalentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DoseEquivalentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DoseEquivalentMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DoseEquivalentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DoseEquivalentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DoseEquivalentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DoseEquivalentMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DoseEquivalentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DoseEquivalentMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DoseEquivalentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:813 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure (-344)
/* simple XML schema type 'eml23:DynamicViscosityMeasure': */
class SOAP_CMAC eml23__DynamicViscosityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DynamicViscosityUom'
        eml23__DynamicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DynamicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml23__DynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DynamicViscosityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__DynamicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__DynamicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml23__DynamicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__DynamicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml23__DynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:815 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt (-345)
/* simple XML schema type 'eml23:DynamicViscosityMeasureExt': */
class SOAP_CMAC eml23__DynamicViscosityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:DynamicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__DynamicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__DynamicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__DynamicViscosityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__DynamicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__DynamicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__DynamicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__DynamicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__DynamicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:817 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure (-346)
/* simple XML schema type 'eml23:ElectricalResistivityMeasure': */
class SOAP_CMAC eml23__ElectricalResistivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricalResistivityUom'
        eml23__ElectricalResistivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricalResistivityMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricalResistivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricalResistivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricalResistivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricalResistivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricalResistivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricalResistivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricalResistivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:819 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt (-347)
/* simple XML schema type 'eml23:ElectricalResistivityMeasureExt': */
class SOAP_CMAC eml23__ElectricalResistivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricalResistivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricalResistivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricalResistivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricalResistivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricalResistivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricalResistivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricalResistivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricalResistivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricalResistivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:821 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure (-348)
/* simple XML schema type 'eml23:ElectricChargeMeasure': */
class SOAP_CMAC eml23__ElectricChargeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargeUom'
        eml23__ElectricChargeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargeMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricChargeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:823 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt (-349)
/* simple XML schema type 'eml23:ElectricChargeMeasureExt': */
class SOAP_CMAC eml23__ElectricChargeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricChargeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:825 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure (-350)
/* simple XML schema type 'eml23:ElectricChargePerAreaMeasure': */
class SOAP_CMAC eml23__ElectricChargePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerAreaUom'
        eml23__ElectricChargePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:827 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt (-351)
/* simple XML schema type 'eml23:ElectricChargePerAreaMeasureExt': */
class SOAP_CMAC eml23__ElectricChargePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:829 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure (-352)
/* simple XML schema type 'eml23:ElectricChargePerMassMeasure': */
class SOAP_CMAC eml23__ElectricChargePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerMassUom'
        eml23__ElectricChargePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:831 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt (-353)
/* simple XML schema type 'eml23:ElectricChargePerMassMeasureExt': */
class SOAP_CMAC eml23__ElectricChargePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:833 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure (-354)
/* simple XML schema type 'eml23:ElectricChargePerVolumeMeasure': */
class SOAP_CMAC eml23__ElectricChargePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerVolumeUom'
        eml23__ElectricChargePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:835 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt (-355)
/* simple XML schema type 'eml23:ElectricChargePerVolumeMeasureExt': */
class SOAP_CMAC eml23__ElectricChargePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricChargePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricChargePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricChargePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricChargePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricChargePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricChargePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricChargePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricChargePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricChargePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:837 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure (-356)
/* simple XML schema type 'eml23:ElectricConductanceMeasure': */
class SOAP_CMAC eml23__ElectricConductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricConductanceUom'
        eml23__ElectricConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricConductanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricConductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricConductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:839 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt (-357)
/* simple XML schema type 'eml23:ElectricConductanceMeasureExt': */
class SOAP_CMAC eml23__ElectricConductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricConductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:841 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure (-358)
/* simple XML schema type 'eml23:ElectricConductivityMeasure': */
class SOAP_CMAC eml23__ElectricConductivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricConductivityUom'
        eml23__ElectricConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricConductivityMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricConductivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricConductivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:843 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt (-359)
/* simple XML schema type 'eml23:ElectricConductivityMeasureExt': */
class SOAP_CMAC eml23__ElectricConductivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricConductivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:845 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure (-360)
/* simple XML schema type 'eml23:ElectricCurrentDensityMeasure': */
class SOAP_CMAC eml23__ElectricCurrentDensityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricCurrentDensityUom'
        eml23__ElectricCurrentDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricCurrentDensityMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricCurrentDensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricCurrentDensityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricCurrentDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricCurrentDensityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricCurrentDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricCurrentDensityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricCurrentDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:847 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt (-361)
/* simple XML schema type 'eml23:ElectricCurrentDensityMeasureExt': */
class SOAP_CMAC eml23__ElectricCurrentDensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricCurrentDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricCurrentDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricCurrentDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricCurrentDensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricCurrentDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricCurrentDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricCurrentDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricCurrentDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricCurrentDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:849 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure (-362)
/* simple XML schema type 'eml23:ElectricCurrentMeasure': */
class SOAP_CMAC eml23__ElectricCurrentMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricCurrentUom'
        eml23__ElectricCurrentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricCurrentMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricCurrentMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricCurrentMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricCurrentMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricCurrentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricCurrentMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:851 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt (-363)
/* simple XML schema type 'eml23:ElectricCurrentMeasureExt': */
class SOAP_CMAC eml23__ElectricCurrentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricCurrentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricCurrentMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricCurrentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricCurrentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricCurrentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricCurrentMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricCurrentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricCurrentMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricCurrentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:853 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure (-364)
/* simple XML schema type 'eml23:ElectricFieldStrengthMeasure': */
class SOAP_CMAC eml23__ElectricFieldStrengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricFieldStrengthUom'
        eml23__ElectricFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricFieldStrengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:855 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt (-365)
/* simple XML schema type 'eml23:ElectricFieldStrengthMeasureExt': */
class SOAP_CMAC eml23__ElectricFieldStrengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricFieldStrengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:857 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure (-366)
/* simple XML schema type 'eml23:ElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml23__ElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricPotentialDifferenceUom'
        eml23__ElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:859 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt (-367)
/* simple XML schema type 'eml23:ElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml23__ElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:861 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure (-368)
/* simple XML schema type 'eml23:ElectricResistanceMeasure': */
class SOAP_CMAC eml23__ElectricResistanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricResistanceUom'
        eml23__ElectricResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricResistanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricResistanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricResistanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:863 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt (-369)
/* simple XML schema type 'eml23:ElectricResistanceMeasureExt': */
class SOAP_CMAC eml23__ElectricResistanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricResistanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:865 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure (-370)
/* simple XML schema type 'eml23:ElectricResistancePerLengthMeasure': */
class SOAP_CMAC eml23__ElectricResistancePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricResistancePerLengthUom'
        eml23__ElectricResistancePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricResistancePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectricResistancePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricResistancePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectricResistancePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricResistancePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectricResistancePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricResistancePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectricResistancePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:867 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt (-371)
/* simple XML schema type 'eml23:ElectricResistancePerLengthMeasureExt': */
class SOAP_CMAC eml23__ElectricResistancePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectricResistancePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectricResistancePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectricResistancePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectricResistancePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectricResistancePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectricResistancePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectricResistancePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectricResistancePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectricResistancePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:869 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure (-372)
/* simple XML schema type 'eml23:ElectromagneticMomentMeasure': */
class SOAP_CMAC eml23__ElectromagneticMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectromagneticMomentUom'
        eml23__ElectromagneticMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectromagneticMomentMeasure, default initialized and not managed by a soap context
        virtual eml23__ElectromagneticMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectromagneticMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ElectromagneticMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ElectromagneticMomentMeasure() { }
        /// Friend allocator used by soap_new_eml23__ElectromagneticMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectromagneticMomentMeasure * SOAP_FMAC2 soap_instantiate_eml23__ElectromagneticMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:871 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt (-373)
/* simple XML schema type 'eml23:ElectromagneticMomentMeasureExt': */
class SOAP_CMAC eml23__ElectromagneticMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ElectromagneticMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ElectromagneticMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ElectromagneticMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ElectromagneticMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ElectromagneticMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ElectromagneticMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ElectromagneticMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ElectromagneticMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ElectromagneticMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:873 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure (-374)
/* simple XML schema type 'eml23:EnergyLengthPerAreaMeasure': */
class SOAP_CMAC eml23__EnergyLengthPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyLengthPerAreaUom'
        eml23__EnergyLengthPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyLengthPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyLengthPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyLengthPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyLengthPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyLengthPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyLengthPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyLengthPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyLengthPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:875 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt (-375)
/* simple XML schema type 'eml23:EnergyLengthPerAreaMeasureExt': */
class SOAP_CMAC eml23__EnergyLengthPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyLengthPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyLengthPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyLengthPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyLengthPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyLengthPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyLengthPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyLengthPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyLengthPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyLengthPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:877 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure (-376)
/* simple XML schema type 'eml23:EnergyLengthPerTimeAreaTemperatureMeasure': */
class SOAP_CMAC eml23__EnergyLengthPerTimeAreaTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyLengthPerTimeAreaTemperatureUom'
        eml23__EnergyLengthPerTimeAreaTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyLengthPerTimeAreaTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyLengthPerTimeAreaTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyLengthPerTimeAreaTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyLengthPerTimeAreaTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyLengthPerTimeAreaTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyLengthPerTimeAreaTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:879 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt (-377)
/* simple XML schema type 'eml23:EnergyLengthPerTimeAreaTemperatureMeasureExt': */
class SOAP_CMAC eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyLengthPerTimeAreaTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:881 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure (-378)
/* simple XML schema type 'eml23:EnergyMeasure': */
class SOAP_CMAC eml23__EnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyUom'
        eml23__EnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:883 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt (-379)
/* simple XML schema type 'eml23:EnergyMeasureExt': */
class SOAP_CMAC eml23__EnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:885 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure (-380)
/* simple XML schema type 'eml23:EnergyPerAreaMeasure': */
class SOAP_CMAC eml23__EnergyPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerAreaUom'
        eml23__EnergyPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:887 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt (-381)
/* simple XML schema type 'eml23:EnergyPerAreaMeasureExt': */
class SOAP_CMAC eml23__EnergyPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:889 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure (-382)
/* simple XML schema type 'eml23:EnergyPerLengthMeasure': */
class SOAP_CMAC eml23__EnergyPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerLengthUom'
        eml23__EnergyPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:891 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt (-383)
/* simple XML schema type 'eml23:EnergyPerLengthMeasureExt': */
class SOAP_CMAC eml23__EnergyPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:893 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure (-384)
/* simple XML schema type 'eml23:EnergyPerMassMeasure': */
class SOAP_CMAC eml23__EnergyPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerMassUom'
        eml23__EnergyPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:895 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt (-385)
/* simple XML schema type 'eml23:EnergyPerMassMeasureExt': */
class SOAP_CMAC eml23__EnergyPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:897 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure (-386)
/* simple XML schema type 'eml23:EnergyPerMassPerTimeMeasure': */
class SOAP_CMAC eml23__EnergyPerMassPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerMassPerTimeUom'
        eml23__EnergyPerMassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerMassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyPerMassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerMassPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerMassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerMassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerMassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerMassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerMassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:899 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt (-387)
/* simple XML schema type 'eml23:EnergyPerMassPerTimeMeasureExt': */
class SOAP_CMAC eml23__EnergyPerMassPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerMassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerMassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyPerMassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerMassPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerMassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerMassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerMassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerMassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerMassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:901 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure (-388)
/* simple XML schema type 'eml23:EnergyPerVolumeMeasure': */
class SOAP_CMAC eml23__EnergyPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerVolumeUom'
        eml23__EnergyPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__EnergyPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:903 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt (-389)
/* simple XML schema type 'eml23:EnergyPerVolumeMeasureExt': */
class SOAP_CMAC eml23__EnergyPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:EnergyPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EnergyPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__EnergyPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EnergyPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__EnergyPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__EnergyPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__EnergyPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__EnergyPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__EnergyPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:905 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure (-390)
/* simple XML schema type 'eml23:ForceAreaMeasure': */
class SOAP_CMAC eml23__ForceAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceAreaUom'
        eml23__ForceAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__ForceAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForceAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForceAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForceAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForceAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:907 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt (-391)
/* simple XML schema type 'eml23:ForceAreaMeasureExt': */
class SOAP_CMAC eml23__ForceAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForceAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForceAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForceAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForceAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForceAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:909 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure (-392)
/* simple XML schema type 'eml23:ForceLengthPerLengthMeasure': */
class SOAP_CMAC eml23__ForceLengthPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceLengthPerLengthUom'
        eml23__ForceLengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceLengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__ForceLengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceLengthPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForceLengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForceLengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForceLengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceLengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForceLengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:911 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt (-393)
/* simple XML schema type 'eml23:ForceLengthPerLengthMeasureExt': */
class SOAP_CMAC eml23__ForceLengthPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceLengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceLengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForceLengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceLengthPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForceLengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForceLengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForceLengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceLengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForceLengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:913 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure (-394)
/* simple XML schema type 'eml23:ForceMeasure': */
class SOAP_CMAC eml23__ForceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceUom'
        eml23__ForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceMeasure, default initialized and not managed by a soap context
        virtual eml23__ForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:915 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt (-395)
/* simple XML schema type 'eml23:ForceMeasureExt': */
class SOAP_CMAC eml23__ForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:917 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure (-396)
/* simple XML schema type 'eml23:ForcePerForceMeasure': */
class SOAP_CMAC eml23__ForcePerForceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerForceUom'
        eml23__ForcePerForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerForceMeasure, default initialized and not managed by a soap context
        virtual eml23__ForcePerForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerForceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerForceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForcePerForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerForceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForcePerForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:919 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt (-397)
/* simple XML schema type 'eml23:ForcePerForceMeasureExt': */
class SOAP_CMAC eml23__ForcePerForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerForceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForcePerForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForcePerForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForcePerForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:921 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure (-398)
/* simple XML schema type 'eml23:ForcePerLengthMeasure': */
class SOAP_CMAC eml23__ForcePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerLengthUom'
        eml23__ForcePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__ForcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForcePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:923 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt (-399)
/* simple XML schema type 'eml23:ForcePerLengthMeasureExt': */
class SOAP_CMAC eml23__ForcePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForcePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForcePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForcePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:925 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure (-400)
/* simple XML schema type 'eml23:ForcePerVolumeMeasure': */
class SOAP_CMAC eml23__ForcePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerVolumeUom'
        eml23__ForcePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__ForcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ForcePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ForcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:927 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt (-401)
/* simple XML schema type 'eml23:ForcePerVolumeMeasureExt': */
class SOAP_CMAC eml23__ForcePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ForcePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ForcePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ForcePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ForcePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ForcePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ForcePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ForcePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ForcePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ForcePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:929 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure (-402)
/* simple XML schema type 'eml23:FrequencyIntervalMeasure': */
class SOAP_CMAC eml23__FrequencyIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:FrequencyIntervalUom'
        eml23__FrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml23__FrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FrequencyIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml23__FrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__FrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml23__FrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__FrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml23__FrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:931 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt (-403)
/* simple XML schema type 'eml23:FrequencyIntervalMeasureExt': */
class SOAP_CMAC eml23__FrequencyIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:FrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml23__FrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FrequencyIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__FrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__FrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__FrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__FrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__FrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:933 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure (-404)
/* simple XML schema type 'eml23:FrequencyMeasure': */
class SOAP_CMAC eml23__FrequencyMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:FrequencyUom'
        eml23__FrequencyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FrequencyMeasure, default initialized and not managed by a soap context
        virtual eml23__FrequencyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FrequencyMeasure); }
      public:
        /// Constructor with default initializations
        eml23__FrequencyMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__FrequencyMeasure() { }
        /// Friend allocator used by soap_new_eml23__FrequencyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__FrequencyMeasure * SOAP_FMAC2 soap_instantiate_eml23__FrequencyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:935 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt (-405)
/* simple XML schema type 'eml23:FrequencyMeasureExt': */
class SOAP_CMAC eml23__FrequencyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:FrequencyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FrequencyMeasureExt, default initialized and not managed by a soap context
        virtual eml23__FrequencyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FrequencyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__FrequencyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__FrequencyMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__FrequencyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__FrequencyMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__FrequencyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:937 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure (-406)
/* simple XML schema type 'eml23:HeatCapacityMeasure': */
class SOAP_CMAC eml23__HeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatCapacityUom'
        eml23__HeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml23__HeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__HeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__HeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml23__HeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml23__HeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:939 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt (-407)
/* simple XML schema type 'eml23:HeatCapacityMeasureExt': */
class SOAP_CMAC eml23__HeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__HeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__HeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__HeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__HeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__HeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:941 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure (-408)
/* simple XML schema type 'eml23:HeatFlowRateMeasure': */
class SOAP_CMAC eml23__HeatFlowRateMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatFlowRateUom'
        eml23__HeatFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml23__HeatFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatFlowRateMeasure); }
      public:
        /// Constructor with default initializations
        eml23__HeatFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__HeatFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml23__HeatFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml23__HeatFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:943 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt (-409)
/* simple XML schema type 'eml23:HeatFlowRateMeasureExt': */
class SOAP_CMAC eml23__HeatFlowRateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml23__HeatFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatFlowRateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__HeatFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__HeatFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__HeatFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__HeatFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:945 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure (-410)
/* simple XML schema type 'eml23:HeatTransferCoefficientMeasure': */
class SOAP_CMAC eml23__HeatTransferCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatTransferCoefficientUom'
        eml23__HeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml23__HeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatTransferCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml23__HeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__HeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml23__HeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml23__HeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:947 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt (-411)
/* simple XML schema type 'eml23:HeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml23__HeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:HeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__HeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml23__HeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__HeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__HeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__HeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__HeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__HeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__HeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:949 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure (-412)
/* simple XML schema type 'eml23:IlluminanceMeasure': */
class SOAP_CMAC eml23__IlluminanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:IlluminanceUom'
        eml23__IlluminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IlluminanceMeasure, default initialized and not managed by a soap context
        virtual eml23__IlluminanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IlluminanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__IlluminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__IlluminanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__IlluminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__IlluminanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__IlluminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:951 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt (-413)
/* simple XML schema type 'eml23:IlluminanceMeasureExt': */
class SOAP_CMAC eml23__IlluminanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:IlluminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IlluminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__IlluminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IlluminanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__IlluminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__IlluminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__IlluminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__IlluminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__IlluminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:953 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure (-414)
/* simple XML schema type 'eml23:InductanceMeasure': */
class SOAP_CMAC eml23__InductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:InductanceUom'
        eml23__InductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__InductanceMeasure, default initialized and not managed by a soap context
        virtual eml23__InductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__InductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__InductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__InductanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__InductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__InductanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__InductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:955 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt (-415)
/* simple XML schema type 'eml23:InductanceMeasureExt': */
class SOAP_CMAC eml23__InductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:InductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__InductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__InductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__InductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__InductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__InductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__InductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__InductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__InductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:957 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure (-416)
/* simple XML schema type 'eml23:IsothermalCompressibilityMeasure': */
class SOAP_CMAC eml23__IsothermalCompressibilityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:IsothermalCompressibilityUom'
        eml23__IsothermalCompressibilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IsothermalCompressibilityMeasure, default initialized and not managed by a soap context
        virtual eml23__IsothermalCompressibilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IsothermalCompressibilityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__IsothermalCompressibilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__IsothermalCompressibilityMeasure() { }
        /// Friend allocator used by soap_new_eml23__IsothermalCompressibilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__IsothermalCompressibilityMeasure * SOAP_FMAC2 soap_instantiate_eml23__IsothermalCompressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:959 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt (-417)
/* simple XML schema type 'eml23:IsothermalCompressibilityMeasureExt': */
class SOAP_CMAC eml23__IsothermalCompressibilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:IsothermalCompressibilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IsothermalCompressibilityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__IsothermalCompressibilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IsothermalCompressibilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__IsothermalCompressibilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__IsothermalCompressibilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__IsothermalCompressibilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__IsothermalCompressibilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__IsothermalCompressibilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:961 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure (-418)
/* simple XML schema type 'eml23:KinematicViscosityMeasure': */
class SOAP_CMAC eml23__KinematicViscosityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:KinematicViscosityUom'
        eml23__KinematicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__KinematicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml23__KinematicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__KinematicViscosityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__KinematicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__KinematicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml23__KinematicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__KinematicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml23__KinematicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:963 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt (-419)
/* simple XML schema type 'eml23:KinematicViscosityMeasureExt': */
class SOAP_CMAC eml23__KinematicViscosityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:KinematicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__KinematicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__KinematicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__KinematicViscosityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__KinematicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__KinematicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__KinematicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__KinematicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__KinematicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:965 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure (-420)
/* simple XML schema type 'eml23:LengthMeasure': */
class SOAP_CMAC eml23__LengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthUom'
        eml23__LengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:967 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt (-421)
/* simple XML schema type 'eml23:LengthMeasureExt': */
class SOAP_CMAC eml23__LengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:969 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt (-422)
/* simple XML schema type 'eml23:LengthOrTimeMeasureExt': */
class SOAP_CMAC eml23__LengthOrTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthOrTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthOrTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthOrTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthOrTimeMeasureExt() : __item(), soap() { }
        virtual ~eml23__LengthOrTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthOrTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthOrTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthOrTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:971 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure (-423)
/* simple XML schema type 'eml23:LengthPerLengthMeasure': */
class SOAP_CMAC eml23__LengthPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerLengthUom'
        eml23__LengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:973 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt (-424)
/* simple XML schema type 'eml23:LengthPerLengthMeasureExt': */
class SOAP_CMAC eml23__LengthPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:975 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure (-425)
/* simple XML schema type 'eml23:LengthPerMassMeasure': */
class SOAP_CMAC eml23__LengthPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerMassUom'
        eml23__LengthPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:977 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt (-426)
/* simple XML schema type 'eml23:LengthPerMassMeasureExt': */
class SOAP_CMAC eml23__LengthPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:979 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure (-427)
/* simple XML schema type 'eml23:LengthPerPressureMeasure': */
class SOAP_CMAC eml23__LengthPerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerPressureUom'
        eml23__LengthPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:981 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt (-428)
/* simple XML schema type 'eml23:LengthPerPressureMeasureExt': */
class SOAP_CMAC eml23__LengthPerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:983 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure (-429)
/* simple XML schema type 'eml23:LengthPerTemperatureMeasure': */
class SOAP_CMAC eml23__LengthPerTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerTemperatureUom'
        eml23__LengthPerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:985 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt (-430)
/* simple XML schema type 'eml23:LengthPerTemperatureMeasureExt': */
class SOAP_CMAC eml23__LengthPerTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:987 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure (-431)
/* simple XML schema type 'eml23:LengthPerTimeMeasure': */
class SOAP_CMAC eml23__LengthPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerTimeUom'
        eml23__LengthPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:989 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt (-432)
/* simple XML schema type 'eml23:LengthPerTimeMeasureExt': */
class SOAP_CMAC eml23__LengthPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:991 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure (-433)
/* simple XML schema type 'eml23:LengthPerVolumeMeasure': */
class SOAP_CMAC eml23__LengthPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerVolumeUom'
        eml23__LengthPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__LengthPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__LengthPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__LengthPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:993 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt (-434)
/* simple XML schema type 'eml23:LengthPerVolumeMeasureExt': */
class SOAP_CMAC eml23__LengthPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LengthPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LengthPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LengthPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LengthPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LengthPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LengthPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LengthPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LengthPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LengthPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:995 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure (-435)
/* simple XML schema type 'eml23:LightExposureMeasure': */
class SOAP_CMAC eml23__LightExposureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LightExposureUom'
        eml23__LightExposureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LightExposureMeasure, default initialized and not managed by a soap context
        virtual eml23__LightExposureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LightExposureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LightExposureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LightExposureMeasure() { }
        /// Friend allocator used by soap_new_eml23__LightExposureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LightExposureMeasure * SOAP_FMAC2 soap_instantiate_eml23__LightExposureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:997 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt (-436)
/* simple XML schema type 'eml23:LightExposureMeasureExt': */
class SOAP_CMAC eml23__LightExposureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LightExposureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LightExposureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LightExposureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LightExposureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LightExposureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LightExposureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LightExposureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LightExposureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LightExposureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:999 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure (-437)
/* simple XML schema type 'eml23:LinearAccelerationMeasure': */
class SOAP_CMAC eml23__LinearAccelerationMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LinearAccelerationUom'
        eml23__LinearAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LinearAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml23__LinearAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LinearAccelerationMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LinearAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LinearAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml23__LinearAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LinearAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml23__LinearAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1001 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt (-438)
/* simple XML schema type 'eml23:LinearAccelerationMeasureExt': */
class SOAP_CMAC eml23__LinearAccelerationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LinearAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LinearAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LinearAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LinearAccelerationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LinearAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LinearAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LinearAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LinearAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LinearAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1003 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure (-439)
/* simple XML schema type 'eml23:LinearThermalExpansionMeasure': */
class SOAP_CMAC eml23__LinearThermalExpansionMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LinearThermalExpansionUom'
        eml23__LinearThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LinearThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml23__LinearThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LinearThermalExpansionMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LinearThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LinearThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml23__LinearThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LinearThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml23__LinearThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1005 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt (-440)
/* simple XML schema type 'eml23:LinearThermalExpansionMeasureExt': */
class SOAP_CMAC eml23__LinearThermalExpansionMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LinearThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LinearThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LinearThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LinearThermalExpansionMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LinearThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LinearThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LinearThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LinearThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LinearThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1007 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure (-441)
/* simple XML schema type 'eml23:LogarithmicPowerRatioMeasure': */
class SOAP_CMAC eml23__LogarithmicPowerRatioMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LogarithmicPowerRatioUom'
        eml23__LogarithmicPowerRatioUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LogarithmicPowerRatioMeasure, default initialized and not managed by a soap context
        virtual eml23__LogarithmicPowerRatioMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LogarithmicPowerRatioMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LogarithmicPowerRatioMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LogarithmicPowerRatioMeasure() { }
        /// Friend allocator used by soap_new_eml23__LogarithmicPowerRatioMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LogarithmicPowerRatioMeasure * SOAP_FMAC2 soap_instantiate_eml23__LogarithmicPowerRatioMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1009 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt (-442)
/* simple XML schema type 'eml23:LogarithmicPowerRatioMeasureExt': */
class SOAP_CMAC eml23__LogarithmicPowerRatioMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LogarithmicPowerRatioUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LogarithmicPowerRatioMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LogarithmicPowerRatioMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LogarithmicPowerRatioMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LogarithmicPowerRatioMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LogarithmicPowerRatioMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LogarithmicPowerRatioMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LogarithmicPowerRatioMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LogarithmicPowerRatioMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1011 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure (-443)
/* simple XML schema type 'eml23:LogarithmicPowerRatioPerLengthMeasure': */
class SOAP_CMAC eml23__LogarithmicPowerRatioPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LogarithmicPowerRatioPerLengthUom'
        eml23__LogarithmicPowerRatioPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LogarithmicPowerRatioPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__LogarithmicPowerRatioPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LogarithmicPowerRatioPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LogarithmicPowerRatioPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LogarithmicPowerRatioPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LogarithmicPowerRatioPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1013 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt (-444)
/* simple XML schema type 'eml23:LogarithmicPowerRatioPerLengthMeasureExt': */
class SOAP_CMAC eml23__LogarithmicPowerRatioPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LogarithmicPowerRatioPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LogarithmicPowerRatioPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LogarithmicPowerRatioPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LogarithmicPowerRatioPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LogarithmicPowerRatioPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LogarithmicPowerRatioPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LogarithmicPowerRatioPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1015 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure (-445)
/* simple XML schema type 'eml23:LuminanceMeasure': */
class SOAP_CMAC eml23__LuminanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminanceUom'
        eml23__LuminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminanceMeasure, default initialized and not managed by a soap context
        virtual eml23__LuminanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LuminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LuminanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__LuminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__LuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1017 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt (-446)
/* simple XML schema type 'eml23:LuminanceMeasureExt': */
class SOAP_CMAC eml23__LuminanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LuminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LuminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LuminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LuminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LuminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1019 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure (-447)
/* simple XML schema type 'eml23:LuminousEfficacyMeasure': */
class SOAP_CMAC eml23__LuminousEfficacyMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousEfficacyUom'
        eml23__LuminousEfficacyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousEfficacyMeasure, default initialized and not managed by a soap context
        virtual eml23__LuminousEfficacyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousEfficacyMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LuminousEfficacyMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousEfficacyMeasure() { }
        /// Friend allocator used by soap_new_eml23__LuminousEfficacyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousEfficacyMeasure * SOAP_FMAC2 soap_instantiate_eml23__LuminousEfficacyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1021 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt (-448)
/* simple XML schema type 'eml23:LuminousEfficacyMeasureExt': */
class SOAP_CMAC eml23__LuminousEfficacyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousEfficacyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousEfficacyMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LuminousEfficacyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousEfficacyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LuminousEfficacyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousEfficacyMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LuminousEfficacyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousEfficacyMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LuminousEfficacyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1023 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure (-449)
/* simple XML schema type 'eml23:LuminousFluxMeasure': */
class SOAP_CMAC eml23__LuminousFluxMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousFluxUom'
        eml23__LuminousFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousFluxMeasure, default initialized and not managed by a soap context
        virtual eml23__LuminousFluxMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousFluxMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LuminousFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousFluxMeasure() { }
        /// Friend allocator used by soap_new_eml23__LuminousFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousFluxMeasure * SOAP_FMAC2 soap_instantiate_eml23__LuminousFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1025 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt (-450)
/* simple XML schema type 'eml23:LuminousFluxMeasureExt': */
class SOAP_CMAC eml23__LuminousFluxMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LuminousFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousFluxMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LuminousFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LuminousFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LuminousFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1027 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure (-451)
/* simple XML schema type 'eml23:LuminousIntensityMeasure': */
class SOAP_CMAC eml23__LuminousIntensityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousIntensityUom'
        eml23__LuminousIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousIntensityMeasure, default initialized and not managed by a soap context
        virtual eml23__LuminousIntensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousIntensityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__LuminousIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml23__LuminousIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml23__LuminousIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1029 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt (-452)
/* simple XML schema type 'eml23:LuminousIntensityMeasureExt': */
class SOAP_CMAC eml23__LuminousIntensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:LuminousIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__LuminousIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__LuminousIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__LuminousIntensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__LuminousIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__LuminousIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__LuminousIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__LuminousIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__LuminousIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1031 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure (-453)
/* simple XML schema type 'eml23:MagneticDipoleMomentMeasure': */
class SOAP_CMAC eml23__MagneticDipoleMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticDipoleMomentUom'
        eml23__MagneticDipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticDipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticDipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticDipoleMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticDipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticDipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticDipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticDipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticDipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1033 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt (-454)
/* simple XML schema type 'eml23:MagneticDipoleMomentMeasureExt': */
class SOAP_CMAC eml23__MagneticDipoleMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticDipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticDipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticDipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticDipoleMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticDipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticDipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticDipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticDipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticDipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1035 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure (-455)
/* simple XML schema type 'eml23:MagneticFieldStrengthMeasure': */
class SOAP_CMAC eml23__MagneticFieldStrengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFieldStrengthUom'
        eml23__MagneticFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFieldStrengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1037 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt (-456)
/* simple XML schema type 'eml23:MagneticFieldStrengthMeasureExt': */
class SOAP_CMAC eml23__MagneticFieldStrengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFieldStrengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1039 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure (-457)
/* simple XML schema type 'eml23:MagneticFluxDensityMeasure': */
class SOAP_CMAC eml23__MagneticFluxDensityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxDensityUom'
        eml23__MagneticFluxDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxDensityMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxDensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxDensityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxDensityMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxDensityMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1041 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt (-458)
/* simple XML schema type 'eml23:MagneticFluxDensityMeasureExt': */
class SOAP_CMAC eml23__MagneticFluxDensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxDensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1043 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure (-459)
/* simple XML schema type 'eml23:MagneticFluxDensityPerLengthMeasure': */
class SOAP_CMAC eml23__MagneticFluxDensityPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxDensityPerLengthUom'
        eml23__MagneticFluxDensityPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxDensityPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxDensityPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxDensityPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxDensityPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxDensityPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxDensityPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxDensityPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxDensityPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1045 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt (-460)
/* simple XML schema type 'eml23:MagneticFluxDensityPerLengthMeasureExt': */
class SOAP_CMAC eml23__MagneticFluxDensityPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxDensityPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxDensityPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxDensityPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxDensityPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxDensityPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxDensityPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxDensityPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1047 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure (-461)
/* simple XML schema type 'eml23:MagneticFluxMeasure': */
class SOAP_CMAC eml23__MagneticFluxMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxUom'
        eml23__MagneticFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1049 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt (-462)
/* simple XML schema type 'eml23:MagneticFluxMeasureExt': */
class SOAP_CMAC eml23__MagneticFluxMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticFluxMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1051 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure (-463)
/* simple XML schema type 'eml23:MagneticPermeabilityMeasure': */
class SOAP_CMAC eml23__MagneticPermeabilityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticPermeabilityUom'
        eml23__MagneticPermeabilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticPermeabilityMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticPermeabilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticPermeabilityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticPermeabilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticPermeabilityMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticPermeabilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticPermeabilityMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticPermeabilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1053 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt (-464)
/* simple XML schema type 'eml23:MagneticPermeabilityMeasureExt': */
class SOAP_CMAC eml23__MagneticPermeabilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticPermeabilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticPermeabilityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticPermeabilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticPermeabilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticPermeabilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticPermeabilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticPermeabilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticPermeabilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticPermeabilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1055 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure (-465)
/* simple XML schema type 'eml23:MagneticVectorPotentialMeasure': */
class SOAP_CMAC eml23__MagneticVectorPotentialMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticVectorPotentialUom'
        eml23__MagneticVectorPotentialUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticVectorPotentialMeasure, default initialized and not managed by a soap context
        virtual eml23__MagneticVectorPotentialMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticVectorPotentialMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MagneticVectorPotentialMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticVectorPotentialMeasure() { }
        /// Friend allocator used by soap_new_eml23__MagneticVectorPotentialMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticVectorPotentialMeasure * SOAP_FMAC2 soap_instantiate_eml23__MagneticVectorPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1057 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt (-466)
/* simple XML schema type 'eml23:MagneticVectorPotentialMeasureExt': */
class SOAP_CMAC eml23__MagneticVectorPotentialMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MagneticVectorPotentialUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MagneticVectorPotentialMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MagneticVectorPotentialMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MagneticVectorPotentialMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MagneticVectorPotentialMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MagneticVectorPotentialMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MagneticVectorPotentialMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MagneticVectorPotentialMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MagneticVectorPotentialMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1059 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure (-467)
/* simple XML schema type 'eml23:MassLengthMeasure': */
class SOAP_CMAC eml23__MassLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassLengthUom'
        eml23__MassLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MassLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1061 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt (-468)
/* simple XML schema type 'eml23:MassLengthMeasureExt': */
class SOAP_CMAC eml23__MassLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1063 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure (-469)
/* simple XML schema type 'eml23:MassMeasure': */
class SOAP_CMAC eml23__MassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassUom'
        eml23__MassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassMeasure, default initialized and not managed by a soap context
        virtual eml23__MassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1065 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt (-470)
/* simple XML schema type 'eml23:MassMeasureExt': */
class SOAP_CMAC eml23__MassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1067 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure (-471)
/* simple XML schema type 'eml23:MassPerAreaMeasure': */
class SOAP_CMAC eml23__MassPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerAreaUom'
        eml23__MassPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1069 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt (-472)
/* simple XML schema type 'eml23:MassPerAreaMeasureExt': */
class SOAP_CMAC eml23__MassPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1071 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure (-473)
/* simple XML schema type 'eml23:MassPerEnergyMeasure': */
class SOAP_CMAC eml23__MassPerEnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerEnergyUom'
        eml23__MassPerEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerEnergyMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerEnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerEnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1073 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt (-474)
/* simple XML schema type 'eml23:MassPerEnergyMeasureExt': */
class SOAP_CMAC eml23__MassPerEnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerEnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1075 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure (-475)
/* simple XML schema type 'eml23:MassPerLengthMeasure': */
class SOAP_CMAC eml23__MassPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerLengthUom'
        eml23__MassPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1077 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt (-476)
/* simple XML schema type 'eml23:MassPerLengthMeasureExt': */
class SOAP_CMAC eml23__MassPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1079 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure (-477)
/* simple XML schema type 'eml23:MassPerMassMeasure': */
class SOAP_CMAC eml23__MassPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerMassUom'
        eml23__MassPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1081 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt (-478)
/* simple XML schema type 'eml23:MassPerMassMeasureExt': */
class SOAP_CMAC eml23__MassPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1083 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure (-479)
/* simple XML schema type 'eml23:MassPerTimeMeasure': */
class SOAP_CMAC eml23__MassPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimeUom'
        eml23__MassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1085 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt (-480)
/* simple XML schema type 'eml23:MassPerTimeMeasureExt': */
class SOAP_CMAC eml23__MassPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1087 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure (-481)
/* simple XML schema type 'eml23:MassPerTimePerAreaMeasure': */
class SOAP_CMAC eml23__MassPerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimePerAreaUom'
        eml23__MassPerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1089 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt (-482)
/* simple XML schema type 'eml23:MassPerTimePerAreaMeasureExt': */
class SOAP_CMAC eml23__MassPerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1091 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure (-483)
/* simple XML schema type 'eml23:MassPerTimePerLengthMeasure': */
class SOAP_CMAC eml23__MassPerTimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimePerLengthUom'
        eml23__MassPerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1093 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt (-484)
/* simple XML schema type 'eml23:MassPerTimePerLengthMeasureExt': */
class SOAP_CMAC eml23__MassPerTimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerTimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1095 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure (-485)
/* simple XML schema type 'eml23:MassPerVolumeMeasure': */
class SOAP_CMAC eml23__MassPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1097 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt (-486)
/* simple XML schema type 'eml23:MassPerVolumeMeasureExt': */
class SOAP_CMAC eml23__MassPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1099 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure (-487)
/* simple XML schema type 'eml23:MassPerVolumePerLengthMeasure': */
class SOAP_CMAC eml23__MassPerVolumePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerLengthUom'
        eml23__MassPerVolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1101 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt (-488)
/* simple XML schema type 'eml23:MassPerVolumePerLengthMeasureExt': */
class SOAP_CMAC eml23__MassPerVolumePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1103 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure (-489)
/* simple XML schema type 'eml23:MassPerVolumePerPressureMeasure': */
class SOAP_CMAC eml23__MassPerVolumePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerPressureUom'
        eml23__MassPerVolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1105 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt (-490)
/* simple XML schema type 'eml23:MassPerVolumePerPressureMeasureExt': */
class SOAP_CMAC eml23__MassPerVolumePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1107 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure (-491)
/* simple XML schema type 'eml23:MassPerVolumePerTemperatureMeasure': */
class SOAP_CMAC eml23__MassPerVolumePerTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerTemperatureUom'
        eml23__MassPerVolumePerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1109 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt (-492)
/* simple XML schema type 'eml23:MassPerVolumePerTemperatureMeasureExt': */
class SOAP_CMAC eml23__MassPerVolumePerTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MassPerVolumePerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MassPerVolumePerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MassPerVolumePerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MassPerVolumePerTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MassPerVolumePerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MassPerVolumePerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MassPerVolumePerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MassPerVolumePerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MassPerVolumePerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1111 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure (-493)
/* simple XML schema type 'eml23:MobilityMeasure': */
class SOAP_CMAC eml23__MobilityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MobilityUom'
        eml23__MobilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MobilityMeasure, default initialized and not managed by a soap context
        virtual eml23__MobilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MobilityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MobilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MobilityMeasure() { }
        /// Friend allocator used by soap_new_eml23__MobilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MobilityMeasure * SOAP_FMAC2 soap_instantiate_eml23__MobilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1113 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt (-494)
/* simple XML schema type 'eml23:MobilityMeasureExt': */
class SOAP_CMAC eml23__MobilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MobilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MobilityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MobilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MobilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MobilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MobilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MobilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MobilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MobilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1115 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure (-495)
/* simple XML schema type 'eml23:MolarEnergyMeasure': */
class SOAP_CMAC eml23__MolarEnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarEnergyUom'
        eml23__MolarEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarEnergyMeasure, default initialized and not managed by a soap context
        virtual eml23__MolarEnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarEnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MolarEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MolarEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml23__MolarEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml23__MolarEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1117 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt (-496)
/* simple XML schema type 'eml23:MolarEnergyMeasureExt': */
class SOAP_CMAC eml23__MolarEnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MolarEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarEnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MolarEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MolarEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MolarEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MolarEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1119 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure (-497)
/* simple XML schema type 'eml23:MolarHeatCapacityMeasure': */
class SOAP_CMAC eml23__MolarHeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarHeatCapacityUom'
        eml23__MolarHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml23__MolarHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarHeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MolarHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MolarHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml23__MolarHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml23__MolarHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1121 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt (-498)
/* simple XML schema type 'eml23:MolarHeatCapacityMeasureExt': */
class SOAP_CMAC eml23__MolarHeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MolarHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarHeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MolarHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MolarHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MolarHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MolarHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1123 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure (-499)
/* simple XML schema type 'eml23:MolarVolumeMeasure': */
class SOAP_CMAC eml23__MolarVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarVolumeUom'
        eml23__MolarVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__MolarVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MolarVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MolarVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__MolarVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__MolarVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1125 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt (-500)
/* simple XML schema type 'eml23:MolarVolumeMeasureExt': */
class SOAP_CMAC eml23__MolarVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolarVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolarVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MolarVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolarVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MolarVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MolarVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MolarVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolarVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MolarVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1127 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure (-501)
/* simple XML schema type 'eml23:MolecularWeightMeasure': */
class SOAP_CMAC eml23__MolecularWeightMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolecularWeightUom'
        eml23__MolecularWeightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolecularWeightMeasure, default initialized and not managed by a soap context
        virtual eml23__MolecularWeightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolecularWeightMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MolecularWeightMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MolecularWeightMeasure() { }
        /// Friend allocator used by soap_new_eml23__MolecularWeightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolecularWeightMeasure * SOAP_FMAC2 soap_instantiate_eml23__MolecularWeightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1129 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt (-502)
/* simple XML schema type 'eml23:MolecularWeightMeasureExt': */
class SOAP_CMAC eml23__MolecularWeightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MolecularWeightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MolecularWeightMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MolecularWeightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MolecularWeightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MolecularWeightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MolecularWeightMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MolecularWeightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MolecularWeightMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MolecularWeightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1131 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure (-503)
/* simple XML schema type 'eml23:MomentOfForceMeasure': */
class SOAP_CMAC eml23__MomentOfForceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentOfForceUom'
        eml23__MomentOfForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentOfForceMeasure, default initialized and not managed by a soap context
        virtual eml23__MomentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentOfForceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MomentOfForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MomentOfForceMeasure() { }
        /// Friend allocator used by soap_new_eml23__MomentOfForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentOfForceMeasure * SOAP_FMAC2 soap_instantiate_eml23__MomentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1133 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt (-504)
/* simple XML schema type 'eml23:MomentOfForceMeasureExt': */
class SOAP_CMAC eml23__MomentOfForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentOfForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentOfForceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MomentOfForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentOfForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MomentOfForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MomentOfForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MomentOfForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentOfForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MomentOfForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1135 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure (-505)
/* simple XML schema type 'eml23:MomentOfInertiaMeasure': */
class SOAP_CMAC eml23__MomentOfInertiaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentOfInertiaUom'
        eml23__MomentOfInertiaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentOfInertiaMeasure, default initialized and not managed by a soap context
        virtual eml23__MomentOfInertiaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentOfInertiaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MomentOfInertiaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MomentOfInertiaMeasure() { }
        /// Friend allocator used by soap_new_eml23__MomentOfInertiaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentOfInertiaMeasure * SOAP_FMAC2 soap_instantiate_eml23__MomentOfInertiaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1137 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt (-506)
/* simple XML schema type 'eml23:MomentOfInertiaMeasureExt': */
class SOAP_CMAC eml23__MomentOfInertiaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentOfInertiaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentOfInertiaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MomentOfInertiaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentOfInertiaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MomentOfInertiaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MomentOfInertiaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MomentOfInertiaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentOfInertiaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MomentOfInertiaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1139 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure (-507)
/* simple XML schema type 'eml23:MomentumMeasure': */
class SOAP_CMAC eml23__MomentumMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentumUom'
        eml23__MomentumUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentumMeasure, default initialized and not managed by a soap context
        virtual eml23__MomentumMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentumMeasure); }
      public:
        /// Constructor with default initializations
        eml23__MomentumMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__MomentumMeasure() { }
        /// Friend allocator used by soap_new_eml23__MomentumMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentumMeasure * SOAP_FMAC2 soap_instantiate_eml23__MomentumMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1141 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt (-508)
/* simple XML schema type 'eml23:MomentumMeasureExt': */
class SOAP_CMAC eml23__MomentumMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:MomentumUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__MomentumMeasureExt, default initialized and not managed by a soap context
        virtual eml23__MomentumMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__MomentumMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__MomentumMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__MomentumMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__MomentumMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__MomentumMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__MomentumMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1143 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure (-509)
/* simple XML schema type 'eml23:NormalizedPowerMeasure': */
class SOAP_CMAC eml23__NormalizedPowerMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:NormalizedPowerUom'
        eml23__NormalizedPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__NormalizedPowerMeasure, default initialized and not managed by a soap context
        virtual eml23__NormalizedPowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__NormalizedPowerMeasure); }
      public:
        /// Constructor with default initializations
        eml23__NormalizedPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__NormalizedPowerMeasure() { }
        /// Friend allocator used by soap_new_eml23__NormalizedPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__NormalizedPowerMeasure * SOAP_FMAC2 soap_instantiate_eml23__NormalizedPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1145 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt (-510)
/* simple XML schema type 'eml23:NormalizedPowerMeasureExt': */
class SOAP_CMAC eml23__NormalizedPowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:NormalizedPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__NormalizedPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml23__NormalizedPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__NormalizedPowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__NormalizedPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__NormalizedPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__NormalizedPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__NormalizedPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__NormalizedPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1147 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure (-511)
/* simple XML schema type 'eml23:PermeabilityLengthMeasure': */
class SOAP_CMAC eml23__PermeabilityLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermeabilityLengthUom'
        eml23__PermeabilityLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermeabilityLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__PermeabilityLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermeabilityLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PermeabilityLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PermeabilityLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__PermeabilityLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermeabilityLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__PermeabilityLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1149 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt (-512)
/* simple XML schema type 'eml23:PermeabilityLengthMeasureExt': */
class SOAP_CMAC eml23__PermeabilityLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermeabilityLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermeabilityLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PermeabilityLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermeabilityLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PermeabilityLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PermeabilityLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PermeabilityLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermeabilityLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PermeabilityLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1151 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure (-513)
/* simple XML schema type 'eml23:PermeabilityRockMeasure': */
class SOAP_CMAC eml23__PermeabilityRockMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermeabilityRockUom'
        eml23__PermeabilityRockUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermeabilityRockMeasure, default initialized and not managed by a soap context
        virtual eml23__PermeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermeabilityRockMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PermeabilityRockMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PermeabilityRockMeasure() { }
        /// Friend allocator used by soap_new_eml23__PermeabilityRockMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermeabilityRockMeasure * SOAP_FMAC2 soap_instantiate_eml23__PermeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1153 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt (-514)
/* simple XML schema type 'eml23:PermeabilityRockMeasureExt': */
class SOAP_CMAC eml23__PermeabilityRockMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermeabilityRockUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermeabilityRockMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PermeabilityRockMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermeabilityRockMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PermeabilityRockMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PermeabilityRockMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PermeabilityRockMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermeabilityRockMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PermeabilityRockMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1155 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure (-515)
/* simple XML schema type 'eml23:PermittivityMeasure': */
class SOAP_CMAC eml23__PermittivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermittivityUom'
        eml23__PermittivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermittivityMeasure, default initialized and not managed by a soap context
        virtual eml23__PermittivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermittivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PermittivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PermittivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__PermittivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermittivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__PermittivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1157 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt (-516)
/* simple XML schema type 'eml23:PermittivityMeasureExt': */
class SOAP_CMAC eml23__PermittivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PermittivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PermittivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PermittivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PermittivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PermittivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PermittivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PermittivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PermittivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PermittivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1159 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure (-517)
/* simple XML schema type 'eml23:PlaneAngleMeasure': */
class SOAP_CMAC eml23__PlaneAngleMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PlaneAngleUom'
        eml23__PlaneAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PlaneAngleMeasure, default initialized and not managed by a soap context
        virtual eml23__PlaneAngleMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PlaneAngleMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PlaneAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PlaneAngleMeasure() { }
        /// Friend allocator used by soap_new_eml23__PlaneAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PlaneAngleMeasure * SOAP_FMAC2 soap_instantiate_eml23__PlaneAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1161 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt (-518)
/* simple XML schema type 'eml23:PlaneAngleMeasureExt': */
class SOAP_CMAC eml23__PlaneAngleMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PlaneAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PlaneAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PlaneAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PlaneAngleMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PlaneAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PlaneAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PlaneAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PlaneAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PlaneAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1163 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure (-519)
/* simple XML schema type 'eml23:PotentialDifferencePerPowerDropMeasure': */
class SOAP_CMAC eml23__PotentialDifferencePerPowerDropMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PotentialDifferencePerPowerDropUom'
        eml23__PotentialDifferencePerPowerDropUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PotentialDifferencePerPowerDropMeasure, default initialized and not managed by a soap context
        virtual eml23__PotentialDifferencePerPowerDropMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PotentialDifferencePerPowerDropMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PotentialDifferencePerPowerDropMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PotentialDifferencePerPowerDropMeasure() { }
        /// Friend allocator used by soap_new_eml23__PotentialDifferencePerPowerDropMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PotentialDifferencePerPowerDropMeasure * SOAP_FMAC2 soap_instantiate_eml23__PotentialDifferencePerPowerDropMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1165 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt (-520)
/* simple XML schema type 'eml23:PotentialDifferencePerPowerDropMeasureExt': */
class SOAP_CMAC eml23__PotentialDifferencePerPowerDropMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PotentialDifferencePerPowerDropUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PotentialDifferencePerPowerDropMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PotentialDifferencePerPowerDropMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PotentialDifferencePerPowerDropMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PotentialDifferencePerPowerDropMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PotentialDifferencePerPowerDropMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PotentialDifferencePerPowerDropMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1167 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure (-521)
/* simple XML schema type 'eml23:PowerMeasure': */
class SOAP_CMAC eml23__PowerMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerUom'
        eml23__PowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerMeasure, default initialized and not managed by a soap context
        virtual eml23__PowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PowerMeasure() { }
        /// Friend allocator used by soap_new_eml23__PowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerMeasure * SOAP_FMAC2 soap_instantiate_eml23__PowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1169 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt (-522)
/* simple XML schema type 'eml23:PowerMeasureExt': */
class SOAP_CMAC eml23__PowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1171 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure (-523)
/* simple XML schema type 'eml23:PowerPerAreaMeasure': */
class SOAP_CMAC eml23__PowerPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerAreaUom'
        eml23__PowerPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__PowerPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__PowerPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__PowerPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1173 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt (-524)
/* simple XML schema type 'eml23:PowerPerAreaMeasureExt': */
class SOAP_CMAC eml23__PowerPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PowerPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PowerPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PowerPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1175 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure (-525)
/* simple XML schema type 'eml23:PowerPerPowerMeasure': */
class SOAP_CMAC eml23__PowerPerPowerMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerPowerUom'
        eml23__PowerPerPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerPowerMeasure, default initialized and not managed by a soap context
        virtual eml23__PowerPerPowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerPowerMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerPowerMeasure() { }
        /// Friend allocator used by soap_new_eml23__PowerPerPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerPowerMeasure * SOAP_FMAC2 soap_instantiate_eml23__PowerPerPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1177 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt (-526)
/* simple XML schema type 'eml23:PowerPerPowerMeasureExt': */
class SOAP_CMAC eml23__PowerPerPowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PowerPerPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerPowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PowerPerPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PowerPerPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1179 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure (-527)
/* simple XML schema type 'eml23:PowerPerVolumeMeasure': */
class SOAP_CMAC eml23__PowerPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerVolumeUom'
        eml23__PowerPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__PowerPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__PowerPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__PowerPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1181 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt (-528)
/* simple XML schema type 'eml23:PowerPerVolumeMeasureExt': */
class SOAP_CMAC eml23__PowerPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PowerPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PowerPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PowerPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PowerPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PowerPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PowerPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PowerPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PowerPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PowerPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1183 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure (-529)
/* simple XML schema type 'eml23:PressureMeasure': */
class SOAP_CMAC eml23__PressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureMeasure, default initialized and not managed by a soap context
        virtual eml23__PressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1185 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt (-530)
/* simple XML schema type 'eml23:PressureMeasureExt': */
class SOAP_CMAC eml23__PressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1187 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure (-531)
/* simple XML schema type 'eml23:PressurePerPressureMeasure': */
class SOAP_CMAC eml23__PressurePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerPressureUom'
        eml23__PressurePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__PressurePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressurePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressurePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1189 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt (-532)
/* simple XML schema type 'eml23:PressurePerPressureMeasureExt': */
class SOAP_CMAC eml23__PressurePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressurePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressurePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressurePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1191 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure (-533)
/* simple XML schema type 'eml23:PressurePerTimeMeasure': */
class SOAP_CMAC eml23__PressurePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerTimeUom'
        eml23__PressurePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__PressurePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressurePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressurePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1193 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt (-534)
/* simple XML schema type 'eml23:PressurePerTimeMeasureExt': */
class SOAP_CMAC eml23__PressurePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressurePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressurePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressurePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1195 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure (-535)
/* simple XML schema type 'eml23:PressurePerVolumeMeasure': */
class SOAP_CMAC eml23__PressurePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__PressurePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressurePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressurePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1197 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt (-536)
/* simple XML schema type 'eml23:PressurePerVolumeMeasureExt': */
class SOAP_CMAC eml23__PressurePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressurePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressurePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressurePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressurePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressurePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressurePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressurePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressurePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressurePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1199 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure (-537)
/* simple XML schema type 'eml23:PressureSquaredMeasure': */
class SOAP_CMAC eml23__PressureSquaredMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureSquaredUom'
        eml23__PressureSquaredUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureSquaredMeasure, default initialized and not managed by a soap context
        virtual eml23__PressureSquaredMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureSquaredMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressureSquaredMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressureSquaredMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressureSquaredMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureSquaredMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressureSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1201 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt (-538)
/* simple XML schema type 'eml23:PressureSquaredMeasureExt': */
class SOAP_CMAC eml23__PressureSquaredMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureSquaredUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureSquaredMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressureSquaredMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureSquaredMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressureSquaredMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressureSquaredMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressureSquaredMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureSquaredMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressureSquaredMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1203 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure (-539)
/* simple XML schema type 'eml23:PressureSquaredPerForceTimePerAreaMeasure': */
class SOAP_CMAC eml23__PressureSquaredPerForceTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureSquaredPerForceTimePerAreaUom'
        eml23__PressureSquaredPerForceTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureSquaredPerForceTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__PressureSquaredPerForceTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureSquaredPerForceTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressureSquaredPerForceTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressureSquaredPerForceTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureSquaredPerForceTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1205 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt (-540)
/* simple XML schema type 'eml23:PressureSquaredPerForceTimePerAreaMeasureExt': */
class SOAP_CMAC eml23__PressureSquaredPerForceTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureSquaredPerForceTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureSquaredPerForceTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressureSquaredPerForceTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureSquaredPerForceTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressureSquaredPerForceTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressureSquaredPerForceTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureSquaredPerForceTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1207 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure (-541)
/* simple XML schema type 'eml23:PressureTimePerVolumeMeasure': */
class SOAP_CMAC eml23__PressureTimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureTimePerVolumeUom'
        eml23__PressureTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__PressureTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureTimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__PressureTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__PressureTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__PressureTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__PressureTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1209 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt (-542)
/* simple XML schema type 'eml23:PressureTimePerVolumeMeasureExt': */
class SOAP_CMAC eml23__PressureTimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__PressureTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__PressureTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__PressureTimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__PressureTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__PressureTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__PressureTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__PressureTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__PressureTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1211 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure (-543)
/* simple XML schema type 'eml23:QuantityOfLightMeasure': */
class SOAP_CMAC eml23__QuantityOfLightMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:QuantityOfLightUom'
        eml23__QuantityOfLightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__QuantityOfLightMeasure, default initialized and not managed by a soap context
        virtual eml23__QuantityOfLightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__QuantityOfLightMeasure); }
      public:
        /// Constructor with default initializations
        eml23__QuantityOfLightMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__QuantityOfLightMeasure() { }
        /// Friend allocator used by soap_new_eml23__QuantityOfLightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__QuantityOfLightMeasure * SOAP_FMAC2 soap_instantiate_eml23__QuantityOfLightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1213 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt (-544)
/* simple XML schema type 'eml23:QuantityOfLightMeasureExt': */
class SOAP_CMAC eml23__QuantityOfLightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:QuantityOfLightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__QuantityOfLightMeasureExt, default initialized and not managed by a soap context
        virtual eml23__QuantityOfLightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__QuantityOfLightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__QuantityOfLightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__QuantityOfLightMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__QuantityOfLightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__QuantityOfLightMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__QuantityOfLightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1215 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure (-545)
/* simple XML schema type 'eml23:RadianceMeasure': */
class SOAP_CMAC eml23__RadianceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:RadianceUom'
        eml23__RadianceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RadianceMeasure, default initialized and not managed by a soap context
        virtual eml23__RadianceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RadianceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__RadianceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__RadianceMeasure() { }
        /// Friend allocator used by soap_new_eml23__RadianceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__RadianceMeasure * SOAP_FMAC2 soap_instantiate_eml23__RadianceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1217 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt (-546)
/* simple XML schema type 'eml23:RadianceMeasureExt': */
class SOAP_CMAC eml23__RadianceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:RadianceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RadianceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__RadianceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RadianceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__RadianceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__RadianceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__RadianceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__RadianceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__RadianceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1219 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure (-547)
/* simple XML schema type 'eml23:RadiantIntensityMeasure': */
class SOAP_CMAC eml23__RadiantIntensityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:RadiantIntensityUom'
        eml23__RadiantIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RadiantIntensityMeasure, default initialized and not managed by a soap context
        virtual eml23__RadiantIntensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RadiantIntensityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__RadiantIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__RadiantIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml23__RadiantIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__RadiantIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml23__RadiantIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1221 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt (-548)
/* simple XML schema type 'eml23:RadiantIntensityMeasureExt': */
class SOAP_CMAC eml23__RadiantIntensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:RadiantIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__RadiantIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__RadiantIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__RadiantIntensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__RadiantIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__RadiantIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__RadiantIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__RadiantIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__RadiantIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1223 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure (-549)
/* simple XML schema type 'eml23:ReciprocalAreaMeasure': */
class SOAP_CMAC eml23__ReciprocalAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalAreaUom'
        eml23__ReciprocalAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1225 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt (-550)
/* simple XML schema type 'eml23:ReciprocalAreaMeasureExt': */
class SOAP_CMAC eml23__ReciprocalAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1227 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure (-551)
/* simple XML schema type 'eml23:ReciprocalElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml23__ReciprocalElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalElectricPotentialDifferenceUom'
        eml23__ReciprocalElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1229 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt (-552)
/* simple XML schema type 'eml23:ReciprocalElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml23__ReciprocalElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1231 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure (-553)
/* simple XML schema type 'eml23:ReciprocalForceMeasure': */
class SOAP_CMAC eml23__ReciprocalForceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalForceUom'
        eml23__ReciprocalForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalForceMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalForceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalForceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalForceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1233 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt (-554)
/* simple XML schema type 'eml23:ReciprocalForceMeasureExt': */
class SOAP_CMAC eml23__ReciprocalForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalForceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1235 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure (-555)
/* simple XML schema type 'eml23:ReciprocalLengthMeasure': */
class SOAP_CMAC eml23__ReciprocalLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalLengthUom'
        eml23__ReciprocalLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1237 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt (-556)
/* simple XML schema type 'eml23:ReciprocalLengthMeasureExt': */
class SOAP_CMAC eml23__ReciprocalLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1239 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure (-557)
/* simple XML schema type 'eml23:ReciprocalMassMeasure': */
class SOAP_CMAC eml23__ReciprocalMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalMassUom'
        eml23__ReciprocalMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalMassMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1241 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt (-558)
/* simple XML schema type 'eml23:ReciprocalMassMeasureExt': */
class SOAP_CMAC eml23__ReciprocalMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1243 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure (-559)
/* simple XML schema type 'eml23:ReciprocalMassTimeMeasure': */
class SOAP_CMAC eml23__ReciprocalMassTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalMassTimeUom'
        eml23__ReciprocalMassTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalMassTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalMassTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalMassTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalMassTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalMassTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalMassTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalMassTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalMassTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1245 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt (-560)
/* simple XML schema type 'eml23:ReciprocalMassTimeMeasureExt': */
class SOAP_CMAC eml23__ReciprocalMassTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalMassTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalMassTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalMassTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalMassTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalMassTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalMassTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalMassTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalMassTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalMassTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1247 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure (-561)
/* simple XML schema type 'eml23:ReciprocalPressureMeasure': */
class SOAP_CMAC eml23__ReciprocalPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalPressureUom'
        eml23__ReciprocalPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1249 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt (-562)
/* simple XML schema type 'eml23:ReciprocalPressureMeasureExt': */
class SOAP_CMAC eml23__ReciprocalPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1251 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure (-563)
/* simple XML schema type 'eml23:ReciprocalTimeMeasure': */
class SOAP_CMAC eml23__ReciprocalTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalTimeUom'
        eml23__ReciprocalTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1253 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt (-564)
/* simple XML schema type 'eml23:ReciprocalTimeMeasureExt': */
class SOAP_CMAC eml23__ReciprocalTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1255 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure (-565)
/* simple XML schema type 'eml23:ReciprocalVolumeMeasure': */
class SOAP_CMAC eml23__ReciprocalVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalVolumeUom'
        eml23__ReciprocalVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__ReciprocalVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1257 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt (-566)
/* simple XML schema type 'eml23:ReciprocalVolumeMeasureExt': */
class SOAP_CMAC eml23__ReciprocalVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReciprocalVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReciprocalVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReciprocalVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReciprocalVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReciprocalVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReciprocalVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReciprocalVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReciprocalVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReciprocalVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1259 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure (-567)
/* simple XML schema type 'eml23:ReluctanceMeasure': */
class SOAP_CMAC eml23__ReluctanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReluctanceUom'
        eml23__ReluctanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReluctanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ReluctanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReluctanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ReluctanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ReluctanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ReluctanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReluctanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ReluctanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1261 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt (-568)
/* simple XML schema type 'eml23:ReluctanceMeasureExt': */
class SOAP_CMAC eml23__ReluctanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ReluctanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReluctanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ReluctanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReluctanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ReluctanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ReluctanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ReluctanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReluctanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ReluctanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1263 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure (-569)
/* simple XML schema type 'eml23:SecondMomentOfAreaMeasure': */
class SOAP_CMAC eml23__SecondMomentOfAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SecondMomentOfAreaUom'
        eml23__SecondMomentOfAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SecondMomentOfAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__SecondMomentOfAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SecondMomentOfAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__SecondMomentOfAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__SecondMomentOfAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__SecondMomentOfAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__SecondMomentOfAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__SecondMomentOfAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1265 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt (-570)
/* simple XML schema type 'eml23:SecondMomentOfAreaMeasureExt': */
class SOAP_CMAC eml23__SecondMomentOfAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SecondMomentOfAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SecondMomentOfAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__SecondMomentOfAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SecondMomentOfAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__SecondMomentOfAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__SecondMomentOfAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__SecondMomentOfAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__SecondMomentOfAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__SecondMomentOfAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1267 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure (-571)
/* simple XML schema type 'eml23:SignalingEventPerTimeMeasure': */
class SOAP_CMAC eml23__SignalingEventPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SignalingEventPerTimeUom'
        eml23__SignalingEventPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SignalingEventPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__SignalingEventPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SignalingEventPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__SignalingEventPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__SignalingEventPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__SignalingEventPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__SignalingEventPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__SignalingEventPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1269 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt (-572)
/* simple XML schema type 'eml23:SignalingEventPerTimeMeasureExt': */
class SOAP_CMAC eml23__SignalingEventPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SignalingEventPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SignalingEventPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__SignalingEventPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SignalingEventPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__SignalingEventPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__SignalingEventPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__SignalingEventPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__SignalingEventPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__SignalingEventPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1271 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure (-573)
/* simple XML schema type 'eml23:SolidAngleMeasure': */
class SOAP_CMAC eml23__SolidAngleMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SolidAngleUom'
        eml23__SolidAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SolidAngleMeasure, default initialized and not managed by a soap context
        virtual eml23__SolidAngleMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SolidAngleMeasure); }
      public:
        /// Constructor with default initializations
        eml23__SolidAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__SolidAngleMeasure() { }
        /// Friend allocator used by soap_new_eml23__SolidAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__SolidAngleMeasure * SOAP_FMAC2 soap_instantiate_eml23__SolidAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1273 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt (-574)
/* simple XML schema type 'eml23:SolidAngleMeasureExt': */
class SOAP_CMAC eml23__SolidAngleMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SolidAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SolidAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml23__SolidAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SolidAngleMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__SolidAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__SolidAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__SolidAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__SolidAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__SolidAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1275 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure (-575)
/* simple XML schema type 'eml23:SpecificHeatCapacityMeasure': */
class SOAP_CMAC eml23__SpecificHeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SpecificHeatCapacityUom'
        eml23__SpecificHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SpecificHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml23__SpecificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SpecificHeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__SpecificHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__SpecificHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml23__SpecificHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__SpecificHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml23__SpecificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1277 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt (-576)
/* simple XML schema type 'eml23:SpecificHeatCapacityMeasureExt': */
class SOAP_CMAC eml23__SpecificHeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:SpecificHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__SpecificHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__SpecificHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__SpecificHeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__SpecificHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__SpecificHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__SpecificHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__SpecificHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__SpecificHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1279 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure (-577)
/* simple XML schema type 'eml23:TemperatureIntervalMeasure': */
class SOAP_CMAC eml23__TemperatureIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalUom'
        eml23__TemperatureIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalMeasure, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1281 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt (-578)
/* simple XML schema type 'eml23:TemperatureIntervalMeasureExt': */
class SOAP_CMAC eml23__TemperatureIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1283 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure (-579)
/* simple XML schema type 'eml23:TemperatureIntervalPerLengthMeasure': */
class SOAP_CMAC eml23__TemperatureIntervalPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerLengthUom'
        eml23__TemperatureIntervalPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1285 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt (-580)
/* simple XML schema type 'eml23:TemperatureIntervalPerLengthMeasureExt': */
class SOAP_CMAC eml23__TemperatureIntervalPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1287 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure (-581)
/* simple XML schema type 'eml23:TemperatureIntervalPerPressureMeasure': */
class SOAP_CMAC eml23__TemperatureIntervalPerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerPressureUom'
        eml23__TemperatureIntervalPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1289 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt (-582)
/* simple XML schema type 'eml23:TemperatureIntervalPerPressureMeasureExt': */
class SOAP_CMAC eml23__TemperatureIntervalPerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1291 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure (-583)
/* simple XML schema type 'eml23:TemperatureIntervalPerTimeMeasure': */
class SOAP_CMAC eml23__TemperatureIntervalPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerTimeUom'
        eml23__TemperatureIntervalPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1293 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt (-584)
/* simple XML schema type 'eml23:TemperatureIntervalPerTimeMeasureExt': */
class SOAP_CMAC eml23__TemperatureIntervalPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TemperatureIntervalPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TemperatureIntervalPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TemperatureIntervalPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TemperatureIntervalPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TemperatureIntervalPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TemperatureIntervalPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TemperatureIntervalPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TemperatureIntervalPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TemperatureIntervalPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1295 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure (-585)
/* simple XML schema type 'eml23:ThermalConductanceMeasure': */
class SOAP_CMAC eml23__ThermalConductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalConductanceUom'
        eml23__ThermalConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalConductanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermalConductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalConductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermalConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermalConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermalConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1297 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt (-586)
/* simple XML schema type 'eml23:ThermalConductanceMeasureExt': */
class SOAP_CMAC eml23__ThermalConductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermalConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalConductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermalConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermalConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermalConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1299 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure (-587)
/* simple XML schema type 'eml23:ThermalConductivityMeasure': */
class SOAP_CMAC eml23__ThermalConductivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalConductivityUom'
        eml23__ThermalConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalConductivityMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalConductivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermalConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermalConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1301 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt (-588)
/* simple XML schema type 'eml23:ThermalConductivityMeasureExt': */
class SOAP_CMAC eml23__ThermalConductivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermalConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalConductivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermalConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermalConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermalConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1303 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure (-589)
/* simple XML schema type 'eml23:ThermalDiffusivityMeasure': */
class SOAP_CMAC eml23__ThermalDiffusivityMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalDiffusivityUom'
        eml23__ThermalDiffusivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalDiffusivityMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermalDiffusivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalDiffusivityMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermalDiffusivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalDiffusivityMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermalDiffusivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalDiffusivityMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermalDiffusivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1305 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt (-590)
/* simple XML schema type 'eml23:ThermalDiffusivityMeasureExt': */
class SOAP_CMAC eml23__ThermalDiffusivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalDiffusivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalDiffusivityMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermalDiffusivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalDiffusivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermalDiffusivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalDiffusivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermalDiffusivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalDiffusivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermalDiffusivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1307 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure (-591)
/* simple XML schema type 'eml23:ThermalInsulanceMeasure': */
class SOAP_CMAC eml23__ThermalInsulanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalInsulanceUom'
        eml23__ThermalInsulanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalInsulanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermalInsulanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalInsulanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermalInsulanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalInsulanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermalInsulanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalInsulanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermalInsulanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1309 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt (-592)
/* simple XML schema type 'eml23:ThermalInsulanceMeasureExt': */
class SOAP_CMAC eml23__ThermalInsulanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalInsulanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalInsulanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermalInsulanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalInsulanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermalInsulanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalInsulanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermalInsulanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalInsulanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermalInsulanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1311 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure (-593)
/* simple XML schema type 'eml23:ThermalResistanceMeasure': */
class SOAP_CMAC eml23__ThermalResistanceMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalResistanceUom'
        eml23__ThermalResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalResistanceMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermalResistanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalResistanceMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermalResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermalResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermalResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1313 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt (-594)
/* simple XML schema type 'eml23:ThermalResistanceMeasureExt': */
class SOAP_CMAC eml23__ThermalResistanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermalResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermalResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermalResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermalResistanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermalResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermalResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermalResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermalResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermalResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1315 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure (-595)
/* simple XML schema type 'eml23:ThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml23__ThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermodynamicTemperatureUom'
        eml23__ThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1317 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt (-596)
/* simple XML schema type 'eml23:ThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml23__ThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1319 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (-597)
/* simple XML schema type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureUom'
        eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1321 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (-598)
/* simple XML schema type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1323 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure (-599)
/* simple XML schema type 'eml23:TimeMeasure': */
class SOAP_CMAC eml23__TimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimeUom'
        eml23__TimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeMeasure, default initialized and not managed by a soap context
        virtual eml23__TimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__TimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__TimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1325 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt (-600)
/* simple XML schema type 'eml23:TimeMeasureExt': */
class SOAP_CMAC eml23__TimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1327 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure (-601)
/* simple XML schema type 'eml23:TimePerLengthMeasure': */
class SOAP_CMAC eml23__TimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerLengthUom'
        eml23__TimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__TimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__TimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__TimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1329 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt (-602)
/* simple XML schema type 'eml23:TimePerLengthMeasureExt': */
class SOAP_CMAC eml23__TimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1331 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure (-603)
/* simple XML schema type 'eml23:TimePerMassMeasure': */
class SOAP_CMAC eml23__TimePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerMassUom'
        eml23__TimePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__TimePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TimePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__TimePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__TimePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1333 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt (-604)
/* simple XML schema type 'eml23:TimePerMassMeasureExt': */
class SOAP_CMAC eml23__TimePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TimePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TimePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TimePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TimePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1335 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure (-605)
/* simple XML schema type 'eml23:TimePerTimeMeasure': */
class SOAP_CMAC eml23__TimePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerTimeUom'
        eml23__TimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__TimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__TimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__TimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1337 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt (-606)
/* simple XML schema type 'eml23:TimePerTimeMeasureExt': */
class SOAP_CMAC eml23__TimePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1339 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure (-607)
/* simple XML schema type 'eml23:TimePerVolumeMeasure': */
class SOAP_CMAC eml23__TimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerVolumeUom'
        eml23__TimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__TimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__TimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__TimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__TimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1341 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt (-608)
/* simple XML schema type 'eml23:TimePerVolumeMeasureExt': */
class SOAP_CMAC eml23__TimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:TimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__TimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__TimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__TimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__TimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__TimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__TimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__TimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__TimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1343 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure (-609)
/* simple XML schema type 'eml23:UnitlessMeasure': */
class SOAP_CMAC eml23__UnitlessMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__UnitlessMeasure, default initialized and not managed by a soap context
        virtual eml23__UnitlessMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__UnitlessMeasure); }
      public:
        /// Constructor with default initializations
        eml23__UnitlessMeasure() : __item(), soap() { }
        virtual ~eml23__UnitlessMeasure() { }
        /// Friend allocator used by soap_new_eml23__UnitlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__UnitlessMeasure * SOAP_FMAC2 soap_instantiate_eml23__UnitlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1345 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure (-610)
/* simple XML schema type 'eml23:VerticalCoordinateMeasure': */
class SOAP_CMAC eml23__VerticalCoordinateMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VerticalCoordinateUom'
        eml23__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalCoordinateMeasure, default initialized and not managed by a soap context
        virtual eml23__VerticalCoordinateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalCoordinateMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VerticalCoordinateMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VerticalCoordinateMeasure() { }
        /// Friend allocator used by soap_new_eml23__VerticalCoordinateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalCoordinateMeasure * SOAP_FMAC2 soap_instantiate_eml23__VerticalCoordinateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1347 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt (-611)
/* simple XML schema type 'eml23:VerticalCoordinateMeasureExt': */
class SOAP_CMAC eml23__VerticalCoordinateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VerticalCoordinateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VerticalCoordinateMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VerticalCoordinateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VerticalCoordinateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VerticalCoordinateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VerticalCoordinateMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VerticalCoordinateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VerticalCoordinateMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VerticalCoordinateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1349 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure (-612)
/* simple XML schema type 'eml23:VolumeFlowRatePerVolumeFlowRateMeasure': */
class SOAP_CMAC eml23__VolumeFlowRatePerVolumeFlowRateMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumeFlowRatePerVolumeFlowRateUom'
        eml23__VolumeFlowRatePerVolumeFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumeFlowRatePerVolumeFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumeFlowRatePerVolumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumeFlowRatePerVolumeFlowRateMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumeFlowRatePerVolumeFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumeFlowRatePerVolumeFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumeFlowRatePerVolumeFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1351 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt (-613)
/* simple XML schema type 'eml23:VolumeFlowRatePerVolumeFlowRateMeasureExt': */
class SOAP_CMAC eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumeFlowRatePerVolumeFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1353 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure (-614)
/* simple XML schema type 'eml23:VolumeMeasure': */
class SOAP_CMAC eml23__VolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1355 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt (-615)
/* simple XML schema type 'eml23:VolumeMeasureExt': */
class SOAP_CMAC eml23__VolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1357 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure (-616)
/* simple XML schema type 'eml23:VolumePerAreaMeasure': */
class SOAP_CMAC eml23__VolumePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerAreaUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1359 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt (-617)
/* simple XML schema type 'eml23:VolumePerAreaMeasureExt': */
class SOAP_CMAC eml23__VolumePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1361 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure (-618)
/* simple XML schema type 'eml23:VolumePerLengthMeasure': */
class SOAP_CMAC eml23__VolumePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerLengthUom'
        eml23__VolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1363 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt (-619)
/* simple XML schema type 'eml23:VolumePerLengthMeasureExt': */
class SOAP_CMAC eml23__VolumePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1365 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure (-620)
/* simple XML schema type 'eml23:VolumePerMassMeasure': */
class SOAP_CMAC eml23__VolumePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerMassUom'
        eml23__VolumePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerMassMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1367 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt (-621)
/* simple XML schema type 'eml23:VolumePerMassMeasureExt': */
class SOAP_CMAC eml23__VolumePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1369 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure (-622)
/* simple XML schema type 'eml23:VolumePerPressureMeasure': */
class SOAP_CMAC eml23__VolumePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerPressureUom'
        eml23__VolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1371 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt (-623)
/* simple XML schema type 'eml23:VolumePerPressureMeasureExt': */
class SOAP_CMAC eml23__VolumePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1373 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure (-624)
/* simple XML schema type 'eml23:VolumePerRotationMeasure': */
class SOAP_CMAC eml23__VolumePerRotationMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerRotationUom'
        eml23__VolumePerRotationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerRotationMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerRotationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerRotationMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerRotationMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerRotationMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerRotationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerRotationMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerRotationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1375 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt (-625)
/* simple XML schema type 'eml23:VolumePerRotationMeasureExt': */
class SOAP_CMAC eml23__VolumePerRotationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerRotationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerRotationMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerRotationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerRotationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerRotationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerRotationMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerRotationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerRotationMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerRotationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1377 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure (-626)
/* simple XML schema type 'eml23:VolumePerTimeLengthMeasure': */
class SOAP_CMAC eml23__VolumePerTimeLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimeLengthUom'
        eml23__VolumePerTimeLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimeLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimeLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimeLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimeLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimeLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimeLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimeLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimeLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1379 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt (-627)
/* simple XML schema type 'eml23:VolumePerTimeLengthMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimeLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimeLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimeLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimeLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimeLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimeLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimeLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimeLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimeLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimeLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1381 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure (-628)
/* simple XML schema type 'eml23:VolumePerTimeMeasure': */
class SOAP_CMAC eml23__VolumePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1383 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt (-629)
/* simple XML schema type 'eml23:VolumePerTimeMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1385 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure (-630)
/* simple XML schema type 'eml23:VolumePerTimePerAreaMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerAreaUom'
        eml23__VolumePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1387 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt (-631)
/* simple XML schema type 'eml23:VolumePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1389 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure (-632)
/* simple XML schema type 'eml23:VolumePerTimePerLengthMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerLengthUom'
        eml23__VolumePerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1391 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt (-633)
/* simple XML schema type 'eml23:VolumePerTimePerLengthMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1393 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure (-634)
/* simple XML schema type 'eml23:VolumePerTimePerPressureLengthMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerPressureLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerPressureLengthUom'
        eml23__VolumePerTimePerPressureLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerPressureLengthMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerPressureLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerPressureLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerPressureLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerPressureLengthMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerPressureLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerPressureLengthMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerPressureLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1395 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt (-635)
/* simple XML schema type 'eml23:VolumePerTimePerPressureLengthMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerPressureLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerPressureLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerPressureLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerPressureLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerPressureLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerPressureLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerPressureLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerPressureLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1397 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure (-636)
/* simple XML schema type 'eml23:VolumePerTimePerPressureMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerPressureUom'
        eml23__VolumePerTimePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1399 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt (-637)
/* simple XML schema type 'eml23:VolumePerTimePerPressureMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1401 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure (-638)
/* simple XML schema type 'eml23:VolumePerTimePerTimeMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerTimeUom'
        eml23__VolumePerTimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1403 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt (-639)
/* simple XML schema type 'eml23:VolumePerTimePerTimeMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1405 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure (-640)
/* simple XML schema type 'eml23:VolumePerTimePerVolumeMeasure': */
class SOAP_CMAC eml23__VolumePerTimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerVolumeUom'
        eml23__VolumePerTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1407 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt (-641)
/* simple XML schema type 'eml23:VolumePerTimePerVolumeMeasureExt': */
class SOAP_CMAC eml23__VolumePerTimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerTimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1409 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure (-642)
/* simple XML schema type 'eml23:VolumePerVolumeMeasure': */
class SOAP_CMAC eml23__VolumePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1411 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt (-643)
/* simple XML schema type 'eml23:VolumePerVolumeMeasureExt': */
class SOAP_CMAC eml23__VolumePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1413 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure (-644)
/* simple XML schema type 'eml23:VolumetricHeatTransferCoefficientMeasure': */
class SOAP_CMAC eml23__VolumetricHeatTransferCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumetricHeatTransferCoefficientUom'
        eml23__VolumetricHeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumetricHeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumetricHeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumetricHeatTransferCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumetricHeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumetricHeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumetricHeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumetricHeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumetricHeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1415 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt (-645)
/* simple XML schema type 'eml23:VolumetricHeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml23__VolumetricHeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumetricHeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumetricHeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumetricHeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumetricHeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumetricHeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumetricHeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumetricHeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1417 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure (-646)
/* simple XML schema type 'eml23:VolumetricThermalExpansionMeasure': */
class SOAP_CMAC eml23__VolumetricThermalExpansionMeasure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumetricThermalExpansionUom'
        eml23__VolumetricThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumetricThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml23__VolumetricThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumetricThermalExpansionMeasure); }
      public:
        /// Constructor with default initializations
        eml23__VolumetricThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__VolumetricThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml23__VolumetricThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumetricThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml23__VolumetricThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1419 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt (-647)
/* simple XML schema type 'eml23:VolumetricThermalExpansionMeasureExt': */
class SOAP_CMAC eml23__VolumetricThermalExpansionMeasureExt {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:VolumetricThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__VolumetricThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml23__VolumetricThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__VolumetricThermalExpansionMeasureExt); }
      public:
        /// Constructor with default initializations
        eml23__VolumetricThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml23__VolumetricThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml23__VolumetricThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml23__VolumetricThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml23__VolumetricThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1563 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure (-719)
/* simple XML schema type 'eml23:ReferencePressure': */
class SOAP_CMAC eml23__ReferencePressure {
      public:
        /// Simple content of XML schema type 'eml23:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml23:PressureUom'
        eml23__PressureUom uom;
        /// Optional attribute 'referencePressureKind' of XML schema type 'eml23:ReferencePressureKind'
        eml23__ReferencePressureKind *referencePressureKind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReferencePressure, default initialized and not managed by a soap context
        virtual eml23__ReferencePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReferencePressure); }
      public:
        /// Constructor with default initializations
        eml23__ReferencePressure() : __item(), uom(), referencePressureKind(), soap() { }
        virtual ~eml23__ReferencePressure() { }
        /// Friend allocator used by soap_new_eml23__ReferencePressure(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReferencePressure * SOAP_FMAC2 soap_instantiate_eml23__ReferencePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:167 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature (-21)
/* Type resqml22__CulturalFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:CulturalFeature': */
class SOAP_CMAC resqml22__CulturalFeature : public resqml22__AbstractTechnicalFeature {
      public:
        /// Required element 'resqml22:CulturalFeatureKind' of XML schema type 'resqml22:CulturalFeatureKindExt'
        std::string CulturalFeatureKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CulturalFeature, default initialized and not managed by a soap context
        virtual resqml22__CulturalFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CulturalFeature); }
      public:
        /// Constructor with default initializations
        resqml22__CulturalFeature() : CulturalFeatureKind() { }
        virtual ~resqml22__CulturalFeature() { }
        /// Friend allocator used by soap_new_resqml22__CulturalFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CulturalFeature * SOAP_FMAC2 soap_instantiate_resqml22__CulturalFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:225 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature (-50)
/* complex XML schema type 'resqml22:AbstractSeismicSurveyFeature': */
class SOAP_CMAC resqml22__AbstractSeismicSurveyFeature : public resqml22__AbstractTechnicalFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSeismicSurveyFeature, default initialized and not managed by a soap context
        virtual resqml22__AbstractSeismicSurveyFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSeismicSurveyFeature); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSeismicSurveyFeature() { }
        virtual ~resqml22__AbstractSeismicSurveyFeature() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSeismicSurveyFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSeismicSurveyFeature * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSeismicSurveyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:235 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation (-55)
/* Type resqml22__Seismic3dPostStackRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Seismic3dPostStackRepresentation': */
class SOAP_CMAC resqml22__Seismic3dPostStackRepresentation : public resqml22__AbstractGridRepresentation {
      public:
        /// Required element 'resqml22:SeismicLatticeSubSampling' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *SeismicLatticeSubSampling;
        /// Required element 'resqml22:TraceSampling' of XML schema type 'eml23:FloatingPointLatticeArray'
        eml23__FloatingPointLatticeArray *TraceSampling;
        /// Required element 'resqml22:SeismicLatticeRepresentation' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *SeismicLatticeRepresentation;
        /// Required element 'resqml22:LocalCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Seismic3dPostStackRepresentation, default initialized and not managed by a soap context
        virtual resqml22__Seismic3dPostStackRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Seismic3dPostStackRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__Seismic3dPostStackRepresentation() : SeismicLatticeSubSampling(), TraceSampling(), SeismicLatticeRepresentation(), LocalCrs() { }
        virtual ~resqml22__Seismic3dPostStackRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__Seismic3dPostStackRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Seismic3dPostStackRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__Seismic3dPostStackRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:247 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation (-61)
/* Type resqml22__AbstractSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml22__AbstractSurfaceFrameworkRepresentation : public resqml22__RepresentationSetRepresentation {
      public:
        /// Optional element 'resqml22:ContactIdentity' of XML schema type 'resqml22:ContactIdentity'
        std::vector<resqml22__ContactIdentity *> ContactIdentity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSurfaceFrameworkRepresentation() : ContactIdentity() { }
        virtual ~resqml22__AbstractSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:267 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation (-71)
/* Type resqml22__PlaneSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:PlaneSetRepresentation': */
class SOAP_CMAC resqml22__PlaneSetRepresentation : public resqml22__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml22:Planes' of XML schema type 'resqml22:AbstractPlaneGeometry'
        std::vector<resqml22__AbstractPlaneGeometry *> Planes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__PlaneSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__PlaneSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__PlaneSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__PlaneSetRepresentation() : Planes() { }
        virtual ~resqml22__PlaneSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__PlaneSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__PlaneSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__PlaneSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:279 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation (-77)
/* Type resqml22__SealedVolumeFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SealedVolumeFrameworkRepresentation': */
class SOAP_CMAC resqml22__SealedVolumeFrameworkRepresentation : public resqml22__RepresentationSetRepresentation {
      public:
        /// Required element 'resqml22:BasedOn' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *BasedOn;
        /// Required element 'resqml22:Regions' of XML schema type 'resqml22:VolumeRegion'
        std::vector<resqml22__VolumeRegion *> Regions;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SealedVolumeFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml22__SealedVolumeFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SealedVolumeFrameworkRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__SealedVolumeFrameworkRepresentation() : BasedOn(), Regions() { }
        virtual ~resqml22__SealedVolumeFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__SealedVolumeFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SealedVolumeFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__SealedVolumeFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:283 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation (-79)
/* Type resqml22__TriangulatedSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:TriangulatedSetRepresentation': */
class SOAP_CMAC resqml22__TriangulatedSetRepresentation : public resqml22__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml22:TrianglePatch' of XML schema type 'resqml22:TrianglePatch'
        std::vector<resqml22__TrianglePatch *> TrianglePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TriangulatedSetRepresentation, default initialized and not managed by a soap context
        virtual resqml22__TriangulatedSetRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TriangulatedSetRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__TriangulatedSetRepresentation() : TrianglePatch() { }
        virtual ~resqml22__TriangulatedSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__TriangulatedSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TriangulatedSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__TriangulatedSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:293 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation (-84)
/* Type resqml22__AbstractGeologicUnitOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractGeologicUnitOrganizationInterpretation': */
class SOAP_CMAC resqml22__AbstractGeologicUnitOrganizationInterpretation : public resqml22__AbstractOrganizationInterpretation {
      public:
        /// Required element 'resqml22:AscendingOrderingCriteria' of XML schema type 'resqml22:OrderingCriteria'
        resqml22__OrderingCriteria AscendingOrderingCriteria;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractGeologicUnitOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml22__AbstractGeologicUnitOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractGeologicUnitOrganizationInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractGeologicUnitOrganizationInterpretation() : AscendingOrderingCriteria() { }
        virtual ~resqml22__AbstractGeologicUnitOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractGeologicUnitOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractGeologicUnitOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractGeologicUnitOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:309 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation (-92)
/* Type resqml22__FaultInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:FaultInterpretation': */
class SOAP_CMAC resqml22__FaultInterpretation : public resqml22__BoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml22:IsListric' of XML schema type 'xsd:boolean'
        bool *IsListric;
        /// Optional element 'resqml22:MaximumThrow' of XML schema type 'eml23:LengthMeasure'
        eml23__LengthMeasure *MaximumThrow;
        /// Optional element 'resqml22:MeanAzimuth' of XML schema type 'eml23:PlaneAngleMeasure'
        eml23__PlaneAngleMeasure *MeanAzimuth;
        /// Optional element 'resqml22:MeanDip' of XML schema type 'eml23:PlaneAngleMeasure'
        eml23__PlaneAngleMeasure *MeanDip;
        /// Optional element 'resqml22:ThrowInterpretation' of XML schema type 'resqml22:FaultThrow'
        std::vector<resqml22__FaultThrow *> ThrowInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__FaultInterpretation, default initialized and not managed by a soap context
        virtual resqml22__FaultInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__FaultInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__FaultInterpretation() : IsListric(), MaximumThrow(), MeanAzimuth(), MeanDip(), ThrowInterpretation() { }
        virtual ~resqml22__FaultInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__FaultInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__FaultInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__FaultInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:313 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation (-94)
/* Type resqml22__FluidBoundaryInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:FluidBoundaryInterpretation': */
class SOAP_CMAC resqml22__FluidBoundaryInterpretation : public resqml22__BoundaryFeatureInterpretation {
      public:
        /// Required element 'resqml22:FluidContact' of XML schema type 'resqml22:FluidContact'
        resqml22__FluidContact FluidContact;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__FluidBoundaryInterpretation, default initialized and not managed by a soap context
        virtual resqml22__FluidBoundaryInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__FluidBoundaryInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__FluidBoundaryInterpretation() : FluidContact() { }
        virtual ~resqml22__FluidBoundaryInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__FluidBoundaryInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__FluidBoundaryInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__FluidBoundaryInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:319 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation (-97)
/* Type resqml22__GeobodyBoundaryInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GeobodyBoundaryInterpretation': */
class SOAP_CMAC resqml22__GeobodyBoundaryInterpretation : public resqml22__BoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml22:BoundaryRelation' of XML schema type 'xsd:string'
        std::vector<std::string> BoundaryRelation;
        /// Optional element 'resqml22:IsConformableAbove' of XML schema type 'xsd:boolean'
        bool *IsConformableAbove;
        /// Optional element 'resqml22:IsConformableBelow' of XML schema type 'xsd:boolean'
        bool *IsConformableBelow;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeobodyBoundaryInterpretation, default initialized and not managed by a soap context
        virtual resqml22__GeobodyBoundaryInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeobodyBoundaryInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__GeobodyBoundaryInterpretation() : BoundaryRelation(), IsConformableAbove(), IsConformableBelow() { }
        virtual ~resqml22__GeobodyBoundaryInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__GeobodyBoundaryInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeobodyBoundaryInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__GeobodyBoundaryInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:321 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation (-98)
/* Type resqml22__GeobodyInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GeobodyInterpretation': */
class SOAP_CMAC resqml22__GeobodyInterpretation : public resqml22__GeologicUnitInterpretation {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeobodyInterpretation, default initialized and not managed by a soap context
        virtual resqml22__GeobodyInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeobodyInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__GeobodyInterpretation() { }
        virtual ~resqml22__GeobodyInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__GeobodyInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeobodyInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__GeobodyInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:329 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation (-102)
/* Type resqml22__HorizonInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:HorizonInterpretation': */
class SOAP_CMAC resqml22__HorizonInterpretation : public resqml22__BoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml22:IsConformableAbove' of XML schema type 'xsd:boolean'
        bool *IsConformableAbove;
        /// Optional element 'resqml22:IsConformableBelow' of XML schema type 'xsd:boolean'
        bool *IsConformableBelow;
        /// Optional element 'resqml22:HorizonStratigraphicRole' of XML schema type 'resqml22:HorizonStratigraphicRole'
        std::vector<resqml22__HorizonStratigraphicRole> HorizonStratigraphicRole;
        /// Optional element 'resqml22:SequenceStratigraphySurface' of XML schema type 'resqml22:SequenceStratigraphySurfaceKind'
        resqml22__SequenceStratigraphySurfaceKind *SequenceStratigraphySurface;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__HorizonInterpretation, default initialized and not managed by a soap context
        virtual resqml22__HorizonInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__HorizonInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__HorizonInterpretation() : IsConformableAbove(), IsConformableBelow(), HorizonStratigraphicRole(), SequenceStratigraphySurface() { }
        virtual ~resqml22__HorizonInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__HorizonInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__HorizonInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__HorizonInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:333 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation (-104)
/* Type resqml22__ReservoirCompartmentInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:ReservoirCompartmentInterpretation': */
class SOAP_CMAC resqml22__ReservoirCompartmentInterpretation : public resqml22__GeologicUnitInterpretation {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ReservoirCompartmentInterpretation, default initialized and not managed by a soap context
        virtual resqml22__ReservoirCompartmentInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ReservoirCompartmentInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__ReservoirCompartmentInterpretation() { }
        virtual ~resqml22__ReservoirCompartmentInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__ReservoirCompartmentInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ReservoirCompartmentInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__ReservoirCompartmentInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:337 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation (-106)
/* Type resqml22__RockFluidOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:RockFluidOrganizationInterpretation': */
class SOAP_CMAC resqml22__RockFluidOrganizationInterpretation : public resqml22__AbstractOrganizationInterpretation {
      public:
        /// Optional element 'resqml22:RockFluidUnit' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> RockFluidUnit;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RockFluidOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml22__RockFluidOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RockFluidOrganizationInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__RockFluidOrganizationInterpretation() : RockFluidUnit() { }
        virtual ~resqml22__RockFluidOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__RockFluidOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RockFluidOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__RockFluidOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:339 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation (-107)
/* Type resqml22__RockFluidUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:RockFluidUnitInterpretation': */
class SOAP_CMAC resqml22__RockFluidUnitInterpretation : public resqml22__GeologicUnitInterpretation {
      public:
        /// Optional element 'resqml22:Phase' of XML schema type 'resqml22:Phase'
        resqml22__Phase *Phase;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__RockFluidUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml22__RockFluidUnitInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__RockFluidUnitInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__RockFluidUnitInterpretation() : Phase() { }
        virtual ~resqml22__RockFluidUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__RockFluidUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__RockFluidUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__RockFluidUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:345 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation (-110)
/* Type resqml22__StratigraphicUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StratigraphicUnitInterpretation': */
class SOAP_CMAC resqml22__StratigraphicUnitInterpretation : public resqml22__GeologicUnitInterpretation {
      public:
        /// Optional element 'resqml22:DepositionMode' of XML schema type 'resqml22:DepositionMode'
        resqml22__DepositionMode *DepositionMode;
        /// Optional element 'resqml22:MaxThickness' of XML schema type 'eml23:LengthMeasure'
        eml23__LengthMeasure *MaxThickness;
        /// Optional element 'resqml22:MinThickness' of XML schema type 'eml23:LengthMeasure'
        eml23__LengthMeasure *MinThickness;
        /// Optional element 'resqml22:StratigraphicUnitKind' of XML schema type 'resqml22:StratigraphicUnitKind'
        resqml22__StratigraphicUnitKind *StratigraphicUnitKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StratigraphicUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml22__StratigraphicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StratigraphicUnitInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__StratigraphicUnitInterpretation() : DepositionMode(), MaxThickness(), MinThickness(), StratigraphicUnitKind() { }
        virtual ~resqml22__StratigraphicUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__StratigraphicUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StratigraphicUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__StratigraphicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:347 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation (-111)
/* Type resqml22__StructuralOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StructuralOrganizationInterpretation': */
class SOAP_CMAC resqml22__StructuralOrganizationInterpretation : public resqml22__AbstractOrganizationInterpretation {
      public:
        /// Required element 'resqml22:AscendingOrderingCriteria' of XML schema type 'resqml22:OrderingCriteria'
        resqml22__OrderingCriteria AscendingOrderingCriteria;
        /// Optional element 'resqml22:BottomFrontier' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> BottomFrontier;
        /// Optional element 'resqml22:TopFrontier' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> TopFrontier;
        /// Optional element 'resqml22:Sides' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> Sides;
        /// Optional element 'resqml22:OrderedBoundaryFeatureInterpretation' of XML schema type 'resqml22:BoundaryFeatureInterpretationPlusItsRank'
        std::vector<resqml22__BoundaryFeatureInterpretationPlusItsRank *> OrderedBoundaryFeatureInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StructuralOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml22__StructuralOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StructuralOrganizationInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__StructuralOrganizationInterpretation() : AscendingOrderingCriteria(), BottomFrontier(), TopFrontier(), Sides(), OrderedBoundaryFeatureInterpretation() { }
        virtual ~resqml22__StructuralOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__StructuralOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StructuralOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__StructuralOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:349 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation (-112)
/* Type resqml22__VoidageGroupInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:VoidageGroupInterpretation': */
class SOAP_CMAC resqml22__VoidageGroupInterpretation : public resqml22__AbstractOrganizationInterpretation {
      public:
        /// Optional element 'resqml22:Stratigraphy' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Stratigraphy;
        /// Optional element 'resqml22:Fluids' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Fluids;
        /// Optional element 'resqml22:Compartments' of XML schema type 'resqml22:ReservoirCompartmentInterpretation'
        std::vector<resqml22__ReservoirCompartmentInterpretation *> Compartments;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__VoidageGroupInterpretation, default initialized and not managed by a soap context
        virtual resqml22__VoidageGroupInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__VoidageGroupInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__VoidageGroupInterpretation() : Stratigraphy(), Fluids(), Compartments() { }
        virtual ~resqml22__VoidageGroupInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__VoidageGroupInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__VoidageGroupInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__VoidageGroupInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:381 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry (-128)
/* complex XML schema type 'resqml22:AbstractColumnLayerGridGeometry': */
class SOAP_CMAC resqml22__AbstractColumnLayerGridGeometry : public resqml22__AbstractGridGeometry {
      public:
        /// Optional element 'resqml22:CellGeometryIsDefined' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *CellGeometryIsDefined;
        /// Required element 'resqml22:KDirection' of XML schema type 'resqml22:KDirection'
        resqml22__KDirection KDirection;
        /// Optional element 'resqml22:NodeIsColocatedInKDirection' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *NodeIsColocatedInKDirection;
        /// Optional element 'resqml22:NodeIsColocatedOnKEdge' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *NodeIsColocatedOnKEdge;
        /// Required element 'resqml22:PillarGeometryIsDefined' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *PillarGeometryIsDefined;
        /// Required element 'resqml22:PillarShape' of XML schema type 'resqml22:PillarShape'
        resqml22__PillarShape PillarShape;
        /// Optional element 'resqml22:SplitColumnEdges' of XML schema type 'resqml22:SplitColumnEdges'
        resqml22__SplitColumnEdges *SplitColumnEdges;
        /// Optional element 'resqml22:ColumnLayerSubnodeTopology' of XML schema type 'resqml22:ColumnLayerSubnodeTopology'
        resqml22__ColumnLayerSubnodeTopology *ColumnLayerSubnodeTopology;
        /// Optional element 'resqml22:ColumnLayerSplitCoordinateLines' of XML schema type 'resqml22:ColumnLayerSplitCoordinateLines'
        resqml22__ColumnLayerSplitCoordinateLines *ColumnLayerSplitCoordinateLines;
        /// Optional element 'resqml22:SplitNodePatch' of XML schema type 'resqml22:SplitNodePatch'
        resqml22__SplitNodePatch *SplitNodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractColumnLayerGridGeometry, default initialized and not managed by a soap context
        virtual resqml22__AbstractColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractColumnLayerGridGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractColumnLayerGridGeometry() : CellGeometryIsDefined(), KDirection(), NodeIsColocatedInKDirection(), NodeIsColocatedOnKEdge(), PillarGeometryIsDefined(), PillarShape(), SplitColumnEdges(), ColumnLayerSubnodeTopology(), ColumnLayerSplitCoordinateLines(), SplitNodePatch() { }
        virtual ~resqml22__AbstractColumnLayerGridGeometry() { }
        /// Friend allocator used by soap_new_resqml22__AbstractColumnLayerGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractColumnLayerGridGeometry * SOAP_FMAC2 soap_instantiate_resqml22__AbstractColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:383 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation (-129)
/* Type resqml22__AbstractColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractColumnLayerGridRepresentation': */
class SOAP_CMAC resqml22__AbstractColumnLayerGridRepresentation : public resqml22__AbstractGridRepresentation {
      public:
        /// Required element 'resqml22:Nk' of XML schema type 'eml23:PositiveLong'
        LONG64 Nk;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractColumnLayerGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractColumnLayerGridRepresentation() : Nk() { }
        virtual ~resqml22__AbstractColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:391 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation (-133)
/* Type resqml22__AbstractTruncatedColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractTruncatedColumnLayerGridRepresentation': */
class SOAP_CMAC resqml22__AbstractTruncatedColumnLayerGridRepresentation : public resqml22__AbstractGridRepresentation {
      public:
        /// Required element 'resqml22:Nk' of XML schema type 'eml23:PositiveLong'
        LONG64 Nk;
        /// Required element 'resqml22:TruncationCellPatch' of XML schema type 'resqml22:TruncationCellPatch'
        resqml22__TruncationCellPatch *TruncationCellPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractTruncatedColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__AbstractTruncatedColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractTruncatedColumnLayerGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractTruncatedColumnLayerGridRepresentation() : Nk(), TruncationCellPatch() { }
        virtual ~resqml22__AbstractTruncatedColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__AbstractTruncatedColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractTruncatedColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__AbstractTruncatedColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:421 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation (-148)
/* Type resqml22__GpGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GpGridRepresentation': */
class SOAP_CMAC resqml22__GpGridRepresentation : public resqml22__AbstractGridRepresentation {
      public:
        /// Optional element 'resqml22:ColumnLayerGpGrid' of XML schema type 'resqml22:ColumnLayerGpGrid'
        std::vector<resqml22__ColumnLayerGpGrid *> ColumnLayerGpGrid;
        /// Optional element 'resqml22:UnstructuredGpGridPatch' of XML schema type 'resqml22:UnstructuredGpGridPatch'
        std::vector<resqml22__UnstructuredGpGridPatch *> UnstructuredGpGridPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GpGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__GpGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GpGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__GpGridRepresentation() : ColumnLayerGpGrid(), UnstructuredGpGridPatch() { }
        virtual ~resqml22__GpGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__GpGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GpGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__GpGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:423 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation (-149)
/* Type resqml22__Grid2dRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:Grid2dRepresentation': */
class SOAP_CMAC resqml22__Grid2dRepresentation : public resqml22__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml22:FastestAxisCount' of XML schema type 'eml23:PositiveLong'
        LONG64 FastestAxisCount;
        /// Required element 'resqml22:SlowestAxisCount' of XML schema type 'eml23:PositiveLong'
        LONG64 SlowestAxisCount;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:PointGeometry'
        resqml22__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__Grid2dRepresentation, default initialized and not managed by a soap context
        virtual resqml22__Grid2dRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__Grid2dRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__Grid2dRepresentation() : FastestAxisCount(), SlowestAxisCount(), Geometry() { }
        virtual ~resqml22__Grid2dRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__Grid2dRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__Grid2dRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__Grid2dRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:481 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry (-178)
/* complex XML schema type 'resqml22:UnstructuredGridGeometry': */
class SOAP_CMAC resqml22__UnstructuredGridGeometry : public resqml22__AbstractGridGeometry {
      public:
        /// Required element 'resqml22:CellFaceIsRightHanded' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *CellFaceIsRightHanded;
        /// Required element 'resqml22:CellShape' of XML schema type 'resqml22:CellShape'
        resqml22__CellShape CellShape;
        /// Required element 'resqml22:FaceCount' of XML schema type 'eml23:PositiveLong'
        LONG64 FaceCount;
        /// Required element 'resqml22:FacesPerCell' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *FacesPerCell;
        /// Required element 'resqml22:NodeCount' of XML schema type 'eml23:PositiveLong'
        LONG64 NodeCount;
        /// Required element 'resqml22:NodesPerFace' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *NodesPerFace;
        /// Optional element 'resqml22:UnstructuredGridHingeNodeFaces' of XML schema type 'resqml22:UnstructuredGridHingeNodeFaces'
        resqml22__UnstructuredGridHingeNodeFaces *UnstructuredGridHingeNodeFaces;
        /// Optional element 'resqml22:UnstructuredSubnodeTopology' of XML schema type 'resqml22:UnstructuredSubnodeTopology'
        resqml22__UnstructuredSubnodeTopology *UnstructuredSubnodeTopology;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredGridGeometry, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredGridGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredGridGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredGridGeometry() : CellFaceIsRightHanded(), CellShape(), FaceCount(), FacesPerCell(), NodeCount(), NodesPerFace(), UnstructuredGridHingeNodeFaces(), UnstructuredSubnodeTopology() { }
        virtual ~resqml22__UnstructuredGridGeometry() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredGridGeometry * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:485 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation (-180)
/* Type resqml22__UnstructuredGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:UnstructuredGridRepresentation': */
class SOAP_CMAC resqml22__UnstructuredGridRepresentation : public resqml22__AbstractGridRepresentation {
      public:
        /// Required element 'resqml22:CellCount' of XML schema type 'eml23:PositiveLong'
        LONG64 CellCount;
        /// Optional element 'resqml22:OriginalCellIndex' of XML schema type 'resqml22:AlternateCellIndex'
        resqml22__AlternateCellIndex *OriginalCellIndex;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:UnstructuredGridGeometry'
        resqml22__UnstructuredGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredGridRepresentation() : CellCount(), OriginalCellIndex(), Geometry() { }
        virtual ~resqml22__UnstructuredGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:537 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty (-206)
/* Type resqml22__BooleanProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:BooleanProperty': */
class SOAP_CMAC resqml22__BooleanProperty : public resqml22__AbstractValuesProperty {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BooleanProperty, default initialized and not managed by a soap context
        virtual resqml22__BooleanProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BooleanProperty); }
      public:
        /// Constructor with default initializations
        resqml22__BooleanProperty() { }
        virtual ~resqml22__BooleanProperty() { }
        /// Friend allocator used by soap_new_resqml22__BooleanProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BooleanProperty * SOAP_FMAC2 soap_instantiate_resqml22__BooleanProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:539 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty (-207)
/* Type resqml22__CategoricalProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:CategoricalProperty': */
class SOAP_CMAC resqml22__CategoricalProperty : public resqml22__AbstractValuesProperty {
      public:
        /// Required element 'resqml22:Lookup' of XML schema type 'eml23:ColumnBasedTable'
        eml23__ColumnBasedTable *Lookup;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CategoricalProperty, default initialized and not managed by a soap context
        virtual resqml22__CategoricalProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CategoricalProperty); }
      public:
        /// Constructor with default initializations
        resqml22__CategoricalProperty() : Lookup() { }
        virtual ~resqml22__CategoricalProperty() { }
        /// Friend allocator used by soap_new_resqml22__CategoricalProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CategoricalProperty * SOAP_FMAC2 soap_instantiate_resqml22__CategoricalProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:541 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty (-208)
/* Type resqml22__CommentProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:CommentProperty': */
class SOAP_CMAC resqml22__CommentProperty : public resqml22__AbstractValuesProperty {
      public:
        /// Optional element 'resqml22:Language' of XML schema type 'eml23:String64'
        std::string *Language;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CommentProperty, default initialized and not managed by a soap context
        virtual resqml22__CommentProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CommentProperty); }
      public:
        /// Constructor with default initializations
        resqml22__CommentProperty() : Language() { }
        virtual ~resqml22__CommentProperty() { }
        /// Friend allocator used by soap_new_resqml22__CommentProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CommentProperty * SOAP_FMAC2 soap_instantiate_resqml22__CommentProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:543 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty (-209)
/* Type resqml22__ContinuousProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:ContinuousProperty': */
class SOAP_CMAC resqml22__ContinuousProperty : public resqml22__AbstractValuesProperty {
      public:
        /// Required element 'resqml22:Uom' of XML schema type 'eml23:UnitOfMeasureExt'
        std::string Uom;
        /// Optional element 'resqml22:CustomUnitDictionary' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *CustomUnitDictionary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ContinuousProperty, default initialized and not managed by a soap context
        virtual resqml22__ContinuousProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ContinuousProperty); }
      public:
        /// Constructor with default initializations
        resqml22__ContinuousProperty() : Uom(), CustomUnitDictionary() { }
        virtual ~resqml22__ContinuousProperty() { }
        /// Friend allocator used by soap_new_resqml22__ContinuousProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ContinuousProperty * SOAP_FMAC2 soap_instantiate_resqml22__ContinuousProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:545 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty (-210)
/* Type resqml22__DiscreteProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:DiscreteProperty': */
class SOAP_CMAC resqml22__DiscreteProperty : public resqml22__AbstractValuesProperty {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__DiscreteProperty, default initialized and not managed by a soap context
        virtual resqml22__DiscreteProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__DiscreteProperty); }
      public:
        /// Constructor with default initializations
        resqml22__DiscreteProperty() { }
        virtual ~resqml22__DiscreteProperty() { }
        /// Friend allocator used by soap_new_resqml22__DiscreteProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml22__DiscreteProperty * SOAP_FMAC2 soap_instantiate_resqml22__DiscreteProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:549 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature (-212)
/* Type resqml22__StreamlinesFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StreamlinesFeature': */
class SOAP_CMAC resqml22__StreamlinesFeature : public resqml22__AbstractTechnicalFeature {
      public:
        /// Required element 'resqml22:Flux' of XML schema type 'resqml22:StreamlineFluxExt'
        std::string Flux;
        /// Required element 'resqml22:TimeIndex' of XML schema type 'eml23:TimeIndex'
        eml23__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StreamlinesFeature, default initialized and not managed by a soap context
        virtual resqml22__StreamlinesFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StreamlinesFeature); }
      public:
        /// Constructor with default initializations
        resqml22__StreamlinesFeature() : Flux(), TimeIndex() { }
        virtual ~resqml22__StreamlinesFeature() { }
        /// Friend allocator used by soap_new_resqml22__StreamlinesFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StreamlinesFeature * SOAP_FMAC2 soap_instantiate_resqml22__StreamlinesFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:555 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation (-215)
/* Type resqml22__BlockedWellboreRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:BlockedWellboreRepresentation': */
class SOAP_CMAC resqml22__BlockedWellboreRepresentation : public resqml22__WellboreFrameRepresentation {
      public:
        /// Required element 'resqml22:IntervalGridCells' of XML schema type 'resqml22:IntervalGridCells'
        resqml22__IntervalGridCells *IntervalGridCells;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__BlockedWellboreRepresentation, default initialized and not managed by a soap context
        virtual resqml22__BlockedWellboreRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__BlockedWellboreRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__BlockedWellboreRepresentation() : IntervalGridCells() { }
        virtual ~resqml22__BlockedWellboreRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__BlockedWellboreRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__BlockedWellboreRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__BlockedWellboreRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:559 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation (-217)
/* Type resqml22__SeismicWellboreFrameRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SeismicWellboreFrameRepresentation': */
class SOAP_CMAC resqml22__SeismicWellboreFrameRepresentation : public resqml22__WellboreFrameRepresentation {
      public:
        /// Required element 'resqml22:NodeTimeValues' of XML schema type 'eml23:AbstractFloatingPointArray'
        eml23__AbstractFloatingPointArray *NodeTimeValues;
        /// Required element 'resqml22:SeismicReferenceDatum' of XML schema type 'xsd:double'
        double SeismicReferenceDatum;
        /// Required element 'resqml22:WeatheringVelocity' of XML schema type 'xsd:double'
        double WeatheringVelocity;
        /// Optional element 'resqml22:TvdInformation' of XML schema type 'resqml22:TvdInformation'
        resqml22__TvdInformation *TvdInformation;
        /// Optional element 'resqml22:CorrectionInformation' of XML schema type 'resqml22:CorrectionInformation'
        resqml22__CorrectionInformation *CorrectionInformation;
        /// Required element 'resqml22:LocalTime3dCrs' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *LocalTime3dCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SeismicWellboreFrameRepresentation, default initialized and not managed by a soap context
        virtual resqml22__SeismicWellboreFrameRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SeismicWellboreFrameRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__SeismicWellboreFrameRepresentation() : NodeTimeValues(), SeismicReferenceDatum(), WeatheringVelocity(), TvdInformation(), CorrectionInformation(), LocalTime3dCrs() { }
        virtual ~resqml22__SeismicWellboreFrameRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__SeismicWellboreFrameRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SeismicWellboreFrameRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__SeismicWellboreFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:563 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature (-219)
/* Type resqml22__WellboreFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreFeature': */
class SOAP_CMAC resqml22__WellboreFeature : public resqml22__AbstractTechnicalFeature {
      public:
        /// Optional element 'resqml22:WitsmlWellbore' of XML schema type 'resqml22:WitsmlWellWellbore'
        resqml22__WitsmlWellWellbore *WitsmlWellbore;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreFeature, default initialized and not managed by a soap context
        virtual resqml22__WellboreFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreFeature); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreFeature() : WitsmlWellbore() { }
        virtual ~resqml22__WellboreFeature() { }
        /// Friend allocator used by soap_new_resqml22__WellboreFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreFeature * SOAP_FMAC2 soap_instantiate_resqml22__WellboreFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:571 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation (-223)
/* Type resqml22__WellboreMarkerFrameRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:WellboreMarkerFrameRepresentation': */
class SOAP_CMAC resqml22__WellboreMarkerFrameRepresentation : public resqml22__WellboreFrameRepresentation {
      public:
        /// Required element 'resqml22:WellboreMarker' of XML schema type 'resqml22:WellboreMarker'
        std::vector<resqml22__WellboreMarker *> WellboreMarker;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__WellboreMarkerFrameRepresentation, default initialized and not managed by a soap context
        virtual resqml22__WellboreMarkerFrameRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__WellboreMarkerFrameRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__WellboreMarkerFrameRepresentation() : WellboreMarker() { }
        virtual ~resqml22__WellboreMarkerFrameRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__WellboreMarkerFrameRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__WellboreMarkerFrameRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__WellboreMarkerFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:613 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName (-244)
/* simple XML schema type 'eml23:AuthorityQualifiedName': */
class SOAP_CMAC eml23__AuthorityQualifiedName {
      public:
        /// Simple content of XML schema type 'eml23:String64' wrapped by this struct
        std::string __item;
        /// Required attribute 'authority' of XML schema type 'eml23:String64'
        std::string authority;
        /// Optional attribute 'code' of XML schema type 'eml23:String64'
        std::string *code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__AuthorityQualifiedName, default initialized and not managed by a soap context
        virtual eml23__AuthorityQualifiedName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__AuthorityQualifiedName); }
      public:
        /// Constructor with default initializations
        eml23__AuthorityQualifiedName() : __item(), authority(), code(), soap() { }
        virtual ~eml23__AuthorityQualifiedName() { }
        /// Friend allocator used by soap_new_eml23__AuthorityQualifiedName(struct soap*, int)
        friend SOAP_FMAC1 eml23__AuthorityQualifiedName * SOAP_FMAC2 soap_instantiate_eml23__AuthorityQualifiedName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:623 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray (-249)
/* complex XML schema type 'eml23:FloatingPointConstantArray': */
class SOAP_CMAC eml23__FloatingPointConstantArray : public eml23__AbstractFloatingPointArray {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:double'
        double Value;
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FloatingPointConstantArray, default initialized and not managed by a soap context
        virtual eml23__FloatingPointConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FloatingPointConstantArray); }
      public:
        /// Constructor with default initializations
        eml23__FloatingPointConstantArray() : Value(), Count() { }
        virtual ~eml23__FloatingPointConstantArray() { }
        /// Friend allocator used by soap_new_eml23__FloatingPointConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__FloatingPointConstantArray * SOAP_FMAC2 soap_instantiate_eml23__FloatingPointConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:625 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray (-250)
/* complex XML schema type 'eml23:FloatingPointExternalArray': */
class SOAP_CMAC eml23__FloatingPointExternalArray : public eml23__AbstractFloatingPointArray {
      public:
        /// Required element 'eml23:ArrayFloatingPointType' of XML schema type 'eml23:FloatingPointType'
        eml23__FloatingPointType ArrayFloatingPointType;
        /// Required element 'eml23:Values' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Values;
        /// Optional element 'eml23:ValidValueCount' of XML schema type 'xsd:long'
        LONG64 *ValidValueCount;
        /// Optional element 'eml23:MinimumValue' of XML schema type 'xsd:double'
        double *MinimumValue;
        /// Optional element 'eml23:MaximumValue' of XML schema type 'xsd:double'
        double *MaximumValue;
        /// Optional element 'eml23:ValuesMean' of XML schema type 'xsd:double'
        double *ValuesMean;
        /// Optional element 'eml23:ValuesMedian' of XML schema type 'xsd:double'
        double *ValuesMedian;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:double'
        double *ValuesMode;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
        /// Optional element 'eml23:ValuesStandardDeviation' of XML schema type 'xsd:double'
        double *ValuesStandardDeviation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FloatingPointExternalArray, default initialized and not managed by a soap context
        virtual eml23__FloatingPointExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FloatingPointExternalArray); }
      public:
        /// Constructor with default initializations
        eml23__FloatingPointExternalArray() : ArrayFloatingPointType(), Values(), ValidValueCount(), MinimumValue(), MaximumValue(), ValuesMean(), ValuesMedian(), ValuesMode(), ModePercentage(), ValuesStandardDeviation() { }
        virtual ~eml23__FloatingPointExternalArray() { }
        /// Friend allocator used by soap_new_eml23__FloatingPointExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__FloatingPointExternalArray * SOAP_FMAC2 soap_instantiate_eml23__FloatingPointExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:627 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray (-251)
/* complex XML schema type 'eml23:FloatingPointLatticeArray': */
class SOAP_CMAC eml23__FloatingPointLatticeArray : public eml23__AbstractFloatingPointArray {
      public:
        /// Required element 'eml23:StartValue' of XML schema type 'xsd:double'
        double StartValue;
        /// Required element 'eml23:Offset' of XML schema type 'eml23:FloatingPointConstantArray'
        std::vector<eml23__FloatingPointConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FloatingPointLatticeArray, default initialized and not managed by a soap context
        virtual eml23__FloatingPointLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FloatingPointLatticeArray); }
      public:
        /// Constructor with default initializations
        eml23__FloatingPointLatticeArray() : StartValue(), Offset() { }
        virtual ~eml23__FloatingPointLatticeArray() { }
        /// Friend allocator used by soap_new_eml23__FloatingPointLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__FloatingPointLatticeArray * SOAP_FMAC2 soap_instantiate_eml23__FloatingPointLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:629 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray (-252)
/* complex XML schema type 'eml23:FloatingPointXmlArray': */
class SOAP_CMAC eml23__FloatingPointXmlArray : public eml23__AbstractFloatingPointArray {
      public:
        /// Required element 'eml23:Values' of XML schema type 'eml23:FloatingPointXmlArrayList'
        std::string Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__FloatingPointXmlArray, default initialized and not managed by a soap context
        virtual eml23__FloatingPointXmlArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__FloatingPointXmlArray); }
      public:
        /// Constructor with default initializations
        eml23__FloatingPointXmlArray() : Values() { }
        virtual ~eml23__FloatingPointXmlArray() { }
        /// Friend allocator used by soap_new_eml23__FloatingPointXmlArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__FloatingPointXmlArray * SOAP_FMAC2 soap_instantiate_eml23__FloatingPointXmlArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:633 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray (-254)
/* complex XML schema type 'eml23:IntegerArrayFromBooleanMaskArray': */
class SOAP_CMAC eml23__IntegerArrayFromBooleanMaskArray : public eml23__AbstractIntegerArray {
      public:
        /// Required element 'eml23:Mask' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *Mask;
        /// Optional element 'eml23:MinimumValue' of XML schema type 'xsd:long'
        LONG64 *MinimumValue;
        /// Optional element 'eml23:MaximumValue' of XML schema type 'xsd:long'
        LONG64 *MaximumValue;
        /// Optional element 'eml23:ValuesMedian' of XML schema type 'xsd:long'
        LONG64 *ValuesMedian;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:long'
        LONG64 *ValuesMode;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IntegerArrayFromBooleanMaskArray, default initialized and not managed by a soap context
        virtual eml23__IntegerArrayFromBooleanMaskArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IntegerArrayFromBooleanMaskArray); }
      public:
        /// Constructor with default initializations
        eml23__IntegerArrayFromBooleanMaskArray() : Mask(), MinimumValue(), MaximumValue(), ValuesMedian(), ValuesMode(), ModePercentage() { }
        virtual ~eml23__IntegerArrayFromBooleanMaskArray() { }
        /// Friend allocator used by soap_new_eml23__IntegerArrayFromBooleanMaskArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__IntegerArrayFromBooleanMaskArray * SOAP_FMAC2 soap_instantiate_eml23__IntegerArrayFromBooleanMaskArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:635 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray (-255)
/* complex XML schema type 'eml23:IntegerConstantArray': */
class SOAP_CMAC eml23__IntegerConstantArray : public eml23__AbstractIntegerArray {
      public:
        /// Required element 'eml23:Value' of XML schema type 'xsd:long'
        LONG64 Value;
        /// Required element 'eml23:Count' of XML schema type 'eml23:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IntegerConstantArray, default initialized and not managed by a soap context
        virtual eml23__IntegerConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IntegerConstantArray); }
      public:
        /// Constructor with default initializations
        eml23__IntegerConstantArray() : Value(), Count() { }
        virtual ~eml23__IntegerConstantArray() { }
        /// Friend allocator used by soap_new_eml23__IntegerConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__IntegerConstantArray * SOAP_FMAC2 soap_instantiate_eml23__IntegerConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:637 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray (-256)
/* complex XML schema type 'eml23:IntegerExternalArray': */
class SOAP_CMAC eml23__IntegerExternalArray : public eml23__AbstractIntegerArray {
      public:
        /// Required element 'eml23:ArrayIntegerType' of XML schema type 'eml23:IntegerType'
        eml23__IntegerType ArrayIntegerType;
        /// Required element 'eml23:NullValue' of XML schema type 'xsd:long'
        LONG64 NullValue;
        /// Required element 'eml23:Values' of XML schema type 'eml23:ExternalDataArray'
        eml23__ExternalDataArray *Values;
        /// Optional element 'eml23:ValidValueCount' of XML schema type 'xsd:long'
        LONG64 *ValidValueCount;
        /// Optional element 'eml23:MinimumValue' of XML schema type 'xsd:long'
        LONG64 *MinimumValue;
        /// Optional element 'eml23:MaximumValue' of XML schema type 'xsd:long'
        LONG64 *MaximumValue;
        /// Optional element 'eml23:ValuesMedian' of XML schema type 'xsd:long'
        LONG64 *ValuesMedian;
        /// Optional element 'eml23:ValuesMode' of XML schema type 'xsd:long'
        LONG64 *ValuesMode;
        /// Optional element 'eml23:ModePercentage' of XML schema type 'xsd:double'
        double *ModePercentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IntegerExternalArray, default initialized and not managed by a soap context
        virtual eml23__IntegerExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IntegerExternalArray); }
      public:
        /// Constructor with default initializations
        eml23__IntegerExternalArray() : ArrayIntegerType(), NullValue(), Values(), ValidValueCount(), MinimumValue(), MaximumValue(), ValuesMedian(), ValuesMode(), ModePercentage() { }
        virtual ~eml23__IntegerExternalArray() { }
        /// Friend allocator used by soap_new_eml23__IntegerExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__IntegerExternalArray * SOAP_FMAC2 soap_instantiate_eml23__IntegerExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:639 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray (-257)
/* complex XML schema type 'eml23:IntegerLatticeArray': */
class SOAP_CMAC eml23__IntegerLatticeArray : public eml23__AbstractIntegerArray {
      public:
        /// Required element 'eml23:StartValue' of XML schema type 'xsd:long'
        LONG64 StartValue;
        /// Required element 'eml23:Offset' of XML schema type 'eml23:IntegerConstantArray'
        std::vector<eml23__IntegerConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__IntegerLatticeArray, default initialized and not managed by a soap context
        virtual eml23__IntegerLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__IntegerLatticeArray); }
      public:
        /// Constructor with default initializations
        eml23__IntegerLatticeArray() : StartValue(), Offset() { }
        virtual ~eml23__IntegerLatticeArray() { }
        /// Friend allocator used by soap_new_eml23__IntegerLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml23__IntegerLatticeArray * SOAP_FMAC2 soap_instantiate_eml23__IntegerLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:651 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure (-263)
/* simple XML schema type 'eml23:StringMeasure': */
class SOAP_CMAC eml23__StringMeasure {
      public:
        /// Simple content of XML schema type 'eml23:String2000' wrapped by this struct
        std::string __item;
        /// Optional attribute 'uom' of XML schema type 'eml23:UnitOfMeasureExt'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__StringMeasure, default initialized and not managed by a soap context
        virtual eml23__StringMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__StringMeasure); }
      public:
        /// Constructor with default initializations
        eml23__StringMeasure() : __item(), uom(), soap() { }
        virtual ~eml23__StringMeasure() { }
        /// Friend allocator used by soap_new_eml23__StringMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml23__StringMeasure * SOAP_FMAC2 soap_instantiate_eml23__StringMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:677 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore (-276)
/* Type eml23__ReferencePointInAWellbore is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'eml23:ReferencePointInAWellbore': */
class SOAP_CMAC eml23__ReferencePointInAWellbore : public eml23__RecursiveReferencePoint {
      public:
        /// Required element 'eml23:Md' of XML schema type 'eml23:LengthMeasureExt'
        eml23__LengthMeasureExt *Md;
        /// Optional element 'eml23:Trajectory' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Trajectory;
        /// Required element 'eml23:Wellbore' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *Wellbore;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__ReferencePointInAWellbore, default initialized and not managed by a soap context
        virtual eml23__ReferencePointInAWellbore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__ReferencePointInAWellbore); }
      public:
        /// Constructor with default initializations
        eml23__ReferencePointInAWellbore() : Md(), Trajectory(), Wellbore() { }
        virtual ~eml23__ReferencePointInAWellbore() { }
        /// Friend allocator used by soap_new_eml23__ReferencePointInAWellbore(struct soap*, int)
        friend SOAP_FMAC1 eml23__ReferencePointInAWellbore * SOAP_FMAC2 soap_instantiate_eml23__ReferencePointInAWellbore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1517 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct (-696)
/* simple XML schema type 'eml23:EmailQualifierStruct': */
class SOAP_CMAC eml23__EmailQualifierStruct {
      public:
        /// Simple content of XML schema type 'eml23:String64' wrapped by this struct
        std::string __item;
        /// Optional attribute 'qualifier' of XML schema type 'eml23:AddressQualifier'
        eml23__AddressQualifier *qualifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__EmailQualifierStruct, default initialized and not managed by a soap context
        virtual eml23__EmailQualifierStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__EmailQualifierStruct); }
      public:
        /// Constructor with default initializations
        eml23__EmailQualifierStruct() : __item(), qualifier(), soap() { }
        virtual ~eml23__EmailQualifierStruct() { }
        /// Friend allocator used by soap_new_eml23__EmailQualifierStruct(struct soap*, int)
        friend SOAP_FMAC1 eml23__EmailQualifierStruct * SOAP_FMAC2 soap_instantiate_eml23__EmailQualifierStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:1521 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct (-698)
/* simple XML schema type 'eml23:NameStruct': */
class SOAP_CMAC eml23__NameStruct {
      public:
        /// Simple content of XML schema type 'eml23:String64' wrapped by this struct
        std::string __item;
        /// Optional attribute 'authority' of XML schema type 'eml23:String64'
        std::string *authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml23__NameStruct, default initialized and not managed by a soap context
        virtual eml23__NameStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml23__NameStruct); }
      public:
        /// Constructor with default initializations
        eml23__NameStruct() : __item(), authority(), soap() { }
        virtual ~eml23__NameStruct() { }
        /// Friend allocator used by soap_new_eml23__NameStruct(struct soap*, int)
        friend SOAP_FMAC1 eml23__NameStruct * SOAP_FMAC2 soap_instantiate_eml23__NameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:223 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature (-49)
/* Type resqml22__AbstractSeismicLineFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:AbstractSeismicLineFeature': */
class SOAP_CMAC resqml22__AbstractSeismicLineFeature : public resqml22__AbstractSeismicSurveyFeature {
      public:
        /// Optional element 'resqml22:TraceLabels' of XML schema type 'eml23:StringExternalArray'
        eml23__StringExternalArray *TraceLabels;
        /// Optional element 'resqml22:IsPartOf' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *IsPartOf;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__AbstractSeismicLineFeature, default initialized and not managed by a soap context
        virtual resqml22__AbstractSeismicLineFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__AbstractSeismicLineFeature); }
      public:
        /// Constructor with default initializations
        resqml22__AbstractSeismicLineFeature() : TraceLabels(), IsPartOf() { }
        virtual ~resqml22__AbstractSeismicLineFeature() { }
        /// Friend allocator used by soap_new_resqml22__AbstractSeismicLineFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__AbstractSeismicLineFeature * SOAP_FMAC2 soap_instantiate_resqml22__AbstractSeismicLineFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:237 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature (-56)
/* Type resqml22__SeismicLatticeFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SeismicLatticeFeature': */
class SOAP_CMAC resqml22__SeismicLatticeFeature : public resqml22__AbstractSeismicSurveyFeature {
      public:
        /// Optional element 'resqml22:CrosslineLabels' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *CrosslineLabels;
        /// Optional element 'resqml22:InlineLabels' of XML schema type 'eml23:IntegerLatticeArray'
        eml23__IntegerLatticeArray *InlineLabels;
        /// Optional element 'resqml22:IsPartOf' of XML schema type 'resqml22:SeismicLatticeSetFeature'
        resqml22__SeismicLatticeSetFeature *IsPartOf;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SeismicLatticeFeature, default initialized and not managed by a soap context
        virtual resqml22__SeismicLatticeFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SeismicLatticeFeature); }
      public:
        /// Constructor with default initializations
        resqml22__SeismicLatticeFeature() : CrosslineLabels(), InlineLabels(), IsPartOf() { }
        virtual ~resqml22__SeismicLatticeFeature() { }
        /// Friend allocator used by soap_new_resqml22__SeismicLatticeFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SeismicLatticeFeature * SOAP_FMAC2 soap_instantiate_resqml22__SeismicLatticeFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:239 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature (-57)
/* complex XML schema type 'resqml22:SeismicLatticeSetFeature': */
class SOAP_CMAC resqml22__SeismicLatticeSetFeature : public resqml22__AbstractSeismicSurveyFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SeismicLatticeSetFeature, default initialized and not managed by a soap context
        virtual resqml22__SeismicLatticeSetFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SeismicLatticeSetFeature); }
      public:
        /// Constructor with default initializations
        resqml22__SeismicLatticeSetFeature() { }
        virtual ~resqml22__SeismicLatticeSetFeature() { }
        /// Friend allocator used by soap_new_resqml22__SeismicLatticeSetFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SeismicLatticeSetFeature * SOAP_FMAC2 soap_instantiate_resqml22__SeismicLatticeSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:241 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature (-58)
/* Type resqml22__SeismicLineSetFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SeismicLineSetFeature': */
class SOAP_CMAC resqml22__SeismicLineSetFeature : public resqml22__AbstractSeismicSurveyFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SeismicLineSetFeature, default initialized and not managed by a soap context
        virtual resqml22__SeismicLineSetFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SeismicLineSetFeature); }
      public:
        /// Constructor with default initializations
        resqml22__SeismicLineSetFeature() { }
        virtual ~resqml22__SeismicLineSetFeature() { }
        /// Friend allocator used by soap_new_resqml22__SeismicLineSetFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SeismicLineSetFeature * SOAP_FMAC2 soap_instantiate_resqml22__SeismicLineSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:263 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation (-69)
/* Type resqml22__NonSealedSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:NonSealedSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml22__NonSealedSurfaceFrameworkRepresentation : public resqml22__AbstractSurfaceFrameworkRepresentation {
      public:
        /// Optional element 'resqml22:Contacts' of XML schema type 'resqml22:AbstractSurfaceFrameworkContact'
        std::vector<resqml22__AbstractSurfaceFrameworkContact *> Contacts;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__NonSealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml22__NonSealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__NonSealedSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__NonSealedSurfaceFrameworkRepresentation() : Contacts() { }
        virtual ~resqml22__NonSealedSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__NonSealedSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__NonSealedSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__NonSealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:277 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation (-76)
/* Type resqml22__SealedSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:SealedSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml22__SealedSurfaceFrameworkRepresentation : public resqml22__AbstractSurfaceFrameworkRepresentation {
      public:
        /// Optional element 'resqml22:Contacts' of XML schema type 'resqml22:SealedContact'
        std::vector<resqml22__SealedContact *> Contacts;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__SealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml22__SealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__SealedSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__SealedSurfaceFrameworkRepresentation() : Contacts() { }
        virtual ~resqml22__SealedSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__SealedSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__SealedSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__SealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:327 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation (-101)
/* Type resqml22__GeologicUnitOccurrenceInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:GeologicUnitOccurrenceInterpretation': */
class SOAP_CMAC resqml22__GeologicUnitOccurrenceInterpretation : public resqml22__AbstractGeologicUnitOrganizationInterpretation {
      public:
        /// Optional element 'resqml22:GeologicUnit' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> GeologicUnit;
        /// Optional element 'resqml22:IsOccurrenceOf' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *IsOccurrenceOf;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__GeologicUnitOccurrenceInterpretation, default initialized and not managed by a soap context
        virtual resqml22__GeologicUnitOccurrenceInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__GeologicUnitOccurrenceInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__GeologicUnitOccurrenceInterpretation() : GeologicUnit(), IsOccurrenceOf() { }
        virtual ~resqml22__GeologicUnitOccurrenceInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__GeologicUnitOccurrenceInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__GeologicUnitOccurrenceInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__GeologicUnitOccurrenceInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:343 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation (-109)
/* Type resqml22__StratigraphicColumnRankInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:StratigraphicColumnRankInterpretation': */
class SOAP_CMAC resqml22__StratigraphicColumnRankInterpretation : public resqml22__AbstractGeologicUnitOrganizationInterpretation {
      public:
        /// Required element 'resqml22:RankInStratigraphicColumn' of XML schema type 'eml23:NonNegativeLong'
        LONG64 RankInStratigraphicColumn;
        /// Required element 'resqml22:StratigraphicUnits' of XML schema type 'eml23:DataObjectReference'
        std::vector<eml23__DataObjectReference *> StratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__StratigraphicColumnRankInterpretation, default initialized and not managed by a soap context
        virtual resqml22__StratigraphicColumnRankInterpretation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__StratigraphicColumnRankInterpretation); }
      public:
        /// Constructor with default initializations
        resqml22__StratigraphicColumnRankInterpretation() : RankInStratigraphicColumn(), StratigraphicUnits() { }
        virtual ~resqml22__StratigraphicColumnRankInterpretation() { }
        /// Friend allocator used by soap_new_resqml22__StratigraphicColumnRankInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__StratigraphicColumnRankInterpretation * SOAP_FMAC2 soap_instantiate_resqml22__StratigraphicColumnRankInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:431 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry (-153)
/* complex XML schema type 'resqml22:IjkGridGeometry': */
class SOAP_CMAC resqml22__IjkGridGeometry : public resqml22__AbstractColumnLayerGridGeometry {
      public:
        /// Required element 'resqml22:GridIsRighthanded' of XML schema type 'xsd:boolean'
        bool GridIsRighthanded;
        /// Optional element 'resqml22:IjGaps' of XML schema type 'resqml22:IjGaps'
        resqml22__IjGaps *IjGaps;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IjkGridGeometry, default initialized and not managed by a soap context
        virtual resqml22__IjkGridGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IjkGridGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__IjkGridGeometry() : GridIsRighthanded(), IjGaps() { }
        virtual ~resqml22__IjkGridGeometry() { }
        /// Friend allocator used by soap_new_resqml22__IjkGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IjkGridGeometry * SOAP_FMAC2 soap_instantiate_resqml22__IjkGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:433 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation (-154)
/* Type resqml22__IjkGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:IjkGridRepresentation': */
class SOAP_CMAC resqml22__IjkGridRepresentation : public resqml22__AbstractColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml22:Ni' of XML schema type 'eml23:PositiveLong'
        LONG64 Ni;
        /// Required element 'resqml22:Nj' of XML schema type 'eml23:PositiveLong'
        LONG64 Nj;
        /// Optional element 'resqml22:RadialGridIsComplete' of XML schema type 'xsd:boolean'
        bool *RadialGridIsComplete;
        /// Optional element 'resqml22:KGaps' of XML schema type 'resqml22:KGaps'
        resqml22__KGaps *KGaps;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:IjkGridGeometry'
        resqml22__IjkGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__IjkGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__IjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__IjkGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__IjkGridRepresentation() : Ni(), Nj(), RadialGridIsComplete(), KGaps(), Geometry() { }
        virtual ~resqml22__IjkGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__IjkGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__IjkGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__IjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:463 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation (-169)
/* Type resqml22__TruncatedIjkGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:TruncatedIjkGridRepresentation': */
class SOAP_CMAC resqml22__TruncatedIjkGridRepresentation : public resqml22__AbstractTruncatedColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml22:Ni' of XML schema type 'eml23:PositiveLong'
        LONG64 Ni;
        /// Required element 'resqml22:Nj' of XML schema type 'eml23:PositiveLong'
        LONG64 Nj;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:IjkGridGeometry'
        resqml22__IjkGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TruncatedIjkGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__TruncatedIjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TruncatedIjkGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__TruncatedIjkGridRepresentation() : Ni(), Nj(), Geometry() { }
        virtual ~resqml22__TruncatedIjkGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__TruncatedIjkGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TruncatedIjkGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__TruncatedIjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:465 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation (-170)
/* Type resqml22__TruncatedUnstructuredColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:TruncatedUnstructuredColumnLayerGridRepresentation': */
class SOAP_CMAC resqml22__TruncatedUnstructuredColumnLayerGridRepresentation : public resqml22__AbstractTruncatedColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml22:ColumnCount' of XML schema type 'eml23:PositiveLong'
        LONG64 ColumnCount;
        /// Required element 'resqml22:Geometry' of XML schema type 'resqml22:UnstructuredColumnLayerGridGeometry'
        resqml22__UnstructuredColumnLayerGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__TruncatedUnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__TruncatedUnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__TruncatedUnstructuredColumnLayerGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__TruncatedUnstructuredColumnLayerGridRepresentation() : ColumnCount(), Geometry() { }
        virtual ~resqml22__TruncatedUnstructuredColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__TruncatedUnstructuredColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:475 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry (-175)
/* complex XML schema type 'resqml22:UnstructuredColumnLayerGridGeometry': */
class SOAP_CMAC resqml22__UnstructuredColumnLayerGridGeometry : public resqml22__AbstractColumnLayerGridGeometry {
      public:
        /// Required element 'resqml22:ColumnIsRightHanded' of XML schema type 'eml23:AbstractBooleanArray'
        eml23__AbstractBooleanArray *ColumnIsRightHanded;
        /// Required element 'resqml22:ColumnShape' of XML schema type 'resqml22:ColumnShape'
        resqml22__ColumnShape ColumnShape;
        /// Required element 'resqml22:PillarCount' of XML schema type 'eml23:PositiveLong'
        LONG64 PillarCount;
        /// Required element 'resqml22:PillarsPerColumn' of XML schema type 'eml23:JaggedArray'
        eml23__JaggedArray *PillarsPerColumn;
        /// Optional element 'resqml22:UnstructuredColumnEdges' of XML schema type 'resqml22:UnstructuredColumnEdges'
        resqml22__UnstructuredColumnEdges *UnstructuredColumnEdges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredColumnLayerGridGeometry, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredColumnLayerGridGeometry); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredColumnLayerGridGeometry() : ColumnIsRightHanded(), ColumnShape(), PillarCount(), PillarsPerColumn(), UnstructuredColumnEdges() { }
        virtual ~resqml22__UnstructuredColumnLayerGridGeometry() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredColumnLayerGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredColumnLayerGridGeometry * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:477 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation (-176)
/* Type resqml22__UnstructuredColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:UnstructuredColumnLayerGridRepresentation': */
class SOAP_CMAC resqml22__UnstructuredColumnLayerGridRepresentation : public resqml22__AbstractColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml22:ColumnCount' of XML schema type 'eml23:PositiveLong'
        LONG64 ColumnCount;
        /// Optional element 'resqml22:Geometry' of XML schema type 'resqml22:UnstructuredColumnLayerGridGeometry'
        resqml22__UnstructuredColumnLayerGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__UnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml22__UnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__UnstructuredColumnLayerGridRepresentation); }
      public:
        /// Constructor with default initializations
        resqml22__UnstructuredColumnLayerGridRepresentation() : ColumnCount(), Geometry() { }
        virtual ~resqml22__UnstructuredColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml22__UnstructuredColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml22__UnstructuredColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml22__UnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:227 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature (-51)
/* Type resqml22__CmpLineFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:CmpLineFeature': */
class SOAP_CMAC resqml22__CmpLineFeature : public resqml22__AbstractSeismicLineFeature {
      public:
        /// Required element 'resqml22:NearestShotPointIndices' of XML schema type 'eml23:AbstractIntegerArray'
        eml23__AbstractIntegerArray *NearestShotPointIndices;
        /// Optional element 'resqml22:ShotPointLineFeature' of XML schema type 'eml23:DataObjectReference'
        eml23__DataObjectReference *ShotPointLineFeature;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__CmpLineFeature, default initialized and not managed by a soap context
        virtual resqml22__CmpLineFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__CmpLineFeature); }
      public:
        /// Constructor with default initializations
        resqml22__CmpLineFeature() : NearestShotPointIndices(), ShotPointLineFeature() { }
        virtual ~resqml22__CmpLineFeature() { }
        /// Friend allocator used by soap_new_resqml22__CmpLineFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__CmpLineFeature * SOAP_FMAC2 soap_instantiate_resqml22__CmpLineFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:243 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature (-59)
/* Type resqml22__ShotPointLineFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'resqml22:ShotPointLineFeature': */
class SOAP_CMAC resqml22__ShotPointLineFeature : public resqml22__AbstractSeismicLineFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml22__ShotPointLineFeature, default initialized and not managed by a soap context
        virtual resqml22__ShotPointLineFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(resqml22__ShotPointLineFeature); }
      public:
        /// Constructor with default initializations
        resqml22__ShotPointLineFeature() { }
        virtual ~resqml22__ShotPointLineFeature() { }
        /// Friend allocator used by soap_new_resqml22__ShotPointLineFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml22__ShotPointLineFeature * SOAP_FMAC2 soap_instantiate_resqml22__ShotPointLineFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_3ForGsoap.h:42052 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header (-845615104)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_3ForGsoap.h:42052 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code (-845615105)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_3ForGsoap.h:42052 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail (-845615107)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_3ForGsoap.h:42052 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason (-845615110)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_3ForGsoap.h:42052 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault (-845615111)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_3__XML
#define SOAP_TYPE_gsoap_eml2_3__XML (-5)

typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_3__QName
#define SOAP_TYPE_gsoap_eml2_3__QName (-6)

typedef char *_QName;
#endif

/* eml2_3ForGsoap.h:148 */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_3_xsd__nonNegativeInteger (-15)

typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* eml2_3ForGsoap.h:151 */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_3_xsd__anyURI (-17)

typedef std::string xsd__anyURI;
#endif

/* eml2_3ForGsoap.h:1582 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKindExt (-724)

typedef std::string resqml22__CulturalFeatureKindExt;
#endif

/* eml2_3ForGsoap.h:1585 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LineRoleExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LineRoleExt (-725)

typedef std::string resqml22__LineRoleExt;
#endif

/* eml2_3ForGsoap.h:1588 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKindExt (-726)

typedef std::string resqml22__DepositionalEnvironmentKindExt;
#endif

/* eml2_3ForGsoap.h:1591 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKindExt (-727)

typedef std::string resqml22__DepositionalFaciesKindExt;
#endif

/* eml2_3ForGsoap.h:1594 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3dExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3dExt (-728)

typedef std::string resqml22__Shape3dExt;
#endif

/* eml2_3ForGsoap.h:1597 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKindExt (-729)

typedef std::string resqml22__ThrowKindExt;
#endif

/* eml2_3ForGsoap.h:1600 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatternExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatternExt (-730)

typedef std::string resqml22__EdgePatternExt;
#endif

/* eml2_3ForGsoap.h:1603 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbolExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbolExt (-731)

typedef std::string resqml22__NodeSymbolExt;
#endif

/* eml2_3ForGsoap.h:1606 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKindExt (-732)

typedef std::string resqml22__ViewerKindExt;
#endif

/* eml2_3ForGsoap.h:1609 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKindExt (-733)

typedef std::string resqml22__SequenceStratigraphySurfaceKindExt;
#endif

/* eml2_3ForGsoap.h:1612 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFluxExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFluxExt (-734)

typedef std::string resqml22__StreamlineFluxExt;
#endif

/* eml2_3ForGsoap.h:1623 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKindExt (-735)

typedef std::string eml23__ExistenceKindExt;
#endif

/* eml2_3ForGsoap.h:1626 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKindExt (-736)

typedef std::string eml23__LithologyKindExt;
#endif

/* eml2_3ForGsoap.h:1629 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKindExt (-737)

typedef std::string eml23__LithologyQualifierKindExt;
#endif

/* eml2_3ForGsoap.h:1632 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKindExt (-738)

typedef std::string eml23__MatrixCementKindExt;
#endif

/* eml2_3ForGsoap.h:1635 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKindExt (-739)

typedef std::string eml23__QuantityClassKindExt;
#endif

/* eml2_3ForGsoap.h:1638 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceConditionExt (-740)

typedef std::string eml23__ReferenceConditionExt;
#endif

/* eml2_3ForGsoap.h:1641 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasureExt (-741)

typedef std::string eml23__UnitOfMeasureExt;
#endif

/* eml2_3ForGsoap.h:1645 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanXmlArray (-742)

typedef std::string eml23__BooleanXmlArray;
#endif

/* eml2_3ForGsoap.h:1649 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArrayList
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArrayList (-743)

typedef std::string eml23__FloatingPointXmlArrayList;
#endif

/* eml2_3ForGsoap.h:1653 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerXmlArray (-744)

typedef std::string eml23__IntegerXmlArray;
#endif

/* eml2_3ForGsoap.h:1656 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKindExt (-745)

typedef std::string eml23__ReferencePointKindExt;
#endif

/* eml2_3ForGsoap.h:1659 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReferenceExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReferenceExt (-746)

typedef std::string eml23__WellboreDatumReferenceExt;
#endif

/* eml2_3ForGsoap.h:1662 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomWithLegacy (-747)

typedef std::string eml23__MassPerVolumeUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1665 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomWithLegacy (-748)

typedef std::string eml23__PressurePerVolumeUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1668 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomWithLegacy (-749)

typedef std::string eml23__PressureUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1671 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomWithLegacy (-750)

typedef std::string eml23__VolumePerAreaUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1674 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomWithLegacy (-751)

typedef std::string eml23__VolumePerTimeUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1677 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomWithLegacy (-752)

typedef std::string eml23__VolumePerVolumeUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1680 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomWithLegacy (-753)

typedef std::string eml23__VolumeUomWithLegacy;
#endif

/* eml2_3ForGsoap.h:1683 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUomExt (-754)

typedef std::string eml23__AbsorbedDoseUomExt;
#endif

/* eml2_3ForGsoap.h:1686 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUomExt (-755)

typedef std::string eml23__ActivityOfRadioactivityUomExt;
#endif

/* eml2_3ForGsoap.h:1689 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUomExt (-756)

typedef std::string eml23__AmountOfSubstancePerAmountOfSubstanceUomExt;
#endif

/* eml2_3ForGsoap.h:1692 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUomExt (-757)

typedef std::string eml23__AmountOfSubstancePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1695 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUomExt (-758)

typedef std::string eml23__AmountOfSubstancePerTimePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1698 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUomExt (-759)

typedef std::string eml23__AmountOfSubstancePerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1701 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUomExt (-760)

typedef std::string eml23__AmountOfSubstancePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1704 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUomExt (-761)

typedef std::string eml23__AmountOfSubstanceUomExt;
#endif

/* eml2_3ForGsoap.h:1707 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUomExt (-762)

typedef std::string eml23__AnglePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1710 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUomExt (-763)

typedef std::string eml23__AnglePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1713 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUomExt (-764)

typedef std::string eml23__AngularAccelerationUomExt;
#endif

/* eml2_3ForGsoap.h:1716 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUomExt (-765)

typedef std::string eml23__AngularVelocityUomExt;
#endif

/* eml2_3ForGsoap.h:1719 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUomExt (-766)

typedef std::string eml23__APIGammaRayUomExt;
#endif

/* eml2_3ForGsoap.h:1722 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUomExt (-767)

typedef std::string eml23__APIGravityUomExt;
#endif

/* eml2_3ForGsoap.h:1725 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUomExt (-768)

typedef std::string eml23__APINeutronUomExt;
#endif

/* eml2_3ForGsoap.h:1728 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUomExt (-769)

typedef std::string eml23__AreaPerAmountOfSubstanceUomExt;
#endif

/* eml2_3ForGsoap.h:1731 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUomExt (-770)

typedef std::string eml23__AreaPerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1734 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUomExt (-771)

typedef std::string eml23__AreaPerCountUomExt;
#endif

/* eml2_3ForGsoap.h:1737 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUomExt (-772)

typedef std::string eml23__AreaPerMassUomExt;
#endif

/* eml2_3ForGsoap.h:1740 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUomExt (-773)

typedef std::string eml23__AreaPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1743 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUomExt (-774)

typedef std::string eml23__AreaPerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1746 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaUomExt (-775)

typedef std::string eml23__AreaUomExt;
#endif

/* eml2_3ForGsoap.h:1749 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUomExt (-776)

typedef std::string eml23__AttenuationPerFrequencyIntervalUomExt;
#endif

/* eml2_3ForGsoap.h:1752 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUomExt (-777)

typedef std::string eml23__CapacitanceUomExt;
#endif

/* eml2_3ForGsoap.h:1755 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUomExt (-778)

typedef std::string eml23__CationExchangeCapacityUomExt;
#endif

/* eml2_3ForGsoap.h:1758 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUomExt (-779)

typedef std::string eml23__DataTransferSpeedUomExt;
#endif

/* eml2_3ForGsoap.h:1761 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUomExt (-780)

typedef std::string eml23__DiffusionCoefficientUomExt;
#endif

/* eml2_3ForGsoap.h:1764 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUomExt (-781)

typedef std::string eml23__DiffusiveTimeOfFlightUomExt;
#endif

/* eml2_3ForGsoap.h:1767 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUomExt (-782)

typedef std::string eml23__DigitalStorageUomExt;
#endif

/* eml2_3ForGsoap.h:1770 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUomExt (-783)

typedef std::string eml23__DimensionlessUomExt;
#endif

/* eml2_3ForGsoap.h:1773 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUomExt (-784)

typedef std::string eml23__DipoleMomentUomExt;
#endif

/* eml2_3ForGsoap.h:1776 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUomExt (-785)

typedef std::string eml23__DoseEquivalentUomExt;
#endif

/* eml2_3ForGsoap.h:1779 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUomExt (-786)

typedef std::string eml23__DynamicViscosityUomExt;
#endif

/* eml2_3ForGsoap.h:1782 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUomExt (-787)

typedef std::string eml23__ElectricalResistivityUomExt;
#endif

/* eml2_3ForGsoap.h:1785 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUomExt (-788)

typedef std::string eml23__ElectricChargePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1788 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUomExt (-789)

typedef std::string eml23__ElectricChargePerMassUomExt;
#endif

/* eml2_3ForGsoap.h:1791 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUomExt (-790)

typedef std::string eml23__ElectricChargePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1794 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUomExt (-791)

typedef std::string eml23__ElectricChargeUomExt;
#endif

/* eml2_3ForGsoap.h:1797 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUomExt (-792)

typedef std::string eml23__ElectricConductanceUomExt;
#endif

/* eml2_3ForGsoap.h:1800 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUomExt (-793)

typedef std::string eml23__ElectricConductivityUomExt;
#endif

/* eml2_3ForGsoap.h:1803 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUomExt (-794)

typedef std::string eml23__ElectricCurrentDensityUomExt;
#endif

/* eml2_3ForGsoap.h:1806 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUomExt (-795)

typedef std::string eml23__ElectricCurrentUomExt;
#endif

/* eml2_3ForGsoap.h:1809 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUomExt (-796)

typedef std::string eml23__ElectricFieldStrengthUomExt;
#endif

/* eml2_3ForGsoap.h:1812 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUomExt (-797)

typedef std::string eml23__ElectricPotentialDifferenceUomExt;
#endif

/* eml2_3ForGsoap.h:1815 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUomExt (-798)

typedef std::string eml23__ElectricResistancePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1818 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUomExt (-799)

typedef std::string eml23__ElectricResistanceUomExt;
#endif

/* eml2_3ForGsoap.h:1821 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUomExt (-800)

typedef std::string eml23__ElectromagneticMomentUomExt;
#endif

/* eml2_3ForGsoap.h:1824 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUomExt (-801)

typedef std::string eml23__EnergyLengthPerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1827 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUomExt (-802)

typedef std::string eml23__EnergyLengthPerTimeAreaTemperatureUomExt;
#endif

/* eml2_3ForGsoap.h:1830 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUomExt (-803)

typedef std::string eml23__EnergyPerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1833 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUomExt (-804)

typedef std::string eml23__EnergyPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1836 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUomExt (-805)

typedef std::string eml23__EnergyPerMassPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1839 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUomExt (-806)

typedef std::string eml23__EnergyPerMassUomExt;
#endif

/* eml2_3ForGsoap.h:1842 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUomExt (-807)

typedef std::string eml23__EnergyPerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1845 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUomExt (-808)

typedef std::string eml23__EnergyUomExt;
#endif

/* eml2_3ForGsoap.h:1848 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUomExt (-809)

typedef std::string eml23__ForceAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1851 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUomExt (-810)

typedef std::string eml23__ForceLengthPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1854 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUomExt (-811)

typedef std::string eml23__ForcePerForceUomExt;
#endif

/* eml2_3ForGsoap.h:1857 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUomExt (-812)

typedef std::string eml23__ForcePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1860 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUomExt (-813)

typedef std::string eml23__ForcePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1863 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceUomExt (-814)

typedef std::string eml23__ForceUomExt;
#endif

/* eml2_3ForGsoap.h:1866 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUomExt (-815)

typedef std::string eml23__FrequencyIntervalUomExt;
#endif

/* eml2_3ForGsoap.h:1869 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUomExt (-816)

typedef std::string eml23__FrequencyUomExt;
#endif

/* eml2_3ForGsoap.h:1872 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUomExt (-817)

typedef std::string eml23__HeatCapacityUomExt;
#endif

/* eml2_3ForGsoap.h:1875 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUomExt (-818)

typedef std::string eml23__HeatFlowRateUomExt;
#endif

/* eml2_3ForGsoap.h:1878 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUomExt (-819)

typedef std::string eml23__HeatTransferCoefficientUomExt;
#endif

/* eml2_3ForGsoap.h:1881 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUomExt (-820)

typedef std::string eml23__IlluminanceUomExt;
#endif

/* eml2_3ForGsoap.h:1884 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUomExt (-821)

typedef std::string eml23__InductanceUomExt;
#endif

/* eml2_3ForGsoap.h:1887 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUomExt (-822)

typedef std::string eml23__IsothermalCompressibilityUomExt;
#endif

/* eml2_3ForGsoap.h:1890 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUomExt (-823)

typedef std::string eml23__KinematicViscosityUomExt;
#endif

/* eml2_3ForGsoap.h:1893 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthAndTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthAndTimeUomExt (-824)

typedef std::string eml23__LengthAndTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1896 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUomExt (-825)

typedef std::string eml23__LengthPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1899 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUomExt (-826)

typedef std::string eml23__LengthPerMassUomExt;
#endif

/* eml2_3ForGsoap.h:1902 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUomExt (-827)

typedef std::string eml23__LengthPerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:1905 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUomExt (-828)

typedef std::string eml23__LengthPerTemperatureUomExt;
#endif

/* eml2_3ForGsoap.h:1908 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUomExt (-829)

typedef std::string eml23__LengthPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1911 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUomExt (-830)

typedef std::string eml23__LengthPerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:1914 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthUomExt (-831)

typedef std::string eml23__LengthUomExt;
#endif

/* eml2_3ForGsoap.h:1917 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUomExt (-832)

typedef std::string eml23__LightExposureUomExt;
#endif

/* eml2_3ForGsoap.h:1920 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUomExt (-833)

typedef std::string eml23__LinearAccelerationUomExt;
#endif

/* eml2_3ForGsoap.h:1923 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUomExt (-834)

typedef std::string eml23__LinearThermalExpansionUomExt;
#endif

/* eml2_3ForGsoap.h:1926 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUomExt (-835)

typedef std::string eml23__LogarithmicPowerRatioPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1929 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUomExt (-836)

typedef std::string eml23__LogarithmicPowerRatioUomExt;
#endif

/* eml2_3ForGsoap.h:1932 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUomExt (-837)

typedef std::string eml23__LuminanceUomExt;
#endif

/* eml2_3ForGsoap.h:1935 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUomExt (-838)

typedef std::string eml23__LuminousEfficacyUomExt;
#endif

/* eml2_3ForGsoap.h:1938 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUomExt (-839)

typedef std::string eml23__LuminousFluxUomExt;
#endif

/* eml2_3ForGsoap.h:1941 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUomExt (-840)

typedef std::string eml23__LuminousIntensityUomExt;
#endif

/* eml2_3ForGsoap.h:1944 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUomExt (-841)

typedef std::string eml23__MagneticDipoleMomentUomExt;
#endif

/* eml2_3ForGsoap.h:1947 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUomExt (-842)

typedef std::string eml23__MagneticFieldStrengthUomExt;
#endif

/* eml2_3ForGsoap.h:1950 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUomExt (-843)

typedef std::string eml23__MagneticFluxDensityPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1953 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUomExt (-844)

typedef std::string eml23__MagneticFluxDensityUomExt;
#endif

/* eml2_3ForGsoap.h:1956 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUomExt (-845)

typedef std::string eml23__MagneticFluxUomExt;
#endif

/* eml2_3ForGsoap.h:1959 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUomExt (-846)

typedef std::string eml23__MagneticPermeabilityUomExt;
#endif

/* eml2_3ForGsoap.h:1962 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUomExt (-847)

typedef std::string eml23__MagneticVectorPotentialUomExt;
#endif

/* eml2_3ForGsoap.h:1965 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUomExt (-848)

typedef std::string eml23__MassLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1968 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUomExt (-849)

typedef std::string eml23__MassPerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1971 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUomExt (-850)

typedef std::string eml23__MassPerEnergyUomExt;
#endif

/* eml2_3ForGsoap.h:1974 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUomExt (-851)

typedef std::string eml23__MassPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1977 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUomExt (-852)

typedef std::string eml23__MassPerMassUomExt;
#endif

/* eml2_3ForGsoap.h:1980 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUomExt (-853)

typedef std::string eml23__MassPerTimePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:1983 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUomExt (-854)

typedef std::string eml23__MassPerTimePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1986 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUomExt (-855)

typedef std::string eml23__MassPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:1989 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUomExt (-856)

typedef std::string eml23__MassPerVolumePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:1992 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUomExt (-857)

typedef std::string eml23__MassPerVolumePerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:1995 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUomExt (-858)

typedef std::string eml23__MassPerVolumePerTemperatureUomExt;
#endif

/* eml2_3ForGsoap.h:1998 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomExt (-859)

typedef std::string eml23__MassPerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2001 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassUomExt (-860)

typedef std::string eml23__MassUomExt;
#endif

/* eml2_3ForGsoap.h:2004 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUomExt (-861)

typedef std::string eml23__MobilityUomExt;
#endif

/* eml2_3ForGsoap.h:2007 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUomExt (-862)

typedef std::string eml23__MolarEnergyUomExt;
#endif

/* eml2_3ForGsoap.h:2010 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUomExt (-863)

typedef std::string eml23__MolarHeatCapacityUomExt;
#endif

/* eml2_3ForGsoap.h:2013 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUomExt (-864)

typedef std::string eml23__MolarVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2016 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUomExt (-865)

typedef std::string eml23__MolecularWeightUomExt;
#endif

/* eml2_3ForGsoap.h:2019 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUomExt (-866)

typedef std::string eml23__MomentOfForceUomExt;
#endif

/* eml2_3ForGsoap.h:2022 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUomExt (-867)

typedef std::string eml23__MomentOfInertiaUomExt;
#endif

/* eml2_3ForGsoap.h:2025 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUomExt (-868)

typedef std::string eml23__MomentumUomExt;
#endif

/* eml2_3ForGsoap.h:2028 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUomExt (-869)

typedef std::string eml23__NormalizedPowerUomExt;
#endif

/* eml2_3ForGsoap.h:2031 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUomExt (-870)

typedef std::string eml23__PermeabilityLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2034 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUomExt (-871)

typedef std::string eml23__PermeabilityRockUomExt;
#endif

/* eml2_3ForGsoap.h:2037 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUomExt (-872)

typedef std::string eml23__PermittivityUomExt;
#endif

/* eml2_3ForGsoap.h:2040 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUomExt (-873)

typedef std::string eml23__PlaneAngleUomExt;
#endif

/* eml2_3ForGsoap.h:2043 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUomExt (-874)

typedef std::string eml23__PotentialDifferencePerPowerDropUomExt;
#endif

/* eml2_3ForGsoap.h:2046 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUomExt (-875)

typedef std::string eml23__PowerPerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2049 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUomExt (-876)

typedef std::string eml23__PowerPerPowerUomExt;
#endif

/* eml2_3ForGsoap.h:2052 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUomExt (-877)

typedef std::string eml23__PowerPerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2055 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerUomExt (-878)

typedef std::string eml23__PowerUomExt;
#endif

/* eml2_3ForGsoap.h:2058 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUomExt (-879)

typedef std::string eml23__PressurePerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:2061 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUomExt (-880)

typedef std::string eml23__PressurePerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2064 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomExt (-881)

typedef std::string eml23__PressurePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2067 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUomExt (-882)

typedef std::string eml23__PressureSquaredPerForceTimePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2070 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUomExt (-883)

typedef std::string eml23__PressureSquaredUomExt;
#endif

/* eml2_3ForGsoap.h:2073 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUomExt (-884)

typedef std::string eml23__PressureTimePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2076 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomExt (-885)

typedef std::string eml23__PressureUomExt;
#endif

/* eml2_3ForGsoap.h:2079 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUomExt (-886)

typedef std::string eml23__QuantityOfLightUomExt;
#endif

/* eml2_3ForGsoap.h:2082 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUomExt (-887)

typedef std::string eml23__RadianceUomExt;
#endif

/* eml2_3ForGsoap.h:2085 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUomExt (-888)

typedef std::string eml23__RadiantIntensityUomExt;
#endif

/* eml2_3ForGsoap.h:2088 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUomExt (-889)

typedef std::string eml23__ReciprocalAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2091 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUomExt (-890)

typedef std::string eml23__ReciprocalElectricPotentialDifferenceUomExt;
#endif

/* eml2_3ForGsoap.h:2094 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUomExt (-891)

typedef std::string eml23__ReciprocalForceUomExt;
#endif

/* eml2_3ForGsoap.h:2097 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUomExt (-892)

typedef std::string eml23__ReciprocalLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2100 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUomExt (-893)

typedef std::string eml23__ReciprocalMassTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2103 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUomExt (-894)

typedef std::string eml23__ReciprocalMassUomExt;
#endif

/* eml2_3ForGsoap.h:2106 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUomExt (-895)

typedef std::string eml23__ReciprocalPressureUomExt;
#endif

/* eml2_3ForGsoap.h:2109 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUomExt (-896)

typedef std::string eml23__ReciprocalTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2112 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUomExt (-897)

typedef std::string eml23__ReciprocalVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2115 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUomExt (-898)

typedef std::string eml23__ReluctanceUomExt;
#endif

/* eml2_3ForGsoap.h:2118 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUomExt (-899)

typedef std::string eml23__SecondMomentOfAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2121 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUomExt (-900)

typedef std::string eml23__SignalingEventPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2124 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUomExt (-901)

typedef std::string eml23__SolidAngleUomExt;
#endif

/* eml2_3ForGsoap.h:2127 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUomExt (-902)

typedef std::string eml23__SpecificHeatCapacityUomExt;
#endif

/* eml2_3ForGsoap.h:2130 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUomExt (-903)

typedef std::string eml23__TemperatureIntervalPerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2133 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUomExt (-904)

typedef std::string eml23__TemperatureIntervalPerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:2136 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUomExt (-905)

typedef std::string eml23__TemperatureIntervalPerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2139 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUomExt (-906)

typedef std::string eml23__TemperatureIntervalUomExt;
#endif

/* eml2_3ForGsoap.h:2142 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUomExt (-907)

typedef std::string eml23__ThermalConductanceUomExt;
#endif

/* eml2_3ForGsoap.h:2145 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUomExt (-908)

typedef std::string eml23__ThermalConductivityUomExt;
#endif

/* eml2_3ForGsoap.h:2148 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUomExt (-909)

typedef std::string eml23__ThermalDiffusivityUomExt;
#endif

/* eml2_3ForGsoap.h:2151 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUomExt (-910)

typedef std::string eml23__ThermalInsulanceUomExt;
#endif

/* eml2_3ForGsoap.h:2154 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUomExt (-911)

typedef std::string eml23__ThermalResistanceUomExt;
#endif

/* eml2_3ForGsoap.h:2157 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (-912)

typedef std::string eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt;
#endif

/* eml2_3ForGsoap.h:2160 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUomExt (-913)

typedef std::string eml23__ThermodynamicTemperatureUomExt;
#endif

/* eml2_3ForGsoap.h:2163 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUomExt (-914)

typedef std::string eml23__TimePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2166 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUomExt (-915)

typedef std::string eml23__TimePerMassUomExt;
#endif

/* eml2_3ForGsoap.h:2169 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUomExt (-916)

typedef std::string eml23__TimePerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2172 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUomExt (-917)

typedef std::string eml23__TimePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2175 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeUomExt (-918)

typedef std::string eml23__TimeUomExt;
#endif

/* eml2_3ForGsoap.h:2178 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUomExt (-919)

typedef std::string eml23__VerticalCoordinateUomExt;
#endif

/* eml2_3ForGsoap.h:2181 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUomExt (-920)

typedef std::string eml23__VolumeFlowRatePerVolumeFlowRateUomExt;
#endif

/* eml2_3ForGsoap.h:2184 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomExt (-921)

typedef std::string eml23__VolumePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2187 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUomExt (-922)

typedef std::string eml23__VolumePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2190 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUomExt (-923)

typedef std::string eml23__VolumePerMassUomExt;
#endif

/* eml2_3ForGsoap.h:2193 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUomExt (-924)

typedef std::string eml23__VolumePerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:2196 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUomExt (-925)

typedef std::string eml23__VolumePerRotationUomExt;
#endif

/* eml2_3ForGsoap.h:2199 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUomExt (-926)

typedef std::string eml23__VolumePerTimeLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2202 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUomExt (-927)

typedef std::string eml23__VolumePerTimePerAreaUomExt;
#endif

/* eml2_3ForGsoap.h:2205 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUomExt (-928)

typedef std::string eml23__VolumePerTimePerLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2208 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUomExt (-929)

typedef std::string eml23__VolumePerTimePerPressureLengthUomExt;
#endif

/* eml2_3ForGsoap.h:2211 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUomExt (-930)

typedef std::string eml23__VolumePerTimePerPressureUomExt;
#endif

/* eml2_3ForGsoap.h:2214 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUomExt (-931)

typedef std::string eml23__VolumePerTimePerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2217 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUomExt (-932)

typedef std::string eml23__VolumePerTimePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2220 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomExt (-933)

typedef std::string eml23__VolumePerTimeUomExt;
#endif

/* eml2_3ForGsoap.h:2223 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomExt (-934)

typedef std::string eml23__VolumePerVolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2226 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUomExt (-935)

typedef std::string eml23__VolumetricHeatTransferCoefficientUomExt;
#endif

/* eml2_3ForGsoap.h:2229 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUomExt (-936)

typedef std::string eml23__VolumetricThermalExpansionUomExt;
#endif

/* eml2_3ForGsoap.h:2232 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomExt (-937)

typedef std::string eml23__VolumeUomExt;
#endif

/* eml2_3ForGsoap.h:2235 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FacetExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FacetExt (-938)

typedef std::string eml23__FacetExt;
#endif

/* eml2_3ForGsoap.h:2238 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKindExt (-939)

typedef std::string eml23__CollectionKindExt;
#endif

/* eml2_3ForGsoap.h:2242 */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKind (-940)

typedef std::string resqml22__DepositionalEnvironmentKind;
#endif

/* eml2_3ForGsoap.h:2373 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMeasure (-945)

typedef double eml23__AbstractMeasure;
#endif

/* eml2_3ForGsoap.h:2381 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractString
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractString (-946)

typedef std::string eml23__AbstractString;
#endif

/* eml2_3ForGsoap.h:2416 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_3_eml23__NonNegativeLong (-950)

typedef LONG64 eml23__NonNegativeLong;
#endif

/* eml2_3ForGsoap.h:2421 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PositiveDouble
#define SOAP_TYPE_gsoap_eml2_3_eml23__PositiveDouble (-951)

typedef double eml23__PositiveDouble;
#endif

/* eml2_3ForGsoap.h:2426 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PositiveLong
#define SOAP_TYPE_gsoap_eml2_3_eml23__PositiveLong (-952)

typedef LONG64 eml23__PositiveLong;
#endif

/* eml2_3ForGsoap.h:2431 */
#ifndef SOAP_TYPE_eml23__TimeStamp
#define SOAP_TYPE_eml23__TimeStamp (-953)

typedef struct tm eml23__TimeStamp;
#endif

/* eml2_3ForGsoap.h:2493 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnumExtensionPattern (-955)

typedef std::string eml23__EnumExtensionPattern;
#endif

/* eml2_3ForGsoap.h:2498 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String2000
#define SOAP_TYPE_gsoap_eml2_3_eml23__String2000 (-956)

typedef std::string eml23__String2000;
#endif

/* eml2_3ForGsoap.h:2503 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String256
#define SOAP_TYPE_gsoap_eml2_3_eml23__String256 (-957)

typedef std::string eml23__String256;
#endif

/* eml2_3ForGsoap.h:2508 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String64
#define SOAP_TYPE_gsoap_eml2_3_eml23__String64 (-958)

typedef std::string eml23__String64;
#endif

/* eml2_3ForGsoap.h:2518 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UomEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__UomEnum (-959)

typedef std::string eml23__UomEnum;
#endif

/* eml2_3ForGsoap.h:2523 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UuidString
#define SOAP_TYPE_gsoap_eml2_3_eml23__UuidString (-960)

typedef std::string eml23__UuidString;
#endif

/* eml2_3ForGsoap.h:4062 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeZone
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeZone (-963)

typedef std::string eml23__TimeZone;
#endif

/* eml2_3ForGsoap.h:4070 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TypeEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__TypeEnum (-964)

typedef eml23__String64 eml23__TypeEnum;
#endif

/* eml2_3ForGsoap.h:12869 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterSection (-1155)

typedef std::string eml23__PublicLandSurveySystemQuarterSection;
#endif

/* eml2_3ForGsoap.h:12878 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterTownship (-1156)

typedef std::string eml23__PublicLandSurveySystemQuarterTownship;
#endif

/* eml2_3ForGsoap.h:12887 */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SectionNumber
#define SOAP_TYPE_gsoap_eml2_3_eml23__SectionNumber (-1157)

typedef std::string eml23__SectionNumber;
#endif

/* eml2_3ForGsoap.h:40420 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeature (-1498)

typedef resqml22__BoundaryFeature _resqml22__BoundaryFeature;
#endif

/* eml2_3ForGsoap.h:40423 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CulturalFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CulturalFeature (-1499)

typedef resqml22__CulturalFeature _resqml22__CulturalFeature;
#endif

/* eml2_3ForGsoap.h:40426 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Model
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Model (-1500)

typedef resqml22__Model _resqml22__Model;
#endif

/* eml2_3ForGsoap.h:40429 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockVolumeFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockVolumeFeature (-1501)

typedef resqml22__RockVolumeFeature _resqml22__RockVolumeFeature;
#endif

/* eml2_3ForGsoap.h:40432 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CmpLineFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CmpLineFeature (-1502)

typedef resqml22__CmpLineFeature _resqml22__CmpLineFeature;
#endif

/* eml2_3ForGsoap.h:40435 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic2dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic2dPostStackRepresentation (-1503)

typedef resqml22__Seismic2dPostStackRepresentation _resqml22__Seismic2dPostStackRepresentation;
#endif

/* eml2_3ForGsoap.h:40438 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic3dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic3dPostStackRepresentation (-1504)

typedef resqml22__Seismic3dPostStackRepresentation _resqml22__Seismic3dPostStackRepresentation;
#endif

/* eml2_3ForGsoap.h:40441 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLatticeFeature (-1505)

typedef resqml22__SeismicLatticeFeature _resqml22__SeismicLatticeFeature;
#endif

/* eml2_3ForGsoap.h:40444 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLineSetFeature (-1506)

typedef resqml22__SeismicLineSetFeature _resqml22__SeismicLineSetFeature;
#endif

/* eml2_3ForGsoap.h:40447 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ShotPointLineFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ShotPointLineFeature (-1507)

typedef resqml22__ShotPointLineFeature _resqml22__ShotPointLineFeature;
#endif

/* eml2_3ForGsoap.h:40450 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__NonSealedSurfaceFrameworkRepresentation (-1508)

typedef resqml22__NonSealedSurfaceFrameworkRepresentation _resqml22__NonSealedSurfaceFrameworkRepresentation;
#endif

/* eml2_3ForGsoap.h:40453 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PlaneSetRepresentation (-1509)

typedef resqml22__PlaneSetRepresentation _resqml22__PlaneSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40456 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PointSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PointSetRepresentation (-1510)

typedef resqml22__PointSetRepresentation _resqml22__PointSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40459 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineRepresentation (-1511)

typedef resqml22__PolylineRepresentation _resqml22__PolylineRepresentation;
#endif

/* eml2_3ForGsoap.h:40462 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineSetRepresentation (-1512)

typedef resqml22__PolylineSetRepresentation _resqml22__PolylineSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40465 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SealedSurfaceFrameworkRepresentation (-1513)

typedef resqml22__SealedSurfaceFrameworkRepresentation _resqml22__SealedSurfaceFrameworkRepresentation;
#endif

/* eml2_3ForGsoap.h:40468 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SealedVolumeFrameworkRepresentation (-1514)

typedef resqml22__SealedVolumeFrameworkRepresentation _resqml22__SealedVolumeFrameworkRepresentation;
#endif

/* eml2_3ForGsoap.h:40471 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TriangulatedSetRepresentation (-1515)

typedef resqml22__TriangulatedSetRepresentation _resqml22__TriangulatedSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40474 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeatureInterpretation (-1516)

typedef resqml22__BoundaryFeatureInterpretation _resqml22__BoundaryFeatureInterpretation;
#endif

/* eml2_3ForGsoap.h:40477 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__EarthModelInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__EarthModelInterpretation (-1517)

typedef resqml22__EarthModelInterpretation _resqml22__EarthModelInterpretation;
#endif

/* eml2_3ForGsoap.h:40480 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__FaultInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__FaultInterpretation (-1518)

typedef resqml22__FaultInterpretation _resqml22__FaultInterpretation;
#endif

/* eml2_3ForGsoap.h:40483 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__FluidBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__FluidBoundaryInterpretation (-1519)

typedef resqml22__FluidBoundaryInterpretation _resqml22__FluidBoundaryInterpretation;
#endif

/* eml2_3ForGsoap.h:40486 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GenericFeatureInterpretation (-1520)

typedef resqml22__GenericFeatureInterpretation _resqml22__GenericFeatureInterpretation;
#endif

/* eml2_3ForGsoap.h:40489 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyBoundaryInterpretation (-1521)

typedef resqml22__GeobodyBoundaryInterpretation _resqml22__GeobodyBoundaryInterpretation;
#endif

/* eml2_3ForGsoap.h:40492 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyInterpretation (-1522)

typedef resqml22__GeobodyInterpretation _resqml22__GeobodyInterpretation;
#endif

/* eml2_3ForGsoap.h:40495 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitInterpretation (-1523)

typedef resqml22__GeologicUnitInterpretation _resqml22__GeologicUnitInterpretation;
#endif

/* eml2_3ForGsoap.h:40498 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitOccurrenceInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitOccurrenceInterpretation (-1524)

typedef resqml22__GeologicUnitOccurrenceInterpretation _resqml22__GeologicUnitOccurrenceInterpretation;
#endif

/* eml2_3ForGsoap.h:40501 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__HorizonInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__HorizonInterpretation (-1525)

typedef resqml22__HorizonInterpretation _resqml22__HorizonInterpretation;
#endif

/* eml2_3ForGsoap.h:40504 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidOrganizationInterpretation (-1526)

typedef resqml22__RockFluidOrganizationInterpretation _resqml22__RockFluidOrganizationInterpretation;
#endif

/* eml2_3ForGsoap.h:40507 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidUnitInterpretation (-1527)

typedef resqml22__RockFluidUnitInterpretation _resqml22__RockFluidUnitInterpretation;
#endif

/* eml2_3ForGsoap.h:40510 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumn
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumn (-1528)

typedef resqml22__StratigraphicColumn _resqml22__StratigraphicColumn;
#endif

/* eml2_3ForGsoap.h:40513 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumnRankInterpretation (-1529)

typedef resqml22__StratigraphicColumnRankInterpretation _resqml22__StratigraphicColumnRankInterpretation;
#endif

/* eml2_3ForGsoap.h:40516 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicUnitInterpretation (-1530)

typedef resqml22__StratigraphicUnitInterpretation _resqml22__StratigraphicUnitInterpretation;
#endif

/* eml2_3ForGsoap.h:40519 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StructuralOrganizationInterpretation (-1531)

typedef resqml22__StructuralOrganizationInterpretation _resqml22__StructuralOrganizationInterpretation;
#endif

/* eml2_3ForGsoap.h:40522 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationIdentitySet (-1532)

typedef resqml22__RepresentationIdentitySet _resqml22__RepresentationIdentitySet;
#endif

/* eml2_3ForGsoap.h:40525 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationSetRepresentation (-1533)

typedef resqml22__RepresentationSetRepresentation _resqml22__RepresentationSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40528 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SubRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SubRepresentation (-1534)

typedef resqml22__SubRepresentation _resqml22__SubRepresentation;
#endif

/* eml2_3ForGsoap.h:40531 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreIntervalSet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreIntervalSet (-1535)

typedef resqml22__WellboreIntervalSet _resqml22__WellboreIntervalSet;
#endif

/* eml2_3ForGsoap.h:40534 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GpGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GpGridRepresentation (-1536)

typedef resqml22__GpGridRepresentation _resqml22__GpGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40537 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Grid2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Grid2dRepresentation (-1537)

typedef resqml22__Grid2dRepresentation _resqml22__Grid2dRepresentation;
#endif

/* eml2_3ForGsoap.h:40540 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GridConnectionSetRepresentation (-1538)

typedef resqml22__GridConnectionSetRepresentation _resqml22__GridConnectionSetRepresentation;
#endif

/* eml2_3ForGsoap.h:40543 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__IjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__IjkGridRepresentation (-1539)

typedef resqml22__IjkGridRepresentation _resqml22__IjkGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40546 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__LocalGridSet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__LocalGridSet (-1540)

typedef resqml22__LocalGridSet _resqml22__LocalGridSet;
#endif

/* eml2_3ForGsoap.h:40549 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedIjkGridRepresentation (-1541)

typedef resqml22__TruncatedIjkGridRepresentation _resqml22__TruncatedIjkGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40552 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedUnstructuredColumnLayerGridRepresentation (-1542)

typedef resqml22__TruncatedUnstructuredColumnLayerGridRepresentation _resqml22__TruncatedUnstructuredColumnLayerGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40555 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredColumnLayerGridRepresentation (-1543)

typedef resqml22__UnstructuredColumnLayerGridRepresentation _resqml22__UnstructuredColumnLayerGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40558 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredGridRepresentation (-1544)

typedef resqml22__UnstructuredGridRepresentation _resqml22__UnstructuredGridRepresentation;
#endif

/* eml2_3ForGsoap.h:40561 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ColorMapDictionary
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ColorMapDictionary (-1545)

typedef resqml22__ColorMapDictionary _resqml22__ColorMapDictionary;
#endif

/* eml2_3ForGsoap.h:40564 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousColorMap
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousColorMap (-1546)

typedef resqml22__ContinuousColorMap _resqml22__ContinuousColorMap;
#endif

/* eml2_3ForGsoap.h:40567 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteColorMap
#define SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteColorMap (-1547)

typedef resqml22__DiscreteColorMap _resqml22__DiscreteColorMap;
#endif

/* eml2_3ForGsoap.h:40570 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BooleanProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BooleanProperty (-1548)

typedef resqml22__BooleanProperty _resqml22__BooleanProperty;
#endif

/* eml2_3ForGsoap.h:40573 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CategoricalProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CategoricalProperty (-1549)

typedef resqml22__CategoricalProperty _resqml22__CategoricalProperty;
#endif

/* eml2_3ForGsoap.h:40576 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CommentProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CommentProperty (-1550)

typedef resqml22__CommentProperty _resqml22__CommentProperty;
#endif

/* eml2_3ForGsoap.h:40579 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousProperty (-1551)

typedef resqml22__ContinuousProperty _resqml22__ContinuousProperty;
#endif

/* eml2_3ForGsoap.h:40582 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteProperty (-1552)

typedef resqml22__DiscreteProperty _resqml22__DiscreteProperty;
#endif

/* eml2_3ForGsoap.h:40585 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PointsProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PointsProperty (-1553)

typedef resqml22__PointsProperty _resqml22__PointsProperty;
#endif

/* eml2_3ForGsoap.h:40588 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesFeature (-1554)

typedef resqml22__StreamlinesFeature _resqml22__StreamlinesFeature;
#endif

/* eml2_3ForGsoap.h:40591 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesRepresentation (-1555)

typedef resqml22__StreamlinesRepresentation _resqml22__StreamlinesRepresentation;
#endif

/* eml2_3ForGsoap.h:40594 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BlockedWellboreRepresentation (-1556)

typedef resqml22__BlockedWellboreRepresentation _resqml22__BlockedWellboreRepresentation;
#endif

/* eml2_3ForGsoap.h:40597 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicWellboreFrameRepresentation (-1557)

typedef resqml22__SeismicWellboreFrameRepresentation _resqml22__SeismicWellboreFrameRepresentation;
#endif

/* eml2_3ForGsoap.h:40600 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFeature (-1558)

typedef resqml22__WellboreFeature _resqml22__WellboreFeature;
#endif

/* eml2_3ForGsoap.h:40603 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFrameRepresentation (-1559)

typedef resqml22__WellboreFrameRepresentation _resqml22__WellboreFrameRepresentation;
#endif

/* eml2_3ForGsoap.h:40606 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreInterpretation (-1560)

typedef resqml22__WellboreInterpretation _resqml22__WellboreInterpretation;
#endif

/* eml2_3ForGsoap.h:40609 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreMarkerFrameRepresentation (-1561)

typedef resqml22__WellboreMarkerFrameRepresentation _resqml22__WellboreMarkerFrameRepresentation;
#endif

/* eml2_3ForGsoap.h:40612 */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreTrajectoryRepresentation (-1562)

typedef resqml22__WellboreTrajectoryRepresentation _resqml22__WellboreTrajectoryRepresentation;
#endif

/* eml2_3ForGsoap.h:40631 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__RecursiveReferencePoint
#define SOAP_TYPE_gsoap_eml2_3__eml23__RecursiveReferencePoint (-1563)

typedef eml23__RecursiveReferencePoint _eml23__RecursiveReferencePoint;
#endif

/* eml2_3ForGsoap.h:40634 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInACrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInACrs (-1564)

typedef eml23__ReferencePointInACrs _eml23__ReferencePointInACrs;
#endif

/* eml2_3ForGsoap.h:40637 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInALocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInALocalEngineeringCompoundCrs (-1565)

typedef eml23__ReferencePointInALocalEngineeringCompoundCrs _eml23__ReferencePointInALocalEngineeringCompoundCrs;
#endif

/* eml2_3ForGsoap.h:40640 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInAWellbore
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInAWellbore (-1566)

typedef eml23__ReferencePointInAWellbore _eml23__ReferencePointInAWellbore;
#endif

/* eml2_3ForGsoap.h:40643 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__GeodeticCrs (-1567)

typedef eml23__GeodeticCrs _eml23__GeodeticCrs;
#endif

/* eml2_3ForGsoap.h:40646 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__LocalEngineeringCompoundCrs (-1568)

typedef eml23__LocalEngineeringCompoundCrs _eml23__LocalEngineeringCompoundCrs;
#endif

/* eml2_3ForGsoap.h:40649 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ProjectedCrs (-1569)

typedef eml23__ProjectedCrs _eml23__ProjectedCrs;
#endif

/* eml2_3ForGsoap.h:40652 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__VerticalCrs (-1570)

typedef eml23__VerticalCrs _eml23__VerticalCrs;
#endif

/* eml2_3ForGsoap.h:40655 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKind (-1571)

typedef eml23__PropertyKind _eml23__PropertyKind;
#endif

/* eml2_3ForGsoap.h:40658 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKindDictionary (-1572)

typedef eml23__PropertyKindDictionary _eml23__PropertyKindDictionary;
#endif

/* eml2_3ForGsoap.h:40661 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__TimeSeries
#define SOAP_TYPE_gsoap_eml2_3__eml23__TimeSeries (-1573)

typedef eml23__TimeSeries _eml23__TimeSeries;
#endif

/* eml2_3ForGsoap.h:40664 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Activity
#define SOAP_TYPE_gsoap_eml2_3__eml23__Activity (-1574)

typedef eml23__Activity _eml23__Activity;
#endif

/* eml2_3ForGsoap.h:40667 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_3__eml23__ActivityTemplate (-1575)

typedef eml23__ActivityTemplate _eml23__ActivityTemplate;
#endif

/* eml2_3ForGsoap.h:40670 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Aggregate
#define SOAP_TYPE_gsoap_eml2_3__eml23__Aggregate (-1576)

typedef eml23__Aggregate _eml23__Aggregate;
#endif

/* eml2_3ForGsoap.h:40673 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Attachment
#define SOAP_TYPE_gsoap_eml2_3__eml23__Attachment (-1577)

typedef eml23__Attachment _eml23__Attachment;
#endif

/* eml2_3ForGsoap.h:40676 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_3__eml23__BusinessAssociate (-1578)

typedef eml23__BusinessAssociate _eml23__BusinessAssociate;
#endif

/* eml2_3ForGsoap.h:40679 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__CollectionsToDataobjectsAssociationSet
#define SOAP_TYPE_gsoap_eml2_3__eml23__CollectionsToDataobjectsAssociationSet (-1579)

typedef eml23__CollectionsToDataobjectsAssociationSet _eml23__CollectionsToDataobjectsAssociationSet;
#endif

/* eml2_3ForGsoap.h:40682 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__DataobjectCollection
#define SOAP_TYPE_gsoap_eml2_3__eml23__DataobjectCollection (-1580)

typedef eml23__DataobjectCollection _eml23__DataobjectCollection;
#endif

/* eml2_3ForGsoap.h:40685 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3__eml23__ColumnBasedTable (-1581)

typedef eml23__ColumnBasedTable _eml23__ColumnBasedTable;
#endif

/* eml2_3ForGsoap.h:40688 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_3__eml23__DataAssuranceRecord (-1582)

typedef eml23__DataAssuranceRecord _eml23__DataAssuranceRecord;
#endif

/* eml2_3ForGsoap.h:40691 */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_3__eml23__GraphicalInformationSet (-1583)

typedef eml23__GraphicalInformationSet _eml23__GraphicalInformationSet;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_gsoap_eml2_3_byte
#define SOAP_TYPE_gsoap_eml2_3_byte (-3)

#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_3_int
#define SOAP_TYPE_gsoap_eml2_3_int (-1)

#endif

/* eml23__PositiveLong has binding name 'eml23__PositiveLong' for type 'eml23:PositiveLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PositiveLong
#define SOAP_TYPE_gsoap_eml2_3_eml23__PositiveLong (-952)

#endif

/* eml23__NonNegativeLong has binding name 'eml23__NonNegativeLong' for type 'eml23:NonNegativeLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_3_eml23__NonNegativeLong (-950)

#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_3_LONG64
#define SOAP_TYPE_gsoap_eml2_3_LONG64 (-949)

#endif

/* eml23__PositiveDouble has binding name 'eml23__PositiveDouble' for type 'eml23:PositiveDouble' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PositiveDouble
#define SOAP_TYPE_gsoap_eml2_3_eml23__PositiveDouble (-951)

#endif

/* eml23__AbstractMeasure has binding name 'eml23__AbstractMeasure' for type 'eml23:AbstractMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMeasure (-945)

#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_3_double
#define SOAP_TYPE_gsoap_eml2_3_double (-944)

#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_gsoap_eml2_3_unsignedByte
#define SOAP_TYPE_gsoap_eml2_3_unsignedByte (-10)

#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_unsignedInt
#define SOAP_TYPE_gsoap_eml2_3_unsignedInt (-9)

#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_3_xsd__nonNegativeInteger (-15)

#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_ULONG64
#define SOAP_TYPE_gsoap_eml2_3_ULONG64 (-14)

#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_3_bool
#define SOAP_TYPE_gsoap_eml2_3_bool (-1259)

#endif

/* eml23__ReferencePressureKind has binding name 'eml23__ReferencePressureKind' for type 'eml23:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressureKind (-1218)

#endif

/* eml23__CollectionKind has binding name 'eml23__CollectionKind' for type 'eml23:CollectionKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKind (-1217)

#endif

/* eml23__PhoneType has binding name 'eml23__PhoneType' for type 'eml23:PhoneType' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PhoneType
#define SOAP_TYPE_gsoap_eml2_3_eml23__PhoneType (-1216)

#endif

/* eml23__AddressQualifier has binding name 'eml23__AddressQualifier' for type 'eml23:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_3_eml23__AddressQualifier (-1215)

#endif

/* eml23__AddressKindEnum has binding name 'eml23__AddressKindEnum' for type 'eml23:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__AddressKindEnum (-1214)

#endif

/* eml23__ActivityParameterKind has binding name 'eml23__ActivityParameterKind' for type 'eml23:ActivityParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityParameterKind (-1213)

#endif

/* eml23__FacetKind has binding name 'eml23__FacetKind' for type 'eml23:FacetKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FacetKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__FacetKind (-1212)

#endif

/* eml23__Facet has binding name 'eml23__Facet' for type 'eml23:Facet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Facet
#define SOAP_TYPE_gsoap_eml2_3_eml23__Facet (-1211)

#endif

/* eml23__VerticalDirection has binding name 'eml23__VerticalDirection' for type 'eml23:VerticalDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDirection (-1210)

#endif

/* eml23__PrincipalMeridian has binding name 'eml23__PrincipalMeridian' for type 'eml23:PrincipalMeridian' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_3_eml23__PrincipalMeridian (-1209)

#endif

/* eml23__NorthOrSouth has binding name 'eml23__NorthOrSouth' for type 'eml23:NorthOrSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_3_eml23__NorthOrSouth (-1208)

#endif

/* eml23__EastOrWest has binding name 'eml23__EastOrWest' for type 'eml23:EastOrWest' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EastOrWest
#define SOAP_TYPE_gsoap_eml2_3_eml23__EastOrWest (-1207)

#endif

/* eml23__AxisOrder2d has binding name 'eml23__AxisOrder2d' for type 'eml23:AxisOrder2d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_3_eml23__AxisOrder2d (-1206)

#endif

/* eml23__WellboreDatumReference has binding name 'eml23__WellboreDatumReference' for type 'eml23:WellboreDatumReference' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReference (-1205)

#endif

/* eml23__ReferencePointKind has binding name 'eml23__ReferencePointKind' for type 'eml23:ReferencePointKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKind (-1204)

#endif

/* eml23__WellStatus has binding name 'eml23__WellStatus' for type 'eml23:WellStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellStatus
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellStatus (-1203)

#endif

/* eml23__ReferenceCondition has binding name 'eml23__ReferenceCondition' for type 'eml23:ReferenceCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceCondition (-1202)

#endif

/* eml23__QuantityClassKind has binding name 'eml23__QuantityClassKind' for type 'eml23:QuantityClassKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKind (-1201)

#endif

/* eml23__MeasureClass has binding name 'eml23__MeasureClass' for type 'eml23:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MeasureClass
#define SOAP_TYPE_gsoap_eml2_3_eml23__MeasureClass (-1200)

#endif

/* eml23__MatrixCementKind has binding name 'eml23__MatrixCementKind' for type 'eml23:MatrixCementKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKind (-1199)

#endif

/* eml23__LithostratigraphicRank has binding name 'eml23__LithostratigraphicRank' for type 'eml23:LithostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithostratigraphicRank (-1198)

#endif

/* eml23__LithologyQualifierKind has binding name 'eml23__LithologyQualifierKind' for type 'eml23:LithologyQualifierKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKind (-1197)

#endif

/* eml23__LithologyKind has binding name 'eml23__LithologyKind' for type 'eml23:LithologyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKind (-1196)

#endif

/* eml23__GeochronologicalRank has binding name 'eml23__GeochronologicalRank' for type 'eml23:GeochronologicalRank' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeochronologicalRank (-1195)

#endif

/* eml23__ChannelStatusKind has binding name 'eml23__ChannelStatusKind' for type 'eml23:ChannelStatusKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ChannelStatusKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ChannelStatusKind (-1194)

#endif

/* eml23__ExistenceKind has binding name 'eml23__ExistenceKind' for type 'eml23:ExistenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKind (-1193)

#endif

/* resqml22__MdDomain has binding name 'resqml22__MdDomain' for type 'resqml22:MdDomain' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MdDomain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MdDomain (-1192)

#endif

/* resqml22__GeologicBoundaryKind has binding name 'resqml22__GeologicBoundaryKind' for type 'resqml22:GeologicBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicBoundaryKind (-1191)

#endif

/* resqml22__FluidMarker has binding name 'resqml22__FluidMarker' for type 'resqml22:FluidMarker' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidMarker
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidMarker (-1190)

#endif

/* resqml22__StreamlineFlux has binding name 'resqml22__StreamlineFlux' for type 'resqml22:StreamlineFlux' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFlux
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFlux (-1189)

#endif

/* resqml22__ViewerKind has binding name 'resqml22__ViewerKind' for type 'resqml22:ViewerKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKind (-1188)

#endif

/* resqml22__NodeSymbol has binding name 'resqml22__NodeSymbol' for type 'resqml22:NodeSymbol' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbol
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbol (-1187)

#endif

/* resqml22__InterpolationMethod has binding name 'resqml22__InterpolationMethod' for type 'resqml22:InterpolationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationMethod
#define SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationMethod (-1186)

#endif

/* resqml22__InterpolationDomain has binding name 'resqml22__InterpolationDomain' for type 'resqml22:InterpolationDomain' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationDomain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__InterpolationDomain (-1185)

#endif

/* resqml22__EdgePattern has binding name 'resqml22__EdgePattern' for type 'resqml22:EdgePattern' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePattern
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePattern (-1184)

#endif

/* resqml22__DisplaySpace has binding name 'resqml22__DisplaySpace' for type 'resqml22:DisplaySpace' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DisplaySpace
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DisplaySpace (-1183)

#endif

/* resqml22__SubnodeNodeObject has binding name 'resqml22__SubnodeNodeObject' for type 'resqml22:SubnodeNodeObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeNodeObject
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeNodeObject (-1182)

#endif

/* resqml22__PillarShape has binding name 'resqml22__PillarShape' for type 'resqml22:PillarShape' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PillarShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PillarShape (-1181)

#endif

/* resqml22__KDirection has binding name 'resqml22__KDirection' for type 'resqml22:KDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__KDirection
#define SOAP_TYPE_gsoap_eml2_3_resqml22__KDirection (-1180)

#endif

/* resqml22__GridGeometryAttachment has binding name 'resqml22__GridGeometryAttachment' for type 'resqml22:GridGeometryAttachment' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GridGeometryAttachment
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GridGeometryAttachment (-1179)

#endif

/* resqml22__ColumnShape has binding name 'resqml22__ColumnShape' for type 'resqml22:ColumnShape' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnShape (-1178)

#endif

/* resqml22__CellShape has binding name 'resqml22__CellShape' for type 'resqml22:CellShape' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellShape
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellShape (-1177)

#endif

/* resqml22__IdentityKind has binding name 'resqml22__IdentityKind' for type 'resqml22:IdentityKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IdentityKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IdentityKind (-1176)

#endif

/* resqml22__ThrowKind has binding name 'resqml22__ThrowKind' for type 'resqml22:ThrowKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKind (-1175)

#endif

/* resqml22__StratigraphicUnitKind has binding name 'resqml22__StratigraphicUnitKind' for type 'resqml22:StratigraphicUnitKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitKind (-1174)

#endif

/* resqml22__Shape3d has binding name 'resqml22__Shape3d' for type 'resqml22:Shape3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3d (-1173)

#endif

/* resqml22__SequenceStratigraphySurfaceKind has binding name 'resqml22__SequenceStratigraphySurfaceKind' for type 'resqml22:SequenceStratigraphySurfaceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKind (-1172)

#endif

/* resqml22__Phase has binding name 'resqml22__Phase' for type 'resqml22:Phase' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Phase
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Phase (-1171)

#endif

/* resqml22__OrderingCriteria has binding name 'resqml22__OrderingCriteria' for type 'resqml22:OrderingCriteria' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__OrderingCriteria
#define SOAP_TYPE_gsoap_eml2_3_resqml22__OrderingCriteria (-1170)

#endif

/* resqml22__HorizonStratigraphicRole has binding name 'resqml22__HorizonStratigraphicRole' for type 'resqml22:HorizonStratigraphicRole' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonStratigraphicRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonStratigraphicRole (-1169)

#endif

/* resqml22__GeologicUnitMaterialEmplacement has binding name 'resqml22__GeologicUnitMaterialEmplacement' for type 'resqml22:GeologicUnitMaterialEmplacement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitMaterialEmplacement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitMaterialEmplacement (-1168)

#endif

/* resqml22__FluidContact has binding name 'resqml22__FluidContact' for type 'resqml22:FluidContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidContact (-1167)

#endif

/* resqml22__Domain has binding name 'resqml22__Domain' for type 'resqml22:Domain' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Domain
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Domain (-1166)

#endif

/* resqml22__DepositionMode has binding name 'resqml22__DepositionMode' for type 'resqml22:DepositionMode' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionMode
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionMode (-1165)

#endif

/* resqml22__DepositionalFaciesKind has binding name 'resqml22__DepositionalFaciesKind' for type 'resqml22:DepositionalFaciesKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKind (-1164)

#endif

/* resqml22__ContactVerb has binding name 'resqml22__ContactVerb' for type 'resqml22:ContactVerb' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactVerb
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactVerb (-1163)

#endif

/* resqml22__ContactSide has binding name 'resqml22__ContactSide' for type 'resqml22:ContactSide' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactSide
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactSide (-1162)

#endif

/* resqml22__ContactMode has binding name 'resqml22__ContactMode' for type 'resqml22:ContactMode' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactMode
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactMode (-1161)

#endif

/* resqml22__SurfaceRole has binding name 'resqml22__SurfaceRole' for type 'resqml22:SurfaceRole' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SurfaceRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SurfaceRole (-1160)

#endif

/* resqml22__LineRole has binding name 'resqml22__LineRole' for type 'resqml22:LineRole' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LineRole
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LineRole (-1159)

#endif

/* resqml22__CulturalFeatureKind has binding name 'resqml22__CulturalFeatureKind' for type 'resqml22:CulturalFeatureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKind (-1158)

#endif

/* eml23__VolumeUom has binding name 'eml23__VolumeUom' for type 'eml23:VolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUom (-1154)

#endif

/* eml23__VolumetricThermalExpansionUom has binding name 'eml23__VolumetricThermalExpansionUom' for type 'eml23:VolumetricThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUom (-1153)

#endif

/* eml23__VolumetricHeatTransferCoefficientUom has binding name 'eml23__VolumetricHeatTransferCoefficientUom' for type 'eml23:VolumetricHeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUom (-1152)

#endif

/* eml23__VolumePerVolumeUom has binding name 'eml23__VolumePerVolumeUom' for type 'eml23:VolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUom (-1151)

#endif

/* eml23__VolumePerTimeUom has binding name 'eml23__VolumePerTimeUom' for type 'eml23:VolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUom (-1150)

#endif

/* eml23__VolumePerTimePerVolumeUom has binding name 'eml23__VolumePerTimePerVolumeUom' for type 'eml23:VolumePerTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUom (-1149)

#endif

/* eml23__VolumePerTimePerTimeUom has binding name 'eml23__VolumePerTimePerTimeUom' for type 'eml23:VolumePerTimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUom (-1148)

#endif

/* eml23__VolumePerTimePerPressureUom has binding name 'eml23__VolumePerTimePerPressureUom' for type 'eml23:VolumePerTimePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUom (-1147)

#endif

/* eml23__VolumePerTimePerPressureLengthUom has binding name 'eml23__VolumePerTimePerPressureLengthUom' for type 'eml23:VolumePerTimePerPressureLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUom (-1146)

#endif

/* eml23__VolumePerTimePerLengthUom has binding name 'eml23__VolumePerTimePerLengthUom' for type 'eml23:VolumePerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUom (-1145)

#endif

/* eml23__VolumePerTimePerAreaUom has binding name 'eml23__VolumePerTimePerAreaUom' for type 'eml23:VolumePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUom (-1144)

#endif

/* eml23__VolumePerTimeLengthUom has binding name 'eml23__VolumePerTimeLengthUom' for type 'eml23:VolumePerTimeLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUom (-1143)

#endif

/* eml23__VolumePerRotationUom has binding name 'eml23__VolumePerRotationUom' for type 'eml23:VolumePerRotationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUom (-1142)

#endif

/* eml23__VolumePerPressureUom has binding name 'eml23__VolumePerPressureUom' for type 'eml23:VolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUom (-1141)

#endif

/* eml23__VolumePerMassUom has binding name 'eml23__VolumePerMassUom' for type 'eml23:VolumePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUom (-1140)

#endif

/* eml23__VolumePerLengthUom has binding name 'eml23__VolumePerLengthUom' for type 'eml23:VolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUom (-1139)

#endif

/* eml23__VolumePerAreaUom has binding name 'eml23__VolumePerAreaUom' for type 'eml23:VolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUom (-1138)

#endif

/* eml23__VolumeFlowRatePerVolumeFlowRateUom has binding name 'eml23__VolumeFlowRatePerVolumeFlowRateUom' for type 'eml23:VolumeFlowRatePerVolumeFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUom (-1137)

#endif

/* eml23__VerticalCoordinateUom has binding name 'eml23__VerticalCoordinateUom' for type 'eml23:VerticalCoordinateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUom (-1136)

#endif

/* eml23__TimeUom has binding name 'eml23__TimeUom' for type 'eml23:TimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeUom (-1135)

#endif

/* eml23__TimePerVolumeUom has binding name 'eml23__TimePerVolumeUom' for type 'eml23:TimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUom (-1134)

#endif

/* eml23__TimePerTimeUom has binding name 'eml23__TimePerTimeUom' for type 'eml23:TimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUom (-1133)

#endif

/* eml23__TimePerMassUom has binding name 'eml23__TimePerMassUom' for type 'eml23:TimePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUom (-1132)

#endif

/* eml23__TimePerLengthUom has binding name 'eml23__TimePerLengthUom' for type 'eml23:TimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUom (-1131)

#endif

/* eml23__ThermodynamicTemperatureUom has binding name 'eml23__ThermodynamicTemperatureUom' for type 'eml23:ThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUom (-1130)

#endif

/* eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom has binding name 'eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom' for type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUom (-1129)

#endif

/* eml23__ThermalResistanceUom has binding name 'eml23__ThermalResistanceUom' for type 'eml23:ThermalResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUom (-1128)

#endif

/* eml23__ThermalInsulanceUom has binding name 'eml23__ThermalInsulanceUom' for type 'eml23:ThermalInsulanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUom (-1127)

#endif

/* eml23__ThermalDiffusivityUom has binding name 'eml23__ThermalDiffusivityUom' for type 'eml23:ThermalDiffusivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUom (-1126)

#endif

/* eml23__ThermalConductivityUom has binding name 'eml23__ThermalConductivityUom' for type 'eml23:ThermalConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUom (-1125)

#endif

/* eml23__ThermalConductanceUom has binding name 'eml23__ThermalConductanceUom' for type 'eml23:ThermalConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUom (-1124)

#endif

/* eml23__TemperatureIntervalUom has binding name 'eml23__TemperatureIntervalUom' for type 'eml23:TemperatureIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUom (-1123)

#endif

/* eml23__TemperatureIntervalPerTimeUom has binding name 'eml23__TemperatureIntervalPerTimeUom' for type 'eml23:TemperatureIntervalPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUom (-1122)

#endif

/* eml23__TemperatureIntervalPerPressureUom has binding name 'eml23__TemperatureIntervalPerPressureUom' for type 'eml23:TemperatureIntervalPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUom (-1121)

#endif

/* eml23__TemperatureIntervalPerLengthUom has binding name 'eml23__TemperatureIntervalPerLengthUom' for type 'eml23:TemperatureIntervalPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUom (-1120)

#endif

/* eml23__SpecificHeatCapacityUom has binding name 'eml23__SpecificHeatCapacityUom' for type 'eml23:SpecificHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUom (-1119)

#endif

/* eml23__SolidAngleUom has binding name 'eml23__SolidAngleUom' for type 'eml23:SolidAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUom (-1118)

#endif

/* eml23__SignalingEventPerTimeUom has binding name 'eml23__SignalingEventPerTimeUom' for type 'eml23:SignalingEventPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUom (-1117)

#endif

/* eml23__SecondMomentOfAreaUom has binding name 'eml23__SecondMomentOfAreaUom' for type 'eml23:SecondMomentOfAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUom (-1116)

#endif

/* eml23__ReluctanceUom has binding name 'eml23__ReluctanceUom' for type 'eml23:ReluctanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUom (-1115)

#endif

/* eml23__ReciprocalVolumeUom has binding name 'eml23__ReciprocalVolumeUom' for type 'eml23:ReciprocalVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUom (-1114)

#endif

/* eml23__ReciprocalTimeUom has binding name 'eml23__ReciprocalTimeUom' for type 'eml23:ReciprocalTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUom (-1113)

#endif

/* eml23__ReciprocalPressureUom has binding name 'eml23__ReciprocalPressureUom' for type 'eml23:ReciprocalPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUom (-1112)

#endif

/* eml23__ReciprocalMassUom has binding name 'eml23__ReciprocalMassUom' for type 'eml23:ReciprocalMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUom (-1111)

#endif

/* eml23__ReciprocalMassTimeUom has binding name 'eml23__ReciprocalMassTimeUom' for type 'eml23:ReciprocalMassTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUom (-1110)

#endif

/* eml23__ReciprocalLengthUom has binding name 'eml23__ReciprocalLengthUom' for type 'eml23:ReciprocalLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUom (-1109)

#endif

/* eml23__ReciprocalForceUom has binding name 'eml23__ReciprocalForceUom' for type 'eml23:ReciprocalForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUom (-1108)

#endif

/* eml23__ReciprocalElectricPotentialDifferenceUom has binding name 'eml23__ReciprocalElectricPotentialDifferenceUom' for type 'eml23:ReciprocalElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUom (-1107)

#endif

/* eml23__ReciprocalAreaUom has binding name 'eml23__ReciprocalAreaUom' for type 'eml23:ReciprocalAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUom (-1106)

#endif

/* eml23__RadiantIntensityUom has binding name 'eml23__RadiantIntensityUom' for type 'eml23:RadiantIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUom (-1105)

#endif

/* eml23__RadianceUom has binding name 'eml23__RadianceUom' for type 'eml23:RadianceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUom (-1104)

#endif

/* eml23__QuantityOfLightUom has binding name 'eml23__QuantityOfLightUom' for type 'eml23:QuantityOfLightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUom (-1103)

#endif

/* eml23__PressureUom has binding name 'eml23__PressureUom' for type 'eml23:PressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUom (-1102)

#endif

/* eml23__PressureTimePerVolumeUom has binding name 'eml23__PressureTimePerVolumeUom' for type 'eml23:PressureTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUom (-1101)

#endif

/* eml23__PressureSquaredUom has binding name 'eml23__PressureSquaredUom' for type 'eml23:PressureSquaredUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUom (-1100)

#endif

/* eml23__PressureSquaredPerForceTimePerAreaUom has binding name 'eml23__PressureSquaredPerForceTimePerAreaUom' for type 'eml23:PressureSquaredPerForceTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUom (-1099)

#endif

/* eml23__PressurePerVolumeUom has binding name 'eml23__PressurePerVolumeUom' for type 'eml23:PressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUom (-1098)

#endif

/* eml23__PressurePerTimeUom has binding name 'eml23__PressurePerTimeUom' for type 'eml23:PressurePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUom (-1097)

#endif

/* eml23__PressurePerPressureUom has binding name 'eml23__PressurePerPressureUom' for type 'eml23:PressurePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUom (-1096)

#endif

/* eml23__PowerUom has binding name 'eml23__PowerUom' for type 'eml23:PowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerUom (-1095)

#endif

/* eml23__PowerPerVolumeUom has binding name 'eml23__PowerPerVolumeUom' for type 'eml23:PowerPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUom (-1094)

#endif

/* eml23__PowerPerPowerUom has binding name 'eml23__PowerPerPowerUom' for type 'eml23:PowerPerPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUom (-1093)

#endif

/* eml23__PowerPerAreaUom has binding name 'eml23__PowerPerAreaUom' for type 'eml23:PowerPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUom (-1092)

#endif

/* eml23__PotentialDifferencePerPowerDropUom has binding name 'eml23__PotentialDifferencePerPowerDropUom' for type 'eml23:PotentialDifferencePerPowerDropUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUom (-1091)

#endif

/* eml23__PlaneAngleUom has binding name 'eml23__PlaneAngleUom' for type 'eml23:PlaneAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUom (-1090)

#endif

/* eml23__PermittivityUom has binding name 'eml23__PermittivityUom' for type 'eml23:PermittivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUom (-1089)

#endif

/* eml23__PermeabilityRockUom has binding name 'eml23__PermeabilityRockUom' for type 'eml23:PermeabilityRockUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUom (-1088)

#endif

/* eml23__PermeabilityLengthUom has binding name 'eml23__PermeabilityLengthUom' for type 'eml23:PermeabilityLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUom (-1087)

#endif

/* eml23__NormalizedPowerUom has binding name 'eml23__NormalizedPowerUom' for type 'eml23:NormalizedPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUom (-1086)

#endif

/* eml23__MomentumUom has binding name 'eml23__MomentumUom' for type 'eml23:MomentumUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUom (-1085)

#endif

/* eml23__MomentOfInertiaUom has binding name 'eml23__MomentOfInertiaUom' for type 'eml23:MomentOfInertiaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUom (-1084)

#endif

/* eml23__MomentOfForceUom has binding name 'eml23__MomentOfForceUom' for type 'eml23:MomentOfForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUom (-1083)

#endif

/* eml23__MolecularWeightUom has binding name 'eml23__MolecularWeightUom' for type 'eml23:MolecularWeightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUom (-1082)

#endif

/* eml23__MolarVolumeUom has binding name 'eml23__MolarVolumeUom' for type 'eml23:MolarVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUom (-1081)

#endif

/* eml23__MolarHeatCapacityUom has binding name 'eml23__MolarHeatCapacityUom' for type 'eml23:MolarHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUom (-1080)

#endif

/* eml23__MolarEnergyUom has binding name 'eml23__MolarEnergyUom' for type 'eml23:MolarEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUom (-1079)

#endif

/* eml23__MobilityUom has binding name 'eml23__MobilityUom' for type 'eml23:MobilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUom (-1078)

#endif

/* eml23__MassUom has binding name 'eml23__MassUom' for type 'eml23:MassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassUom (-1077)

#endif

/* eml23__MassPerVolumeUom has binding name 'eml23__MassPerVolumeUom' for type 'eml23:MassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUom (-1076)

#endif

/* eml23__MassPerVolumePerTemperatureUom has binding name 'eml23__MassPerVolumePerTemperatureUom' for type 'eml23:MassPerVolumePerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUom (-1075)

#endif

/* eml23__MassPerVolumePerPressureUom has binding name 'eml23__MassPerVolumePerPressureUom' for type 'eml23:MassPerVolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUom (-1074)

#endif

/* eml23__MassPerVolumePerLengthUom has binding name 'eml23__MassPerVolumePerLengthUom' for type 'eml23:MassPerVolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUom (-1073)

#endif

/* eml23__MassPerTimeUom has binding name 'eml23__MassPerTimeUom' for type 'eml23:MassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUom (-1072)

#endif

/* eml23__MassPerTimePerLengthUom has binding name 'eml23__MassPerTimePerLengthUom' for type 'eml23:MassPerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUom (-1071)

#endif

/* eml23__MassPerTimePerAreaUom has binding name 'eml23__MassPerTimePerAreaUom' for type 'eml23:MassPerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUom (-1070)

#endif

/* eml23__MassPerMassUom has binding name 'eml23__MassPerMassUom' for type 'eml23:MassPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUom (-1069)

#endif

/* eml23__MassPerLengthUom has binding name 'eml23__MassPerLengthUom' for type 'eml23:MassPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUom (-1068)

#endif

/* eml23__MassPerEnergyUom has binding name 'eml23__MassPerEnergyUom' for type 'eml23:MassPerEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUom (-1067)

#endif

/* eml23__MassPerAreaUom has binding name 'eml23__MassPerAreaUom' for type 'eml23:MassPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUom (-1066)

#endif

/* eml23__MassLengthUom has binding name 'eml23__MassLengthUom' for type 'eml23:MassLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUom (-1065)

#endif

/* eml23__MagneticVectorPotentialUom has binding name 'eml23__MagneticVectorPotentialUom' for type 'eml23:MagneticVectorPotentialUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUom (-1064)

#endif

/* eml23__MagneticPermeabilityUom has binding name 'eml23__MagneticPermeabilityUom' for type 'eml23:MagneticPermeabilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUom (-1063)

#endif

/* eml23__MagneticFluxUom has binding name 'eml23__MagneticFluxUom' for type 'eml23:MagneticFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUom (-1062)

#endif

/* eml23__MagneticFluxDensityUom has binding name 'eml23__MagneticFluxDensityUom' for type 'eml23:MagneticFluxDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUom (-1061)

#endif

/* eml23__MagneticFluxDensityPerLengthUom has binding name 'eml23__MagneticFluxDensityPerLengthUom' for type 'eml23:MagneticFluxDensityPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUom (-1060)

#endif

/* eml23__MagneticFieldStrengthUom has binding name 'eml23__MagneticFieldStrengthUom' for type 'eml23:MagneticFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUom (-1059)

#endif

/* eml23__MagneticDipoleMomentUom has binding name 'eml23__MagneticDipoleMomentUom' for type 'eml23:MagneticDipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUom (-1058)

#endif

/* eml23__LuminousIntensityUom has binding name 'eml23__LuminousIntensityUom' for type 'eml23:LuminousIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUom (-1057)

#endif

/* eml23__LuminousFluxUom has binding name 'eml23__LuminousFluxUom' for type 'eml23:LuminousFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUom (-1056)

#endif

/* eml23__LuminousEfficacyUom has binding name 'eml23__LuminousEfficacyUom' for type 'eml23:LuminousEfficacyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUom (-1055)

#endif

/* eml23__LuminanceUom has binding name 'eml23__LuminanceUom' for type 'eml23:LuminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUom (-1054)

#endif

/* eml23__LogarithmicPowerRatioUom has binding name 'eml23__LogarithmicPowerRatioUom' for type 'eml23:LogarithmicPowerRatioUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUom (-1053)

#endif

/* eml23__LogarithmicPowerRatioPerLengthUom has binding name 'eml23__LogarithmicPowerRatioPerLengthUom' for type 'eml23:LogarithmicPowerRatioPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUom (-1052)

#endif

/* eml23__LinearThermalExpansionUom has binding name 'eml23__LinearThermalExpansionUom' for type 'eml23:LinearThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUom (-1051)

#endif

/* eml23__LinearAccelerationUom has binding name 'eml23__LinearAccelerationUom' for type 'eml23:LinearAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUom (-1050)

#endif

/* eml23__LightExposureUom has binding name 'eml23__LightExposureUom' for type 'eml23:LightExposureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUom (-1049)

#endif

/* eml23__LengthUom has binding name 'eml23__LengthUom' for type 'eml23:LengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthUom (-1048)

#endif

/* eml23__LengthPerVolumeUom has binding name 'eml23__LengthPerVolumeUom' for type 'eml23:LengthPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUom (-1047)

#endif

/* eml23__LengthPerTimeUom has binding name 'eml23__LengthPerTimeUom' for type 'eml23:LengthPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUom (-1046)

#endif

/* eml23__LengthPerTemperatureUom has binding name 'eml23__LengthPerTemperatureUom' for type 'eml23:LengthPerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUom (-1045)

#endif

/* eml23__LengthPerPressureUom has binding name 'eml23__LengthPerPressureUom' for type 'eml23:LengthPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUom (-1044)

#endif

/* eml23__LengthPerMassUom has binding name 'eml23__LengthPerMassUom' for type 'eml23:LengthPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUom (-1043)

#endif

/* eml23__LengthPerLengthUom has binding name 'eml23__LengthPerLengthUom' for type 'eml23:LengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUom (-1042)

#endif

/* eml23__KinematicViscosityUom has binding name 'eml23__KinematicViscosityUom' for type 'eml23:KinematicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUom (-1041)

#endif

/* eml23__IsothermalCompressibilityUom has binding name 'eml23__IsothermalCompressibilityUom' for type 'eml23:IsothermalCompressibilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUom (-1040)

#endif

/* eml23__InductanceUom has binding name 'eml23__InductanceUom' for type 'eml23:InductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUom (-1039)

#endif

/* eml23__IlluminanceUom has binding name 'eml23__IlluminanceUom' for type 'eml23:IlluminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUom (-1038)

#endif

/* eml23__HeatTransferCoefficientUom has binding name 'eml23__HeatTransferCoefficientUom' for type 'eml23:HeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUom (-1037)

#endif

/* eml23__HeatFlowRateUom has binding name 'eml23__HeatFlowRateUom' for type 'eml23:HeatFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUom (-1036)

#endif

/* eml23__HeatCapacityUom has binding name 'eml23__HeatCapacityUom' for type 'eml23:HeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUom (-1035)

#endif

/* eml23__FrequencyUom has binding name 'eml23__FrequencyUom' for type 'eml23:FrequencyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUom (-1034)

#endif

/* eml23__FrequencyIntervalUom has binding name 'eml23__FrequencyIntervalUom' for type 'eml23:FrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUom (-1033)

#endif

/* eml23__ForceUom has binding name 'eml23__ForceUom' for type 'eml23:ForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceUom (-1032)

#endif

/* eml23__ForcePerVolumeUom has binding name 'eml23__ForcePerVolumeUom' for type 'eml23:ForcePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUom (-1031)

#endif

/* eml23__ForcePerLengthUom has binding name 'eml23__ForcePerLengthUom' for type 'eml23:ForcePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUom (-1030)

#endif

/* eml23__ForcePerForceUom has binding name 'eml23__ForcePerForceUom' for type 'eml23:ForcePerForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUom (-1029)

#endif

/* eml23__ForceLengthPerLengthUom has binding name 'eml23__ForceLengthPerLengthUom' for type 'eml23:ForceLengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUom (-1028)

#endif

/* eml23__ForceAreaUom has binding name 'eml23__ForceAreaUom' for type 'eml23:ForceAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUom (-1027)

#endif

/* eml23__EnergyUom has binding name 'eml23__EnergyUom' for type 'eml23:EnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUom (-1026)

#endif

/* eml23__EnergyPerVolumeUom has binding name 'eml23__EnergyPerVolumeUom' for type 'eml23:EnergyPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUom (-1025)

#endif

/* eml23__EnergyPerMassUom has binding name 'eml23__EnergyPerMassUom' for type 'eml23:EnergyPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUom (-1024)

#endif

/* eml23__EnergyPerMassPerTimeUom has binding name 'eml23__EnergyPerMassPerTimeUom' for type 'eml23:EnergyPerMassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUom (-1023)

#endif

/* eml23__EnergyPerLengthUom has binding name 'eml23__EnergyPerLengthUom' for type 'eml23:EnergyPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUom (-1022)

#endif

/* eml23__EnergyPerAreaUom has binding name 'eml23__EnergyPerAreaUom' for type 'eml23:EnergyPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUom (-1021)

#endif

/* eml23__EnergyLengthPerTimeAreaTemperatureUom has binding name 'eml23__EnergyLengthPerTimeAreaTemperatureUom' for type 'eml23:EnergyLengthPerTimeAreaTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUom (-1020)

#endif

/* eml23__EnergyLengthPerAreaUom has binding name 'eml23__EnergyLengthPerAreaUom' for type 'eml23:EnergyLengthPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUom (-1019)

#endif

/* eml23__ElectromagneticMomentUom has binding name 'eml23__ElectromagneticMomentUom' for type 'eml23:ElectromagneticMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUom (-1018)

#endif

/* eml23__ElectricResistanceUom has binding name 'eml23__ElectricResistanceUom' for type 'eml23:ElectricResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUom (-1017)

#endif

/* eml23__ElectricResistancePerLengthUom has binding name 'eml23__ElectricResistancePerLengthUom' for type 'eml23:ElectricResistancePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUom (-1016)

#endif

/* eml23__ElectricPotentialDifferenceUom has binding name 'eml23__ElectricPotentialDifferenceUom' for type 'eml23:ElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUom (-1015)

#endif

/* eml23__ElectricFieldStrengthUom has binding name 'eml23__ElectricFieldStrengthUom' for type 'eml23:ElectricFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUom (-1014)

#endif

/* eml23__ElectricCurrentUom has binding name 'eml23__ElectricCurrentUom' for type 'eml23:ElectricCurrentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUom (-1013)

#endif

/* eml23__ElectricCurrentDensityUom has binding name 'eml23__ElectricCurrentDensityUom' for type 'eml23:ElectricCurrentDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUom (-1012)

#endif

/* eml23__ElectricConductivityUom has binding name 'eml23__ElectricConductivityUom' for type 'eml23:ElectricConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUom (-1011)

#endif

/* eml23__ElectricConductanceUom has binding name 'eml23__ElectricConductanceUom' for type 'eml23:ElectricConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUom (-1010)

#endif

/* eml23__ElectricChargeUom has binding name 'eml23__ElectricChargeUom' for type 'eml23:ElectricChargeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUom (-1009)

#endif

/* eml23__ElectricChargePerVolumeUom has binding name 'eml23__ElectricChargePerVolumeUom' for type 'eml23:ElectricChargePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUom (-1008)

#endif

/* eml23__ElectricChargePerMassUom has binding name 'eml23__ElectricChargePerMassUom' for type 'eml23:ElectricChargePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUom (-1007)

#endif

/* eml23__ElectricChargePerAreaUom has binding name 'eml23__ElectricChargePerAreaUom' for type 'eml23:ElectricChargePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUom (-1006)

#endif

/* eml23__ElectricalResistivityUom has binding name 'eml23__ElectricalResistivityUom' for type 'eml23:ElectricalResistivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUom (-1005)

#endif

/* eml23__DynamicViscosityUom has binding name 'eml23__DynamicViscosityUom' for type 'eml23:DynamicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUom (-1004)

#endif

/* eml23__DoseEquivalentUom has binding name 'eml23__DoseEquivalentUom' for type 'eml23:DoseEquivalentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUom (-1003)

#endif

/* eml23__DipoleMomentUom has binding name 'eml23__DipoleMomentUom' for type 'eml23:DipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUom (-1002)

#endif

/* eml23__DimensionlessUom has binding name 'eml23__DimensionlessUom' for type 'eml23:DimensionlessUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUom (-1001)

#endif

/* eml23__DigitalStorageUom has binding name 'eml23__DigitalStorageUom' for type 'eml23:DigitalStorageUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUom (-1000)

#endif

/* eml23__DiffusiveTimeOfFlightUom has binding name 'eml23__DiffusiveTimeOfFlightUom' for type 'eml23:DiffusiveTimeOfFlightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUom (-999)

#endif

/* eml23__DiffusionCoefficientUom has binding name 'eml23__DiffusionCoefficientUom' for type 'eml23:DiffusionCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUom (-998)

#endif

/* eml23__DataTransferSpeedUom has binding name 'eml23__DataTransferSpeedUom' for type 'eml23:DataTransferSpeedUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUom (-997)

#endif

/* eml23__CationExchangeCapacityUom has binding name 'eml23__CationExchangeCapacityUom' for type 'eml23:CationExchangeCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUom (-996)

#endif

/* eml23__CapacitanceUom has binding name 'eml23__CapacitanceUom' for type 'eml23:CapacitanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUom (-995)

#endif

/* eml23__AttenuationPerFrequencyIntervalUom has binding name 'eml23__AttenuationPerFrequencyIntervalUom' for type 'eml23:AttenuationPerFrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUom (-994)

#endif

/* eml23__AreaUom has binding name 'eml23__AreaUom' for type 'eml23:AreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaUom (-993)

#endif

/* eml23__AreaPerVolumeUom has binding name 'eml23__AreaPerVolumeUom' for type 'eml23:AreaPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUom (-992)

#endif

/* eml23__AreaPerTimeUom has binding name 'eml23__AreaPerTimeUom' for type 'eml23:AreaPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUom (-991)

#endif

/* eml23__AreaPerMassUom has binding name 'eml23__AreaPerMassUom' for type 'eml23:AreaPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUom (-990)

#endif

/* eml23__AreaPerCountUom has binding name 'eml23__AreaPerCountUom' for type 'eml23:AreaPerCountUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUom (-989)

#endif

/* eml23__AreaPerAreaUom has binding name 'eml23__AreaPerAreaUom' for type 'eml23:AreaPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUom (-988)

#endif

/* eml23__AreaPerAmountOfSubstanceUom has binding name 'eml23__AreaPerAmountOfSubstanceUom' for type 'eml23:AreaPerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUom (-987)

#endif

/* eml23__APINeutronUom has binding name 'eml23__APINeutronUom' for type 'eml23:APINeutronUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUom (-986)

#endif

/* eml23__APIGravityUom has binding name 'eml23__APIGravityUom' for type 'eml23:APIGravityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUom (-985)

#endif

/* eml23__APIGammaRayUom has binding name 'eml23__APIGammaRayUom' for type 'eml23:APIGammaRayUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUom (-984)

#endif

/* eml23__AngularVelocityUom has binding name 'eml23__AngularVelocityUom' for type 'eml23:AngularVelocityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUom (-983)

#endif

/* eml23__AngularAccelerationUom has binding name 'eml23__AngularAccelerationUom' for type 'eml23:AngularAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUom (-982)

#endif

/* eml23__AnglePerVolumeUom has binding name 'eml23__AnglePerVolumeUom' for type 'eml23:AnglePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUom (-981)

#endif

/* eml23__AnglePerLengthUom has binding name 'eml23__AnglePerLengthUom' for type 'eml23:AnglePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUom (-980)

#endif

/* eml23__AmountOfSubstanceUom has binding name 'eml23__AmountOfSubstanceUom' for type 'eml23:AmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUom (-979)

#endif

/* eml23__AmountOfSubstancePerVolumeUom has binding name 'eml23__AmountOfSubstancePerVolumeUom' for type 'eml23:AmountOfSubstancePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUom (-978)

#endif

/* eml23__AmountOfSubstancePerTimeUom has binding name 'eml23__AmountOfSubstancePerTimeUom' for type 'eml23:AmountOfSubstancePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUom (-977)

#endif

/* eml23__AmountOfSubstancePerTimePerAreaUom has binding name 'eml23__AmountOfSubstancePerTimePerAreaUom' for type 'eml23:AmountOfSubstancePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUom (-976)

#endif

/* eml23__AmountOfSubstancePerAreaUom has binding name 'eml23__AmountOfSubstancePerAreaUom' for type 'eml23:AmountOfSubstancePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUom (-975)

#endif

/* eml23__AmountOfSubstancePerAmountOfSubstanceUom has binding name 'eml23__AmountOfSubstancePerAmountOfSubstanceUom' for type 'eml23:AmountOfSubstancePerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUom (-974)

#endif

/* eml23__ActivityOfRadioactivityUom has binding name 'eml23__ActivityOfRadioactivityUom' for type 'eml23:ActivityOfRadioactivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUom (-973)

#endif

/* eml23__AbsorbedDoseUom has binding name 'eml23__AbsorbedDoseUom' for type 'eml23:AbsorbedDoseUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUom (-972)

#endif

/* eml23__LegacyVolumeUom has binding name 'eml23__LegacyVolumeUom' for type 'eml23:LegacyVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumeUom (-971)

#endif

/* eml23__LegacyVolumePerVolumeUom has binding name 'eml23__LegacyVolumePerVolumeUom' for type 'eml23:LegacyVolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerVolumeUom (-970)

#endif

/* eml23__LegacyVolumePerTimeUom has binding name 'eml23__LegacyVolumePerTimeUom' for type 'eml23:LegacyVolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerTimeUom (-969)

#endif

/* eml23__LegacyVolumePerAreaUom has binding name 'eml23__LegacyVolumePerAreaUom' for type 'eml23:LegacyVolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyVolumePerAreaUom (-968)

#endif

/* eml23__LegacyPressureUom has binding name 'eml23__LegacyPressureUom' for type 'eml23:LegacyPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressureUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressureUom (-967)

#endif

/* eml23__LegacyPressurePerVolumeUom has binding name 'eml23__LegacyPressurePerVolumeUom' for type 'eml23:LegacyPressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyPressurePerVolumeUom (-966)

#endif

/* eml23__LegacyMassPerVolumeUom has binding name 'eml23__LegacyMassPerVolumeUom' for type 'eml23:LegacyMassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyMassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyMassPerVolumeUom (-965)

#endif

/* eml23__UnitOfMeasure has binding name 'eml23__UnitOfMeasure' for type 'eml23:UnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasure (-962)

#endif

/* eml23__LegacyUnitOfMeasure has binding name 'eml23__LegacyUnitOfMeasure' for type 'eml23:LegacyUnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LegacyUnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LegacyUnitOfMeasure (-961)

#endif

/* eml23__AxisDirectionKind has binding name 'eml23__AxisDirectionKind' for type 'eml23:AxisDirectionKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AxisDirectionKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__AxisDirectionKind (-954)

#endif

/* eml23__IntegerType has binding name 'eml23__IntegerType' for type 'eml23:IntegerType' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerType
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerType (-948)

#endif

/* eml23__FloatingPointType has binding name 'eml23__FloatingPointType' for type 'eml23:FloatingPointType' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointType
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointType (-947)

#endif

/* eml23__NorthReferenceKind has binding name 'eml23__NorthReferenceKind' for type 'eml23:NorthReferenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NorthReferenceKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__NorthReferenceKind (-943)

#endif

/* eml23__IndexableElement has binding name 'eml23__IndexableElement' for type 'eml23:IndexableElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IndexableElement
#define SOAP_TYPE_gsoap_eml2_3_eml23__IndexableElement (-942)

#endif

/* eml23__GrowingStatusKind has binding name 'eml23__GrowingStatusKind' for type 'eml23:GrowingStatusKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GrowingStatusKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__GrowingStatusKind (-941)

#endif

/* _eml23__GraphicalInformationSet has binding name '_eml23__GraphicalInformationSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_3__eml23__GraphicalInformationSet (-1583)

#endif

/* _eml23__DataAssuranceRecord has binding name '_eml23__DataAssuranceRecord' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_3__eml23__DataAssuranceRecord (-1582)

#endif

/* _eml23__ColumnBasedTable has binding name '_eml23__ColumnBasedTable' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3__eml23__ColumnBasedTable (-1581)

#endif

/* _eml23__DataobjectCollection has binding name '_eml23__DataobjectCollection' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__DataobjectCollection
#define SOAP_TYPE_gsoap_eml2_3__eml23__DataobjectCollection (-1580)

#endif

/* _eml23__CollectionsToDataobjectsAssociationSet has binding name '_eml23__CollectionsToDataobjectsAssociationSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__CollectionsToDataobjectsAssociationSet
#define SOAP_TYPE_gsoap_eml2_3__eml23__CollectionsToDataobjectsAssociationSet (-1579)

#endif

/* _eml23__BusinessAssociate has binding name '_eml23__BusinessAssociate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_3__eml23__BusinessAssociate (-1578)

#endif

/* _eml23__Attachment has binding name '_eml23__Attachment' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Attachment
#define SOAP_TYPE_gsoap_eml2_3__eml23__Attachment (-1577)

#endif

/* _eml23__Aggregate has binding name '_eml23__Aggregate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Aggregate
#define SOAP_TYPE_gsoap_eml2_3__eml23__Aggregate (-1576)

#endif

/* _eml23__ActivityTemplate has binding name '_eml23__ActivityTemplate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_3__eml23__ActivityTemplate (-1575)

#endif

/* _eml23__Activity has binding name '_eml23__Activity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__Activity
#define SOAP_TYPE_gsoap_eml2_3__eml23__Activity (-1574)

#endif

/* _eml23__TimeSeries has binding name '_eml23__TimeSeries' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__TimeSeries
#define SOAP_TYPE_gsoap_eml2_3__eml23__TimeSeries (-1573)

#endif

/* _eml23__PropertyKindDictionary has binding name '_eml23__PropertyKindDictionary' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKindDictionary (-1572)

#endif

/* _eml23__PropertyKind has binding name '_eml23__PropertyKind' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3__eml23__PropertyKind (-1571)

#endif

/* _eml23__VerticalCrs has binding name '_eml23__VerticalCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__VerticalCrs (-1570)

#endif

/* _eml23__ProjectedCrs has binding name '_eml23__ProjectedCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ProjectedCrs (-1569)

#endif

/* _eml23__LocalEngineeringCompoundCrs has binding name '_eml23__LocalEngineeringCompoundCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__LocalEngineeringCompoundCrs (-1568)

#endif

/* _eml23__GeodeticCrs has binding name '_eml23__GeodeticCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__GeodeticCrs (-1567)

#endif

/* _eml23__ReferencePointInAWellbore has binding name '_eml23__ReferencePointInAWellbore' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInAWellbore
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInAWellbore (-1566)

#endif

/* _eml23__ReferencePointInALocalEngineeringCompoundCrs has binding name '_eml23__ReferencePointInALocalEngineeringCompoundCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInALocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInALocalEngineeringCompoundCrs (-1565)

#endif

/* _eml23__ReferencePointInACrs has binding name '_eml23__ReferencePointInACrs' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInACrs
#define SOAP_TYPE_gsoap_eml2_3__eml23__ReferencePointInACrs (-1564)

#endif

/* _eml23__RecursiveReferencePoint has binding name '_eml23__RecursiveReferencePoint' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__eml23__RecursiveReferencePoint
#define SOAP_TYPE_gsoap_eml2_3__eml23__RecursiveReferencePoint (-1563)

#endif

/* _resqml22__WellboreTrajectoryRepresentation has binding name '_resqml22__WellboreTrajectoryRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreTrajectoryRepresentation (-1562)

#endif

/* _resqml22__WellboreMarkerFrameRepresentation has binding name '_resqml22__WellboreMarkerFrameRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreMarkerFrameRepresentation (-1561)

#endif

/* _resqml22__WellboreInterpretation has binding name '_resqml22__WellboreInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreInterpretation (-1560)

#endif

/* _resqml22__WellboreFrameRepresentation has binding name '_resqml22__WellboreFrameRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFrameRepresentation (-1559)

#endif

/* _resqml22__WellboreFeature has binding name '_resqml22__WellboreFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreFeature (-1558)

#endif

/* _resqml22__SeismicWellboreFrameRepresentation has binding name '_resqml22__SeismicWellboreFrameRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicWellboreFrameRepresentation (-1557)

#endif

/* _resqml22__BlockedWellboreRepresentation has binding name '_resqml22__BlockedWellboreRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BlockedWellboreRepresentation (-1556)

#endif

/* _resqml22__StreamlinesRepresentation has binding name '_resqml22__StreamlinesRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesRepresentation (-1555)

#endif

/* _resqml22__StreamlinesFeature has binding name '_resqml22__StreamlinesFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StreamlinesFeature (-1554)

#endif

/* _resqml22__PointsProperty has binding name '_resqml22__PointsProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PointsProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PointsProperty (-1553)

#endif

/* _resqml22__DiscreteProperty has binding name '_resqml22__DiscreteProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteProperty (-1552)

#endif

/* _resqml22__ContinuousProperty has binding name '_resqml22__ContinuousProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousProperty (-1551)

#endif

/* _resqml22__CommentProperty has binding name '_resqml22__CommentProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CommentProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CommentProperty (-1550)

#endif

/* _resqml22__CategoricalProperty has binding name '_resqml22__CategoricalProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CategoricalProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CategoricalProperty (-1549)

#endif

/* _resqml22__BooleanProperty has binding name '_resqml22__BooleanProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BooleanProperty
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BooleanProperty (-1548)

#endif

/* _resqml22__DiscreteColorMap has binding name '_resqml22__DiscreteColorMap' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteColorMap
#define SOAP_TYPE_gsoap_eml2_3__resqml22__DiscreteColorMap (-1547)

#endif

/* _resqml22__ContinuousColorMap has binding name '_resqml22__ContinuousColorMap' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousColorMap
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ContinuousColorMap (-1546)

#endif

/* _resqml22__ColorMapDictionary has binding name '_resqml22__ColorMapDictionary' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ColorMapDictionary
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ColorMapDictionary (-1545)

#endif

/* _resqml22__UnstructuredGridRepresentation has binding name '_resqml22__UnstructuredGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredGridRepresentation (-1544)

#endif

/* _resqml22__UnstructuredColumnLayerGridRepresentation has binding name '_resqml22__UnstructuredColumnLayerGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__UnstructuredColumnLayerGridRepresentation (-1543)

#endif

/* _resqml22__TruncatedUnstructuredColumnLayerGridRepresentation has binding name '_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedUnstructuredColumnLayerGridRepresentation (-1542)

#endif

/* _resqml22__TruncatedIjkGridRepresentation has binding name '_resqml22__TruncatedIjkGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TruncatedIjkGridRepresentation (-1541)

#endif

/* _resqml22__LocalGridSet has binding name '_resqml22__LocalGridSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__LocalGridSet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__LocalGridSet (-1540)

#endif

/* _resqml22__IjkGridRepresentation has binding name '_resqml22__IjkGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__IjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__IjkGridRepresentation (-1539)

#endif

/* _resqml22__GridConnectionSetRepresentation has binding name '_resqml22__GridConnectionSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GridConnectionSetRepresentation (-1538)

#endif

/* _resqml22__Grid2dRepresentation has binding name '_resqml22__Grid2dRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Grid2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Grid2dRepresentation (-1537)

#endif

/* _resqml22__GpGridRepresentation has binding name '_resqml22__GpGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GpGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GpGridRepresentation (-1536)

#endif

/* _resqml22__WellboreIntervalSet has binding name '_resqml22__WellboreIntervalSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreIntervalSet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__WellboreIntervalSet (-1535)

#endif

/* _resqml22__SubRepresentation has binding name '_resqml22__SubRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SubRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SubRepresentation (-1534)

#endif

/* _resqml22__RepresentationSetRepresentation has binding name '_resqml22__RepresentationSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationSetRepresentation (-1533)

#endif

/* _resqml22__RepresentationIdentitySet has binding name '_resqml22__RepresentationIdentitySet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RepresentationIdentitySet (-1532)

#endif

/* _resqml22__StructuralOrganizationInterpretation has binding name '_resqml22__StructuralOrganizationInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StructuralOrganizationInterpretation (-1531)

#endif

/* _resqml22__StratigraphicUnitInterpretation has binding name '_resqml22__StratigraphicUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicUnitInterpretation (-1530)

#endif

/* _resqml22__StratigraphicColumnRankInterpretation has binding name '_resqml22__StratigraphicColumnRankInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumnRankInterpretation (-1529)

#endif

/* _resqml22__StratigraphicColumn has binding name '_resqml22__StratigraphicColumn' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumn
#define SOAP_TYPE_gsoap_eml2_3__resqml22__StratigraphicColumn (-1528)

#endif

/* _resqml22__RockFluidUnitInterpretation has binding name '_resqml22__RockFluidUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidUnitInterpretation (-1527)

#endif

/* _resqml22__RockFluidOrganizationInterpretation has binding name '_resqml22__RockFluidOrganizationInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockFluidOrganizationInterpretation (-1526)

#endif

/* _resqml22__HorizonInterpretation has binding name '_resqml22__HorizonInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__HorizonInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__HorizonInterpretation (-1525)

#endif

/* _resqml22__GeologicUnitOccurrenceInterpretation has binding name '_resqml22__GeologicUnitOccurrenceInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitOccurrenceInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitOccurrenceInterpretation (-1524)

#endif

/* _resqml22__GeologicUnitInterpretation has binding name '_resqml22__GeologicUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeologicUnitInterpretation (-1523)

#endif

/* _resqml22__GeobodyInterpretation has binding name '_resqml22__GeobodyInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyInterpretation (-1522)

#endif

/* _resqml22__GeobodyBoundaryInterpretation has binding name '_resqml22__GeobodyBoundaryInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GeobodyBoundaryInterpretation (-1521)

#endif

/* _resqml22__GenericFeatureInterpretation has binding name '_resqml22__GenericFeatureInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__GenericFeatureInterpretation (-1520)

#endif

/* _resqml22__FluidBoundaryInterpretation has binding name '_resqml22__FluidBoundaryInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__FluidBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__FluidBoundaryInterpretation (-1519)

#endif

/* _resqml22__FaultInterpretation has binding name '_resqml22__FaultInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__FaultInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__FaultInterpretation (-1518)

#endif

/* _resqml22__EarthModelInterpretation has binding name '_resqml22__EarthModelInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__EarthModelInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__EarthModelInterpretation (-1517)

#endif

/* _resqml22__BoundaryFeatureInterpretation has binding name '_resqml22__BoundaryFeatureInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeatureInterpretation (-1516)

#endif

/* _resqml22__TriangulatedSetRepresentation has binding name '_resqml22__TriangulatedSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__TriangulatedSetRepresentation (-1515)

#endif

/* _resqml22__SealedVolumeFrameworkRepresentation has binding name '_resqml22__SealedVolumeFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SealedVolumeFrameworkRepresentation (-1514)

#endif

/* _resqml22__SealedSurfaceFrameworkRepresentation has binding name '_resqml22__SealedSurfaceFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SealedSurfaceFrameworkRepresentation (-1513)

#endif

/* _resqml22__PolylineSetRepresentation has binding name '_resqml22__PolylineSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineSetRepresentation (-1512)

#endif

/* _resqml22__PolylineRepresentation has binding name '_resqml22__PolylineRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PolylineRepresentation (-1511)

#endif

/* _resqml22__PointSetRepresentation has binding name '_resqml22__PointSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PointSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PointSetRepresentation (-1510)

#endif

/* _resqml22__PlaneSetRepresentation has binding name '_resqml22__PlaneSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__PlaneSetRepresentation (-1509)

#endif

/* _resqml22__NonSealedSurfaceFrameworkRepresentation has binding name '_resqml22__NonSealedSurfaceFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__NonSealedSurfaceFrameworkRepresentation (-1508)

#endif

/* _resqml22__ShotPointLineFeature has binding name '_resqml22__ShotPointLineFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__ShotPointLineFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__ShotPointLineFeature (-1507)

#endif

/* _resqml22__SeismicLineSetFeature has binding name '_resqml22__SeismicLineSetFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLineSetFeature (-1506)

#endif

/* _resqml22__SeismicLatticeFeature has binding name '_resqml22__SeismicLatticeFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__SeismicLatticeFeature (-1505)

#endif

/* _resqml22__Seismic3dPostStackRepresentation has binding name '_resqml22__Seismic3dPostStackRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic3dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic3dPostStackRepresentation (-1504)

#endif

/* _resqml22__Seismic2dPostStackRepresentation has binding name '_resqml22__Seismic2dPostStackRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic2dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Seismic2dPostStackRepresentation (-1503)

#endif

/* _resqml22__CmpLineFeature has binding name '_resqml22__CmpLineFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CmpLineFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CmpLineFeature (-1502)

#endif

/* _resqml22__RockVolumeFeature has binding name '_resqml22__RockVolumeFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__RockVolumeFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__RockVolumeFeature (-1501)

#endif

/* _resqml22__Model has binding name '_resqml22__Model' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__Model
#define SOAP_TYPE_gsoap_eml2_3__resqml22__Model (-1500)

#endif

/* _resqml22__CulturalFeature has binding name '_resqml22__CulturalFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__CulturalFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__CulturalFeature (-1499)

#endif

/* _resqml22__BoundaryFeature has binding name '_resqml22__BoundaryFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeature
#define SOAP_TYPE_gsoap_eml2_3__resqml22__BoundaryFeature (-1498)

#endif

/* eml23__SectionNumber has binding name 'eml23__SectionNumber' for type 'eml23:SectionNumber' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SectionNumber
#define SOAP_TYPE_gsoap_eml2_3_eml23__SectionNumber (-1157)

#endif

/* eml23__PublicLandSurveySystemQuarterTownship has binding name 'eml23__PublicLandSurveySystemQuarterTownship' for type 'eml23:PublicLandSurveySystemQuarterTownship' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterTownship (-1156)

#endif

/* eml23__PublicLandSurveySystemQuarterSection has binding name 'eml23__PublicLandSurveySystemQuarterSection' for type 'eml23:PublicLandSurveySystemQuarterSection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemQuarterSection (-1155)

#endif

/* eml23__TypeEnum has binding name 'eml23__TypeEnum' for type 'eml23:TypeEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TypeEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__TypeEnum (-964)

#endif

/* eml23__TimeZone has binding name 'eml23__TimeZone' for type 'eml23:TimeZone' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeZone
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeZone (-963)

#endif

/* eml23__UuidString has binding name 'eml23__UuidString' for type 'eml23:UuidString' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UuidString
#define SOAP_TYPE_gsoap_eml2_3_eml23__UuidString (-960)

#endif

/* eml23__UomEnum has binding name 'eml23__UomEnum' for type 'eml23:UomEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UomEnum
#define SOAP_TYPE_gsoap_eml2_3_eml23__UomEnum (-959)

#endif

/* eml23__String64 has binding name 'eml23__String64' for type 'eml23:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String64
#define SOAP_TYPE_gsoap_eml2_3_eml23__String64 (-958)

#endif

/* eml23__String256 has binding name 'eml23__String256' for type 'eml23:String256' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String256
#define SOAP_TYPE_gsoap_eml2_3_eml23__String256 (-957)

#endif

/* eml23__String2000 has binding name 'eml23__String2000' for type 'eml23:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__String2000
#define SOAP_TYPE_gsoap_eml2_3_eml23__String2000 (-956)

#endif

/* eml23__EnumExtensionPattern has binding name 'eml23__EnumExtensionPattern' for type 'eml23:EnumExtensionPattern' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnumExtensionPattern (-955)

#endif

/* eml23__AbstractString has binding name 'eml23__AbstractString' for type 'eml23:AbstractString' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractString
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractString (-946)

#endif

/* resqml22__DepositionalEnvironmentKind has binding name 'resqml22__DepositionalEnvironmentKind' for type 'resqml22:DepositionalEnvironmentKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKind
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKind (-940)

#endif

/* eml23__CollectionKindExt has binding name 'eml23__CollectionKindExt' for type 'eml23:CollectionKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionKindExt (-939)

#endif

/* eml23__FacetExt has binding name 'eml23__FacetExt' for type 'eml23:FacetExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FacetExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FacetExt (-938)

#endif

/* eml23__VolumeUomExt has binding name 'eml23__VolumeUomExt' for type 'eml23:VolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomExt (-937)

#endif

/* eml23__VolumetricThermalExpansionUomExt has binding name 'eml23__VolumetricThermalExpansionUomExt' for type 'eml23:VolumetricThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionUomExt (-936)

#endif

/* eml23__VolumetricHeatTransferCoefficientUomExt has binding name 'eml23__VolumetricHeatTransferCoefficientUomExt' for type 'eml23:VolumetricHeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientUomExt (-935)

#endif

/* eml23__VolumePerVolumeUomExt has binding name 'eml23__VolumePerVolumeUomExt' for type 'eml23:VolumePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomExt (-934)

#endif

/* eml23__VolumePerTimeUomExt has binding name 'eml23__VolumePerTimeUomExt' for type 'eml23:VolumePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomExt (-933)

#endif

/* eml23__VolumePerTimePerVolumeUomExt has binding name 'eml23__VolumePerTimePerVolumeUomExt' for type 'eml23:VolumePerTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeUomExt (-932)

#endif

/* eml23__VolumePerTimePerTimeUomExt has binding name 'eml23__VolumePerTimePerTimeUomExt' for type 'eml23:VolumePerTimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeUomExt (-931)

#endif

/* eml23__VolumePerTimePerPressureUomExt has binding name 'eml23__VolumePerTimePerPressureUomExt' for type 'eml23:VolumePerTimePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureUomExt (-930)

#endif

/* eml23__VolumePerTimePerPressureLengthUomExt has binding name 'eml23__VolumePerTimePerPressureLengthUomExt' for type 'eml23:VolumePerTimePerPressureLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthUomExt (-929)

#endif

/* eml23__VolumePerTimePerLengthUomExt has binding name 'eml23__VolumePerTimePerLengthUomExt' for type 'eml23:VolumePerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthUomExt (-928)

#endif

/* eml23__VolumePerTimePerAreaUomExt has binding name 'eml23__VolumePerTimePerAreaUomExt' for type 'eml23:VolumePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaUomExt (-927)

#endif

/* eml23__VolumePerTimeLengthUomExt has binding name 'eml23__VolumePerTimeLengthUomExt' for type 'eml23:VolumePerTimeLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthUomExt (-926)

#endif

/* eml23__VolumePerRotationUomExt has binding name 'eml23__VolumePerRotationUomExt' for type 'eml23:VolumePerRotationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationUomExt (-925)

#endif

/* eml23__VolumePerPressureUomExt has binding name 'eml23__VolumePerPressureUomExt' for type 'eml23:VolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureUomExt (-924)

#endif

/* eml23__VolumePerMassUomExt has binding name 'eml23__VolumePerMassUomExt' for type 'eml23:VolumePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassUomExt (-923)

#endif

/* eml23__VolumePerLengthUomExt has binding name 'eml23__VolumePerLengthUomExt' for type 'eml23:VolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthUomExt (-922)

#endif

/* eml23__VolumePerAreaUomExt has binding name 'eml23__VolumePerAreaUomExt' for type 'eml23:VolumePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomExt (-921)

#endif

/* eml23__VolumeFlowRatePerVolumeFlowRateUomExt has binding name 'eml23__VolumeFlowRatePerVolumeFlowRateUomExt' for type 'eml23:VolumeFlowRatePerVolumeFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateUomExt (-920)

#endif

/* eml23__VerticalCoordinateUomExt has binding name 'eml23__VerticalCoordinateUomExt' for type 'eml23:VerticalCoordinateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateUomExt (-919)

#endif

/* eml23__TimeUomExt has binding name 'eml23__TimeUomExt' for type 'eml23:TimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeUomExt (-918)

#endif

/* eml23__TimePerVolumeUomExt has binding name 'eml23__TimePerVolumeUomExt' for type 'eml23:TimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeUomExt (-917)

#endif

/* eml23__TimePerTimeUomExt has binding name 'eml23__TimePerTimeUomExt' for type 'eml23:TimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeUomExt (-916)

#endif

/* eml23__TimePerMassUomExt has binding name 'eml23__TimePerMassUomExt' for type 'eml23:TimePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassUomExt (-915)

#endif

/* eml23__TimePerLengthUomExt has binding name 'eml23__TimePerLengthUomExt' for type 'eml23:TimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthUomExt (-914)

#endif

/* eml23__ThermodynamicTemperatureUomExt has binding name 'eml23__ThermodynamicTemperatureUomExt' for type 'eml23:ThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureUomExt (-913)

#endif

/* eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt has binding name 'eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' for type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (-912)

#endif

/* eml23__ThermalResistanceUomExt has binding name 'eml23__ThermalResistanceUomExt' for type 'eml23:ThermalResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceUomExt (-911)

#endif

/* eml23__ThermalInsulanceUomExt has binding name 'eml23__ThermalInsulanceUomExt' for type 'eml23:ThermalInsulanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceUomExt (-910)

#endif

/* eml23__ThermalDiffusivityUomExt has binding name 'eml23__ThermalDiffusivityUomExt' for type 'eml23:ThermalDiffusivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityUomExt (-909)

#endif

/* eml23__ThermalConductivityUomExt has binding name 'eml23__ThermalConductivityUomExt' for type 'eml23:ThermalConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityUomExt (-908)

#endif

/* eml23__ThermalConductanceUomExt has binding name 'eml23__ThermalConductanceUomExt' for type 'eml23:ThermalConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceUomExt (-907)

#endif

/* eml23__TemperatureIntervalUomExt has binding name 'eml23__TemperatureIntervalUomExt' for type 'eml23:TemperatureIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalUomExt (-906)

#endif

/* eml23__TemperatureIntervalPerTimeUomExt has binding name 'eml23__TemperatureIntervalPerTimeUomExt' for type 'eml23:TemperatureIntervalPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeUomExt (-905)

#endif

/* eml23__TemperatureIntervalPerPressureUomExt has binding name 'eml23__TemperatureIntervalPerPressureUomExt' for type 'eml23:TemperatureIntervalPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureUomExt (-904)

#endif

/* eml23__TemperatureIntervalPerLengthUomExt has binding name 'eml23__TemperatureIntervalPerLengthUomExt' for type 'eml23:TemperatureIntervalPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthUomExt (-903)

#endif

/* eml23__SpecificHeatCapacityUomExt has binding name 'eml23__SpecificHeatCapacityUomExt' for type 'eml23:SpecificHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityUomExt (-902)

#endif

/* eml23__SolidAngleUomExt has binding name 'eml23__SolidAngleUomExt' for type 'eml23:SolidAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleUomExt (-901)

#endif

/* eml23__SignalingEventPerTimeUomExt has binding name 'eml23__SignalingEventPerTimeUomExt' for type 'eml23:SignalingEventPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeUomExt (-900)

#endif

/* eml23__SecondMomentOfAreaUomExt has binding name 'eml23__SecondMomentOfAreaUomExt' for type 'eml23:SecondMomentOfAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaUomExt (-899)

#endif

/* eml23__ReluctanceUomExt has binding name 'eml23__ReluctanceUomExt' for type 'eml23:ReluctanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceUomExt (-898)

#endif

/* eml23__ReciprocalVolumeUomExt has binding name 'eml23__ReciprocalVolumeUomExt' for type 'eml23:ReciprocalVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeUomExt (-897)

#endif

/* eml23__ReciprocalTimeUomExt has binding name 'eml23__ReciprocalTimeUomExt' for type 'eml23:ReciprocalTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeUomExt (-896)

#endif

/* eml23__ReciprocalPressureUomExt has binding name 'eml23__ReciprocalPressureUomExt' for type 'eml23:ReciprocalPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureUomExt (-895)

#endif

/* eml23__ReciprocalMassUomExt has binding name 'eml23__ReciprocalMassUomExt' for type 'eml23:ReciprocalMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassUomExt (-894)

#endif

/* eml23__ReciprocalMassTimeUomExt has binding name 'eml23__ReciprocalMassTimeUomExt' for type 'eml23:ReciprocalMassTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeUomExt (-893)

#endif

/* eml23__ReciprocalLengthUomExt has binding name 'eml23__ReciprocalLengthUomExt' for type 'eml23:ReciprocalLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthUomExt (-892)

#endif

/* eml23__ReciprocalForceUomExt has binding name 'eml23__ReciprocalForceUomExt' for type 'eml23:ReciprocalForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceUomExt (-891)

#endif

/* eml23__ReciprocalElectricPotentialDifferenceUomExt has binding name 'eml23__ReciprocalElectricPotentialDifferenceUomExt' for type 'eml23:ReciprocalElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceUomExt (-890)

#endif

/* eml23__ReciprocalAreaUomExt has binding name 'eml23__ReciprocalAreaUomExt' for type 'eml23:ReciprocalAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaUomExt (-889)

#endif

/* eml23__RadiantIntensityUomExt has binding name 'eml23__RadiantIntensityUomExt' for type 'eml23:RadiantIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityUomExt (-888)

#endif

/* eml23__RadianceUomExt has binding name 'eml23__RadianceUomExt' for type 'eml23:RadianceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceUomExt (-887)

#endif

/* eml23__QuantityOfLightUomExt has binding name 'eml23__QuantityOfLightUomExt' for type 'eml23:QuantityOfLightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightUomExt (-886)

#endif

/* eml23__PressureUomExt has binding name 'eml23__PressureUomExt' for type 'eml23:PressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomExt (-885)

#endif

/* eml23__PressureTimePerVolumeUomExt has binding name 'eml23__PressureTimePerVolumeUomExt' for type 'eml23:PressureTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeUomExt (-884)

#endif

/* eml23__PressureSquaredUomExt has binding name 'eml23__PressureSquaredUomExt' for type 'eml23:PressureSquaredUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredUomExt (-883)

#endif

/* eml23__PressureSquaredPerForceTimePerAreaUomExt has binding name 'eml23__PressureSquaredPerForceTimePerAreaUomExt' for type 'eml23:PressureSquaredPerForceTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaUomExt (-882)

#endif

/* eml23__PressurePerVolumeUomExt has binding name 'eml23__PressurePerVolumeUomExt' for type 'eml23:PressurePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomExt (-881)

#endif

/* eml23__PressurePerTimeUomExt has binding name 'eml23__PressurePerTimeUomExt' for type 'eml23:PressurePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeUomExt (-880)

#endif

/* eml23__PressurePerPressureUomExt has binding name 'eml23__PressurePerPressureUomExt' for type 'eml23:PressurePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureUomExt (-879)

#endif

/* eml23__PowerUomExt has binding name 'eml23__PowerUomExt' for type 'eml23:PowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerUomExt (-878)

#endif

/* eml23__PowerPerVolumeUomExt has binding name 'eml23__PowerPerVolumeUomExt' for type 'eml23:PowerPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeUomExt (-877)

#endif

/* eml23__PowerPerPowerUomExt has binding name 'eml23__PowerPerPowerUomExt' for type 'eml23:PowerPerPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerUomExt (-876)

#endif

/* eml23__PowerPerAreaUomExt has binding name 'eml23__PowerPerAreaUomExt' for type 'eml23:PowerPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaUomExt (-875)

#endif

/* eml23__PotentialDifferencePerPowerDropUomExt has binding name 'eml23__PotentialDifferencePerPowerDropUomExt' for type 'eml23:PotentialDifferencePerPowerDropUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropUomExt (-874)

#endif

/* eml23__PlaneAngleUomExt has binding name 'eml23__PlaneAngleUomExt' for type 'eml23:PlaneAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleUomExt (-873)

#endif

/* eml23__PermittivityUomExt has binding name 'eml23__PermittivityUomExt' for type 'eml23:PermittivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityUomExt (-872)

#endif

/* eml23__PermeabilityRockUomExt has binding name 'eml23__PermeabilityRockUomExt' for type 'eml23:PermeabilityRockUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockUomExt (-871)

#endif

/* eml23__PermeabilityLengthUomExt has binding name 'eml23__PermeabilityLengthUomExt' for type 'eml23:PermeabilityLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthUomExt (-870)

#endif

/* eml23__NormalizedPowerUomExt has binding name 'eml23__NormalizedPowerUomExt' for type 'eml23:NormalizedPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerUomExt (-869)

#endif

/* eml23__MomentumUomExt has binding name 'eml23__MomentumUomExt' for type 'eml23:MomentumUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumUomExt (-868)

#endif

/* eml23__MomentOfInertiaUomExt has binding name 'eml23__MomentOfInertiaUomExt' for type 'eml23:MomentOfInertiaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaUomExt (-867)

#endif

/* eml23__MomentOfForceUomExt has binding name 'eml23__MomentOfForceUomExt' for type 'eml23:MomentOfForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceUomExt (-866)

#endif

/* eml23__MolecularWeightUomExt has binding name 'eml23__MolecularWeightUomExt' for type 'eml23:MolecularWeightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightUomExt (-865)

#endif

/* eml23__MolarVolumeUomExt has binding name 'eml23__MolarVolumeUomExt' for type 'eml23:MolarVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeUomExt (-864)

#endif

/* eml23__MolarHeatCapacityUomExt has binding name 'eml23__MolarHeatCapacityUomExt' for type 'eml23:MolarHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityUomExt (-863)

#endif

/* eml23__MolarEnergyUomExt has binding name 'eml23__MolarEnergyUomExt' for type 'eml23:MolarEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyUomExt (-862)

#endif

/* eml23__MobilityUomExt has binding name 'eml23__MobilityUomExt' for type 'eml23:MobilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityUomExt (-861)

#endif

/* eml23__MassUomExt has binding name 'eml23__MassUomExt' for type 'eml23:MassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassUomExt (-860)

#endif

/* eml23__MassPerVolumeUomExt has binding name 'eml23__MassPerVolumeUomExt' for type 'eml23:MassPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomExt (-859)

#endif

/* eml23__MassPerVolumePerTemperatureUomExt has binding name 'eml23__MassPerVolumePerTemperatureUomExt' for type 'eml23:MassPerVolumePerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureUomExt (-858)

#endif

/* eml23__MassPerVolumePerPressureUomExt has binding name 'eml23__MassPerVolumePerPressureUomExt' for type 'eml23:MassPerVolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureUomExt (-857)

#endif

/* eml23__MassPerVolumePerLengthUomExt has binding name 'eml23__MassPerVolumePerLengthUomExt' for type 'eml23:MassPerVolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthUomExt (-856)

#endif

/* eml23__MassPerTimeUomExt has binding name 'eml23__MassPerTimeUomExt' for type 'eml23:MassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeUomExt (-855)

#endif

/* eml23__MassPerTimePerLengthUomExt has binding name 'eml23__MassPerTimePerLengthUomExt' for type 'eml23:MassPerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthUomExt (-854)

#endif

/* eml23__MassPerTimePerAreaUomExt has binding name 'eml23__MassPerTimePerAreaUomExt' for type 'eml23:MassPerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaUomExt (-853)

#endif

/* eml23__MassPerMassUomExt has binding name 'eml23__MassPerMassUomExt' for type 'eml23:MassPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassUomExt (-852)

#endif

/* eml23__MassPerLengthUomExt has binding name 'eml23__MassPerLengthUomExt' for type 'eml23:MassPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthUomExt (-851)

#endif

/* eml23__MassPerEnergyUomExt has binding name 'eml23__MassPerEnergyUomExt' for type 'eml23:MassPerEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyUomExt (-850)

#endif

/* eml23__MassPerAreaUomExt has binding name 'eml23__MassPerAreaUomExt' for type 'eml23:MassPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaUomExt (-849)

#endif

/* eml23__MassLengthUomExt has binding name 'eml23__MassLengthUomExt' for type 'eml23:MassLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthUomExt (-848)

#endif

/* eml23__MagneticVectorPotentialUomExt has binding name 'eml23__MagneticVectorPotentialUomExt' for type 'eml23:MagneticVectorPotentialUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialUomExt (-847)

#endif

/* eml23__MagneticPermeabilityUomExt has binding name 'eml23__MagneticPermeabilityUomExt' for type 'eml23:MagneticPermeabilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityUomExt (-846)

#endif

/* eml23__MagneticFluxUomExt has binding name 'eml23__MagneticFluxUomExt' for type 'eml23:MagneticFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxUomExt (-845)

#endif

/* eml23__MagneticFluxDensityUomExt has binding name 'eml23__MagneticFluxDensityUomExt' for type 'eml23:MagneticFluxDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityUomExt (-844)

#endif

/* eml23__MagneticFluxDensityPerLengthUomExt has binding name 'eml23__MagneticFluxDensityPerLengthUomExt' for type 'eml23:MagneticFluxDensityPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthUomExt (-843)

#endif

/* eml23__MagneticFieldStrengthUomExt has binding name 'eml23__MagneticFieldStrengthUomExt' for type 'eml23:MagneticFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthUomExt (-842)

#endif

/* eml23__MagneticDipoleMomentUomExt has binding name 'eml23__MagneticDipoleMomentUomExt' for type 'eml23:MagneticDipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentUomExt (-841)

#endif

/* eml23__LuminousIntensityUomExt has binding name 'eml23__LuminousIntensityUomExt' for type 'eml23:LuminousIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityUomExt (-840)

#endif

/* eml23__LuminousFluxUomExt has binding name 'eml23__LuminousFluxUomExt' for type 'eml23:LuminousFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxUomExt (-839)

#endif

/* eml23__LuminousEfficacyUomExt has binding name 'eml23__LuminousEfficacyUomExt' for type 'eml23:LuminousEfficacyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyUomExt (-838)

#endif

/* eml23__LuminanceUomExt has binding name 'eml23__LuminanceUomExt' for type 'eml23:LuminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceUomExt (-837)

#endif

/* eml23__LogarithmicPowerRatioUomExt has binding name 'eml23__LogarithmicPowerRatioUomExt' for type 'eml23:LogarithmicPowerRatioUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioUomExt (-836)

#endif

/* eml23__LogarithmicPowerRatioPerLengthUomExt has binding name 'eml23__LogarithmicPowerRatioPerLengthUomExt' for type 'eml23:LogarithmicPowerRatioPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthUomExt (-835)

#endif

/* eml23__LinearThermalExpansionUomExt has binding name 'eml23__LinearThermalExpansionUomExt' for type 'eml23:LinearThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionUomExt (-834)

#endif

/* eml23__LinearAccelerationUomExt has binding name 'eml23__LinearAccelerationUomExt' for type 'eml23:LinearAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationUomExt (-833)

#endif

/* eml23__LightExposureUomExt has binding name 'eml23__LightExposureUomExt' for type 'eml23:LightExposureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureUomExt (-832)

#endif

/* eml23__LengthUomExt has binding name 'eml23__LengthUomExt' for type 'eml23:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthUomExt (-831)

#endif

/* eml23__LengthPerVolumeUomExt has binding name 'eml23__LengthPerVolumeUomExt' for type 'eml23:LengthPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeUomExt (-830)

#endif

/* eml23__LengthPerTimeUomExt has binding name 'eml23__LengthPerTimeUomExt' for type 'eml23:LengthPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeUomExt (-829)

#endif

/* eml23__LengthPerTemperatureUomExt has binding name 'eml23__LengthPerTemperatureUomExt' for type 'eml23:LengthPerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureUomExt (-828)

#endif

/* eml23__LengthPerPressureUomExt has binding name 'eml23__LengthPerPressureUomExt' for type 'eml23:LengthPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureUomExt (-827)

#endif

/* eml23__LengthPerMassUomExt has binding name 'eml23__LengthPerMassUomExt' for type 'eml23:LengthPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassUomExt (-826)

#endif

/* eml23__LengthPerLengthUomExt has binding name 'eml23__LengthPerLengthUomExt' for type 'eml23:LengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthUomExt (-825)

#endif

/* eml23__LengthAndTimeUomExt has binding name 'eml23__LengthAndTimeUomExt' for type 'eml23:LengthAndTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthAndTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthAndTimeUomExt (-824)

#endif

/* eml23__KinematicViscosityUomExt has binding name 'eml23__KinematicViscosityUomExt' for type 'eml23:KinematicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityUomExt (-823)

#endif

/* eml23__IsothermalCompressibilityUomExt has binding name 'eml23__IsothermalCompressibilityUomExt' for type 'eml23:IsothermalCompressibilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityUomExt (-822)

#endif

/* eml23__InductanceUomExt has binding name 'eml23__InductanceUomExt' for type 'eml23:InductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceUomExt (-821)

#endif

/* eml23__IlluminanceUomExt has binding name 'eml23__IlluminanceUomExt' for type 'eml23:IlluminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceUomExt (-820)

#endif

/* eml23__HeatTransferCoefficientUomExt has binding name 'eml23__HeatTransferCoefficientUomExt' for type 'eml23:HeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientUomExt (-819)

#endif

/* eml23__HeatFlowRateUomExt has binding name 'eml23__HeatFlowRateUomExt' for type 'eml23:HeatFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateUomExt (-818)

#endif

/* eml23__HeatCapacityUomExt has binding name 'eml23__HeatCapacityUomExt' for type 'eml23:HeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityUomExt (-817)

#endif

/* eml23__FrequencyUomExt has binding name 'eml23__FrequencyUomExt' for type 'eml23:FrequencyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyUomExt (-816)

#endif

/* eml23__FrequencyIntervalUomExt has binding name 'eml23__FrequencyIntervalUomExt' for type 'eml23:FrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalUomExt (-815)

#endif

/* eml23__ForceUomExt has binding name 'eml23__ForceUomExt' for type 'eml23:ForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceUomExt (-814)

#endif

/* eml23__ForcePerVolumeUomExt has binding name 'eml23__ForcePerVolumeUomExt' for type 'eml23:ForcePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeUomExt (-813)

#endif

/* eml23__ForcePerLengthUomExt has binding name 'eml23__ForcePerLengthUomExt' for type 'eml23:ForcePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthUomExt (-812)

#endif

/* eml23__ForcePerForceUomExt has binding name 'eml23__ForcePerForceUomExt' for type 'eml23:ForcePerForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceUomExt (-811)

#endif

/* eml23__ForceLengthPerLengthUomExt has binding name 'eml23__ForceLengthPerLengthUomExt' for type 'eml23:ForceLengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthUomExt (-810)

#endif

/* eml23__ForceAreaUomExt has binding name 'eml23__ForceAreaUomExt' for type 'eml23:ForceAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaUomExt (-809)

#endif

/* eml23__EnergyUomExt has binding name 'eml23__EnergyUomExt' for type 'eml23:EnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyUomExt (-808)

#endif

/* eml23__EnergyPerVolumeUomExt has binding name 'eml23__EnergyPerVolumeUomExt' for type 'eml23:EnergyPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeUomExt (-807)

#endif

/* eml23__EnergyPerMassUomExt has binding name 'eml23__EnergyPerMassUomExt' for type 'eml23:EnergyPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassUomExt (-806)

#endif

/* eml23__EnergyPerMassPerTimeUomExt has binding name 'eml23__EnergyPerMassPerTimeUomExt' for type 'eml23:EnergyPerMassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeUomExt (-805)

#endif

/* eml23__EnergyPerLengthUomExt has binding name 'eml23__EnergyPerLengthUomExt' for type 'eml23:EnergyPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthUomExt (-804)

#endif

/* eml23__EnergyPerAreaUomExt has binding name 'eml23__EnergyPerAreaUomExt' for type 'eml23:EnergyPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaUomExt (-803)

#endif

/* eml23__EnergyLengthPerTimeAreaTemperatureUomExt has binding name 'eml23__EnergyLengthPerTimeAreaTemperatureUomExt' for type 'eml23:EnergyLengthPerTimeAreaTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureUomExt (-802)

#endif

/* eml23__EnergyLengthPerAreaUomExt has binding name 'eml23__EnergyLengthPerAreaUomExt' for type 'eml23:EnergyLengthPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaUomExt (-801)

#endif

/* eml23__ElectromagneticMomentUomExt has binding name 'eml23__ElectromagneticMomentUomExt' for type 'eml23:ElectromagneticMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentUomExt (-800)

#endif

/* eml23__ElectricResistanceUomExt has binding name 'eml23__ElectricResistanceUomExt' for type 'eml23:ElectricResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceUomExt (-799)

#endif

/* eml23__ElectricResistancePerLengthUomExt has binding name 'eml23__ElectricResistancePerLengthUomExt' for type 'eml23:ElectricResistancePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthUomExt (-798)

#endif

/* eml23__ElectricPotentialDifferenceUomExt has binding name 'eml23__ElectricPotentialDifferenceUomExt' for type 'eml23:ElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceUomExt (-797)

#endif

/* eml23__ElectricFieldStrengthUomExt has binding name 'eml23__ElectricFieldStrengthUomExt' for type 'eml23:ElectricFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthUomExt (-796)

#endif

/* eml23__ElectricCurrentUomExt has binding name 'eml23__ElectricCurrentUomExt' for type 'eml23:ElectricCurrentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentUomExt (-795)

#endif

/* eml23__ElectricCurrentDensityUomExt has binding name 'eml23__ElectricCurrentDensityUomExt' for type 'eml23:ElectricCurrentDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityUomExt (-794)

#endif

/* eml23__ElectricConductivityUomExt has binding name 'eml23__ElectricConductivityUomExt' for type 'eml23:ElectricConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityUomExt (-793)

#endif

/* eml23__ElectricConductanceUomExt has binding name 'eml23__ElectricConductanceUomExt' for type 'eml23:ElectricConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceUomExt (-792)

#endif

/* eml23__ElectricChargeUomExt has binding name 'eml23__ElectricChargeUomExt' for type 'eml23:ElectricChargeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeUomExt (-791)

#endif

/* eml23__ElectricChargePerVolumeUomExt has binding name 'eml23__ElectricChargePerVolumeUomExt' for type 'eml23:ElectricChargePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeUomExt (-790)

#endif

/* eml23__ElectricChargePerMassUomExt has binding name 'eml23__ElectricChargePerMassUomExt' for type 'eml23:ElectricChargePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassUomExt (-789)

#endif

/* eml23__ElectricChargePerAreaUomExt has binding name 'eml23__ElectricChargePerAreaUomExt' for type 'eml23:ElectricChargePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaUomExt (-788)

#endif

/* eml23__ElectricalResistivityUomExt has binding name 'eml23__ElectricalResistivityUomExt' for type 'eml23:ElectricalResistivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityUomExt (-787)

#endif

/* eml23__DynamicViscosityUomExt has binding name 'eml23__DynamicViscosityUomExt' for type 'eml23:DynamicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityUomExt (-786)

#endif

/* eml23__DoseEquivalentUomExt has binding name 'eml23__DoseEquivalentUomExt' for type 'eml23:DoseEquivalentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentUomExt (-785)

#endif

/* eml23__DipoleMomentUomExt has binding name 'eml23__DipoleMomentUomExt' for type 'eml23:DipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentUomExt (-784)

#endif

/* eml23__DimensionlessUomExt has binding name 'eml23__DimensionlessUomExt' for type 'eml23:DimensionlessUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessUomExt (-783)

#endif

/* eml23__DigitalStorageUomExt has binding name 'eml23__DigitalStorageUomExt' for type 'eml23:DigitalStorageUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageUomExt (-782)

#endif

/* eml23__DiffusiveTimeOfFlightUomExt has binding name 'eml23__DiffusiveTimeOfFlightUomExt' for type 'eml23:DiffusiveTimeOfFlightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightUomExt (-781)

#endif

/* eml23__DiffusionCoefficientUomExt has binding name 'eml23__DiffusionCoefficientUomExt' for type 'eml23:DiffusionCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientUomExt (-780)

#endif

/* eml23__DataTransferSpeedUomExt has binding name 'eml23__DataTransferSpeedUomExt' for type 'eml23:DataTransferSpeedUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedUomExt (-779)

#endif

/* eml23__CationExchangeCapacityUomExt has binding name 'eml23__CationExchangeCapacityUomExt' for type 'eml23:CationExchangeCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityUomExt (-778)

#endif

/* eml23__CapacitanceUomExt has binding name 'eml23__CapacitanceUomExt' for type 'eml23:CapacitanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceUomExt (-777)

#endif

/* eml23__AttenuationPerFrequencyIntervalUomExt has binding name 'eml23__AttenuationPerFrequencyIntervalUomExt' for type 'eml23:AttenuationPerFrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalUomExt (-776)

#endif

/* eml23__AreaUomExt has binding name 'eml23__AreaUomExt' for type 'eml23:AreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaUomExt (-775)

#endif

/* eml23__AreaPerVolumeUomExt has binding name 'eml23__AreaPerVolumeUomExt' for type 'eml23:AreaPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeUomExt (-774)

#endif

/* eml23__AreaPerTimeUomExt has binding name 'eml23__AreaPerTimeUomExt' for type 'eml23:AreaPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeUomExt (-773)

#endif

/* eml23__AreaPerMassUomExt has binding name 'eml23__AreaPerMassUomExt' for type 'eml23:AreaPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassUomExt (-772)

#endif

/* eml23__AreaPerCountUomExt has binding name 'eml23__AreaPerCountUomExt' for type 'eml23:AreaPerCountUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountUomExt (-771)

#endif

/* eml23__AreaPerAreaUomExt has binding name 'eml23__AreaPerAreaUomExt' for type 'eml23:AreaPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaUomExt (-770)

#endif

/* eml23__AreaPerAmountOfSubstanceUomExt has binding name 'eml23__AreaPerAmountOfSubstanceUomExt' for type 'eml23:AreaPerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceUomExt (-769)

#endif

/* eml23__APINeutronUomExt has binding name 'eml23__APINeutronUomExt' for type 'eml23:APINeutronUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronUomExt (-768)

#endif

/* eml23__APIGravityUomExt has binding name 'eml23__APIGravityUomExt' for type 'eml23:APIGravityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityUomExt (-767)

#endif

/* eml23__APIGammaRayUomExt has binding name 'eml23__APIGammaRayUomExt' for type 'eml23:APIGammaRayUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayUomExt (-766)

#endif

/* eml23__AngularVelocityUomExt has binding name 'eml23__AngularVelocityUomExt' for type 'eml23:AngularVelocityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityUomExt (-765)

#endif

/* eml23__AngularAccelerationUomExt has binding name 'eml23__AngularAccelerationUomExt' for type 'eml23:AngularAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationUomExt (-764)

#endif

/* eml23__AnglePerVolumeUomExt has binding name 'eml23__AnglePerVolumeUomExt' for type 'eml23:AnglePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeUomExt (-763)

#endif

/* eml23__AnglePerLengthUomExt has binding name 'eml23__AnglePerLengthUomExt' for type 'eml23:AnglePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthUomExt (-762)

#endif

/* eml23__AmountOfSubstanceUomExt has binding name 'eml23__AmountOfSubstanceUomExt' for type 'eml23:AmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceUomExt (-761)

#endif

/* eml23__AmountOfSubstancePerVolumeUomExt has binding name 'eml23__AmountOfSubstancePerVolumeUomExt' for type 'eml23:AmountOfSubstancePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeUomExt (-760)

#endif

/* eml23__AmountOfSubstancePerTimeUomExt has binding name 'eml23__AmountOfSubstancePerTimeUomExt' for type 'eml23:AmountOfSubstancePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeUomExt (-759)

#endif

/* eml23__AmountOfSubstancePerTimePerAreaUomExt has binding name 'eml23__AmountOfSubstancePerTimePerAreaUomExt' for type 'eml23:AmountOfSubstancePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaUomExt (-758)

#endif

/* eml23__AmountOfSubstancePerAreaUomExt has binding name 'eml23__AmountOfSubstancePerAreaUomExt' for type 'eml23:AmountOfSubstancePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaUomExt (-757)

#endif

/* eml23__AmountOfSubstancePerAmountOfSubstanceUomExt has binding name 'eml23__AmountOfSubstancePerAmountOfSubstanceUomExt' for type 'eml23:AmountOfSubstancePerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceUomExt (-756)

#endif

/* eml23__ActivityOfRadioactivityUomExt has binding name 'eml23__ActivityOfRadioactivityUomExt' for type 'eml23:ActivityOfRadioactivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityUomExt (-755)

#endif

/* eml23__AbsorbedDoseUomExt has binding name 'eml23__AbsorbedDoseUomExt' for type 'eml23:AbsorbedDoseUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseUomExt (-754)

#endif

/* eml23__VolumeUomWithLegacy has binding name 'eml23__VolumeUomWithLegacy' for type 'eml23:VolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeUomWithLegacy (-753)

#endif

/* eml23__VolumePerVolumeUomWithLegacy has binding name 'eml23__VolumePerVolumeUomWithLegacy' for type 'eml23:VolumePerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeUomWithLegacy (-752)

#endif

/* eml23__VolumePerTimeUomWithLegacy has binding name 'eml23__VolumePerTimeUomWithLegacy' for type 'eml23:VolumePerTimeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeUomWithLegacy (-751)

#endif

/* eml23__VolumePerAreaUomWithLegacy has binding name 'eml23__VolumePerAreaUomWithLegacy' for type 'eml23:VolumePerAreaUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaUomWithLegacy (-750)

#endif

/* eml23__PressureUomWithLegacy has binding name 'eml23__PressureUomWithLegacy' for type 'eml23:PressureUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureUomWithLegacy (-749)

#endif

/* eml23__PressurePerVolumeUomWithLegacy has binding name 'eml23__PressurePerVolumeUomWithLegacy' for type 'eml23:PressurePerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeUomWithLegacy (-748)

#endif

/* eml23__MassPerVolumeUomWithLegacy has binding name 'eml23__MassPerVolumeUomWithLegacy' for type 'eml23:MassPerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeUomWithLegacy (-747)

#endif

/* eml23__WellboreDatumReferenceExt has binding name 'eml23__WellboreDatumReferenceExt' for type 'eml23:WellboreDatumReferenceExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReferenceExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__WellboreDatumReferenceExt (-746)

#endif

/* eml23__ReferencePointKindExt has binding name 'eml23__ReferencePointKindExt' for type 'eml23:ReferencePointKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointKindExt (-745)

#endif

/* eml23__IntegerXmlArray has binding name 'eml23__IntegerXmlArray' for type 'eml23:IntegerXmlArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerXmlArray (-744)

#endif

/* eml23__FloatingPointXmlArrayList has binding name 'eml23__FloatingPointXmlArrayList' for type 'eml23:FloatingPointXmlArrayList' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArrayList
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArrayList (-743)

#endif

/* eml23__BooleanXmlArray has binding name 'eml23__BooleanXmlArray' for type 'eml23:BooleanXmlArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanXmlArray (-742)

#endif

/* eml23__UnitOfMeasureExt has binding name 'eml23__UnitOfMeasureExt' for type 'eml23:UnitOfMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitOfMeasureExt (-741)

#endif

/* eml23__ReferenceConditionExt has binding name 'eml23__ReferenceConditionExt' for type 'eml23:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceConditionExt (-740)

#endif

/* eml23__QuantityClassKindExt has binding name 'eml23__QuantityClassKindExt' for type 'eml23:QuantityClassKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityClassKindExt (-739)

#endif

/* eml23__MatrixCementKindExt has binding name 'eml23__MatrixCementKindExt' for type 'eml23:MatrixCementKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MatrixCementKindExt (-738)

#endif

/* eml23__LithologyQualifierKindExt has binding name 'eml23__LithologyQualifierKindExt' for type 'eml23:LithologyQualifierKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyQualifierKindExt (-737)

#endif

/* eml23__LithologyKindExt has binding name 'eml23__LithologyKindExt' for type 'eml23:LithologyKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LithologyKindExt (-736)

#endif

/* eml23__ExistenceKindExt has binding name 'eml23__ExistenceKindExt' for type 'eml23:ExistenceKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKindExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExistenceKindExt (-735)

#endif

/* resqml22__StreamlineFluxExt has binding name 'resqml22__StreamlineFluxExt' for type 'resqml22:StreamlineFluxExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFluxExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineFluxExt (-734)

#endif

/* resqml22__SequenceStratigraphySurfaceKindExt has binding name 'resqml22__SequenceStratigraphySurfaceKindExt' for type 'resqml22:SequenceStratigraphySurfaceKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SequenceStratigraphySurfaceKindExt (-733)

#endif

/* resqml22__ViewerKindExt has binding name 'resqml22__ViewerKindExt' for type 'resqml22:ViewerKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ViewerKindExt (-732)

#endif

/* resqml22__NodeSymbolExt has binding name 'resqml22__NodeSymbolExt' for type 'resqml22:NodeSymbolExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbolExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodeSymbolExt (-731)

#endif

/* resqml22__EdgePatternExt has binding name 'resqml22__EdgePatternExt' for type 'resqml22:EdgePatternExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatternExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatternExt (-730)

#endif

/* resqml22__ThrowKindExt has binding name 'resqml22__ThrowKindExt' for type 'resqml22:ThrowKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThrowKindExt (-729)

#endif

/* resqml22__Shape3dExt has binding name 'resqml22__Shape3dExt' for type 'resqml22:Shape3dExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3dExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Shape3dExt (-728)

#endif

/* resqml22__DepositionalFaciesKindExt has binding name 'resqml22__DepositionalFaciesKindExt' for type 'resqml22:DepositionalFaciesKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalFaciesKindExt (-727)

#endif

/* resqml22__DepositionalEnvironmentKindExt has binding name 'resqml22__DepositionalEnvironmentKindExt' for type 'resqml22:DepositionalEnvironmentKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DepositionalEnvironmentKindExt (-726)

#endif

/* resqml22__LineRoleExt has binding name 'resqml22__LineRoleExt' for type 'resqml22:LineRoleExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LineRoleExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LineRoleExt (-725)

#endif

/* resqml22__CulturalFeatureKindExt has binding name 'resqml22__CulturalFeatureKindExt' for type 'resqml22:CulturalFeatureKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKindExt
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeatureKindExt (-724)

#endif

/* eml23__VolumeValue has binding name 'eml23__VolumeValue' for type 'eml23:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeValue (-723)

#endif

/* eml23__TemperaturePressure has binding name 'eml23__TemperaturePressure' for type 'eml23:TemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperaturePressure (-722)

#endif

/* eml23__RelativePressure has binding name 'eml23__RelativePressure' for type 'eml23:RelativePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RelativePressure (-721)

#endif

/* eml23__ReferenceTemperaturePressure has binding name 'eml23__ReferenceTemperaturePressure' for type 'eml23:ReferenceTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferenceTemperaturePressure (-720)

#endif

/* eml23__ReferencePressure has binding name 'eml23__ReferencePressure' for type 'eml23:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePressure (-719)

#endif

/* eml23__PressureValue has binding name 'eml23__PressureValue' for type 'eml23:PressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureValue (-718)

#endif

/* eml23__GaugePressure has binding name 'eml23__GaugePressure' for type 'eml23:GaugePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__GaugePressure (-717)

#endif

/* eml23__FlowRateValue has binding name 'eml23__FlowRateValue' for type 'eml23:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__FlowRateValue (-716)

#endif

/* eml23__DensityValue has binding name 'eml23__DensityValue' for type 'eml23:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__DensityValue (-715)

#endif

/* eml23__AbstractTemperaturePressure has binding name 'eml23__AbstractTemperaturePressure' for type 'eml23:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTemperaturePressure (-714)

#endif

/* eml23__AbstractPressureValue has binding name 'eml23__AbstractPressureValue' for type 'eml23:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractPressureValue (-713)

#endif

/* eml23__AbsolutePressure has binding name 'eml23__AbsolutePressure' for type 'eml23:AbsolutePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsolutePressure (-712)

#endif

/* eml23__GraphicalInformationSet has binding name 'eml23__GraphicalInformationSet' for type 'eml23:GraphicalInformationSet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_3_eml23__GraphicalInformationSet (-711)

#endif

/* eml23__AbstractGraphicalInformation has binding name 'eml23__AbstractGraphicalInformation' for type 'eml23:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGraphicalInformation (-710)

#endif

/* eml23__IndexRange has binding name 'eml23__IndexRange' for type 'eml23:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange
#define SOAP_TYPE_gsoap_eml2_3_eml23__IndexRange (-709)

#endif

/* eml23__FailingRule has binding name 'eml23__FailingRule' for type 'eml23:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule
#define SOAP_TYPE_gsoap_eml2_3_eml23__FailingRule (-708)

#endif

/* eml23__DataAssuranceRecord has binding name 'eml23__DataAssuranceRecord' for type 'eml23:DataAssuranceRecord' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataAssuranceRecord (-707)

#endif

/* eml23__NestedColumnBasedTable has binding name 'eml23__NestedColumnBasedTable' for type 'eml23:NestedColumnBasedTable' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3_eml23__NestedColumnBasedTable (-706)

#endif

/* eml23__ColumnBasedTable has binding name 'eml23__ColumnBasedTable' for type 'eml23:ColumnBasedTable' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3_eml23__ColumnBasedTable (-705)

#endif

/* eml23__Column has binding name 'eml23__Column' for type 'eml23:Column' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Column
#define SOAP_TYPE_gsoap_eml2_3_eml23__Column (-704)

#endif

/* eml23__SingleCollectionAssociation has binding name 'eml23__SingleCollectionAssociation' for type 'eml23:SingleCollectionAssociation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation
#define SOAP_TYPE_gsoap_eml2_3_eml23__SingleCollectionAssociation (-703)

#endif

/* eml23__DataobjectCollection has binding name 'eml23__DataobjectCollection' for type 'eml23:DataobjectCollection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataobjectCollection (-702)

#endif

/* eml23__CollectionsToDataobjectsAssociationSet has binding name 'eml23__CollectionsToDataobjectsAssociationSet' for type 'eml23:CollectionsToDataobjectsAssociationSet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet
#define SOAP_TYPE_gsoap_eml2_3_eml23__CollectionsToDataobjectsAssociationSet (-701)

#endif

/* eml23__PhoneNumberStruct has binding name 'eml23__PhoneNumberStruct' for type 'eml23:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__PhoneNumberStruct (-700)

#endif

/* eml23__PersonName has binding name 'eml23__PersonName' for type 'eml23:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PersonName
#define SOAP_TYPE_gsoap_eml2_3_eml23__PersonName (-699)

#endif

/* eml23__NameStruct has binding name 'eml23__NameStruct' for type 'eml23:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__NameStruct (-698)

#endif

/* eml23__GeneralAddress has binding name 'eml23__GeneralAddress' for type 'eml23:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeneralAddress (-697)

#endif

/* eml23__EmailQualifierStruct has binding name 'eml23__EmailQualifierStruct' for type 'eml23:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_3_eml23__EmailQualifierStruct (-696)

#endif

/* eml23__BusinessAssociate has binding name 'eml23__BusinessAssociate' for type 'eml23:BusinessAssociate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_3_eml23__BusinessAssociate (-695)

#endif

/* eml23__Attachment has binding name 'eml23__Attachment' for type 'eml23:Attachment' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Attachment
#define SOAP_TYPE_gsoap_eml2_3_eml23__Attachment (-694)

#endif

/* eml23__Aggregate has binding name 'eml23__Aggregate' for type 'eml23:Aggregate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate
#define SOAP_TYPE_gsoap_eml2_3_eml23__Aggregate (-693)

#endif

/* eml23__TimeIndexParameterKey has binding name 'eml23__TimeIndexParameterKey' for type 'eml23:TimeIndexParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameterKey (-692)

#endif

/* eml23__TimeIndexParameter has binding name 'eml23__TimeIndexParameter' for type 'eml23:TimeIndexParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndexParameter (-691)

#endif

/* eml23__StringParameter has binding name 'eml23__StringParameter' for type 'eml23:StringParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringParameter (-690)

#endif

/* eml23__ParameterTemplate has binding name 'eml23__ParameterTemplate' for type 'eml23:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_3_eml23__ParameterTemplate (-689)

#endif

/* eml23__ObjectParameterKey has binding name 'eml23__ObjectParameterKey' for type 'eml23:ObjectParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__ObjectParameterKey (-688)

#endif

/* eml23__IntegerQuantityParameter has binding name 'eml23__IntegerQuantityParameter' for type 'eml23:IntegerQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerQuantityParameter (-687)

#endif

/* eml23__DoubleQuantityParameter has binding name 'eml23__DoubleQuantityParameter' for type 'eml23:DoubleQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoubleQuantityParameter (-686)

#endif

/* eml23__DataObjectParameter has binding name 'eml23__DataObjectParameter' for type 'eml23:DataObjectParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectParameter (-685)

#endif

/* eml23__ActivityTemplate has binding name 'eml23__ActivityTemplate' for type 'eml23:ActivityTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityTemplate (-684)

#endif

/* eml23__Activity has binding name 'eml23__Activity' for type 'eml23:Activity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Activity
#define SOAP_TYPE_gsoap_eml2_3_eml23__Activity (-683)

#endif

/* eml23__AbstractParameterKey has binding name 'eml23__AbstractParameterKey' for type 'eml23:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractParameterKey (-682)

#endif

/* eml23__AbstractActivityParameter has binding name 'eml23__AbstractActivityParameter' for type 'eml23:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractActivityParameter (-681)

#endif

/* eml23__OSDUIntegration has binding name 'eml23__OSDUIntegration' for type 'eml23:OSDUIntegration' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration
#define SOAP_TYPE_gsoap_eml2_3_eml23__OSDUIntegration (-680)

#endif

/* eml23__TimeSeriesParentage has binding name 'eml23__TimeSeriesParentage' for type 'eml23:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeriesParentage (-679)

#endif

/* eml23__TimeSeries has binding name 'eml23__TimeSeries' for type 'eml23:TimeSeries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeSeries (-678)

#endif

/* eml23__TimeOrIntervalSeries has binding name 'eml23__TimeOrIntervalSeries' for type 'eml23:TimeOrIntervalSeries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeOrIntervalSeries (-677)

#endif

/* eml23__TimeIndex has binding name 'eml23__TimeIndex' for type 'eml23:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeIndex (-676)

#endif

/* eml23__PropertyKindFacet has binding name 'eml23__PropertyKindFacet' for type 'eml23:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindFacet (-675)

#endif

/* eml23__PropertyKindDictionary has binding name 'eml23__PropertyKindDictionary' for type 'eml23:PropertyKindDictionary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKindDictionary (-674)

#endif

/* eml23__PropertyKind has binding name 'eml23__PropertyKind' for type 'eml23:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3_eml23__PropertyKind (-673)

#endif

/* eml23__GeologicTime has binding name 'eml23__GeologicTime' for type 'eml23:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeologicTime (-672)

#endif

/* eml23__DateTimeInterval has binding name 'eml23__DateTimeInterval' for type 'eml23:DateTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__DateTimeInterval (-671)

#endif

/* eml23__VerticalWktCrs has binding name 'eml23__VerticalWktCrs' for type 'eml23:VerticalWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalWktCrs (-670)

#endif

/* eml23__VerticalUnknownCrs has binding name 'eml23__VerticalUnknownCrs' for type 'eml23:VerticalUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalUnknownCrs (-669)

#endif

/* eml23__VerticalLocalAuthorityCrs has binding name 'eml23__VerticalLocalAuthorityCrs' for type 'eml23:VerticalLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalLocalAuthorityCrs (-668)

#endif

/* eml23__VerticalEpsgCrs has binding name 'eml23__VerticalEpsgCrs' for type 'eml23:VerticalEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalEpsgCrs (-667)

#endif

/* eml23__VerticalCrs has binding name 'eml23__VerticalCrs' for type 'eml23:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCrs (-666)

#endif

/* eml23__VerticalAxis has binding name 'eml23__VerticalAxis' for type 'eml23:VerticalAxis' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalAxis (-665)

#endif

/* eml23__Vector has binding name 'eml23__Vector' for type 'eml23:Vector' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Vector
#define SOAP_TYPE_gsoap_eml2_3_eml23__Vector (-664)

#endif

/* eml23__PublicLandSurveySystem has binding name 'eml23__PublicLandSurveySystem' for type 'eml23:PublicLandSurveySystem' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystem (-663)

#endif

/* eml23__ProjectedWktCrs has binding name 'eml23__ProjectedWktCrs' for type 'eml23:ProjectedWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedWktCrs (-662)

#endif

/* eml23__ProjectedUnknownCrs has binding name 'eml23__ProjectedUnknownCrs' for type 'eml23:ProjectedUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedUnknownCrs (-661)

#endif

/* eml23__ProjectedLocalAuthorityCrs has binding name 'eml23__ProjectedLocalAuthorityCrs' for type 'eml23:ProjectedLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedLocalAuthorityCrs (-660)

#endif

/* eml23__ProjectedEpsgCrs has binding name 'eml23__ProjectedEpsgCrs' for type 'eml23:ProjectedEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedEpsgCrs (-659)

#endif

/* eml23__ProjectedCrs has binding name 'eml23__ProjectedCrs' for type 'eml23:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCrs (-658)

#endif

/* eml23__LocalEngineeringCompoundCrs has binding name 'eml23__LocalEngineeringCompoundCrs' for type 'eml23:LocalEngineeringCompoundCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__LocalEngineeringCompoundCrs (-657)

#endif

/* eml23__HorizontalAxes has binding name 'eml23__HorizontalAxes' for type 'eml23:HorizontalAxes' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalAxes (-656)

#endif

/* eml23__GeodeticWktCrs has binding name 'eml23__GeodeticWktCrs' for type 'eml23:GeodeticWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticWktCrs (-655)

#endif

/* eml23__GeodeticUnknownCrs has binding name 'eml23__GeodeticUnknownCrs' for type 'eml23:GeodeticUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticUnknownCrs (-654)

#endif

/* eml23__GeodeticLocalAuthorityCrs has binding name 'eml23__GeodeticLocalAuthorityCrs' for type 'eml23:GeodeticLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticLocalAuthorityCrs (-653)

#endif

/* eml23__GeodeticEpsgCrs has binding name 'eml23__GeodeticEpsgCrs' for type 'eml23:GeodeticEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticEpsgCrs (-652)

#endif

/* eml23__GeodeticCrs has binding name 'eml23__GeodeticCrs' for type 'eml23:GeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCrs (-651)

#endif

/* eml23__AbstractVerticalCrs has binding name 'eml23__AbstractVerticalCrs' for type 'eml23:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractVerticalCrs (-650)

#endif

/* eml23__AbstractProjectedCrs has binding name 'eml23__AbstractProjectedCrs' for type 'eml23:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractProjectedCrs (-649)

#endif

/* eml23__AbstractGeodeticCrs has binding name 'eml23__AbstractGeodeticCrs' for type 'eml23:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGeodeticCrs (-648)

#endif

/* eml23__VolumetricThermalExpansionMeasureExt has binding name 'eml23__VolumetricThermalExpansionMeasureExt' for type 'eml23:VolumetricThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasureExt (-647)

#endif

/* eml23__VolumetricThermalExpansionMeasure has binding name 'eml23__VolumetricThermalExpansionMeasure' for type 'eml23:VolumetricThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricThermalExpansionMeasure (-646)

#endif

/* eml23__VolumetricHeatTransferCoefficientMeasureExt has binding name 'eml23__VolumetricHeatTransferCoefficientMeasureExt' for type 'eml23:VolumetricHeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasureExt (-645)

#endif

/* eml23__VolumetricHeatTransferCoefficientMeasure has binding name 'eml23__VolumetricHeatTransferCoefficientMeasure' for type 'eml23:VolumetricHeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumetricHeatTransferCoefficientMeasure (-644)

#endif

/* eml23__VolumePerVolumeMeasureExt has binding name 'eml23__VolumePerVolumeMeasureExt' for type 'eml23:VolumePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasureExt (-643)

#endif

/* eml23__VolumePerVolumeMeasure has binding name 'eml23__VolumePerVolumeMeasure' for type 'eml23:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerVolumeMeasure (-642)

#endif

/* eml23__VolumePerTimePerVolumeMeasureExt has binding name 'eml23__VolumePerTimePerVolumeMeasureExt' for type 'eml23:VolumePerTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasureExt (-641)

#endif

/* eml23__VolumePerTimePerVolumeMeasure has binding name 'eml23__VolumePerTimePerVolumeMeasure' for type 'eml23:VolumePerTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerVolumeMeasure (-640)

#endif

/* eml23__VolumePerTimePerTimeMeasureExt has binding name 'eml23__VolumePerTimePerTimeMeasureExt' for type 'eml23:VolumePerTimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasureExt (-639)

#endif

/* eml23__VolumePerTimePerTimeMeasure has binding name 'eml23__VolumePerTimePerTimeMeasure' for type 'eml23:VolumePerTimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerTimeMeasure (-638)

#endif

/* eml23__VolumePerTimePerPressureMeasureExt has binding name 'eml23__VolumePerTimePerPressureMeasureExt' for type 'eml23:VolumePerTimePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasureExt (-637)

#endif

/* eml23__VolumePerTimePerPressureMeasure has binding name 'eml23__VolumePerTimePerPressureMeasure' for type 'eml23:VolumePerTimePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureMeasure (-636)

#endif

/* eml23__VolumePerTimePerPressureLengthMeasureExt has binding name 'eml23__VolumePerTimePerPressureLengthMeasureExt' for type 'eml23:VolumePerTimePerPressureLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasureExt (-635)

#endif

/* eml23__VolumePerTimePerPressureLengthMeasure has binding name 'eml23__VolumePerTimePerPressureLengthMeasure' for type 'eml23:VolumePerTimePerPressureLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerPressureLengthMeasure (-634)

#endif

/* eml23__VolumePerTimePerLengthMeasureExt has binding name 'eml23__VolumePerTimePerLengthMeasureExt' for type 'eml23:VolumePerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasureExt (-633)

#endif

/* eml23__VolumePerTimePerLengthMeasure has binding name 'eml23__VolumePerTimePerLengthMeasure' for type 'eml23:VolumePerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerLengthMeasure (-632)

#endif

/* eml23__VolumePerTimePerAreaMeasureExt has binding name 'eml23__VolumePerTimePerAreaMeasureExt' for type 'eml23:VolumePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasureExt (-631)

#endif

/* eml23__VolumePerTimePerAreaMeasure has binding name 'eml23__VolumePerTimePerAreaMeasure' for type 'eml23:VolumePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimePerAreaMeasure (-630)

#endif

/* eml23__VolumePerTimeMeasureExt has binding name 'eml23__VolumePerTimeMeasureExt' for type 'eml23:VolumePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasureExt (-629)

#endif

/* eml23__VolumePerTimeMeasure has binding name 'eml23__VolumePerTimeMeasure' for type 'eml23:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeMeasure (-628)

#endif

/* eml23__VolumePerTimeLengthMeasureExt has binding name 'eml23__VolumePerTimeLengthMeasureExt' for type 'eml23:VolumePerTimeLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasureExt (-627)

#endif

/* eml23__VolumePerTimeLengthMeasure has binding name 'eml23__VolumePerTimeLengthMeasure' for type 'eml23:VolumePerTimeLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerTimeLengthMeasure (-626)

#endif

/* eml23__VolumePerRotationMeasureExt has binding name 'eml23__VolumePerRotationMeasureExt' for type 'eml23:VolumePerRotationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasureExt (-625)

#endif

/* eml23__VolumePerRotationMeasure has binding name 'eml23__VolumePerRotationMeasure' for type 'eml23:VolumePerRotationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerRotationMeasure (-624)

#endif

/* eml23__VolumePerPressureMeasureExt has binding name 'eml23__VolumePerPressureMeasureExt' for type 'eml23:VolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasureExt (-623)

#endif

/* eml23__VolumePerPressureMeasure has binding name 'eml23__VolumePerPressureMeasure' for type 'eml23:VolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerPressureMeasure (-622)

#endif

/* eml23__VolumePerMassMeasureExt has binding name 'eml23__VolumePerMassMeasureExt' for type 'eml23:VolumePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasureExt (-621)

#endif

/* eml23__VolumePerMassMeasure has binding name 'eml23__VolumePerMassMeasure' for type 'eml23:VolumePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerMassMeasure (-620)

#endif

/* eml23__VolumePerLengthMeasureExt has binding name 'eml23__VolumePerLengthMeasureExt' for type 'eml23:VolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasureExt (-619)

#endif

/* eml23__VolumePerLengthMeasure has binding name 'eml23__VolumePerLengthMeasure' for type 'eml23:VolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerLengthMeasure (-618)

#endif

/* eml23__VolumePerAreaMeasureExt has binding name 'eml23__VolumePerAreaMeasureExt' for type 'eml23:VolumePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasureExt (-617)

#endif

/* eml23__VolumePerAreaMeasure has binding name 'eml23__VolumePerAreaMeasure' for type 'eml23:VolumePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumePerAreaMeasure (-616)

#endif

/* eml23__VolumeMeasureExt has binding name 'eml23__VolumeMeasureExt' for type 'eml23:VolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasureExt (-615)

#endif

/* eml23__VolumeMeasure has binding name 'eml23__VolumeMeasure' for type 'eml23:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeMeasure (-614)

#endif

/* eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt has binding name 'eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt' for type 'eml23:VolumeFlowRatePerVolumeFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasureExt (-613)

#endif

/* eml23__VolumeFlowRatePerVolumeFlowRateMeasure has binding name 'eml23__VolumeFlowRatePerVolumeFlowRateMeasure' for type 'eml23:VolumeFlowRatePerVolumeFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VolumeFlowRatePerVolumeFlowRateMeasure (-612)

#endif

/* eml23__VerticalCoordinateMeasureExt has binding name 'eml23__VerticalCoordinateMeasureExt' for type 'eml23:VerticalCoordinateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasureExt (-611)

#endif

/* eml23__VerticalCoordinateMeasure has binding name 'eml23__VerticalCoordinateMeasure' for type 'eml23:VerticalCoordinateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalCoordinateMeasure (-610)

#endif

/* eml23__UnitlessMeasure has binding name 'eml23__UnitlessMeasure' for type 'eml23:UnitlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__UnitlessMeasure (-609)

#endif

/* eml23__TimePerVolumeMeasureExt has binding name 'eml23__TimePerVolumeMeasureExt' for type 'eml23:TimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasureExt (-608)

#endif

/* eml23__TimePerVolumeMeasure has binding name 'eml23__TimePerVolumeMeasure' for type 'eml23:TimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerVolumeMeasure (-607)

#endif

/* eml23__TimePerTimeMeasureExt has binding name 'eml23__TimePerTimeMeasureExt' for type 'eml23:TimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasureExt (-606)

#endif

/* eml23__TimePerTimeMeasure has binding name 'eml23__TimePerTimeMeasure' for type 'eml23:TimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerTimeMeasure (-605)

#endif

/* eml23__TimePerMassMeasureExt has binding name 'eml23__TimePerMassMeasureExt' for type 'eml23:TimePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasureExt (-604)

#endif

/* eml23__TimePerMassMeasure has binding name 'eml23__TimePerMassMeasure' for type 'eml23:TimePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerMassMeasure (-603)

#endif

/* eml23__TimePerLengthMeasureExt has binding name 'eml23__TimePerLengthMeasureExt' for type 'eml23:TimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasureExt (-602)

#endif

/* eml23__TimePerLengthMeasure has binding name 'eml23__TimePerLengthMeasure' for type 'eml23:TimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimePerLengthMeasure (-601)

#endif

/* eml23__TimeMeasureExt has binding name 'eml23__TimeMeasureExt' for type 'eml23:TimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasureExt (-600)

#endif

/* eml23__TimeMeasure has binding name 'eml23__TimeMeasure' for type 'eml23:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TimeMeasure (-599)

#endif

/* eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt has binding name 'eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' for type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (-598)

#endif

/* eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure has binding name 'eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' for type 'eml23:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (-597)

#endif

/* eml23__ThermodynamicTemperatureMeasureExt has binding name 'eml23__ThermodynamicTemperatureMeasureExt' for type 'eml23:ThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasureExt (-596)

#endif

/* eml23__ThermodynamicTemperatureMeasure has binding name 'eml23__ThermodynamicTemperatureMeasure' for type 'eml23:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermodynamicTemperatureMeasure (-595)

#endif

/* eml23__ThermalResistanceMeasureExt has binding name 'eml23__ThermalResistanceMeasureExt' for type 'eml23:ThermalResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasureExt (-594)

#endif

/* eml23__ThermalResistanceMeasure has binding name 'eml23__ThermalResistanceMeasure' for type 'eml23:ThermalResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalResistanceMeasure (-593)

#endif

/* eml23__ThermalInsulanceMeasureExt has binding name 'eml23__ThermalInsulanceMeasureExt' for type 'eml23:ThermalInsulanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasureExt (-592)

#endif

/* eml23__ThermalInsulanceMeasure has binding name 'eml23__ThermalInsulanceMeasure' for type 'eml23:ThermalInsulanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalInsulanceMeasure (-591)

#endif

/* eml23__ThermalDiffusivityMeasureExt has binding name 'eml23__ThermalDiffusivityMeasureExt' for type 'eml23:ThermalDiffusivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasureExt (-590)

#endif

/* eml23__ThermalDiffusivityMeasure has binding name 'eml23__ThermalDiffusivityMeasure' for type 'eml23:ThermalDiffusivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalDiffusivityMeasure (-589)

#endif

/* eml23__ThermalConductivityMeasureExt has binding name 'eml23__ThermalConductivityMeasureExt' for type 'eml23:ThermalConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasureExt (-588)

#endif

/* eml23__ThermalConductivityMeasure has binding name 'eml23__ThermalConductivityMeasure' for type 'eml23:ThermalConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductivityMeasure (-587)

#endif

/* eml23__ThermalConductanceMeasureExt has binding name 'eml23__ThermalConductanceMeasureExt' for type 'eml23:ThermalConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasureExt (-586)

#endif

/* eml23__ThermalConductanceMeasure has binding name 'eml23__ThermalConductanceMeasure' for type 'eml23:ThermalConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ThermalConductanceMeasure (-585)

#endif

/* eml23__TemperatureIntervalPerTimeMeasureExt has binding name 'eml23__TemperatureIntervalPerTimeMeasureExt' for type 'eml23:TemperatureIntervalPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasureExt (-584)

#endif

/* eml23__TemperatureIntervalPerTimeMeasure has binding name 'eml23__TemperatureIntervalPerTimeMeasure' for type 'eml23:TemperatureIntervalPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerTimeMeasure (-583)

#endif

/* eml23__TemperatureIntervalPerPressureMeasureExt has binding name 'eml23__TemperatureIntervalPerPressureMeasureExt' for type 'eml23:TemperatureIntervalPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasureExt (-582)

#endif

/* eml23__TemperatureIntervalPerPressureMeasure has binding name 'eml23__TemperatureIntervalPerPressureMeasure' for type 'eml23:TemperatureIntervalPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerPressureMeasure (-581)

#endif

/* eml23__TemperatureIntervalPerLengthMeasureExt has binding name 'eml23__TemperatureIntervalPerLengthMeasureExt' for type 'eml23:TemperatureIntervalPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasureExt (-580)

#endif

/* eml23__TemperatureIntervalPerLengthMeasure has binding name 'eml23__TemperatureIntervalPerLengthMeasure' for type 'eml23:TemperatureIntervalPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalPerLengthMeasure (-579)

#endif

/* eml23__TemperatureIntervalMeasureExt has binding name 'eml23__TemperatureIntervalMeasureExt' for type 'eml23:TemperatureIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasureExt (-578)

#endif

/* eml23__TemperatureIntervalMeasure has binding name 'eml23__TemperatureIntervalMeasure' for type 'eml23:TemperatureIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__TemperatureIntervalMeasure (-577)

#endif

/* eml23__SpecificHeatCapacityMeasureExt has binding name 'eml23__SpecificHeatCapacityMeasureExt' for type 'eml23:SpecificHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasureExt (-576)

#endif

/* eml23__SpecificHeatCapacityMeasure has binding name 'eml23__SpecificHeatCapacityMeasure' for type 'eml23:SpecificHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SpecificHeatCapacityMeasure (-575)

#endif

/* eml23__SolidAngleMeasureExt has binding name 'eml23__SolidAngleMeasureExt' for type 'eml23:SolidAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasureExt (-574)

#endif

/* eml23__SolidAngleMeasure has binding name 'eml23__SolidAngleMeasure' for type 'eml23:SolidAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SolidAngleMeasure (-573)

#endif

/* eml23__SignalingEventPerTimeMeasureExt has binding name 'eml23__SignalingEventPerTimeMeasureExt' for type 'eml23:SignalingEventPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasureExt (-572)

#endif

/* eml23__SignalingEventPerTimeMeasure has binding name 'eml23__SignalingEventPerTimeMeasure' for type 'eml23:SignalingEventPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SignalingEventPerTimeMeasure (-571)

#endif

/* eml23__SecondMomentOfAreaMeasureExt has binding name 'eml23__SecondMomentOfAreaMeasureExt' for type 'eml23:SecondMomentOfAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasureExt (-570)

#endif

/* eml23__SecondMomentOfAreaMeasure has binding name 'eml23__SecondMomentOfAreaMeasure' for type 'eml23:SecondMomentOfAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__SecondMomentOfAreaMeasure (-569)

#endif

/* eml23__ReluctanceMeasureExt has binding name 'eml23__ReluctanceMeasureExt' for type 'eml23:ReluctanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasureExt (-568)

#endif

/* eml23__ReluctanceMeasure has binding name 'eml23__ReluctanceMeasure' for type 'eml23:ReluctanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReluctanceMeasure (-567)

#endif

/* eml23__ReciprocalVolumeMeasureExt has binding name 'eml23__ReciprocalVolumeMeasureExt' for type 'eml23:ReciprocalVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasureExt (-566)

#endif

/* eml23__ReciprocalVolumeMeasure has binding name 'eml23__ReciprocalVolumeMeasure' for type 'eml23:ReciprocalVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalVolumeMeasure (-565)

#endif

/* eml23__ReciprocalTimeMeasureExt has binding name 'eml23__ReciprocalTimeMeasureExt' for type 'eml23:ReciprocalTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasureExt (-564)

#endif

/* eml23__ReciprocalTimeMeasure has binding name 'eml23__ReciprocalTimeMeasure' for type 'eml23:ReciprocalTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalTimeMeasure (-563)

#endif

/* eml23__ReciprocalPressureMeasureExt has binding name 'eml23__ReciprocalPressureMeasureExt' for type 'eml23:ReciprocalPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasureExt (-562)

#endif

/* eml23__ReciprocalPressureMeasure has binding name 'eml23__ReciprocalPressureMeasure' for type 'eml23:ReciprocalPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalPressureMeasure (-561)

#endif

/* eml23__ReciprocalMassTimeMeasureExt has binding name 'eml23__ReciprocalMassTimeMeasureExt' for type 'eml23:ReciprocalMassTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasureExt (-560)

#endif

/* eml23__ReciprocalMassTimeMeasure has binding name 'eml23__ReciprocalMassTimeMeasure' for type 'eml23:ReciprocalMassTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassTimeMeasure (-559)

#endif

/* eml23__ReciprocalMassMeasureExt has binding name 'eml23__ReciprocalMassMeasureExt' for type 'eml23:ReciprocalMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasureExt (-558)

#endif

/* eml23__ReciprocalMassMeasure has binding name 'eml23__ReciprocalMassMeasure' for type 'eml23:ReciprocalMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalMassMeasure (-557)

#endif

/* eml23__ReciprocalLengthMeasureExt has binding name 'eml23__ReciprocalLengthMeasureExt' for type 'eml23:ReciprocalLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasureExt (-556)

#endif

/* eml23__ReciprocalLengthMeasure has binding name 'eml23__ReciprocalLengthMeasure' for type 'eml23:ReciprocalLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalLengthMeasure (-555)

#endif

/* eml23__ReciprocalForceMeasureExt has binding name 'eml23__ReciprocalForceMeasureExt' for type 'eml23:ReciprocalForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasureExt (-554)

#endif

/* eml23__ReciprocalForceMeasure has binding name 'eml23__ReciprocalForceMeasure' for type 'eml23:ReciprocalForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalForceMeasure (-553)

#endif

/* eml23__ReciprocalElectricPotentialDifferenceMeasureExt has binding name 'eml23__ReciprocalElectricPotentialDifferenceMeasureExt' for type 'eml23:ReciprocalElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasureExt (-552)

#endif

/* eml23__ReciprocalElectricPotentialDifferenceMeasure has binding name 'eml23__ReciprocalElectricPotentialDifferenceMeasure' for type 'eml23:ReciprocalElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalElectricPotentialDifferenceMeasure (-551)

#endif

/* eml23__ReciprocalAreaMeasureExt has binding name 'eml23__ReciprocalAreaMeasureExt' for type 'eml23:ReciprocalAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasureExt (-550)

#endif

/* eml23__ReciprocalAreaMeasure has binding name 'eml23__ReciprocalAreaMeasure' for type 'eml23:ReciprocalAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReciprocalAreaMeasure (-549)

#endif

/* eml23__RadiantIntensityMeasureExt has binding name 'eml23__RadiantIntensityMeasureExt' for type 'eml23:RadiantIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasureExt (-548)

#endif

/* eml23__RadiantIntensityMeasure has binding name 'eml23__RadiantIntensityMeasure' for type 'eml23:RadiantIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadiantIntensityMeasure (-547)

#endif

/* eml23__RadianceMeasureExt has binding name 'eml23__RadianceMeasureExt' for type 'eml23:RadianceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasureExt (-546)

#endif

/* eml23__RadianceMeasure has binding name 'eml23__RadianceMeasure' for type 'eml23:RadianceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__RadianceMeasure (-545)

#endif

/* eml23__QuantityOfLightMeasureExt has binding name 'eml23__QuantityOfLightMeasureExt' for type 'eml23:QuantityOfLightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasureExt (-544)

#endif

/* eml23__QuantityOfLightMeasure has binding name 'eml23__QuantityOfLightMeasure' for type 'eml23:QuantityOfLightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__QuantityOfLightMeasure (-543)

#endif

/* eml23__PressureTimePerVolumeMeasureExt has binding name 'eml23__PressureTimePerVolumeMeasureExt' for type 'eml23:PressureTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasureExt (-542)

#endif

/* eml23__PressureTimePerVolumeMeasure has binding name 'eml23__PressureTimePerVolumeMeasure' for type 'eml23:PressureTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureTimePerVolumeMeasure (-541)

#endif

/* eml23__PressureSquaredPerForceTimePerAreaMeasureExt has binding name 'eml23__PressureSquaredPerForceTimePerAreaMeasureExt' for type 'eml23:PressureSquaredPerForceTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasureExt (-540)

#endif

/* eml23__PressureSquaredPerForceTimePerAreaMeasure has binding name 'eml23__PressureSquaredPerForceTimePerAreaMeasure' for type 'eml23:PressureSquaredPerForceTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredPerForceTimePerAreaMeasure (-539)

#endif

/* eml23__PressureSquaredMeasureExt has binding name 'eml23__PressureSquaredMeasureExt' for type 'eml23:PressureSquaredMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasureExt (-538)

#endif

/* eml23__PressureSquaredMeasure has binding name 'eml23__PressureSquaredMeasure' for type 'eml23:PressureSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureSquaredMeasure (-537)

#endif

/* eml23__PressurePerVolumeMeasureExt has binding name 'eml23__PressurePerVolumeMeasureExt' for type 'eml23:PressurePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasureExt (-536)

#endif

/* eml23__PressurePerVolumeMeasure has binding name 'eml23__PressurePerVolumeMeasure' for type 'eml23:PressurePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerVolumeMeasure (-535)

#endif

/* eml23__PressurePerTimeMeasureExt has binding name 'eml23__PressurePerTimeMeasureExt' for type 'eml23:PressurePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasureExt (-534)

#endif

/* eml23__PressurePerTimeMeasure has binding name 'eml23__PressurePerTimeMeasure' for type 'eml23:PressurePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerTimeMeasure (-533)

#endif

/* eml23__PressurePerPressureMeasureExt has binding name 'eml23__PressurePerPressureMeasureExt' for type 'eml23:PressurePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasureExt (-532)

#endif

/* eml23__PressurePerPressureMeasure has binding name 'eml23__PressurePerPressureMeasure' for type 'eml23:PressurePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressurePerPressureMeasure (-531)

#endif

/* eml23__PressureMeasureExt has binding name 'eml23__PressureMeasureExt' for type 'eml23:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasureExt (-530)

#endif

/* eml23__PressureMeasure has binding name 'eml23__PressureMeasure' for type 'eml23:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PressureMeasure (-529)

#endif

/* eml23__PowerPerVolumeMeasureExt has binding name 'eml23__PowerPerVolumeMeasureExt' for type 'eml23:PowerPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasureExt (-528)

#endif

/* eml23__PowerPerVolumeMeasure has binding name 'eml23__PowerPerVolumeMeasure' for type 'eml23:PowerPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerVolumeMeasure (-527)

#endif

/* eml23__PowerPerPowerMeasureExt has binding name 'eml23__PowerPerPowerMeasureExt' for type 'eml23:PowerPerPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasureExt (-526)

#endif

/* eml23__PowerPerPowerMeasure has binding name 'eml23__PowerPerPowerMeasure' for type 'eml23:PowerPerPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerPowerMeasure (-525)

#endif

/* eml23__PowerPerAreaMeasureExt has binding name 'eml23__PowerPerAreaMeasureExt' for type 'eml23:PowerPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasureExt (-524)

#endif

/* eml23__PowerPerAreaMeasure has binding name 'eml23__PowerPerAreaMeasure' for type 'eml23:PowerPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerPerAreaMeasure (-523)

#endif

/* eml23__PowerMeasureExt has binding name 'eml23__PowerMeasureExt' for type 'eml23:PowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasureExt (-522)

#endif

/* eml23__PowerMeasure has binding name 'eml23__PowerMeasure' for type 'eml23:PowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PowerMeasure (-521)

#endif

/* eml23__PotentialDifferencePerPowerDropMeasureExt has binding name 'eml23__PotentialDifferencePerPowerDropMeasureExt' for type 'eml23:PotentialDifferencePerPowerDropMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasureExt (-520)

#endif

/* eml23__PotentialDifferencePerPowerDropMeasure has binding name 'eml23__PotentialDifferencePerPowerDropMeasure' for type 'eml23:PotentialDifferencePerPowerDropMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PotentialDifferencePerPowerDropMeasure (-519)

#endif

/* eml23__PlaneAngleMeasureExt has binding name 'eml23__PlaneAngleMeasureExt' for type 'eml23:PlaneAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasureExt (-518)

#endif

/* eml23__PlaneAngleMeasure has binding name 'eml23__PlaneAngleMeasure' for type 'eml23:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PlaneAngleMeasure (-517)

#endif

/* eml23__PermittivityMeasureExt has binding name 'eml23__PermittivityMeasureExt' for type 'eml23:PermittivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasureExt (-516)

#endif

/* eml23__PermittivityMeasure has binding name 'eml23__PermittivityMeasure' for type 'eml23:PermittivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermittivityMeasure (-515)

#endif

/* eml23__PermeabilityRockMeasureExt has binding name 'eml23__PermeabilityRockMeasureExt' for type 'eml23:PermeabilityRockMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasureExt (-514)

#endif

/* eml23__PermeabilityRockMeasure has binding name 'eml23__PermeabilityRockMeasure' for type 'eml23:PermeabilityRockMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityRockMeasure (-513)

#endif

/* eml23__PermeabilityLengthMeasureExt has binding name 'eml23__PermeabilityLengthMeasureExt' for type 'eml23:PermeabilityLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasureExt (-512)

#endif

/* eml23__PermeabilityLengthMeasure has binding name 'eml23__PermeabilityLengthMeasure' for type 'eml23:PermeabilityLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__PermeabilityLengthMeasure (-511)

#endif

/* eml23__NormalizedPowerMeasureExt has binding name 'eml23__NormalizedPowerMeasureExt' for type 'eml23:NormalizedPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasureExt (-510)

#endif

/* eml23__NormalizedPowerMeasure has binding name 'eml23__NormalizedPowerMeasure' for type 'eml23:NormalizedPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__NormalizedPowerMeasure (-509)

#endif

/* eml23__MomentumMeasureExt has binding name 'eml23__MomentumMeasureExt' for type 'eml23:MomentumMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasureExt (-508)

#endif

/* eml23__MomentumMeasure has binding name 'eml23__MomentumMeasure' for type 'eml23:MomentumMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentumMeasure (-507)

#endif

/* eml23__MomentOfInertiaMeasureExt has binding name 'eml23__MomentOfInertiaMeasureExt' for type 'eml23:MomentOfInertiaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasureExt (-506)

#endif

/* eml23__MomentOfInertiaMeasure has binding name 'eml23__MomentOfInertiaMeasure' for type 'eml23:MomentOfInertiaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfInertiaMeasure (-505)

#endif

/* eml23__MomentOfForceMeasureExt has binding name 'eml23__MomentOfForceMeasureExt' for type 'eml23:MomentOfForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasureExt (-504)

#endif

/* eml23__MomentOfForceMeasure has binding name 'eml23__MomentOfForceMeasure' for type 'eml23:MomentOfForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MomentOfForceMeasure (-503)

#endif

/* eml23__MolecularWeightMeasureExt has binding name 'eml23__MolecularWeightMeasureExt' for type 'eml23:MolecularWeightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasureExt (-502)

#endif

/* eml23__MolecularWeightMeasure has binding name 'eml23__MolecularWeightMeasure' for type 'eml23:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolecularWeightMeasure (-501)

#endif

/* eml23__MolarVolumeMeasureExt has binding name 'eml23__MolarVolumeMeasureExt' for type 'eml23:MolarVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasureExt (-500)

#endif

/* eml23__MolarVolumeMeasure has binding name 'eml23__MolarVolumeMeasure' for type 'eml23:MolarVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarVolumeMeasure (-499)

#endif

/* eml23__MolarHeatCapacityMeasureExt has binding name 'eml23__MolarHeatCapacityMeasureExt' for type 'eml23:MolarHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasureExt (-498)

#endif

/* eml23__MolarHeatCapacityMeasure has binding name 'eml23__MolarHeatCapacityMeasure' for type 'eml23:MolarHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarHeatCapacityMeasure (-497)

#endif

/* eml23__MolarEnergyMeasureExt has binding name 'eml23__MolarEnergyMeasureExt' for type 'eml23:MolarEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasureExt (-496)

#endif

/* eml23__MolarEnergyMeasure has binding name 'eml23__MolarEnergyMeasure' for type 'eml23:MolarEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MolarEnergyMeasure (-495)

#endif

/* eml23__MobilityMeasureExt has binding name 'eml23__MobilityMeasureExt' for type 'eml23:MobilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasureExt (-494)

#endif

/* eml23__MobilityMeasure has binding name 'eml23__MobilityMeasure' for type 'eml23:MobilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MobilityMeasure (-493)

#endif

/* eml23__MassPerVolumePerTemperatureMeasureExt has binding name 'eml23__MassPerVolumePerTemperatureMeasureExt' for type 'eml23:MassPerVolumePerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasureExt (-492)

#endif

/* eml23__MassPerVolumePerTemperatureMeasure has binding name 'eml23__MassPerVolumePerTemperatureMeasure' for type 'eml23:MassPerVolumePerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerTemperatureMeasure (-491)

#endif

/* eml23__MassPerVolumePerPressureMeasureExt has binding name 'eml23__MassPerVolumePerPressureMeasureExt' for type 'eml23:MassPerVolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasureExt (-490)

#endif

/* eml23__MassPerVolumePerPressureMeasure has binding name 'eml23__MassPerVolumePerPressureMeasure' for type 'eml23:MassPerVolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerPressureMeasure (-489)

#endif

/* eml23__MassPerVolumePerLengthMeasureExt has binding name 'eml23__MassPerVolumePerLengthMeasureExt' for type 'eml23:MassPerVolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasureExt (-488)

#endif

/* eml23__MassPerVolumePerLengthMeasure has binding name 'eml23__MassPerVolumePerLengthMeasure' for type 'eml23:MassPerVolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumePerLengthMeasure (-487)

#endif

/* eml23__MassPerVolumeMeasureExt has binding name 'eml23__MassPerVolumeMeasureExt' for type 'eml23:MassPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasureExt (-486)

#endif

/* eml23__MassPerVolumeMeasure has binding name 'eml23__MassPerVolumeMeasure' for type 'eml23:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerVolumeMeasure (-485)

#endif

/* eml23__MassPerTimePerLengthMeasureExt has binding name 'eml23__MassPerTimePerLengthMeasureExt' for type 'eml23:MassPerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasureExt (-484)

#endif

/* eml23__MassPerTimePerLengthMeasure has binding name 'eml23__MassPerTimePerLengthMeasure' for type 'eml23:MassPerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerLengthMeasure (-483)

#endif

/* eml23__MassPerTimePerAreaMeasureExt has binding name 'eml23__MassPerTimePerAreaMeasureExt' for type 'eml23:MassPerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasureExt (-482)

#endif

/* eml23__MassPerTimePerAreaMeasure has binding name 'eml23__MassPerTimePerAreaMeasure' for type 'eml23:MassPerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimePerAreaMeasure (-481)

#endif

/* eml23__MassPerTimeMeasureExt has binding name 'eml23__MassPerTimeMeasureExt' for type 'eml23:MassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasureExt (-480)

#endif

/* eml23__MassPerTimeMeasure has binding name 'eml23__MassPerTimeMeasure' for type 'eml23:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerTimeMeasure (-479)

#endif

/* eml23__MassPerMassMeasureExt has binding name 'eml23__MassPerMassMeasureExt' for type 'eml23:MassPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasureExt (-478)

#endif

/* eml23__MassPerMassMeasure has binding name 'eml23__MassPerMassMeasure' for type 'eml23:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerMassMeasure (-477)

#endif

/* eml23__MassPerLengthMeasureExt has binding name 'eml23__MassPerLengthMeasureExt' for type 'eml23:MassPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasureExt (-476)

#endif

/* eml23__MassPerLengthMeasure has binding name 'eml23__MassPerLengthMeasure' for type 'eml23:MassPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerLengthMeasure (-475)

#endif

/* eml23__MassPerEnergyMeasureExt has binding name 'eml23__MassPerEnergyMeasureExt' for type 'eml23:MassPerEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasureExt (-474)

#endif

/* eml23__MassPerEnergyMeasure has binding name 'eml23__MassPerEnergyMeasure' for type 'eml23:MassPerEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerEnergyMeasure (-473)

#endif

/* eml23__MassPerAreaMeasureExt has binding name 'eml23__MassPerAreaMeasureExt' for type 'eml23:MassPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasureExt (-472)

#endif

/* eml23__MassPerAreaMeasure has binding name 'eml23__MassPerAreaMeasure' for type 'eml23:MassPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassPerAreaMeasure (-471)

#endif

/* eml23__MassMeasureExt has binding name 'eml23__MassMeasureExt' for type 'eml23:MassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasureExt (-470)

#endif

/* eml23__MassMeasure has binding name 'eml23__MassMeasure' for type 'eml23:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassMeasure (-469)

#endif

/* eml23__MassLengthMeasureExt has binding name 'eml23__MassLengthMeasureExt' for type 'eml23:MassLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasureExt (-468)

#endif

/* eml23__MassLengthMeasure has binding name 'eml23__MassLengthMeasure' for type 'eml23:MassLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MassLengthMeasure (-467)

#endif

/* eml23__MagneticVectorPotentialMeasureExt has binding name 'eml23__MagneticVectorPotentialMeasureExt' for type 'eml23:MagneticVectorPotentialMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasureExt (-466)

#endif

/* eml23__MagneticVectorPotentialMeasure has binding name 'eml23__MagneticVectorPotentialMeasure' for type 'eml23:MagneticVectorPotentialMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticVectorPotentialMeasure (-465)

#endif

/* eml23__MagneticPermeabilityMeasureExt has binding name 'eml23__MagneticPermeabilityMeasureExt' for type 'eml23:MagneticPermeabilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasureExt (-464)

#endif

/* eml23__MagneticPermeabilityMeasure has binding name 'eml23__MagneticPermeabilityMeasure' for type 'eml23:MagneticPermeabilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticPermeabilityMeasure (-463)

#endif

/* eml23__MagneticFluxMeasureExt has binding name 'eml23__MagneticFluxMeasureExt' for type 'eml23:MagneticFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasureExt (-462)

#endif

/* eml23__MagneticFluxMeasure has binding name 'eml23__MagneticFluxMeasure' for type 'eml23:MagneticFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxMeasure (-461)

#endif

/* eml23__MagneticFluxDensityPerLengthMeasureExt has binding name 'eml23__MagneticFluxDensityPerLengthMeasureExt' for type 'eml23:MagneticFluxDensityPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasureExt (-460)

#endif

/* eml23__MagneticFluxDensityPerLengthMeasure has binding name 'eml23__MagneticFluxDensityPerLengthMeasure' for type 'eml23:MagneticFluxDensityPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityPerLengthMeasure (-459)

#endif

/* eml23__MagneticFluxDensityMeasureExt has binding name 'eml23__MagneticFluxDensityMeasureExt' for type 'eml23:MagneticFluxDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasureExt (-458)

#endif

/* eml23__MagneticFluxDensityMeasure has binding name 'eml23__MagneticFluxDensityMeasure' for type 'eml23:MagneticFluxDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFluxDensityMeasure (-457)

#endif

/* eml23__MagneticFieldStrengthMeasureExt has binding name 'eml23__MagneticFieldStrengthMeasureExt' for type 'eml23:MagneticFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasureExt (-456)

#endif

/* eml23__MagneticFieldStrengthMeasure has binding name 'eml23__MagneticFieldStrengthMeasure' for type 'eml23:MagneticFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticFieldStrengthMeasure (-455)

#endif

/* eml23__MagneticDipoleMomentMeasureExt has binding name 'eml23__MagneticDipoleMomentMeasureExt' for type 'eml23:MagneticDipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasureExt (-454)

#endif

/* eml23__MagneticDipoleMomentMeasure has binding name 'eml23__MagneticDipoleMomentMeasure' for type 'eml23:MagneticDipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__MagneticDipoleMomentMeasure (-453)

#endif

/* eml23__LuminousIntensityMeasureExt has binding name 'eml23__LuminousIntensityMeasureExt' for type 'eml23:LuminousIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasureExt (-452)

#endif

/* eml23__LuminousIntensityMeasure has binding name 'eml23__LuminousIntensityMeasure' for type 'eml23:LuminousIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousIntensityMeasure (-451)

#endif

/* eml23__LuminousFluxMeasureExt has binding name 'eml23__LuminousFluxMeasureExt' for type 'eml23:LuminousFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasureExt (-450)

#endif

/* eml23__LuminousFluxMeasure has binding name 'eml23__LuminousFluxMeasure' for type 'eml23:LuminousFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousFluxMeasure (-449)

#endif

/* eml23__LuminousEfficacyMeasureExt has binding name 'eml23__LuminousEfficacyMeasureExt' for type 'eml23:LuminousEfficacyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasureExt (-448)

#endif

/* eml23__LuminousEfficacyMeasure has binding name 'eml23__LuminousEfficacyMeasure' for type 'eml23:LuminousEfficacyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminousEfficacyMeasure (-447)

#endif

/* eml23__LuminanceMeasureExt has binding name 'eml23__LuminanceMeasureExt' for type 'eml23:LuminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasureExt (-446)

#endif

/* eml23__LuminanceMeasure has binding name 'eml23__LuminanceMeasure' for type 'eml23:LuminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LuminanceMeasure (-445)

#endif

/* eml23__LogarithmicPowerRatioPerLengthMeasureExt has binding name 'eml23__LogarithmicPowerRatioPerLengthMeasureExt' for type 'eml23:LogarithmicPowerRatioPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasureExt (-444)

#endif

/* eml23__LogarithmicPowerRatioPerLengthMeasure has binding name 'eml23__LogarithmicPowerRatioPerLengthMeasure' for type 'eml23:LogarithmicPowerRatioPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioPerLengthMeasure (-443)

#endif

/* eml23__LogarithmicPowerRatioMeasureExt has binding name 'eml23__LogarithmicPowerRatioMeasureExt' for type 'eml23:LogarithmicPowerRatioMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasureExt (-442)

#endif

/* eml23__LogarithmicPowerRatioMeasure has binding name 'eml23__LogarithmicPowerRatioMeasure' for type 'eml23:LogarithmicPowerRatioMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LogarithmicPowerRatioMeasure (-441)

#endif

/* eml23__LinearThermalExpansionMeasureExt has binding name 'eml23__LinearThermalExpansionMeasureExt' for type 'eml23:LinearThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasureExt (-440)

#endif

/* eml23__LinearThermalExpansionMeasure has binding name 'eml23__LinearThermalExpansionMeasure' for type 'eml23:LinearThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearThermalExpansionMeasure (-439)

#endif

/* eml23__LinearAccelerationMeasureExt has binding name 'eml23__LinearAccelerationMeasureExt' for type 'eml23:LinearAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasureExt (-438)

#endif

/* eml23__LinearAccelerationMeasure has binding name 'eml23__LinearAccelerationMeasure' for type 'eml23:LinearAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LinearAccelerationMeasure (-437)

#endif

/* eml23__LightExposureMeasureExt has binding name 'eml23__LightExposureMeasureExt' for type 'eml23:LightExposureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasureExt (-436)

#endif

/* eml23__LightExposureMeasure has binding name 'eml23__LightExposureMeasure' for type 'eml23:LightExposureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LightExposureMeasure (-435)

#endif

/* eml23__LengthPerVolumeMeasureExt has binding name 'eml23__LengthPerVolumeMeasureExt' for type 'eml23:LengthPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasureExt (-434)

#endif

/* eml23__LengthPerVolumeMeasure has binding name 'eml23__LengthPerVolumeMeasure' for type 'eml23:LengthPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerVolumeMeasure (-433)

#endif

/* eml23__LengthPerTimeMeasureExt has binding name 'eml23__LengthPerTimeMeasureExt' for type 'eml23:LengthPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasureExt (-432)

#endif

/* eml23__LengthPerTimeMeasure has binding name 'eml23__LengthPerTimeMeasure' for type 'eml23:LengthPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTimeMeasure (-431)

#endif

/* eml23__LengthPerTemperatureMeasureExt has binding name 'eml23__LengthPerTemperatureMeasureExt' for type 'eml23:LengthPerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasureExt (-430)

#endif

/* eml23__LengthPerTemperatureMeasure has binding name 'eml23__LengthPerTemperatureMeasure' for type 'eml23:LengthPerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerTemperatureMeasure (-429)

#endif

/* eml23__LengthPerPressureMeasureExt has binding name 'eml23__LengthPerPressureMeasureExt' for type 'eml23:LengthPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasureExt (-428)

#endif

/* eml23__LengthPerPressureMeasure has binding name 'eml23__LengthPerPressureMeasure' for type 'eml23:LengthPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerPressureMeasure (-427)

#endif

/* eml23__LengthPerMassMeasureExt has binding name 'eml23__LengthPerMassMeasureExt' for type 'eml23:LengthPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasureExt (-426)

#endif

/* eml23__LengthPerMassMeasure has binding name 'eml23__LengthPerMassMeasure' for type 'eml23:LengthPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerMassMeasure (-425)

#endif

/* eml23__LengthPerLengthMeasureExt has binding name 'eml23__LengthPerLengthMeasureExt' for type 'eml23:LengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasureExt (-424)

#endif

/* eml23__LengthPerLengthMeasure has binding name 'eml23__LengthPerLengthMeasure' for type 'eml23:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthPerLengthMeasure (-423)

#endif

/* eml23__LengthOrTimeMeasureExt has binding name 'eml23__LengthOrTimeMeasureExt' for type 'eml23:LengthOrTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthOrTimeMeasureExt (-422)

#endif

/* eml23__LengthMeasureExt has binding name 'eml23__LengthMeasureExt' for type 'eml23:LengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasureExt (-421)

#endif

/* eml23__LengthMeasure has binding name 'eml23__LengthMeasure' for type 'eml23:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__LengthMeasure (-420)

#endif

/* eml23__KinematicViscosityMeasureExt has binding name 'eml23__KinematicViscosityMeasureExt' for type 'eml23:KinematicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasureExt (-419)

#endif

/* eml23__KinematicViscosityMeasure has binding name 'eml23__KinematicViscosityMeasure' for type 'eml23:KinematicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__KinematicViscosityMeasure (-418)

#endif

/* eml23__IsothermalCompressibilityMeasureExt has binding name 'eml23__IsothermalCompressibilityMeasureExt' for type 'eml23:IsothermalCompressibilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasureExt (-417)

#endif

/* eml23__IsothermalCompressibilityMeasure has binding name 'eml23__IsothermalCompressibilityMeasure' for type 'eml23:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__IsothermalCompressibilityMeasure (-416)

#endif

/* eml23__InductanceMeasureExt has binding name 'eml23__InductanceMeasureExt' for type 'eml23:InductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasureExt (-415)

#endif

/* eml23__InductanceMeasure has binding name 'eml23__InductanceMeasure' for type 'eml23:InductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__InductanceMeasure (-414)

#endif

/* eml23__IlluminanceMeasureExt has binding name 'eml23__IlluminanceMeasureExt' for type 'eml23:IlluminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasureExt (-413)

#endif

/* eml23__IlluminanceMeasure has binding name 'eml23__IlluminanceMeasure' for type 'eml23:IlluminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__IlluminanceMeasure (-412)

#endif

/* eml23__HeatTransferCoefficientMeasureExt has binding name 'eml23__HeatTransferCoefficientMeasureExt' for type 'eml23:HeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasureExt (-411)

#endif

/* eml23__HeatTransferCoefficientMeasure has binding name 'eml23__HeatTransferCoefficientMeasure' for type 'eml23:HeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatTransferCoefficientMeasure (-410)

#endif

/* eml23__HeatFlowRateMeasureExt has binding name 'eml23__HeatFlowRateMeasureExt' for type 'eml23:HeatFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasureExt (-409)

#endif

/* eml23__HeatFlowRateMeasure has binding name 'eml23__HeatFlowRateMeasure' for type 'eml23:HeatFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatFlowRateMeasure (-408)

#endif

/* eml23__HeatCapacityMeasureExt has binding name 'eml23__HeatCapacityMeasureExt' for type 'eml23:HeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasureExt (-407)

#endif

/* eml23__HeatCapacityMeasure has binding name 'eml23__HeatCapacityMeasure' for type 'eml23:HeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__HeatCapacityMeasure (-406)

#endif

/* eml23__FrequencyMeasureExt has binding name 'eml23__FrequencyMeasureExt' for type 'eml23:FrequencyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasureExt (-405)

#endif

/* eml23__FrequencyMeasure has binding name 'eml23__FrequencyMeasure' for type 'eml23:FrequencyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyMeasure (-404)

#endif

/* eml23__FrequencyIntervalMeasureExt has binding name 'eml23__FrequencyIntervalMeasureExt' for type 'eml23:FrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasureExt (-403)

#endif

/* eml23__FrequencyIntervalMeasure has binding name 'eml23__FrequencyIntervalMeasure' for type 'eml23:FrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__FrequencyIntervalMeasure (-402)

#endif

/* eml23__ForcePerVolumeMeasureExt has binding name 'eml23__ForcePerVolumeMeasureExt' for type 'eml23:ForcePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasureExt (-401)

#endif

/* eml23__ForcePerVolumeMeasure has binding name 'eml23__ForcePerVolumeMeasure' for type 'eml23:ForcePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerVolumeMeasure (-400)

#endif

/* eml23__ForcePerLengthMeasureExt has binding name 'eml23__ForcePerLengthMeasureExt' for type 'eml23:ForcePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasureExt (-399)

#endif

/* eml23__ForcePerLengthMeasure has binding name 'eml23__ForcePerLengthMeasure' for type 'eml23:ForcePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerLengthMeasure (-398)

#endif

/* eml23__ForcePerForceMeasureExt has binding name 'eml23__ForcePerForceMeasureExt' for type 'eml23:ForcePerForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasureExt (-397)

#endif

/* eml23__ForcePerForceMeasure has binding name 'eml23__ForcePerForceMeasure' for type 'eml23:ForcePerForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForcePerForceMeasure (-396)

#endif

/* eml23__ForceMeasureExt has binding name 'eml23__ForceMeasureExt' for type 'eml23:ForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasureExt (-395)

#endif

/* eml23__ForceMeasure has binding name 'eml23__ForceMeasure' for type 'eml23:ForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceMeasure (-394)

#endif

/* eml23__ForceLengthPerLengthMeasureExt has binding name 'eml23__ForceLengthPerLengthMeasureExt' for type 'eml23:ForceLengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasureExt (-393)

#endif

/* eml23__ForceLengthPerLengthMeasure has binding name 'eml23__ForceLengthPerLengthMeasure' for type 'eml23:ForceLengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceLengthPerLengthMeasure (-392)

#endif

/* eml23__ForceAreaMeasureExt has binding name 'eml23__ForceAreaMeasureExt' for type 'eml23:ForceAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasureExt (-391)

#endif

/* eml23__ForceAreaMeasure has binding name 'eml23__ForceAreaMeasure' for type 'eml23:ForceAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ForceAreaMeasure (-390)

#endif

/* eml23__EnergyPerVolumeMeasureExt has binding name 'eml23__EnergyPerVolumeMeasureExt' for type 'eml23:EnergyPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasureExt (-389)

#endif

/* eml23__EnergyPerVolumeMeasure has binding name 'eml23__EnergyPerVolumeMeasure' for type 'eml23:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerVolumeMeasure (-388)

#endif

/* eml23__EnergyPerMassPerTimeMeasureExt has binding name 'eml23__EnergyPerMassPerTimeMeasureExt' for type 'eml23:EnergyPerMassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasureExt (-387)

#endif

/* eml23__EnergyPerMassPerTimeMeasure has binding name 'eml23__EnergyPerMassPerTimeMeasure' for type 'eml23:EnergyPerMassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassPerTimeMeasure (-386)

#endif

/* eml23__EnergyPerMassMeasureExt has binding name 'eml23__EnergyPerMassMeasureExt' for type 'eml23:EnergyPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasureExt (-385)

#endif

/* eml23__EnergyPerMassMeasure has binding name 'eml23__EnergyPerMassMeasure' for type 'eml23:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerMassMeasure (-384)

#endif

/* eml23__EnergyPerLengthMeasureExt has binding name 'eml23__EnergyPerLengthMeasureExt' for type 'eml23:EnergyPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasureExt (-383)

#endif

/* eml23__EnergyPerLengthMeasure has binding name 'eml23__EnergyPerLengthMeasure' for type 'eml23:EnergyPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerLengthMeasure (-382)

#endif

/* eml23__EnergyPerAreaMeasureExt has binding name 'eml23__EnergyPerAreaMeasureExt' for type 'eml23:EnergyPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasureExt (-381)

#endif

/* eml23__EnergyPerAreaMeasure has binding name 'eml23__EnergyPerAreaMeasure' for type 'eml23:EnergyPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyPerAreaMeasure (-380)

#endif

/* eml23__EnergyMeasureExt has binding name 'eml23__EnergyMeasureExt' for type 'eml23:EnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasureExt (-379)

#endif

/* eml23__EnergyMeasure has binding name 'eml23__EnergyMeasure' for type 'eml23:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyMeasure (-378)

#endif

/* eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt has binding name 'eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt' for type 'eml23:EnergyLengthPerTimeAreaTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasureExt (-377)

#endif

/* eml23__EnergyLengthPerTimeAreaTemperatureMeasure has binding name 'eml23__EnergyLengthPerTimeAreaTemperatureMeasure' for type 'eml23:EnergyLengthPerTimeAreaTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerTimeAreaTemperatureMeasure (-376)

#endif

/* eml23__EnergyLengthPerAreaMeasureExt has binding name 'eml23__EnergyLengthPerAreaMeasureExt' for type 'eml23:EnergyLengthPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasureExt (-375)

#endif

/* eml23__EnergyLengthPerAreaMeasure has binding name 'eml23__EnergyLengthPerAreaMeasure' for type 'eml23:EnergyLengthPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__EnergyLengthPerAreaMeasure (-374)

#endif

/* eml23__ElectromagneticMomentMeasureExt has binding name 'eml23__ElectromagneticMomentMeasureExt' for type 'eml23:ElectromagneticMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasureExt (-373)

#endif

/* eml23__ElectromagneticMomentMeasure has binding name 'eml23__ElectromagneticMomentMeasure' for type 'eml23:ElectromagneticMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectromagneticMomentMeasure (-372)

#endif

/* eml23__ElectricResistancePerLengthMeasureExt has binding name 'eml23__ElectricResistancePerLengthMeasureExt' for type 'eml23:ElectricResistancePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasureExt (-371)

#endif

/* eml23__ElectricResistancePerLengthMeasure has binding name 'eml23__ElectricResistancePerLengthMeasure' for type 'eml23:ElectricResistancePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistancePerLengthMeasure (-370)

#endif

/* eml23__ElectricResistanceMeasureExt has binding name 'eml23__ElectricResistanceMeasureExt' for type 'eml23:ElectricResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasureExt (-369)

#endif

/* eml23__ElectricResistanceMeasure has binding name 'eml23__ElectricResistanceMeasure' for type 'eml23:ElectricResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricResistanceMeasure (-368)

#endif

/* eml23__ElectricPotentialDifferenceMeasureExt has binding name 'eml23__ElectricPotentialDifferenceMeasureExt' for type 'eml23:ElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasureExt (-367)

#endif

/* eml23__ElectricPotentialDifferenceMeasure has binding name 'eml23__ElectricPotentialDifferenceMeasure' for type 'eml23:ElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricPotentialDifferenceMeasure (-366)

#endif

/* eml23__ElectricFieldStrengthMeasureExt has binding name 'eml23__ElectricFieldStrengthMeasureExt' for type 'eml23:ElectricFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasureExt (-365)

#endif

/* eml23__ElectricFieldStrengthMeasure has binding name 'eml23__ElectricFieldStrengthMeasure' for type 'eml23:ElectricFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricFieldStrengthMeasure (-364)

#endif

/* eml23__ElectricCurrentMeasureExt has binding name 'eml23__ElectricCurrentMeasureExt' for type 'eml23:ElectricCurrentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasureExt (-363)

#endif

/* eml23__ElectricCurrentMeasure has binding name 'eml23__ElectricCurrentMeasure' for type 'eml23:ElectricCurrentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentMeasure (-362)

#endif

/* eml23__ElectricCurrentDensityMeasureExt has binding name 'eml23__ElectricCurrentDensityMeasureExt' for type 'eml23:ElectricCurrentDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasureExt (-361)

#endif

/* eml23__ElectricCurrentDensityMeasure has binding name 'eml23__ElectricCurrentDensityMeasure' for type 'eml23:ElectricCurrentDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricCurrentDensityMeasure (-360)

#endif

/* eml23__ElectricConductivityMeasureExt has binding name 'eml23__ElectricConductivityMeasureExt' for type 'eml23:ElectricConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasureExt (-359)

#endif

/* eml23__ElectricConductivityMeasure has binding name 'eml23__ElectricConductivityMeasure' for type 'eml23:ElectricConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductivityMeasure (-358)

#endif

/* eml23__ElectricConductanceMeasureExt has binding name 'eml23__ElectricConductanceMeasureExt' for type 'eml23:ElectricConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasureExt (-357)

#endif

/* eml23__ElectricConductanceMeasure has binding name 'eml23__ElectricConductanceMeasure' for type 'eml23:ElectricConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricConductanceMeasure (-356)

#endif

/* eml23__ElectricChargePerVolumeMeasureExt has binding name 'eml23__ElectricChargePerVolumeMeasureExt' for type 'eml23:ElectricChargePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasureExt (-355)

#endif

/* eml23__ElectricChargePerVolumeMeasure has binding name 'eml23__ElectricChargePerVolumeMeasure' for type 'eml23:ElectricChargePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerVolumeMeasure (-354)

#endif

/* eml23__ElectricChargePerMassMeasureExt has binding name 'eml23__ElectricChargePerMassMeasureExt' for type 'eml23:ElectricChargePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasureExt (-353)

#endif

/* eml23__ElectricChargePerMassMeasure has binding name 'eml23__ElectricChargePerMassMeasure' for type 'eml23:ElectricChargePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerMassMeasure (-352)

#endif

/* eml23__ElectricChargePerAreaMeasureExt has binding name 'eml23__ElectricChargePerAreaMeasureExt' for type 'eml23:ElectricChargePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasureExt (-351)

#endif

/* eml23__ElectricChargePerAreaMeasure has binding name 'eml23__ElectricChargePerAreaMeasure' for type 'eml23:ElectricChargePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargePerAreaMeasure (-350)

#endif

/* eml23__ElectricChargeMeasureExt has binding name 'eml23__ElectricChargeMeasureExt' for type 'eml23:ElectricChargeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasureExt (-349)

#endif

/* eml23__ElectricChargeMeasure has binding name 'eml23__ElectricChargeMeasure' for type 'eml23:ElectricChargeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricChargeMeasure (-348)

#endif

/* eml23__ElectricalResistivityMeasureExt has binding name 'eml23__ElectricalResistivityMeasureExt' for type 'eml23:ElectricalResistivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasureExt (-347)

#endif

/* eml23__ElectricalResistivityMeasure has binding name 'eml23__ElectricalResistivityMeasure' for type 'eml23:ElectricalResistivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ElectricalResistivityMeasure (-346)

#endif

/* eml23__DynamicViscosityMeasureExt has binding name 'eml23__DynamicViscosityMeasureExt' for type 'eml23:DynamicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasureExt (-345)

#endif

/* eml23__DynamicViscosityMeasure has binding name 'eml23__DynamicViscosityMeasure' for type 'eml23:DynamicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DynamicViscosityMeasure (-344)

#endif

/* eml23__DoseEquivalentMeasureExt has binding name 'eml23__DoseEquivalentMeasureExt' for type 'eml23:DoseEquivalentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasureExt (-343)

#endif

/* eml23__DoseEquivalentMeasure has binding name 'eml23__DoseEquivalentMeasure' for type 'eml23:DoseEquivalentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DoseEquivalentMeasure (-342)

#endif

/* eml23__DipoleMomentMeasureExt has binding name 'eml23__DipoleMomentMeasureExt' for type 'eml23:DipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasureExt (-341)

#endif

/* eml23__DipoleMomentMeasure has binding name 'eml23__DipoleMomentMeasure' for type 'eml23:DipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DipoleMomentMeasure (-340)

#endif

/* eml23__DimensionlessMeasureExt has binding name 'eml23__DimensionlessMeasureExt' for type 'eml23:DimensionlessMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasureExt (-339)

#endif

/* eml23__DimensionlessMeasure has binding name 'eml23__DimensionlessMeasure' for type 'eml23:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DimensionlessMeasure (-338)

#endif

/* eml23__DigitalStorageMeasureExt has binding name 'eml23__DigitalStorageMeasureExt' for type 'eml23:DigitalStorageMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasureExt (-337)

#endif

/* eml23__DigitalStorageMeasure has binding name 'eml23__DigitalStorageMeasure' for type 'eml23:DigitalStorageMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DigitalStorageMeasure (-336)

#endif

/* eml23__DiffusiveTimeOfFlightMeasureExt has binding name 'eml23__DiffusiveTimeOfFlightMeasureExt' for type 'eml23:DiffusiveTimeOfFlightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasureExt (-335)

#endif

/* eml23__DiffusiveTimeOfFlightMeasure has binding name 'eml23__DiffusiveTimeOfFlightMeasure' for type 'eml23:DiffusiveTimeOfFlightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusiveTimeOfFlightMeasure (-334)

#endif

/* eml23__DiffusionCoefficientMeasureExt has binding name 'eml23__DiffusionCoefficientMeasureExt' for type 'eml23:DiffusionCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasureExt (-333)

#endif

/* eml23__DiffusionCoefficientMeasure has binding name 'eml23__DiffusionCoefficientMeasure' for type 'eml23:DiffusionCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DiffusionCoefficientMeasure (-332)

#endif

/* eml23__DataTransferSpeedMeasureExt has binding name 'eml23__DataTransferSpeedMeasureExt' for type 'eml23:DataTransferSpeedMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasureExt (-331)

#endif

/* eml23__DataTransferSpeedMeasure has binding name 'eml23__DataTransferSpeedMeasure' for type 'eml23:DataTransferSpeedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataTransferSpeedMeasure (-330)

#endif

/* eml23__CationExchangeCapacityMeasureExt has binding name 'eml23__CationExchangeCapacityMeasureExt' for type 'eml23:CationExchangeCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasureExt (-329)

#endif

/* eml23__CationExchangeCapacityMeasure has binding name 'eml23__CationExchangeCapacityMeasure' for type 'eml23:CationExchangeCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__CationExchangeCapacityMeasure (-328)

#endif

/* eml23__CapacitanceMeasureExt has binding name 'eml23__CapacitanceMeasureExt' for type 'eml23:CapacitanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasureExt (-327)

#endif

/* eml23__CapacitanceMeasure has binding name 'eml23__CapacitanceMeasure' for type 'eml23:CapacitanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__CapacitanceMeasure (-326)

#endif

/* eml23__AttenuationPerFrequencyIntervalMeasureExt has binding name 'eml23__AttenuationPerFrequencyIntervalMeasureExt' for type 'eml23:AttenuationPerFrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasureExt (-325)

#endif

/* eml23__AttenuationPerFrequencyIntervalMeasure has binding name 'eml23__AttenuationPerFrequencyIntervalMeasure' for type 'eml23:AttenuationPerFrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AttenuationPerFrequencyIntervalMeasure (-324)

#endif

/* eml23__AreaPerVolumeMeasureExt has binding name 'eml23__AreaPerVolumeMeasureExt' for type 'eml23:AreaPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasureExt (-323)

#endif

/* eml23__AreaPerVolumeMeasure has binding name 'eml23__AreaPerVolumeMeasure' for type 'eml23:AreaPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerVolumeMeasure (-322)

#endif

/* eml23__AreaPerTimeMeasureExt has binding name 'eml23__AreaPerTimeMeasureExt' for type 'eml23:AreaPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasureExt (-321)

#endif

/* eml23__AreaPerTimeMeasure has binding name 'eml23__AreaPerTimeMeasure' for type 'eml23:AreaPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerTimeMeasure (-320)

#endif

/* eml23__AreaPerMassMeasureExt has binding name 'eml23__AreaPerMassMeasureExt' for type 'eml23:AreaPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasureExt (-319)

#endif

/* eml23__AreaPerMassMeasure has binding name 'eml23__AreaPerMassMeasure' for type 'eml23:AreaPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerMassMeasure (-318)

#endif

/* eml23__AreaPerCountMeasureExt has binding name 'eml23__AreaPerCountMeasureExt' for type 'eml23:AreaPerCountMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasureExt (-317)

#endif

/* eml23__AreaPerCountMeasure has binding name 'eml23__AreaPerCountMeasure' for type 'eml23:AreaPerCountMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerCountMeasure (-316)

#endif

/* eml23__AreaPerAreaMeasureExt has binding name 'eml23__AreaPerAreaMeasureExt' for type 'eml23:AreaPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasureExt (-315)

#endif

/* eml23__AreaPerAreaMeasure has binding name 'eml23__AreaPerAreaMeasure' for type 'eml23:AreaPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAreaMeasure (-314)

#endif

/* eml23__AreaPerAmountOfSubstanceMeasureExt has binding name 'eml23__AreaPerAmountOfSubstanceMeasureExt' for type 'eml23:AreaPerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasureExt (-313)

#endif

/* eml23__AreaPerAmountOfSubstanceMeasure has binding name 'eml23__AreaPerAmountOfSubstanceMeasure' for type 'eml23:AreaPerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaPerAmountOfSubstanceMeasure (-312)

#endif

/* eml23__AreaMeasureExt has binding name 'eml23__AreaMeasureExt' for type 'eml23:AreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasureExt (-311)

#endif

/* eml23__AreaMeasure has binding name 'eml23__AreaMeasure' for type 'eml23:AreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AreaMeasure (-310)

#endif

/* eml23__APINeutronMeasureExt has binding name 'eml23__APINeutronMeasureExt' for type 'eml23:APINeutronMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasureExt (-309)

#endif

/* eml23__APINeutronMeasure has binding name 'eml23__APINeutronMeasure' for type 'eml23:APINeutronMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APINeutronMeasure (-308)

#endif

/* eml23__APIGravityMeasureExt has binding name 'eml23__APIGravityMeasureExt' for type 'eml23:APIGravityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasureExt (-307)

#endif

/* eml23__APIGravityMeasure has binding name 'eml23__APIGravityMeasure' for type 'eml23:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGravityMeasure (-306)

#endif

/* eml23__APIGammaRayMeasureExt has binding name 'eml23__APIGammaRayMeasureExt' for type 'eml23:APIGammaRayMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasureExt (-305)

#endif

/* eml23__APIGammaRayMeasure has binding name 'eml23__APIGammaRayMeasure' for type 'eml23:APIGammaRayMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__APIGammaRayMeasure (-304)

#endif

/* eml23__AngularVelocityMeasureExt has binding name 'eml23__AngularVelocityMeasureExt' for type 'eml23:AngularVelocityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasureExt (-303)

#endif

/* eml23__AngularVelocityMeasure has binding name 'eml23__AngularVelocityMeasure' for type 'eml23:AngularVelocityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularVelocityMeasure (-302)

#endif

/* eml23__AngularAccelerationMeasureExt has binding name 'eml23__AngularAccelerationMeasureExt' for type 'eml23:AngularAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasureExt (-301)

#endif

/* eml23__AngularAccelerationMeasure has binding name 'eml23__AngularAccelerationMeasure' for type 'eml23:AngularAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AngularAccelerationMeasure (-300)

#endif

/* eml23__AnglePerVolumeMeasureExt has binding name 'eml23__AnglePerVolumeMeasureExt' for type 'eml23:AnglePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasureExt (-299)

#endif

/* eml23__AnglePerVolumeMeasure has binding name 'eml23__AnglePerVolumeMeasure' for type 'eml23:AnglePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerVolumeMeasure (-298)

#endif

/* eml23__AnglePerLengthMeasureExt has binding name 'eml23__AnglePerLengthMeasureExt' for type 'eml23:AnglePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasureExt (-297)

#endif

/* eml23__AnglePerLengthMeasure has binding name 'eml23__AnglePerLengthMeasure' for type 'eml23:AnglePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AnglePerLengthMeasure (-296)

#endif

/* eml23__AmountOfSubstancePerVolumeMeasureExt has binding name 'eml23__AmountOfSubstancePerVolumeMeasureExt' for type 'eml23:AmountOfSubstancePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasureExt (-295)

#endif

/* eml23__AmountOfSubstancePerVolumeMeasure has binding name 'eml23__AmountOfSubstancePerVolumeMeasure' for type 'eml23:AmountOfSubstancePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerVolumeMeasure (-294)

#endif

/* eml23__AmountOfSubstancePerTimePerAreaMeasureExt has binding name 'eml23__AmountOfSubstancePerTimePerAreaMeasureExt' for type 'eml23:AmountOfSubstancePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasureExt (-293)

#endif

/* eml23__AmountOfSubstancePerTimePerAreaMeasure has binding name 'eml23__AmountOfSubstancePerTimePerAreaMeasure' for type 'eml23:AmountOfSubstancePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimePerAreaMeasure (-292)

#endif

/* eml23__AmountOfSubstancePerTimeMeasureExt has binding name 'eml23__AmountOfSubstancePerTimeMeasureExt' for type 'eml23:AmountOfSubstancePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasureExt (-291)

#endif

/* eml23__AmountOfSubstancePerTimeMeasure has binding name 'eml23__AmountOfSubstancePerTimeMeasure' for type 'eml23:AmountOfSubstancePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerTimeMeasure (-290)

#endif

/* eml23__AmountOfSubstancePerAreaMeasureExt has binding name 'eml23__AmountOfSubstancePerAreaMeasureExt' for type 'eml23:AmountOfSubstancePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasureExt (-289)

#endif

/* eml23__AmountOfSubstancePerAreaMeasure has binding name 'eml23__AmountOfSubstancePerAreaMeasure' for type 'eml23:AmountOfSubstancePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAreaMeasure (-288)

#endif

/* eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt has binding name 'eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt' for type 'eml23:AmountOfSubstancePerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasureExt (-287)

#endif

/* eml23__AmountOfSubstancePerAmountOfSubstanceMeasure has binding name 'eml23__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml23:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstancePerAmountOfSubstanceMeasure (-286)

#endif

/* eml23__AmountOfSubstanceMeasureExt has binding name 'eml23__AmountOfSubstanceMeasureExt' for type 'eml23:AmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasureExt (-285)

#endif

/* eml23__AmountOfSubstanceMeasure has binding name 'eml23__AmountOfSubstanceMeasure' for type 'eml23:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AmountOfSubstanceMeasure (-284)

#endif

/* eml23__ActivityOfRadioactivityMeasureExt has binding name 'eml23__ActivityOfRadioactivityMeasureExt' for type 'eml23:ActivityOfRadioactivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasureExt (-283)

#endif

/* eml23__ActivityOfRadioactivityMeasure has binding name 'eml23__ActivityOfRadioactivityMeasure' for type 'eml23:ActivityOfRadioactivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__ActivityOfRadioactivityMeasure (-282)

#endif

/* eml23__AbsorbedDoseMeasureExt has binding name 'eml23__AbsorbedDoseMeasureExt' for type 'eml23:AbsorbedDoseMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasureExt (-281)

#endif

/* eml23__AbsorbedDoseMeasure has binding name 'eml23__AbsorbedDoseMeasure' for type 'eml23:AbsorbedDoseMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbsorbedDoseMeasure (-280)

#endif

/* eml23__ExternalDataArrayPart has binding name 'eml23__ExternalDataArrayPart' for type 'eml23:ExternalDataArrayPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArrayPart (-279)

#endif

/* eml23__ExternalDataArray has binding name 'eml23__ExternalDataArray' for type 'eml23:ExternalDataArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExternalDataArray (-278)

#endif

/* eml23__DataObjectReference has binding name 'eml23__DataObjectReference' for type 'eml23:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_3_eml23__DataObjectReference (-277)

#endif

/* eml23__ReferencePointInAWellbore has binding name 'eml23__ReferencePointInAWellbore' for type 'eml23:ReferencePointInAWellbore' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInAWellbore (-276)

#endif

/* eml23__ReferencePointInALocalEngineeringCompoundCrs has binding name 'eml23__ReferencePointInALocalEngineeringCompoundCrs' for type 'eml23:ReferencePointInALocalEngineeringCompoundCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInALocalEngineeringCompoundCrs (-275)

#endif

/* eml23__ReferencePointInACrs has binding name 'eml23__ReferencePointInACrs' for type 'eml23:ReferencePointInACrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs
#define SOAP_TYPE_gsoap_eml2_3_eml23__ReferencePointInACrs (-274)

#endif

/* eml23__RecursiveReferencePoint has binding name 'eml23__RecursiveReferencePoint' for type 'eml23:RecursiveReferencePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint
#define SOAP_TYPE_gsoap_eml2_3_eml23__RecursiveReferencePoint (-273)

#endif

/* eml23__PublicLandSurveySystemCoordinates has binding name 'eml23__PublicLandSurveySystemCoordinates' for type 'eml23:PublicLandSurveySystemCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__PublicLandSurveySystemCoordinates (-272)

#endif

/* eml23__ProjectedCoordinates has binding name 'eml23__ProjectedCoordinates' for type 'eml23:ProjectedCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__ProjectedCoordinates (-271)

#endif

/* eml23__HorizontalCoordinates has binding name 'eml23__HorizontalCoordinates' for type 'eml23:HorizontalCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__HorizontalCoordinates (-270)

#endif

/* eml23__GeodeticCoordinates has binding name 'eml23__GeodeticCoordinates' for type 'eml23:GeodeticCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__GeodeticCoordinates (-269)

#endif

/* eml23__AbstractReferencePoint has binding name 'eml23__AbstractReferencePoint' for type 'eml23:AbstractReferencePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractReferencePoint (-268)

#endif

/* eml23__AbstractHorizontalCoordinates has binding name 'eml23__AbstractHorizontalCoordinates' for type 'eml23:AbstractHorizontalCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractHorizontalCoordinates (-267)

#endif

/* eml23__VerticalDepthCoord has binding name 'eml23__VerticalDepthCoord' for type 'eml23:VerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_3_eml23__VerticalDepthCoord (-266)

#endif

/* eml23__TvdInterval has binding name 'eml23__TvdInterval' for type 'eml23:TvdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__TvdInterval (-265)

#endif

/* eml23__StringXmlArray has binding name 'eml23__StringXmlArray' for type 'eml23:StringXmlArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringXmlArray (-264)

#endif

/* eml23__StringMeasure has binding name 'eml23__StringMeasure' for type 'eml23:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringMeasure (-263)

#endif

/* eml23__StringExternalArray has binding name 'eml23__StringExternalArray' for type 'eml23:StringExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringExternalArray (-262)

#endif

/* eml23__StringConstantArray has binding name 'eml23__StringConstantArray' for type 'eml23:StringConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__StringConstantArray (-261)

#endif

/* eml23__MeasuredDepthCoord has binding name 'eml23__MeasuredDepthCoord' for type 'eml23:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_3_eml23__MeasuredDepthCoord (-260)

#endif

/* eml23__MdInterval has binding name 'eml23__MdInterval' for type 'eml23:MdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval
#define SOAP_TYPE_gsoap_eml2_3_eml23__MdInterval (-259)

#endif

/* eml23__JaggedArray has binding name 'eml23__JaggedArray' for type 'eml23:JaggedArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__JaggedArray (-258)

#endif

/* eml23__IntegerLatticeArray has binding name 'eml23__IntegerLatticeArray' for type 'eml23:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerLatticeArray (-257)

#endif

/* eml23__IntegerExternalArray has binding name 'eml23__IntegerExternalArray' for type 'eml23:IntegerExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerExternalArray (-256)

#endif

/* eml23__IntegerConstantArray has binding name 'eml23__IntegerConstantArray' for type 'eml23:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerConstantArray (-255)

#endif

/* eml23__IntegerArrayFromBooleanMaskArray has binding name 'eml23__IntegerArrayFromBooleanMaskArray' for type 'eml23:IntegerArrayFromBooleanMaskArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__IntegerArrayFromBooleanMaskArray (-254)

#endif

/* eml23__GenericMeasure has binding name 'eml23__GenericMeasure' for type 'eml23:GenericMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_3_eml23__GenericMeasure (-253)

#endif

/* eml23__FloatingPointXmlArray has binding name 'eml23__FloatingPointXmlArray' for type 'eml23:FloatingPointXmlArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointXmlArray (-252)

#endif

/* eml23__FloatingPointLatticeArray has binding name 'eml23__FloatingPointLatticeArray' for type 'eml23:FloatingPointLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointLatticeArray (-251)

#endif

/* eml23__FloatingPointExternalArray has binding name 'eml23__FloatingPointExternalArray' for type 'eml23:FloatingPointExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointExternalArray (-250)

#endif

/* eml23__FloatingPointConstantArray has binding name 'eml23__FloatingPointConstantArray' for type 'eml23:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__FloatingPointConstantArray (-249)

#endif

/* eml23__Cost has binding name 'eml23__Cost' for type 'eml23:Cost' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Cost
#define SOAP_TYPE_gsoap_eml2_3_eml23__Cost (-248)

#endif

/* eml23__BooleanExternalArray has binding name 'eml23__BooleanExternalArray' for type 'eml23:BooleanExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanExternalArray (-247)

#endif

/* eml23__BooleanConstantArray has binding name 'eml23__BooleanConstantArray' for type 'eml23:BooleanConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanConstantArray (-246)

#endif

/* eml23__BooleanArrayFromIndexArray has binding name 'eml23__BooleanArrayFromIndexArray' for type 'eml23:BooleanArrayFromIndexArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__BooleanArrayFromIndexArray (-245)

#endif

/* eml23__AuthorityQualifiedName has binding name 'eml23__AuthorityQualifiedName' for type 'eml23:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_3_eml23__AuthorityQualifiedName (-244)

#endif

/* eml23__AbstractValueArray has binding name 'eml23__AbstractValueArray' for type 'eml23:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractValueArray (-243)

#endif

/* eml23__AbstractStringArray has binding name 'eml23__AbstractStringArray' for type 'eml23:AbstractStringArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractStringArray (-242)

#endif

/* eml23__AbstractNumericArray has binding name 'eml23__AbstractNumericArray' for type 'eml23:AbstractNumericArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractNumericArray (-241)

#endif

/* eml23__AbstractIntegerArray has binding name 'eml23__AbstractIntegerArray' for type 'eml23:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractIntegerArray (-240)

#endif

/* eml23__AbstractFloatingPointArray has binding name 'eml23__AbstractFloatingPointArray' for type 'eml23:AbstractFloatingPointArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractFloatingPointArray (-239)

#endif

/* eml23__AbstractBooleanArray has binding name 'eml23__AbstractBooleanArray' for type 'eml23:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractBooleanArray (-238)

#endif

/* eml23__ObjectAlias has binding name 'eml23__ObjectAlias' for type 'eml23:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_3_eml23__ObjectAlias (-237)

#endif

/* eml23__ExtensionNameValue has binding name 'eml23__ExtensionNameValue' for type 'eml23:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_3_eml23__ExtensionNameValue (-236)

#endif

/* eml23__CustomData has binding name 'eml23__CustomData' for type 'eml23:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__CustomData
#define SOAP_TYPE_gsoap_eml2_3_eml23__CustomData (-235)

#endif

/* eml23__Citation has binding name 'eml23__Citation' for type 'eml23:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__Citation
#define SOAP_TYPE_gsoap_eml2_3_eml23__Citation (-234)

#endif

/* eml23__AbstractTimeIntervalGrowingPart has binding name 'eml23__AbstractTimeIntervalGrowingPart' for type 'eml23:AbstractTimeIntervalGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeIntervalGrowingPart (-233)

#endif

/* eml23__AbstractTimeGrowingPart has binding name 'eml23__AbstractTimeGrowingPart' for type 'eml23:AbstractTimeGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractTimeGrowingPart (-232)

#endif

/* eml23__AbstractObject has binding name 'eml23__AbstractObject' for type 'eml23:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractObject (-231)

#endif

/* eml23__AbstractMdIntervalGrowingPart has binding name 'eml23__AbstractMdIntervalGrowingPart' for type 'eml23:AbstractMdIntervalGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdIntervalGrowingPart (-230)

#endif

/* eml23__AbstractMdGrowingPart has binding name 'eml23__AbstractMdGrowingPart' for type 'eml23:AbstractMdGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractMdGrowingPart (-229)

#endif

/* eml23__AbstractGrowingObjectPart has binding name 'eml23__AbstractGrowingObjectPart' for type 'eml23:AbstractGrowingObjectPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObjectPart (-228)

#endif

/* eml23__AbstractGrowingObject has binding name 'eml23__AbstractGrowingObject' for type 'eml23:AbstractGrowingObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject
#define SOAP_TYPE_gsoap_eml2_3_eml23__AbstractGrowingObject (-227)

#endif

/* resqml22__WitsmlWellWellbore has binding name 'resqml22__WitsmlWellWellbore' for type 'resqml22:WitsmlWellWellbore' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WitsmlWellWellbore (-226)

#endif

/* resqml22__WellboreTrajectoryRepresentation has binding name 'resqml22__WellboreTrajectoryRepresentation' for type 'resqml22:WellboreTrajectoryRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryRepresentation (-225)

#endif

/* resqml22__WellboreTrajectoryParentIntersection has binding name 'resqml22__WellboreTrajectoryParentIntersection' for type 'resqml22:WellboreTrajectoryParentIntersection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreTrajectoryParentIntersection (-224)

#endif

/* resqml22__WellboreMarkerFrameRepresentation has binding name 'resqml22__WellboreMarkerFrameRepresentation' for type 'resqml22:WellboreMarkerFrameRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarkerFrameRepresentation (-223)

#endif

/* resqml22__WellboreMarker has binding name 'resqml22__WellboreMarker' for type 'resqml22:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreMarker (-222)

#endif

/* resqml22__WellboreInterpretation has binding name 'resqml22__WellboreInterpretation' for type 'resqml22:WellboreInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreInterpretation (-221)

#endif

/* resqml22__WellboreFrameRepresentation has binding name 'resqml22__WellboreFrameRepresentation' for type 'resqml22:WellboreFrameRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFrameRepresentation (-220)

#endif

/* resqml22__WellboreFeature has binding name 'resqml22__WellboreFeature' for type 'resqml22:WellboreFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreFeature (-219)

#endif

/* resqml22__TvdInformation has binding name 'resqml22__TvdInformation' for type 'resqml22:TvdInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TvdInformation (-218)

#endif

/* resqml22__SeismicWellboreFrameRepresentation has binding name 'resqml22__SeismicWellboreFrameRepresentation' for type 'resqml22:SeismicWellboreFrameRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicWellboreFrameRepresentation (-217)

#endif

/* resqml22__CorrectionInformation has binding name 'resqml22__CorrectionInformation' for type 'resqml22:CorrectionInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CorrectionInformation (-216)

#endif

/* resqml22__BlockedWellboreRepresentation has binding name 'resqml22__BlockedWellboreRepresentation' for type 'resqml22:BlockedWellboreRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BlockedWellboreRepresentation (-215)

#endif

/* resqml22__StreamlineWellbores has binding name 'resqml22__StreamlineWellbores' for type 'resqml22:StreamlineWellbores' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlineWellbores (-214)

#endif

/* resqml22__StreamlinesRepresentation has binding name 'resqml22__StreamlinesRepresentation' for type 'resqml22:StreamlinesRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesRepresentation (-213)

#endif

/* resqml22__StreamlinesFeature has binding name 'resqml22__StreamlinesFeature' for type 'resqml22:StreamlinesFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StreamlinesFeature (-212)

#endif

/* resqml22__PointsProperty has binding name 'resqml22__PointsProperty' for type 'resqml22:PointsProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointsProperty (-211)

#endif

/* resqml22__DiscreteProperty has binding name 'resqml22__DiscreteProperty' for type 'resqml22:DiscreteProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteProperty (-210)

#endif

/* resqml22__ContinuousProperty has binding name 'resqml22__ContinuousProperty' for type 'resqml22:ContinuousProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousProperty (-209)

#endif

/* resqml22__CommentProperty has binding name 'resqml22__CommentProperty' for type 'resqml22:CommentProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CommentProperty (-208)

#endif

/* resqml22__CategoricalProperty has binding name 'resqml22__CategoricalProperty' for type 'resqml22:CategoricalProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CategoricalProperty (-207)

#endif

/* resqml22__BooleanProperty has binding name 'resqml22__BooleanProperty' for type 'resqml22:BooleanProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanProperty (-206)

#endif

/* resqml22__BooleanArrayFromDiscretePropertyArray has binding name 'resqml22__BooleanArrayFromDiscretePropertyArray' for type 'resqml22:BooleanArrayFromDiscretePropertyArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BooleanArrayFromDiscretePropertyArray (-205)

#endif

/* resqml22__AbstractValuesProperty has binding name 'resqml22__AbstractValuesProperty' for type 'resqml22:AbstractValuesProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractValuesProperty (-204)

#endif

/* resqml22__AbstractProperty has binding name 'resqml22__AbstractProperty' for type 'resqml22:AbstractProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractProperty (-203)

#endif

/* resqml22__SizeInformation has binding name 'resqml22__SizeInformation' for type 'resqml22:SizeInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SizeInformation (-202)

#endif

/* resqml22__MinMax has binding name 'resqml22__MinMax' for type 'resqml22:MinMax' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MinMax (-201)

#endif

/* resqml22__HsvColor has binding name 'resqml22__HsvColor' for type 'resqml22:HsvColor' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HsvColor (-200)

#endif

/* resqml22__GraphicalInformationForWholeObject has binding name 'resqml22__GraphicalInformationForWholeObject' for type 'resqml22:GraphicalInformationForWholeObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForWholeObject (-199)

#endif

/* resqml22__GraphicalInformationForVolumes has binding name 'resqml22__GraphicalInformationForVolumes' for type 'resqml22:GraphicalInformationForVolumes' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForVolumes (-198)

#endif

/* resqml22__GraphicalInformationForNodes has binding name 'resqml22__GraphicalInformationForNodes' for type 'resqml22:GraphicalInformationForNodes' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForNodes (-197)

#endif

/* resqml22__GraphicalInformationForFaces has binding name 'resqml22__GraphicalInformationForFaces' for type 'resqml22:GraphicalInformationForFaces' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForFaces (-196)

#endif

/* resqml22__GraphicalInformationForEdges has binding name 'resqml22__GraphicalInformationForEdges' for type 'resqml22:GraphicalInformationForEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GraphicalInformationForEdges (-195)

#endif

/* resqml22__DiscreteColorMapEntry has binding name 'resqml22__DiscreteColorMapEntry' for type 'resqml22:DiscreteColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMapEntry (-194)

#endif

/* resqml22__DiscreteColorMap has binding name 'resqml22__DiscreteColorMap' for type 'resqml22:DiscreteColorMap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DiscreteColorMap (-193)

#endif

/* resqml22__DefaultGraphicalInformation has binding name 'resqml22__DefaultGraphicalInformation' for type 'resqml22:DefaultGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__DefaultGraphicalInformation (-192)

#endif

/* resqml22__ContourLineSetInformation has binding name 'resqml22__ContourLineSetInformation' for type 'resqml22:ContourLineSetInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContourLineSetInformation (-191)

#endif

/* resqml22__ContinuousColorMapEntry has binding name 'resqml22__ContinuousColorMapEntry' for type 'resqml22:ContinuousColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMapEntry (-190)

#endif

/* resqml22__ContinuousColorMap has binding name 'resqml22__ContinuousColorMap' for type 'resqml22:ContinuousColorMap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContinuousColorMap (-189)

#endif

/* resqml22__ColorMapDictionary has binding name 'resqml22__ColorMapDictionary' for type 'resqml22:ColorMapDictionary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColorMapDictionary (-188)

#endif

/* resqml22__ColorInformation has binding name 'resqml22__ColorInformation' for type 'resqml22:ColorInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColorInformation (-187)

#endif

/* resqml22__AnnotationInformation has binding name 'resqml22__AnnotationInformation' for type 'resqml22:AnnotationInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AnnotationInformation (-186)

#endif

/* resqml22__AlphaInformation has binding name 'resqml22__AlphaInformation' for type 'resqml22:AlphaInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AlphaInformation (-185)

#endif

/* resqml22__AbstractGraphicalInformationForIndexableElement has binding name 'resqml22__AbstractGraphicalInformationForIndexableElement' for type 'resqml22:AbstractGraphicalInformationForIndexableElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGraphicalInformationForIndexableElement (-184)

#endif

/* resqml22__AbstractColorMap has binding name 'resqml22__AbstractColorMap' for type 'resqml22:AbstractColorMap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColorMap (-183)

#endif

/* resqml22__VariableSubnodePatch has binding name 'resqml22__VariableSubnodePatch' for type 'resqml22:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VariableSubnodePatch (-182)

#endif

/* resqml22__UnstructuredSubnodeTopology has binding name 'resqml22__UnstructuredSubnodeTopology' for type 'resqml22:UnstructuredSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredSubnodeTopology (-181)

#endif

/* resqml22__UnstructuredGridRepresentation has binding name 'resqml22__UnstructuredGridRepresentation' for type 'resqml22:UnstructuredGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridRepresentation (-180)

#endif

/* resqml22__UnstructuredGridHingeNodeFaces has binding name 'resqml22__UnstructuredGridHingeNodeFaces' for type 'resqml22:UnstructuredGridHingeNodeFaces' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridHingeNodeFaces (-179)

#endif

/* resqml22__UnstructuredGridGeometry has binding name 'resqml22__UnstructuredGridGeometry' for type 'resqml22:UnstructuredGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGridGeometry (-178)

#endif

/* resqml22__UnstructuredGpGridPatch has binding name 'resqml22__UnstructuredGpGridPatch' for type 'resqml22:UnstructuredGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredGpGridPatch (-177)

#endif

/* resqml22__UnstructuredColumnLayerGridRepresentation has binding name 'resqml22__UnstructuredColumnLayerGridRepresentation' for type 'resqml22:UnstructuredColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridRepresentation (-176)

#endif

/* resqml22__UnstructuredColumnLayerGridGeometry has binding name 'resqml22__UnstructuredColumnLayerGridGeometry' for type 'resqml22:UnstructuredColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGridGeometry (-175)

#endif

/* resqml22__UnstructuredColumnLayerGpGridPatch has binding name 'resqml22__UnstructuredColumnLayerGpGridPatch' for type 'resqml22:UnstructuredColumnLayerGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnLayerGpGridPatch (-174)

#endif

/* resqml22__UnstructuredColumnEdges has binding name 'resqml22__UnstructuredColumnEdges' for type 'resqml22:UnstructuredColumnEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UnstructuredColumnEdges (-173)

#endif

/* resqml22__UniformSubnodePatch has binding name 'resqml22__UniformSubnodePatch' for type 'resqml22:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__UniformSubnodePatch (-172)

#endif

/* resqml22__TruncationCellPatch has binding name 'resqml22__TruncationCellPatch' for type 'resqml22:TruncationCellPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncationCellPatch (-171)

#endif

/* resqml22__TruncatedUnstructuredColumnLayerGridRepresentation has binding name 'resqml22__TruncatedUnstructuredColumnLayerGridRepresentation' for type 'resqml22:TruncatedUnstructuredColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedUnstructuredColumnLayerGridRepresentation (-170)

#endif

/* resqml22__TruncatedIjkGridRepresentation has binding name 'resqml22__TruncatedIjkGridRepresentation' for type 'resqml22:TruncatedIjkGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TruncatedIjkGridRepresentation (-169)

#endif

/* resqml22__SubnodeTopology has binding name 'resqml22__SubnodeTopology' for type 'resqml22:SubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodeTopology (-168)

#endif

/* resqml22__SubnodePatch has binding name 'resqml22__SubnodePatch' for type 'resqml22:SubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubnodePatch (-167)

#endif

/* resqml22__SplitNodePatch has binding name 'resqml22__SplitNodePatch' for type 'resqml22:SplitNodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitNodePatch (-166)

#endif

/* resqml22__SplitFaces has binding name 'resqml22__SplitFaces' for type 'resqml22:SplitFaces' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitFaces (-165)

#endif

/* resqml22__SplitEdges has binding name 'resqml22__SplitEdges' for type 'resqml22:SplitEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitEdges (-164)

#endif

/* resqml22__SplitColumnEdges has binding name 'resqml22__SplitColumnEdges' for type 'resqml22:SplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SplitColumnEdges (-163)

#endif

/* resqml22__Regrid has binding name 'resqml22__Regrid' for type 'resqml22:Regrid' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Regrid (-162)

#endif

/* resqml22__OverlapVolume has binding name 'resqml22__OverlapVolume' for type 'resqml22:OverlapVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume
#define SOAP_TYPE_gsoap_eml2_3_resqml22__OverlapVolume (-161)

#endif

/* resqml22__LocalGridSet has binding name 'resqml22__LocalGridSet' for type 'resqml22:LocalGridSet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__LocalGridSet (-160)

#endif

/* resqml22__KGaps has binding name 'resqml22__KGaps' for type 'resqml22:KGaps' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps
#define SOAP_TYPE_gsoap_eml2_3_resqml22__KGaps (-159)

#endif

/* resqml22__IntervalStratigraphicUnits has binding name 'resqml22__IntervalStratigraphicUnits' for type 'resqml22:IntervalStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalStratigraphicUnits (-158)

#endif

/* resqml22__Intervals has binding name 'resqml22__Intervals' for type 'resqml22:Intervals' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Intervals (-157)

#endif

/* resqml22__IntervalGridCells has binding name 'resqml22__IntervalGridCells' for type 'resqml22:IntervalGridCells' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IntervalGridCells (-156)

#endif

/* resqml22__IjkParentWindow has binding name 'resqml22__IjkParentWindow' for type 'resqml22:IjkParentWindow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkParentWindow (-155)

#endif

/* resqml22__IjkGridRepresentation has binding name 'resqml22__IjkGridRepresentation' for type 'resqml22:IjkGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridRepresentation (-154)

#endif

/* resqml22__IjkGridGeometry has binding name 'resqml22__IjkGridGeometry' for type 'resqml22:IjkGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGridGeometry (-153)

#endif

/* resqml22__IjkGpGridPatch has binding name 'resqml22__IjkGpGridPatch' for type 'resqml22:IjkGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjkGpGridPatch (-152)

#endif

/* resqml22__IjGaps has binding name 'resqml22__IjGaps' for type 'resqml22:IjGaps' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps
#define SOAP_TYPE_gsoap_eml2_3_resqml22__IjGaps (-151)

#endif

/* resqml22__GridConnectionSetRepresentation has binding name 'resqml22__GridConnectionSetRepresentation' for type 'resqml22:GridConnectionSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GridConnectionSetRepresentation (-150)

#endif

/* resqml22__Grid2dRepresentation has binding name 'resqml22__Grid2dRepresentation' for type 'resqml22:Grid2dRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Grid2dRepresentation (-149)

#endif

/* resqml22__GpGridRepresentation has binding name 'resqml22__GpGridRepresentation' for type 'resqml22:GpGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GpGridRepresentation (-148)

#endif

/* resqml22__Edges has binding name 'resqml22__Edges' for type 'resqml22:Edges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Edges
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Edges (-147)

#endif

/* resqml22__ConnectionInterpretations has binding name 'resqml22__ConnectionInterpretations' for type 'resqml22:ConnectionInterpretations' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ConnectionInterpretations (-146)

#endif

/* resqml22__ColumnSubnodePatch has binding name 'resqml22__ColumnSubnodePatch' for type 'resqml22:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnSubnodePatch (-145)

#endif

/* resqml22__ColumnLayerSubnodeTopology has binding name 'resqml22__ColumnLayerSubnodeTopology' for type 'resqml22:ColumnLayerSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSubnodeTopology (-144)

#endif

/* resqml22__ColumnLayerSplitCoordinateLines has binding name 'resqml22__ColumnLayerSplitCoordinateLines' for type 'resqml22:ColumnLayerSplitCoordinateLines' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerSplitCoordinateLines (-143)

#endif

/* resqml22__ColumnLayerParentWindow has binding name 'resqml22__ColumnLayerParentWindow' for type 'resqml22:ColumnLayerParentWindow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerParentWindow (-142)

#endif

/* resqml22__ColumnLayerGpGrid has binding name 'resqml22__ColumnLayerGpGrid' for type 'resqml22:ColumnLayerGpGrid' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ColumnLayerGpGrid (-141)

#endif

/* resqml22__CellParentWindow has binding name 'resqml22__CellParentWindow' for type 'resqml22:CellParentWindow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellParentWindow (-140)

#endif

/* resqml22__CellOverlap has binding name 'resqml22__CellOverlap' for type 'resqml22:CellOverlap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellOverlap (-139)

#endif

/* resqml22__CellFluidPhaseUnits has binding name 'resqml22__CellFluidPhaseUnits' for type 'resqml22:CellFluidPhaseUnits' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CellFluidPhaseUnits (-138)

#endif

/* resqml22__AlternateCellIndex has binding name 'resqml22__AlternateCellIndex' for type 'resqml22:AlternateCellIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AlternateCellIndex (-137)

#endif

/* resqml22__AdditionalGridTopology has binding name 'resqml22__AdditionalGridTopology' for type 'resqml22:AdditionalGridTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridTopology (-136)

#endif

/* resqml22__AdditionalGridPoints has binding name 'resqml22__AdditionalGridPoints' for type 'resqml22:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AdditionalGridPoints (-135)

#endif

/* resqml22__Activation has binding name 'resqml22__Activation' for type 'resqml22:Activation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Activation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Activation (-134)

#endif

/* resqml22__AbstractTruncatedColumnLayerGridRepresentation has binding name 'resqml22__AbstractTruncatedColumnLayerGridRepresentation' for type 'resqml22:AbstractTruncatedColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTruncatedColumnLayerGridRepresentation (-133)

#endif

/* resqml22__AbstractParentWindow has binding name 'resqml22__AbstractParentWindow' for type 'resqml22:AbstractParentWindow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParentWindow (-132)

#endif

/* resqml22__AbstractGridRepresentation has binding name 'resqml22__AbstractGridRepresentation' for type 'resqml22:AbstractGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridRepresentation (-131)

#endif

/* resqml22__AbstractGridGeometry has binding name 'resqml22__AbstractGridGeometry' for type 'resqml22:AbstractGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGridGeometry (-130)

#endif

/* resqml22__AbstractColumnLayerGridRepresentation has binding name 'resqml22__AbstractColumnLayerGridRepresentation' for type 'resqml22:AbstractColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridRepresentation (-129)

#endif

/* resqml22__AbstractColumnLayerGridGeometry has binding name 'resqml22__AbstractColumnLayerGridGeometry' for type 'resqml22:AbstractColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractColumnLayerGridGeometry (-128)

#endif

/* resqml22__WellboreIntervalSet has binding name 'resqml22__WellboreIntervalSet' for type 'resqml22:WellboreIntervalSet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__WellboreIntervalSet (-127)

#endif

/* resqml22__SubRepresentationPatch has binding name 'resqml22__SubRepresentationPatch' for type 'resqml22:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentationPatch (-126)

#endif

/* resqml22__SubRepresentation has binding name 'resqml22__SubRepresentation' for type 'resqml22:SubRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SubRepresentation (-125)

#endif

/* resqml22__StratigraphicIntervalBoundary has binding name 'resqml22__StratigraphicIntervalBoundary' for type 'resqml22:StratigraphicIntervalBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicIntervalBoundary (-124)

#endif

/* resqml22__RepresentationSetRepresentation has binding name 'resqml22__RepresentationSetRepresentation' for type 'resqml22:RepresentationSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationSetRepresentation (-123)

#endif

/* resqml22__RepresentationIdentitySet has binding name 'resqml22__RepresentationIdentitySet' for type 'resqml22:RepresentationIdentitySet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentitySet (-122)

#endif

/* resqml22__RepresentationIdentity has binding name 'resqml22__RepresentationIdentity' for type 'resqml22:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RepresentationIdentity (-121)

#endif

/* resqml22__PolylineSetPatch has binding name 'resqml22__PolylineSetPatch' for type 'resqml22:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetPatch (-120)

#endif

/* resqml22__Patch1d has binding name 'resqml22__Patch1d' for type 'resqml22:Patch1d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Patch1d (-119)

#endif

/* resqml22__MarkerInterval has binding name 'resqml22__MarkerInterval' for type 'resqml22:MarkerInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerInterval (-118)

#endif

/* resqml22__MarkerBoundary has binding name 'resqml22__MarkerBoundary' for type 'resqml22:MarkerBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MarkerBoundary (-117)

#endif

/* resqml22__FluidIntervalBoundary has binding name 'resqml22__FluidIntervalBoundary' for type 'resqml22:FluidIntervalBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidIntervalBoundary (-116)

#endif

/* resqml22__ElementIndices has binding name 'resqml22__ElementIndices' for type 'resqml22:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIndices (-115)

#endif

/* resqml22__ElementIdentity has binding name 'resqml22__ElementIdentity' for type 'resqml22:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ElementIdentity (-114)

#endif

/* resqml22__AbstractRepresentation has binding name 'resqml22__AbstractRepresentation' for type 'resqml22:AbstractRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractRepresentation (-113)

#endif

/* resqml22__VoidageGroupInterpretation has binding name 'resqml22__VoidageGroupInterpretation' for type 'resqml22:VoidageGroupInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VoidageGroupInterpretation (-112)

#endif

/* resqml22__StructuralOrganizationInterpretation has binding name 'resqml22__StructuralOrganizationInterpretation' for type 'resqml22:StructuralOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StructuralOrganizationInterpretation (-111)

#endif

/* resqml22__StratigraphicUnitInterpretation has binding name 'resqml22__StratigraphicUnitInterpretation' for type 'resqml22:StratigraphicUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicUnitInterpretation (-110)

#endif

/* resqml22__StratigraphicColumnRankInterpretation has binding name 'resqml22__StratigraphicColumnRankInterpretation' for type 'resqml22:StratigraphicColumnRankInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumnRankInterpretation (-109)

#endif

/* resqml22__StratigraphicColumn has binding name 'resqml22__StratigraphicColumn' for type 'resqml22:StratigraphicColumn' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn
#define SOAP_TYPE_gsoap_eml2_3_resqml22__StratigraphicColumn (-108)

#endif

/* resqml22__RockFluidUnitInterpretation has binding name 'resqml22__RockFluidUnitInterpretation' for type 'resqml22:RockFluidUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidUnitInterpretation (-107)

#endif

/* resqml22__RockFluidOrganizationInterpretation has binding name 'resqml22__RockFluidOrganizationInterpretation' for type 'resqml22:RockFluidOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockFluidOrganizationInterpretation (-106)

#endif

/* resqml22__ReservoirCompartmentUnitInterpretation has binding name 'resqml22__ReservoirCompartmentUnitInterpretation' for type 'resqml22:ReservoirCompartmentUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentUnitInterpretation (-105)

#endif

/* resqml22__ReservoirCompartmentInterpretation has binding name 'resqml22__ReservoirCompartmentInterpretation' for type 'resqml22:ReservoirCompartmentInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ReservoirCompartmentInterpretation (-104)

#endif

/* resqml22__MultipleContactInterpretationPart has binding name 'resqml22__MultipleContactInterpretationPart' for type 'resqml22:MultipleContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__MultipleContactInterpretationPart (-103)

#endif

/* resqml22__HorizonInterpretation has binding name 'resqml22__HorizonInterpretation' for type 'resqml22:HorizonInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizonInterpretation (-102)

#endif

/* resqml22__GeologicUnitOccurrenceInterpretation has binding name 'resqml22__GeologicUnitOccurrenceInterpretation' for type 'resqml22:GeologicUnitOccurrenceInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitOccurrenceInterpretation (-101)

#endif

/* resqml22__GeologicUnitInterpretation has binding name 'resqml22__GeologicUnitInterpretation' for type 'resqml22:GeologicUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicUnitInterpretation (-100)

#endif

/* resqml22__GeologicTimeBasedTimeInterval has binding name 'resqml22__GeologicTimeBasedTimeInterval' for type 'resqml22:GeologicTimeBasedTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeologicTimeBasedTimeInterval (-99)

#endif

/* resqml22__GeobodyInterpretation has binding name 'resqml22__GeobodyInterpretation' for type 'resqml22:GeobodyInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyInterpretation (-98)

#endif

/* resqml22__GeobodyBoundaryInterpretation has binding name 'resqml22__GeobodyBoundaryInterpretation' for type 'resqml22:GeobodyBoundaryInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeobodyBoundaryInterpretation (-97)

#endif

/* resqml22__GeneticBoundaryBasedTimeInterval has binding name 'resqml22__GeneticBoundaryBasedTimeInterval' for type 'resqml22:GeneticBoundaryBasedTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GeneticBoundaryBasedTimeInterval (-96)

#endif

/* resqml22__GenericFeatureInterpretation has binding name 'resqml22__GenericFeatureInterpretation' for type 'resqml22:GenericFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__GenericFeatureInterpretation (-95)

#endif

/* resqml22__FluidBoundaryInterpretation has binding name 'resqml22__FluidBoundaryInterpretation' for type 'resqml22:FluidBoundaryInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FluidBoundaryInterpretation (-94)

#endif

/* resqml22__FaultThrow has binding name 'resqml22__FaultThrow' for type 'resqml22:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FaultThrow (-93)

#endif

/* resqml22__FaultInterpretation has binding name 'resqml22__FaultInterpretation' for type 'resqml22:FaultInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__FaultInterpretation (-92)

#endif

/* resqml22__EarthModelInterpretation has binding name 'resqml22__EarthModelInterpretation' for type 'resqml22:EarthModelInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EarthModelInterpretation (-91)

#endif

/* resqml22__ContactElement has binding name 'resqml22__ContactElement' for type 'resqml22:ContactElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactElement (-90)

#endif

/* resqml22__BoundaryFeatureInterpretationPlusItsRank has binding name 'resqml22__BoundaryFeatureInterpretationPlusItsRank' for type 'resqml22:BoundaryFeatureInterpretationPlusItsRank' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretationPlusItsRank (-89)

#endif

/* resqml22__BoundaryFeatureInterpretation has binding name 'resqml22__BoundaryFeatureInterpretation' for type 'resqml22:BoundaryFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeatureInterpretation (-88)

#endif

/* resqml22__BinaryContactInterpretationPart has binding name 'resqml22__BinaryContactInterpretationPart' for type 'resqml22:BinaryContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BinaryContactInterpretationPart (-87)

#endif

/* resqml22__AbstractTimeInterval has binding name 'resqml22__AbstractTimeInterval' for type 'resqml22:AbstractTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTimeInterval (-86)

#endif

/* resqml22__AbstractOrganizationInterpretation has binding name 'resqml22__AbstractOrganizationInterpretation' for type 'resqml22:AbstractOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractOrganizationInterpretation (-85)

#endif

/* resqml22__AbstractGeologicUnitOrganizationInterpretation has binding name 'resqml22__AbstractGeologicUnitOrganizationInterpretation' for type 'resqml22:AbstractGeologicUnitOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeologicUnitOrganizationInterpretation (-84)

#endif

/* resqml22__AbstractFeatureInterpretation has binding name 'resqml22__AbstractFeatureInterpretation' for type 'resqml22:AbstractFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeatureInterpretation (-83)

#endif

/* resqml22__AbstractContactInterpretationPart has binding name 'resqml22__AbstractContactInterpretationPart' for type 'resqml22:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractContactInterpretationPart (-82)

#endif

/* resqml22__VolumeShell has binding name 'resqml22__VolumeShell' for type 'resqml22:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeShell (-81)

#endif

/* resqml22__VolumeRegion has binding name 'resqml22__VolumeRegion' for type 'resqml22:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion
#define SOAP_TYPE_gsoap_eml2_3_resqml22__VolumeRegion (-80)

#endif

/* resqml22__TriangulatedSetRepresentation has binding name 'resqml22__TriangulatedSetRepresentation' for type 'resqml22:TriangulatedSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TriangulatedSetRepresentation (-79)

#endif

/* resqml22__TrianglePatch has binding name 'resqml22__TrianglePatch' for type 'resqml22:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TrianglePatch (-78)

#endif

/* resqml22__SealedVolumeFrameworkRepresentation has binding name 'resqml22__SealedVolumeFrameworkRepresentation' for type 'resqml22:SealedVolumeFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedVolumeFrameworkRepresentation (-77)

#endif

/* resqml22__SealedSurfaceFrameworkRepresentation has binding name 'resqml22__SealedSurfaceFrameworkRepresentation' for type 'resqml22:SealedSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedSurfaceFrameworkRepresentation (-76)

#endif

/* resqml22__SealedContact has binding name 'resqml22__SealedContact' for type 'resqml22:SealedContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SealedContact (-75)

#endif

/* resqml22__PolylineSetRepresentation has binding name 'resqml22__PolylineSetRepresentation' for type 'resqml22:PolylineSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineSetRepresentation (-74)

#endif

/* resqml22__PolylineRepresentation has binding name 'resqml22__PolylineRepresentation' for type 'resqml22:PolylineRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PolylineRepresentation (-73)

#endif

/* resqml22__PointSetRepresentation has binding name 'resqml22__PointSetRepresentation' for type 'resqml22:PointSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointSetRepresentation (-72)

#endif

/* resqml22__PlaneSetRepresentation has binding name 'resqml22__PlaneSetRepresentation' for type 'resqml22:PlaneSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PlaneSetRepresentation (-71)

#endif

/* resqml22__PatchBoundaries has binding name 'resqml22__PatchBoundaries' for type 'resqml22:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PatchBoundaries (-70)

#endif

/* resqml22__NonSealedSurfaceFrameworkRepresentation has binding name 'resqml22__NonSealedSurfaceFrameworkRepresentation' for type 'resqml22:NonSealedSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedSurfaceFrameworkRepresentation (-69)

#endif

/* resqml22__NonSealedContact has binding name 'resqml22__NonSealedContact' for type 'resqml22:NonSealedContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NonSealedContact (-68)

#endif

/* resqml22__NodePatch has binding name 'resqml22__NodePatch' for type 'resqml22:NodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__NodePatch (-67)

#endif

/* resqml22__EdgePatch has binding name 'resqml22__EdgePatch' for type 'resqml22:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__EdgePatch (-66)

#endif

/* resqml22__ContactReference has binding name 'resqml22__ContactReference' for type 'resqml22:ContactReference' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactReference (-65)

#endif

/* resqml22__ContactPatch has binding name 'resqml22__ContactPatch' for type 'resqml22:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactPatch (-64)

#endif

/* resqml22__ContactIdentity has binding name 'resqml22__ContactIdentity' for type 'resqml22:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ContactIdentity (-63)

#endif

/* resqml22__AbstractSurfaceRepresentation has binding name 'resqml22__AbstractSurfaceRepresentation' for type 'resqml22:AbstractSurfaceRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceRepresentation (-62)

#endif

/* resqml22__AbstractSurfaceFrameworkRepresentation has binding name 'resqml22__AbstractSurfaceFrameworkRepresentation' for type 'resqml22:AbstractSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkRepresentation (-61)

#endif

/* resqml22__AbstractSurfaceFrameworkContact has binding name 'resqml22__AbstractSurfaceFrameworkContact' for type 'resqml22:AbstractSurfaceFrameworkContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSurfaceFrameworkContact (-60)

#endif

/* resqml22__ShotPointLineFeature has binding name 'resqml22__ShotPointLineFeature' for type 'resqml22:ShotPointLineFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ShotPointLineFeature (-59)

#endif

/* resqml22__SeismicLineSetFeature has binding name 'resqml22__SeismicLineSetFeature' for type 'resqml22:SeismicLineSetFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLineSetFeature (-58)

#endif

/* resqml22__SeismicLatticeSetFeature has binding name 'resqml22__SeismicLatticeSetFeature' for type 'resqml22:SeismicLatticeSetFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeSetFeature (-57)

#endif

/* resqml22__SeismicLatticeFeature has binding name 'resqml22__SeismicLatticeFeature' for type 'resqml22:SeismicLatticeFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SeismicLatticeFeature (-56)

#endif

/* resqml22__Seismic3dPostStackRepresentation has binding name 'resqml22__Seismic3dPostStackRepresentation' for type 'resqml22:Seismic3dPostStackRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dPostStackRepresentation (-55)

#endif

/* resqml22__Seismic3dCoordinates has binding name 'resqml22__Seismic3dCoordinates' for type 'resqml22:Seismic3dCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic3dCoordinates (-54)

#endif

/* resqml22__Seismic2dPostStackRepresentation has binding name 'resqml22__Seismic2dPostStackRepresentation' for type 'resqml22:Seismic2dPostStackRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dPostStackRepresentation (-53)

#endif

/* resqml22__Seismic2dCoordinates has binding name 'resqml22__Seismic2dCoordinates' for type 'resqml22:Seismic2dCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Seismic2dCoordinates (-52)

#endif

/* resqml22__CmpLineFeature has binding name 'resqml22__CmpLineFeature' for type 'resqml22:CmpLineFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CmpLineFeature (-51)

#endif

/* resqml22__AbstractSeismicSurveyFeature has binding name 'resqml22__AbstractSeismicSurveyFeature' for type 'resqml22:AbstractSeismicSurveyFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicSurveyFeature (-50)

#endif

/* resqml22__AbstractSeismicLineFeature has binding name 'resqml22__AbstractSeismicLineFeature' for type 'resqml22:AbstractSeismicLineFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicLineFeature (-49)

#endif

/* resqml22__AbstractSeismicCoordinates has binding name 'resqml22__AbstractSeismicCoordinates' for type 'resqml22:AbstractSeismicCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractSeismicCoordinates (-48)

#endif

/* resqml22__TiltedPlaneGeometry has binding name 'resqml22__TiltedPlaneGeometry' for type 'resqml22:TiltedPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__TiltedPlaneGeometry (-47)

#endif

/* resqml22__ThreePoint3d has binding name 'resqml22__ThreePoint3d' for type 'resqml22:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ThreePoint3d (-46)

#endif

/* resqml22__SinglePointGeometry has binding name 'resqml22__SinglePointGeometry' for type 'resqml22:SinglePointGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__SinglePointGeometry (-45)

#endif

/* resqml22__PointGeometry has binding name 'resqml22__PointGeometry' for type 'resqml22:PointGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__PointGeometry (-44)

#endif

/* resqml22__Point3dZValueArray has binding name 'resqml22__Point3dZValueArray' for type 'resqml22:Point3dZValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dZValueArray (-43)

#endif

/* resqml22__Point3dParametricArray has binding name 'resqml22__Point3dParametricArray' for type 'resqml22:Point3dParametricArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dParametricArray (-42)

#endif

/* resqml22__Point3dLatticeDimension has binding name 'resqml22__Point3dLatticeDimension' for type 'resqml22:Point3dLatticeDimension' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeDimension (-41)

#endif

/* resqml22__Point3dLatticeArray has binding name 'resqml22__Point3dLatticeArray' for type 'resqml22:Point3dLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dLatticeArray (-40)

#endif

/* resqml22__Point3dFromRepresentationLatticeArray has binding name 'resqml22__Point3dFromRepresentationLatticeArray' for type 'resqml22:Point3dFromRepresentationLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dFromRepresentationLatticeArray (-39)

#endif

/* resqml22__Point3dExternalArray has binding name 'resqml22__Point3dExternalArray' for type 'resqml22:Point3dExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3dExternalArray (-38)

#endif

/* resqml22__Point3d has binding name 'resqml22__Point3d' for type 'resqml22:Point3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point3d (-37)

#endif

/* resqml22__Point2dExternalArray has binding name 'resqml22__Point2dExternalArray' for type 'resqml22:Point2dExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Point2dExternalArray (-36)

#endif

/* resqml22__ParametricLineIntersections has binding name 'resqml22__ParametricLineIntersections' for type 'resqml22:ParametricLineIntersections' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineIntersections (-35)

#endif

/* resqml22__ParametricLineGeometry has binding name 'resqml22__ParametricLineGeometry' for type 'resqml22:ParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineGeometry (-34)

#endif

/* resqml22__ParametricLineFromRepresentationLatticeArray has binding name 'resqml22__ParametricLineFromRepresentationLatticeArray' for type 'resqml22:ParametricLineFromRepresentationLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationLatticeArray (-33)

#endif

/* resqml22__ParametricLineFromRepresentationGeometry has binding name 'resqml22__ParametricLineFromRepresentationGeometry' for type 'resqml22:ParametricLineFromRepresentationGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineFromRepresentationGeometry (-32)

#endif

/* resqml22__ParametricLineArray has binding name 'resqml22__ParametricLineArray' for type 'resqml22:ParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__ParametricLineArray (-31)

#endif

/* resqml22__HorizontalPlaneGeometry has binding name 'resqml22__HorizontalPlaneGeometry' for type 'resqml22:HorizontalPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__HorizontalPlaneGeometry (-30)

#endif

/* resqml22__Graph2dRepresentation has binding name 'resqml22__Graph2dRepresentation' for type 'resqml22:Graph2dRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Graph2dRepresentation (-29)

#endif

/* resqml22__AbstractPoint3dArray has binding name 'resqml22__AbstractPoint3dArray' for type 'resqml22:AbstractPoint3dArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPoint3dArray (-28)

#endif

/* resqml22__AbstractPlaneGeometry has binding name 'resqml22__AbstractPlaneGeometry' for type 'resqml22:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractPlaneGeometry (-27)

#endif

/* resqml22__AbstractParametricLineGeometry has binding name 'resqml22__AbstractParametricLineGeometry' for type 'resqml22:AbstractParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineGeometry (-26)

#endif

/* resqml22__AbstractParametricLineArray has binding name 'resqml22__AbstractParametricLineArray' for type 'resqml22:AbstractParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractParametricLineArray (-25)

#endif

/* resqml22__AbstractGeometry has binding name 'resqml22__AbstractGeometry' for type 'resqml22:AbstractGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractGeometry (-24)

#endif

/* resqml22__RockVolumeFeature has binding name 'resqml22__RockVolumeFeature' for type 'resqml22:RockVolumeFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__RockVolumeFeature (-23)

#endif

/* resqml22__Model has binding name 'resqml22__Model' for type 'resqml22:Model' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__Model
#define SOAP_TYPE_gsoap_eml2_3_resqml22__Model (-22)

#endif

/* resqml22__CulturalFeature has binding name 'resqml22__CulturalFeature' for type 'resqml22:CulturalFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__CulturalFeature (-21)

#endif

/* resqml22__BoundaryFeature has binding name 'resqml22__BoundaryFeature' for type 'resqml22:BoundaryFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__BoundaryFeature (-20)

#endif

/* resqml22__AbstractTechnicalFeature has binding name 'resqml22__AbstractTechnicalFeature' for type 'resqml22:AbstractTechnicalFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractTechnicalFeature (-19)

#endif

/* resqml22__AbstractFeature has binding name 'resqml22__AbstractFeature' for type 'resqml22:AbstractFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature
#define SOAP_TYPE_gsoap_eml2_3_resqml22__AbstractFeature (-18)

#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_3_xsd__anyURI (-17)

#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__string
#define SOAP_TYPE_gsoap_eml2_3_std__string (-16)

#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary
#define SOAP_TYPE_gsoap_eml2_3_xsd__base64Binary (-8)

#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Fault (-845615111)

#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Reason (-845615110)

#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Detail (-845615107)

#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Code (-845615105)

#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_3_SOAP_ENV__Header (-845615104)

#endif

/* eml23__TimeStamp has binding name 'eml23__TimeStamp' for type 'eml23:TimeStamp' */
#ifndef SOAP_TYPE_eml23__TimeStamp
#define SOAP_TYPE_eml23__TimeStamp (-953)

#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (-13)

#endif

/* struct tm has binding name 'tm' for type 'tm' */
#ifndef SOAP_TYPE_gsoap_eml2_3_tm
#define SOAP_TYPE_gsoap_eml2_3_tm (-12)

#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Reason (-845615113)

#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Detail (-845615112)

#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_3_PointerToSOAP_ENV__Code (-845615106)

#endif

/* resqml22__IjGaps * has binding name 'PointerToresqml22__IjGaps' for type 'resqml22:IjGaps' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjGaps
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjGaps (-1497)

#endif

/* resqml22__SealedContact * has binding name 'PointerToresqml22__SealedContact' for type 'resqml22:SealedContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SealedContact
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SealedContact (-1495)

#endif

/* resqml22__AbstractSurfaceFrameworkContact * has binding name 'PointerToresqml22__AbstractSurfaceFrameworkContact' for type 'resqml22:AbstractSurfaceFrameworkContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractSurfaceFrameworkContact
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractSurfaceFrameworkContact (-1493)

#endif

/* resqml22__SeismicLatticeSetFeature * has binding name 'PointerToresqml22__SeismicLatticeSetFeature' for type 'resqml22:SeismicLatticeSetFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SeismicLatticeSetFeature (-1492)

#endif

/* eml23__StringExternalArray * has binding name 'PointerToeml23__StringExternalArray' for type 'eml23:StringExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__StringExternalArray (-1491)

#endif

/* eml23__IntegerConstantArray * has binding name 'PointerToeml23__IntegerConstantArray' for type 'eml23:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerConstantArray (-1489)

#endif

/* eml23__FloatingPointConstantArray * has binding name 'PointerToeml23__FloatingPointConstantArray' for type 'eml23:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FloatingPointConstantArray (-1487)

#endif

/* resqml22__WellboreMarker * has binding name 'PointerToresqml22__WellboreMarker' for type 'resqml22:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WellboreMarker
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WellboreMarker (-1485)

#endif

/* resqml22__WitsmlWellWellbore * has binding name 'PointerToresqml22__WitsmlWellWellbore' for type 'resqml22:WitsmlWellWellbore' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WitsmlWellWellbore
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WitsmlWellWellbore (-1484)

#endif

/* resqml22__CorrectionInformation * has binding name 'PointerToresqml22__CorrectionInformation' for type 'resqml22:CorrectionInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CorrectionInformation
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CorrectionInformation (-1483)

#endif

/* resqml22__TvdInformation * has binding name 'PointerToresqml22__TvdInformation' for type 'resqml22:TvdInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TvdInformation
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TvdInformation (-1482)

#endif

/* eml23__ColumnBasedTable * has binding name 'PointerToeml23__ColumnBasedTable' for type 'eml23:ColumnBasedTable' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ColumnBasedTable
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ColumnBasedTable (-1481)

#endif

/* resqml22__AlternateCellIndex * has binding name 'PointerToresqml22__AlternateCellIndex' for type 'resqml22:AlternateCellIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AlternateCellIndex
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AlternateCellIndex (-1480)

#endif

/* resqml22__UnstructuredGridHingeNodeFaces * has binding name 'PointerToresqml22__UnstructuredGridHingeNodeFaces' for type 'resqml22:UnstructuredGridHingeNodeFaces' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGridHingeNodeFaces (-1479)

#endif

/* resqml22__UnstructuredGpGridPatch * has binding name 'PointerToresqml22__UnstructuredGpGridPatch' for type 'resqml22:UnstructuredGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGpGridPatch (-1477)

#endif

/* resqml22__ColumnLayerGpGrid * has binding name 'PointerToresqml22__ColumnLayerGpGrid' for type 'resqml22:ColumnLayerGpGrid' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerGpGrid
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerGpGrid (-1475)

#endif

/* resqml22__ColumnLayerSplitCoordinateLines * has binding name 'PointerToresqml22__ColumnLayerSplitCoordinateLines' for type 'resqml22:ColumnLayerSplitCoordinateLines' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerSplitCoordinateLines (-1474)

#endif

/* resqml22__BoundaryFeatureInterpretationPlusItsRank * has binding name 'PointerToresqml22__BoundaryFeatureInterpretationPlusItsRank' for type 'resqml22:BoundaryFeatureInterpretationPlusItsRank' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__BoundaryFeatureInterpretationPlusItsRank
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__BoundaryFeatureInterpretationPlusItsRank (-1471)

#endif

/* resqml22__StratigraphicUnitKind * has binding name 'PointerToresqml22__StratigraphicUnitKind' for type 'resqml22:StratigraphicUnitKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__StratigraphicUnitKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__StratigraphicUnitKind (-1470)

#endif

/* resqml22__DepositionMode * has binding name 'PointerToresqml22__DepositionMode' for type 'resqml22:DepositionMode' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionMode
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionMode (-1469)

#endif

/* resqml22__Phase * has binding name 'PointerToresqml22__Phase' for type 'resqml22:Phase' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Phase
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Phase (-1468)

#endif

/* resqml22__SequenceStratigraphySurfaceKind * has binding name 'PointerToresqml22__SequenceStratigraphySurfaceKind' for type 'resqml22:SequenceStratigraphySurfaceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SequenceStratigraphySurfaceKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SequenceStratigraphySurfaceKind (-1467)

#endif

/* resqml22__FaultThrow * has binding name 'PointerToresqml22__FaultThrow' for type 'resqml22:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FaultThrow
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FaultThrow (-1464)

#endif

/* eml23__LengthMeasure * has binding name 'PointerToeml23__LengthMeasure' for type 'eml23:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthMeasure (-1463)

#endif

/* resqml22__TrianglePatch * has binding name 'PointerToresqml22__TrianglePatch' for type 'resqml22:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TrianglePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TrianglePatch (-1461)

#endif

/* resqml22__VolumeRegion * has binding name 'PointerToresqml22__VolumeRegion' for type 'resqml22:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VolumeRegion
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VolumeRegion (-1459)

#endif

/* resqml22__AbstractPlaneGeometry * has binding name 'PointerToresqml22__AbstractPlaneGeometry' for type 'resqml22:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractPlaneGeometry (-1457)

#endif

/* resqml22__ContactIdentity * has binding name 'PointerToresqml22__ContactIdentity' for type 'resqml22:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactIdentity
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactIdentity (-1455)

#endif

/* eml23__ReferencePressureKind * has binding name 'PointerToeml23__ReferencePressureKind' for type 'eml23:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePressureKind (-1454)

#endif

/* eml23__AbstractHorizontalCoordinates * has binding name 'PointerToeml23__AbstractHorizontalCoordinates' for type 'eml23:AbstractHorizontalCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractHorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractHorizontalCoordinates (-1453)

#endif

/* eml23__HorizontalCoordinates * has binding name 'PointerToeml23__HorizontalCoordinates' for type 'eml23:HorizontalCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__HorizontalCoordinates
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__HorizontalCoordinates (-1452)

#endif

/* resqml22__AbstractParametricLineGeometry * has binding name 'PointerToresqml22__AbstractParametricLineGeometry' for type 'resqml22:AbstractParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParametricLineGeometry (-1451)

#endif

/* resqml22__WellboreTrajectoryParentIntersection * has binding name 'PointerToresqml22__WellboreTrajectoryParentIntersection' for type 'resqml22:WellboreTrajectoryParentIntersection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__WellboreTrajectoryParentIntersection (-1450)

#endif

/* resqml22__MdDomain * has binding name 'PointerToresqml22__MdDomain' for type 'resqml22:MdDomain' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MdDomain
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MdDomain (-1449)

#endif

/* resqml22__StreamlineWellbores * has binding name 'PointerToresqml22__StreamlineWellbores' for type 'resqml22:StreamlineWellbores' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__StreamlineWellbores
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__StreamlineWellbores (-1447)

#endif

/* resqml22__DiscreteColorMapEntry * has binding name 'PointerToresqml22__DiscreteColorMapEntry' for type 'resqml22:DiscreteColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DiscreteColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DiscreteColorMapEntry (-1443)

#endif

/* resqml22__ContinuousColorMapEntry * has binding name 'PointerToresqml22__ContinuousColorMapEntry' for type 'resqml22:ContinuousColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContinuousColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContinuousColorMapEntry (-1441)

#endif

/* resqml22__ConnectionInterpretations * has binding name 'PointerToresqml22__ConnectionInterpretations' for type 'resqml22:ConnectionInterpretations' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ConnectionInterpretations
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ConnectionInterpretations (-1440)

#endif

/* resqml22__IntervalStratigraphicUnits * has binding name 'PointerToresqml22__IntervalStratigraphicUnits' for type 'resqml22:IntervalStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IntervalStratigraphicUnits (-1439)

#endif

/* resqml22__AbstractParentWindow * has binding name 'PointerToresqml22__AbstractParentWindow' for type 'resqml22:AbstractParentWindow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParentWindow
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParentWindow (-1438)

#endif

/* resqml22__CellFluidPhaseUnits * has binding name 'PointerToresqml22__CellFluidPhaseUnits' for type 'resqml22:CellFluidPhaseUnits' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CellFluidPhaseUnits (-1437)

#endif

/* resqml22__AdditionalGridPoints * has binding name 'PointerToresqml22__AdditionalGridPoints' for type 'resqml22:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AdditionalGridPoints
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AdditionalGridPoints (-1435)

#endif

/* resqml22__MarkerInterval * has binding name 'PointerToresqml22__MarkerInterval' for type 'resqml22:MarkerInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MarkerInterval
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MarkerInterval (-1433)

#endif

/* resqml22__MarkerBoundary * has binding name 'PointerToresqml22__MarkerBoundary' for type 'resqml22:MarkerBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MarkerBoundary
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MarkerBoundary (-1431)

#endif

/* resqml22__SubRepresentationPatch * has binding name 'PointerToresqml22__SubRepresentationPatch' for type 'resqml22:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SubRepresentationPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SubRepresentationPatch (-1429)

#endif

/* resqml22__DepositionalFaciesKind * has binding name 'PointerToresqml22__DepositionalFaciesKind' for type 'resqml22:DepositionalFaciesKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionalFaciesKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionalFaciesKind (-1428)

#endif

/* std::string * has binding name 'PointerToresqml22__DepositionalEnvironmentKind' for type 'resqml22:DepositionalEnvironmentKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionalEnvironmentKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DepositionalEnvironmentKind (-1427)

#endif

/* std::string * has binding name 'PointerToresqml22__Shape3dExt' for type 'resqml22:Shape3dExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Shape3dExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Shape3dExt (-1426)

#endif

/* resqml22__GeologicUnitMaterialEmplacement * has binding name 'PointerToresqml22__GeologicUnitMaterialEmplacement' for type 'resqml22:GeologicUnitMaterialEmplacement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GeologicUnitMaterialEmplacement
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GeologicUnitMaterialEmplacement (-1425)

#endif

/* std::string * has binding name 'PointerToeml23__LithologyKindExt' for type 'eml23:LithologyKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LithologyKindExt (-1424)

#endif

/* resqml22__AbstractContactInterpretationPart * has binding name 'PointerToresqml22__AbstractContactInterpretationPart' for type 'resqml22:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractContactInterpretationPart (-1422)

#endif

/* resqml22__PolylineSetPatch * has binding name 'PointerToresqml22__PolylineSetPatch' for type 'resqml22:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PolylineSetPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PolylineSetPatch (-1420)

#endif

/* std::string * has binding name 'PointerToresqml22__LineRoleExt' for type 'resqml22:LineRoleExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__LineRoleExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__LineRoleExt (-1419)

#endif

/* resqml22__NodePatch * has binding name 'PointerToresqml22__NodePatch' for type 'resqml22:NodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__NodePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__NodePatch (-1417)

#endif

/* resqml22__PatchBoundaries * has binding name 'PointerToresqml22__PatchBoundaries' for type 'resqml22:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PatchBoundaries
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PatchBoundaries (-1415)

#endif

/* eml23__FloatingPointLatticeArray * has binding name 'PointerToeml23__FloatingPointLatticeArray' for type 'eml23:FloatingPointLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FloatingPointLatticeArray (-1414)

#endif

/* resqml22__ThreePoint3d * has binding name 'PointerToresqml22__ThreePoint3d' for type 'resqml22:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ThreePoint3d
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ThreePoint3d (-1412)

#endif

/* eml23__ThermodynamicTemperatureMeasure * has binding name 'PointerToeml23__ThermodynamicTemperatureMeasure' for type 'eml23:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ThermodynamicTemperatureMeasure (-1411)

#endif

/* eml23__PressureMeasure * has binding name 'PointerToeml23__PressureMeasure' for type 'eml23:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PressureMeasure (-1410)

#endif

/* std::string * has binding name 'PointerToeml23__ReferenceConditionExt' for type 'eml23:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferenceConditionExt (-1409)

#endif

/* eml23__ReferencePressure * has binding name 'PointerToeml23__ReferencePressure' for type 'eml23:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePressure (-1407)

#endif

/* eml23__PressureMeasureExt * has binding name 'PointerToeml23__PressureMeasureExt' for type 'eml23:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PressureMeasureExt (-1406)

#endif

/* eml23__AbstractGraphicalInformation * has binding name 'PointerToeml23__AbstractGraphicalInformation' for type 'eml23:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractGraphicalInformation (-1404)

#endif

/* eml23__FailingRule * has binding name 'PointerToeml23__FailingRule' for type 'eml23:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FailingRule
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__FailingRule (-1402)

#endif

/* eml23__IndexRange * has binding name 'PointerToeml23__IndexRange' for type 'eml23:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IndexRange
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IndexRange (-1401)

#endif

/* std::string * has binding name 'PointerToeml23__CollectionKindExt' for type 'eml23:CollectionKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__CollectionKindExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__CollectionKindExt (-1400)

#endif

/* eml23__SingleCollectionAssociation * has binding name 'PointerToeml23__SingleCollectionAssociation' for type 'eml23:SingleCollectionAssociation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__SingleCollectionAssociation
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__SingleCollectionAssociation (-1398)

#endif

/* eml23__PersonName * has binding name 'PointerToeml23__PersonName' for type 'eml23:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PersonName
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PersonName (-1397)

#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_3_PointerToxsd__nonNegativeInteger (-1396)

#endif

/* eml23__EmailQualifierStruct * has binding name 'PointerToeml23__EmailQualifierStruct' for type 'eml23:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__EmailQualifierStruct (-1394)

#endif

/* eml23__PhoneNumberStruct * has binding name 'PointerToeml23__PhoneNumberStruct' for type 'eml23:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PhoneNumberStruct (-1392)

#endif

/* eml23__GeneralAddress * has binding name 'PointerToeml23__GeneralAddress' for type 'eml23:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__GeneralAddress (-1391)

#endif

/* eml23__NameStruct * has binding name 'PointerToeml23__NameStruct' for type 'eml23:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NameStruct
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NameStruct (-1389)

#endif

/* eml23__IndexableElement * has binding name 'PointerToeml23__IndexableElement' for type 'eml23:IndexableElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IndexableElement
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IndexableElement (-1388)

#endif

/* eml23__AbstractObject * has binding name 'PointerToeml23__AbstractObject' for type 'eml23:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractObject
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractObject (-1386)

#endif

/* eml23__ParameterTemplate * has binding name 'PointerToeml23__ParameterTemplate' for type 'eml23:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ParameterTemplate (-1384)

#endif

/* eml23__TimeSeriesParentage * has binding name 'PointerToeml23__TimeSeriesParentage' for type 'eml23:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeSeriesParentage (-1383)

#endif

/* eml23__PropertyKind * has binding name 'PointerToeml23__PropertyKind' for type 'eml23:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PropertyKind (-1380)

#endif

/* eml23__AbstractVerticalCrs * has binding name 'PointerToeml23__AbstractVerticalCrs' for type 'eml23:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractVerticalCrs (-1379)

#endif

/* std::string * has binding name 'PointerToeml23__LengthUomExt' for type 'eml23:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthUomExt (-1378)

#endif

/* eml23__AbstractProjectedCrs * has binding name 'PointerToeml23__AbstractProjectedCrs' for type 'eml23:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractProjectedCrs (-1377)

#endif

/* eml23__ProjectedCrs * has binding name 'PointerToeml23__ProjectedCrs' for type 'eml23:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ProjectedCrs (-1376)

#endif

/* eml23__VerticalCrs * has binding name 'PointerToeml23__VerticalCrs' for type 'eml23:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VerticalCrs (-1375)

#endif

/* eml23__HorizontalAxes * has binding name 'PointerToeml23__HorizontalAxes' for type 'eml23:HorizontalAxes' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__HorizontalAxes (-1374)

#endif

/* eml23__VerticalAxis * has binding name 'PointerToeml23__VerticalAxis' for type 'eml23:VerticalAxis' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VerticalAxis (-1373)

#endif

/* eml23__PlaneAngleMeasureExt * has binding name 'PointerToeml23__PlaneAngleMeasureExt' for type 'eml23:PlaneAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PlaneAngleMeasureExt (-1372)

#endif

/* eml23__AuthorityQualifiedName * has binding name 'PointerToeml23__AuthorityQualifiedName' for type 'eml23:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AuthorityQualifiedName (-1371)

#endif

/* eml23__AbstractGeodeticCrs * has binding name 'PointerToeml23__AbstractGeodeticCrs' for type 'eml23:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractGeodeticCrs (-1370)

#endif

/* eml23__PublicLandSurveySystem * has binding name 'PointerToeml23__PublicLandSurveySystem' for type 'eml23:PublicLandSurveySystem' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystem
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystem (-1369)

#endif

/* eml23__Vector * has binding name 'PointerToeml23__Vector' for type 'eml23:Vector' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Vector
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Vector (-1368)

#endif

/* std::string * has binding name 'PointerToeml23__ReferencePointKindExt' for type 'eml23:ReferencePointKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePointKindExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ReferencePointKindExt (-1367)

#endif

/* eml23__DateTimeInterval * has binding name 'PointerToeml23__DateTimeInterval' for type 'eml23:DateTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__DateTimeInterval (-1366)

#endif

/* eml23__MdInterval * has binding name 'PointerToeml23__MdInterval' for type 'eml23:MdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MdInterval
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MdInterval (-1365)

#endif

/* eml23__MeasuredDepthCoord * has binding name 'PointerToeml23__MeasuredDepthCoord' for type 'eml23:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MeasuredDepthCoord (-1364)

#endif

/* resqml22__GeologicBoundaryKind * has binding name 'PointerToresqml22__GeologicBoundaryKind' for type 'resqml22:GeologicBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GeologicBoundaryKind (-1363)

#endif

/* resqml22__FluidMarker * has binding name 'PointerToresqml22__FluidMarker' for type 'resqml22:FluidMarker' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FluidMarker
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FluidMarker (-1362)

#endif

/* resqml22__FluidContact * has binding name 'PointerToresqml22__FluidContact' for type 'resqml22:FluidContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FluidContact
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__FluidContact (-1361)

#endif

/* eml23__TimeOrIntervalSeries * has binding name 'PointerToeml23__TimeOrIntervalSeries' for type 'eml23:TimeOrIntervalSeries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeOrIntervalSeries
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeOrIntervalSeries (-1360)

#endif

/* std::string * has binding name 'PointerToresqml22__NodeSymbolExt' for type 'resqml22:NodeSymbolExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__NodeSymbolExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__NodeSymbolExt (-1358)

#endif

/* std::string * has binding name 'PointerToresqml22__EdgePatternExt' for type 'resqml22:EdgePatternExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__EdgePatternExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__EdgePatternExt (-1357)

#endif

/* resqml22__DisplaySpace * has binding name 'PointerToresqml22__DisplaySpace' for type 'resqml22:DisplaySpace' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DisplaySpace
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__DisplaySpace (-1356)

#endif

/* resqml22__AbstractGraphicalInformationForIndexableElement * has binding name 'PointerToresqml22__AbstractGraphicalInformationForIndexableElement' for type 'resqml22:AbstractGraphicalInformationForIndexableElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractGraphicalInformationForIndexableElement
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractGraphicalInformationForIndexableElement (-1354)

#endif

/* resqml22__GraphicalInformationForEdges * has binding name 'PointerToresqml22__GraphicalInformationForEdges' for type 'resqml22:GraphicalInformationForEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GraphicalInformationForEdges
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__GraphicalInformationForEdges (-1353)

#endif

/* resqml22__AbstractColorMap * has binding name 'PointerToresqml22__AbstractColorMap' for type 'resqml22:AbstractColorMap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractColorMap
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractColorMap (-1351)

#endif

/* resqml22__MinMax * has binding name 'PointerToresqml22__MinMax' for type 'resqml22:MinMax' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MinMax
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__MinMax (-1350)

#endif

/* resqml22__Edges * has binding name 'PointerToresqml22__Edges' for type 'resqml22:Edges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Edges
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Edges (-1348)

#endif

/* resqml22__Activation * has binding name 'PointerToresqml22__Activation' for type 'resqml22:Activation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Activation
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Activation (-1347)

#endif

/* resqml22__ColumnSubnodePatch * has binding name 'PointerToresqml22__ColumnSubnodePatch' for type 'resqml22:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnSubnodePatch (-1345)

#endif

/* resqml22__Regrid * has binding name 'PointerToresqml22__Regrid' for type 'resqml22:Regrid' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Regrid
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Regrid (-1344)

#endif

/* resqml22__ElementIndices * has binding name 'PointerToresqml22__ElementIndices' for type 'resqml22:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ElementIndices
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ElementIndices (-1342)

#endif

/* resqml22__RepresentationIdentity * has binding name 'PointerToresqml22__RepresentationIdentity' for type 'resqml22:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__RepresentationIdentity
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__RepresentationIdentity (-1340)

#endif

/* LONG64 * has binding name 'PointerToeml23__PositiveLong' for type 'eml23:PositiveLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PositiveLong
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PositiveLong (-1339)

#endif

/* eml23__GeologicTime * has binding name 'PointerToeml23__GeologicTime' for type 'eml23:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__GeologicTime
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__GeologicTime (-1337)

#endif

/* resqml22__ContactMode * has binding name 'PointerToresqml22__ContactMode' for type 'resqml22:ContactMode' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactMode
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactMode (-1336)

#endif

/* resqml22__ContactSide * has binding name 'PointerToresqml22__ContactSide' for type 'resqml22:ContactSide' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactSide
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactSide (-1335)

#endif

/* resqml22__ContactElement * has binding name 'PointerToresqml22__ContactElement' for type 'resqml22:ContactElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactElement
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactElement (-1334)

#endif

/* resqml22__Domain * has binding name 'PointerToresqml22__Domain' for type 'resqml22:Domain' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Domain
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Domain (-1333)

#endif

/* resqml22__EdgePatch * has binding name 'PointerToresqml22__EdgePatch' for type 'resqml22:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__EdgePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__EdgePatch (-1331)

#endif

/* resqml22__AbstractGeometry * has binding name 'PointerToresqml22__AbstractGeometry' for type 'resqml22:AbstractGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractGeometry (-1330)

#endif

/* resqml22__ContactPatch * has binding name 'PointerToresqml22__ContactPatch' for type 'resqml22:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ContactPatch (-1328)

#endif

/* resqml22__AbstractSeismicCoordinates * has binding name 'PointerToresqml22__AbstractSeismicCoordinates' for type 'resqml22:AbstractSeismicCoordinates' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractSeismicCoordinates (-1327)

#endif

/* resqml22__AbstractParametricLineArray * has binding name 'PointerToresqml22__AbstractParametricLineArray' for type 'resqml22:AbstractParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractParametricLineArray (-1326)

#endif

/* resqml22__Point3dLatticeDimension * has binding name 'PointerToresqml22__Point3dLatticeDimension' for type 'resqml22:Point3dLatticeDimension' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Point3dLatticeDimension
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Point3dLatticeDimension (-1324)

#endif

/* eml23__ExternalDataArray * has binding name 'PointerToeml23__ExternalDataArray' for type 'eml23:ExternalDataArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExternalDataArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExternalDataArray (-1323)

#endif

/* eml23__IntegerLatticeArray * has binding name 'PointerToeml23__IntegerLatticeArray' for type 'eml23:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerLatticeArray (-1322)

#endif

/* resqml22__ParametricLineIntersections * has binding name 'PointerToresqml22__ParametricLineIntersections' for type 'resqml22:ParametricLineIntersections' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ParametricLineIntersections
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ParametricLineIntersections (-1321)

#endif

/* eml23__VolumeMeasure * has binding name 'PointerToeml23__VolumeMeasure' for type 'eml23:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VolumeMeasure (-1320)

#endif

/* eml23__AbstractPressureValue * has binding name 'PointerToeml23__AbstractPressureValue' for type 'eml23:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractPressureValue (-1319)

#endif

/* eml23__VolumePerTimeMeasure * has binding name 'PointerToeml23__VolumePerTimeMeasure' for type 'eml23:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__VolumePerTimeMeasure (-1318)

#endif

/* eml23__AbstractTemperaturePressure * has binding name 'PointerToeml23__AbstractTemperaturePressure' for type 'eml23:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractTemperaturePressure (-1317)

#endif

/* eml23__MassPerVolumeMeasure * has binding name 'PointerToeml23__MassPerVolumeMeasure' for type 'eml23:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MassPerVolumeMeasure (-1316)

#endif

/* eml23__Column * has binding name 'PointerToeml23__Column' for type 'eml23:Column' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Column
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Column (-1313)

#endif

/* eml23__PropertyKindFacet * has binding name 'PointerToeml23__PropertyKindFacet' for type 'eml23:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PropertyKindFacet (-1311)

#endif

/* std::string * has binding name 'PointerToeml23__UnitOfMeasureExt' for type 'eml23:UnitOfMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__UnitOfMeasureExt (-1310)

#endif

/* eml23__AddressQualifier * has binding name 'PointerToeml23__AddressQualifier' for type 'eml23:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AddressQualifier (-1309)

#endif

/* eml23__AddressKindEnum * has binding name 'PointerToeml23__AddressKindEnum' for type 'eml23:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AddressKindEnum (-1308)

#endif

/* eml23__AbstractActivityParameter * has binding name 'PointerToeml23__AbstractActivityParameter' for type 'eml23:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractActivityParameter (-1305)

#endif

/* eml23__AbstractParameterKey * has binding name 'PointerToeml23__AbstractParameterKey' for type 'eml23:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractParameterKey (-1301)

#endif

/* eml23__PlaneAngleMeasure * has binding name 'PointerToeml23__PlaneAngleMeasure' for type 'eml23:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PlaneAngleMeasure (-1300)

#endif

/* std::string * has binding name 'PointerToeml23__PublicLandSurveySystemQuarterTownship' for type 'eml23:PublicLandSurveySystemQuarterTownship' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystemQuarterTownship (-1298)

#endif

/* std::string * has binding name 'PointerToeml23__PublicLandSurveySystemQuarterSection' for type 'eml23:PublicLandSurveySystemQuarterSection' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PublicLandSurveySystemQuarterSection (-1297)

#endif

/* std::string * has binding name 'PointerToeml23__SectionNumber' for type 'eml23:SectionNumber' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__SectionNumber
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__SectionNumber (-1296)

#endif

/* eml23__NorthOrSouth * has binding name 'PointerToeml23__NorthOrSouth' for type 'eml23:NorthOrSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NorthOrSouth (-1295)

#endif

/* eml23__EastOrWest * has binding name 'PointerToeml23__EastOrWest' for type 'eml23:EastOrWest' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__EastOrWest
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__EastOrWest (-1294)

#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToint
#define SOAP_TYPE_gsoap_eml2_3_PointerToint (-1293)

#endif

/* eml23__PrincipalMeridian * has binding name 'PointerToeml23__PrincipalMeridian' for type 'eml23:PrincipalMeridian' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__PrincipalMeridian (-1292)

#endif

/* eml23__ExternalDataArrayPart * has binding name 'PointerToeml23__ExternalDataArrayPart' for type 'eml23:ExternalDataArrayPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExternalDataArrayPart
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExternalDataArrayPart (-1290)

#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToxsd__anyURI
#define SOAP_TYPE_gsoap_eml2_3_PointerToxsd__anyURI (-1289)

#endif

/* eml23__LengthMeasureExt * has binding name 'PointerToeml23__LengthMeasureExt' for type 'eml23:LengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__LengthMeasureExt (-1288)

#endif

/* eml23__MeasureClass * has binding name 'PointerToeml23__MeasureClass' for type 'eml23:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MeasureClass
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__MeasureClass (-1287)

#endif

/* eml23__StringMeasure * has binding name 'PointerToeml23__StringMeasure' for type 'eml23:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__StringMeasure
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__StringMeasure (-1286)

#endif

/* std::string * has binding name 'PointerToeml23__String2000' for type 'eml23:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__String2000
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__String2000 (-1284)

#endif

/* struct tm * has binding name 'PointerToeml23__TimeStamp' for type 'eml23:TimeStamp' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeStamp
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeStamp (-1283)

#endif

/* eml23__CustomData * has binding name 'PointerToeml23__CustomData' for type 'eml23:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__CustomData
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__CustomData (-1281)

#endif

/* eml23__OSDUIntegration * has binding name 'PointerToeml23__OSDUIntegration' for type 'eml23:OSDUIntegration' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__OSDUIntegration
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__OSDUIntegration (-1280)

#endif

/* std::string * has binding name 'PointerToeml23__ExistenceKindExt' for type 'eml23:ExistenceKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExistenceKindExt
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExistenceKindExt (-1279)

#endif

/* eml23__Citation * has binding name 'PointerToeml23__Citation' for type 'eml23:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Citation
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__Citation (-1278)

#endif

/* eml23__ObjectAlias * has binding name 'PointerToeml23__ObjectAlias' for type 'eml23:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ObjectAlias (-1276)

#endif

/* std::string * has binding name 'PointerToeml23__String64' for type 'eml23:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__String64
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__String64 (-1275)

#endif

/* eml23__ExtensionNameValue * has binding name 'PointerToeml23__ExtensionNameValue' for type 'eml23:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__ExtensionNameValue (-1274)

#endif

/* eml23__AbstractReferencePoint * has binding name 'PointerToeml23__AbstractReferencePoint' for type 'eml23:AbstractReferencePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractReferencePoint
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractReferencePoint (-1273)

#endif

/* resqml22__HsvColor * has binding name 'PointerToresqml22__HsvColor' for type 'resqml22:HsvColor' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__HsvColor
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__HsvColor (-1272)

#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerTodouble
#define SOAP_TYPE_gsoap_eml2_3_PointerTodouble (-1271)

#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToLONG64
#define SOAP_TYPE_gsoap_eml2_3_PointerToLONG64 (-1270)

#endif

/* resqml22__UnstructuredGridGeometry * has binding name 'PointerToresqml22__UnstructuredGridGeometry' for type 'resqml22:UnstructuredGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredGridGeometry (-1269)

#endif

/* resqml22__UnstructuredColumnLayerGridGeometry * has binding name 'PointerToresqml22__UnstructuredColumnLayerGridGeometry' for type 'resqml22:UnstructuredColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnLayerGridGeometry (-1268)

#endif

/* resqml22__UniformSubnodePatch * has binding name 'PointerToresqml22__UniformSubnodePatch' for type 'resqml22:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UniformSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UniformSubnodePatch (-1266)

#endif

/* resqml22__VariableSubnodePatch * has binding name 'PointerToresqml22__VariableSubnodePatch' for type 'resqml22:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VariableSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VariableSubnodePatch (-1264)

#endif

/* resqml22__Intervals * has binding name 'PointerToresqml22__Intervals' for type 'resqml22:Intervals' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Intervals
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Intervals (-1263)

#endif

/* resqml22__TruncationCellPatch * has binding name 'PointerToresqml22__TruncationCellPatch' for type 'resqml22:TruncationCellPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TruncationCellPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__TruncationCellPatch (-1262)

#endif

/* resqml22__IjkGridGeometry * has binding name 'PointerToresqml22__IjkGridGeometry' for type 'resqml22:IjkGridGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjkGridGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjkGridGeometry (-1261)

#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerTobool
#define SOAP_TYPE_gsoap_eml2_3_PointerTobool (-1260)

#endif

/* resqml22__UnstructuredColumnLayerGpGridPatch * has binding name 'PointerToresqml22__UnstructuredColumnLayerGpGridPatch' for type 'resqml22:UnstructuredColumnLayerGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnLayerGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnLayerGpGridPatch (-1257)

#endif

/* resqml22__IjkGpGridPatch * has binding name 'PointerToresqml22__IjkGpGridPatch' for type 'resqml22:IjkGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjkGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IjkGpGridPatch (-1255)

#endif

/* resqml22__KGaps * has binding name 'PointerToresqml22__KGaps' for type 'resqml22:KGaps' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__KGaps
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__KGaps (-1254)

#endif

/* resqml22__OverlapVolume * has binding name 'PointerToresqml22__OverlapVolume' for type 'resqml22:OverlapVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__OverlapVolume
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__OverlapVolume (-1253)

#endif

/* eml23__JaggedArray * has binding name 'PointerToeml23__JaggedArray' for type 'eml23:JaggedArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__JaggedArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__JaggedArray (-1252)

#endif

/* resqml22__ColumnLayerSubnodeTopology * has binding name 'PointerToresqml22__ColumnLayerSubnodeTopology' for type 'resqml22:ColumnLayerSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ColumnLayerSubnodeTopology (-1251)

#endif

/* resqml22__UnstructuredSubnodeTopology * has binding name 'PointerToresqml22__UnstructuredSubnodeTopology' for type 'resqml22:UnstructuredSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredSubnodeTopology (-1250)

#endif

/* resqml22__SplitFaces * has binding name 'PointerToresqml22__SplitFaces' for type 'resqml22:SplitFaces' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitFaces
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitFaces (-1249)

#endif

/* resqml22__UnstructuredColumnEdges * has binding name 'PointerToresqml22__UnstructuredColumnEdges' for type 'resqml22:UnstructuredColumnEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__UnstructuredColumnEdges (-1248)

#endif

/* resqml22__SplitColumnEdges * has binding name 'PointerToresqml22__SplitColumnEdges' for type 'resqml22:SplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitColumnEdges
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitColumnEdges (-1247)

#endif

/* resqml22__SplitNodePatch * has binding name 'PointerToresqml22__SplitNodePatch' for type 'resqml22:SplitNodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitNodePatch
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitNodePatch (-1246)

#endif

/* resqml22__SplitEdges * has binding name 'PointerToresqml22__SplitEdges' for type 'resqml22:SplitEdges' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitEdges
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__SplitEdges (-1245)

#endif

/* resqml22__AbstractPoint3dArray * has binding name 'PointerToresqml22__AbstractPoint3dArray' for type 'resqml22:AbstractPoint3dArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractPoint3dArray (-1244)

#endif

/* resqml22__CellOverlap * has binding name 'PointerToresqml22__CellOverlap' for type 'resqml22:CellOverlap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CellOverlap
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__CellOverlap (-1243)

#endif

/* resqml22__AdditionalGridTopology * has binding name 'PointerToresqml22__AdditionalGridTopology' for type 'resqml22:AdditionalGridTopology' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AdditionalGridTopology
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AdditionalGridTopology (-1242)

#endif

/* resqml22__ElementIdentity * has binding name 'PointerToresqml22__ElementIdentity' for type 'resqml22:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ElementIdentity
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ElementIdentity (-1240)

#endif

/* resqml22__PointGeometry * has binding name 'PointerToresqml22__PointGeometry' for type 'resqml22:PointGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PointGeometry
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__PointGeometry (-1239)

#endif

/* resqml22__IntervalGridCells * has binding name 'PointerToresqml22__IntervalGridCells' for type 'resqml22:IntervalGridCells' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IntervalGridCells
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__IntervalGridCells (-1238)

#endif

/* eml23__AbstractBooleanArray * has binding name 'PointerToeml23__AbstractBooleanArray' for type 'eml23:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractBooleanArray (-1237)

#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerTostd__string
#define SOAP_TYPE_gsoap_eml2_3_PointerTostd__string (-1236)

#endif

/* resqml22__ReservoirCompartmentInterpretation * has binding name 'PointerToresqml22__ReservoirCompartmentInterpretation' for type 'resqml22:ReservoirCompartmentInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ReservoirCompartmentInterpretation
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__ReservoirCompartmentInterpretation (-1235)

#endif

/* resqml22__AbstractTimeInterval * has binding name 'PointerToresqml22__AbstractTimeInterval' for type 'resqml22:AbstractTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractTimeInterval
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__AbstractTimeInterval (-1234)

#endif

/* LONG64 * has binding name 'PointerToeml23__NonNegativeLong' for type 'eml23:NonNegativeLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__NonNegativeLong (-1232)

#endif

/* eml23__BooleanExternalArray * has binding name 'PointerToeml23__BooleanExternalArray' for type 'eml23:BooleanExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__BooleanExternalArray (-1231)

#endif

/* eml23__IntegerExternalArray * has binding name 'PointerToeml23__IntegerExternalArray' for type 'eml23:IntegerExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__IntegerExternalArray (-1230)

#endif

/* resqml22__VolumeShell * has binding name 'PointerToresqml22__VolumeShell' for type 'resqml22:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VolumeShell
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__VolumeShell (-1228)

#endif

/* eml23__AbstractFloatingPointArray * has binding name 'PointerToeml23__AbstractFloatingPointArray' for type 'eml23:AbstractFloatingPointArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractFloatingPointArray (-1225)

#endif

/* resqml22__Point3d * has binding name 'PointerToresqml22__Point3d' for type 'resqml22:Point3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Point3d
#define SOAP_TYPE_gsoap_eml2_3_PointerToresqml22__Point3d (-1224)

#endif

/* eml23__AbstractValueArray * has binding name 'PointerToeml23__AbstractValueArray' for type 'eml23:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractValueArray (-1223)

#endif

/* eml23__AbstractIntegerArray * has binding name 'PointerToeml23__AbstractIntegerArray' for type 'eml23:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__AbstractIntegerArray (-1222)

#endif

/* eml23__DataObjectReference * has binding name 'PointerToeml23__DataObjectReference' for type 'eml23:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__DataObjectReference (-1220)

#endif

/* eml23__TimeIndex * has binding name 'PointerToeml23__TimeIndex' for type 'eml23:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeIndex
#define SOAP_TYPE_gsoap_eml2_3_PointerToeml23__TimeIndex (-1219)

#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_gsoap_eml2_3_PointerTounsignedByte
#define SOAP_TYPE_gsoap_eml2_3_PointerTounsignedByte (-11)

#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_gsoap_eml2_3__QName
#define SOAP_TYPE_gsoap_eml2_3__QName (-6)

#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3__XML
#define SOAP_TYPE_gsoap_eml2_3__XML (-5)

#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_3_string
#define SOAP_TYPE_gsoap_eml2_3_string (-4)

#endif

/* std::vector<resqml22__SealedContact *>  has binding name 'std__vectorTemplateOfPointerToresqml22__SealedContact' for type 'resqml22:SealedContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__SealedContact
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__SealedContact (-1496)

#endif

/* std::vector<resqml22__AbstractSurfaceFrameworkContact *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractSurfaceFrameworkContact' for type 'resqml22:AbstractSurfaceFrameworkContact' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractSurfaceFrameworkContact
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractSurfaceFrameworkContact (-1494)

#endif

/* std::vector<eml23__IntegerConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml23__IntegerConstantArray' for type 'eml23:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__IntegerConstantArray (-1490)

#endif

/* std::vector<eml23__FloatingPointConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml23__FloatingPointConstantArray' for type 'eml23:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__FloatingPointConstantArray (-1488)

#endif

/* std::vector<resqml22__WellboreMarker *>  has binding name 'std__vectorTemplateOfPointerToresqml22__WellboreMarker' for type 'resqml22:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__WellboreMarker
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__WellboreMarker (-1486)

#endif

/* std::vector<resqml22__UnstructuredGpGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__UnstructuredGpGridPatch' for type 'resqml22:UnstructuredGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UnstructuredGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UnstructuredGpGridPatch (-1478)

#endif

/* std::vector<resqml22__ColumnLayerGpGrid *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ColumnLayerGpGrid' for type 'resqml22:ColumnLayerGpGrid' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ColumnLayerGpGrid
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ColumnLayerGpGrid (-1476)

#endif

/* std::vector<resqml22__ReservoirCompartmentInterpretation *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ReservoirCompartmentInterpretation' for type 'resqml22:ReservoirCompartmentInterpretation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ReservoirCompartmentInterpretation
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ReservoirCompartmentInterpretation (-1473)

#endif

/* std::vector<resqml22__BoundaryFeatureInterpretationPlusItsRank *>  has binding name 'std__vectorTemplateOfPointerToresqml22__BoundaryFeatureInterpretationPlusItsRank' for type 'resqml22:BoundaryFeatureInterpretationPlusItsRank' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__BoundaryFeatureInterpretationPlusItsRank
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__BoundaryFeatureInterpretationPlusItsRank (-1472)

#endif

/* std::vector<resqml22__HorizonStratigraphicRole>  has binding name 'std__vectorTemplateOfresqml22__HorizonStratigraphicRole' for type 'resqml22:HorizonStratigraphicRole' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfresqml22__HorizonStratigraphicRole
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfresqml22__HorizonStratigraphicRole (-1466)

#endif

/* std::vector<resqml22__FaultThrow *>  has binding name 'std__vectorTemplateOfPointerToresqml22__FaultThrow' for type 'resqml22:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__FaultThrow
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__FaultThrow (-1465)

#endif

/* std::vector<resqml22__TrianglePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__TrianglePatch' for type 'resqml22:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__TrianglePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__TrianglePatch (-1462)

#endif

/* std::vector<resqml22__VolumeRegion *>  has binding name 'std__vectorTemplateOfPointerToresqml22__VolumeRegion' for type 'resqml22:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VolumeRegion
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VolumeRegion (-1460)

#endif

/* std::vector<resqml22__AbstractPlaneGeometry *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractPlaneGeometry' for type 'resqml22:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractPlaneGeometry (-1458)

#endif

/* std::vector<resqml22__ContactIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ContactIdentity' for type 'resqml22:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContactIdentity
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContactIdentity (-1456)

#endif

/* std::vector<resqml22__IntervalStratigraphicUnits *>  has binding name 'std__vectorTemplateOfPointerToresqml22__IntervalStratigraphicUnits' for type 'resqml22:IntervalStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__IntervalStratigraphicUnits (-1448)

#endif

/* std::vector<resqml22__AbstractPoint3dArray *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractPoint3dArray' for type 'resqml22:AbstractPoint3dArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractPoint3dArray (-1446)

#endif

/* std::vector<eml23__AbstractValueArray *>  has binding name 'std__vectorTemplateOfPointerToeml23__AbstractValueArray' for type 'eml23:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractValueArray (-1445)

#endif

/* std::vector<resqml22__DiscreteColorMapEntry *>  has binding name 'std__vectorTemplateOfPointerToresqml22__DiscreteColorMapEntry' for type 'resqml22:DiscreteColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__DiscreteColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__DiscreteColorMapEntry (-1444)

#endif

/* std::vector<resqml22__ContinuousColorMapEntry *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ContinuousColorMapEntry' for type 'resqml22:ContinuousColorMapEntry' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContinuousColorMapEntry
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContinuousColorMapEntry (-1442)

#endif

/* std::vector<resqml22__AdditionalGridPoints *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AdditionalGridPoints' for type 'resqml22:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AdditionalGridPoints
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AdditionalGridPoints (-1436)

#endif

/* std::vector<resqml22__MarkerInterval *>  has binding name 'std__vectorTemplateOfPointerToresqml22__MarkerInterval' for type 'resqml22:MarkerInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__MarkerInterval
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__MarkerInterval (-1434)

#endif

/* std::vector<resqml22__MarkerBoundary *>  has binding name 'std__vectorTemplateOfPointerToresqml22__MarkerBoundary' for type 'resqml22:MarkerBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__MarkerBoundary
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__MarkerBoundary (-1432)

#endif

/* std::vector<resqml22__SubRepresentationPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__SubRepresentationPatch' for type 'resqml22:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__SubRepresentationPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__SubRepresentationPatch (-1430)

#endif

/* std::vector<resqml22__AbstractContactInterpretationPart *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractContactInterpretationPart' for type 'resqml22:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractContactInterpretationPart (-1423)

#endif

/* std::vector<resqml22__PolylineSetPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__PolylineSetPatch' for type 'resqml22:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__PolylineSetPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__PolylineSetPatch (-1421)

#endif

/* std::vector<resqml22__NodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__NodePatch' for type 'resqml22:NodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__NodePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__NodePatch (-1418)

#endif

/* std::vector<resqml22__PatchBoundaries *>  has binding name 'std__vectorTemplateOfPointerToresqml22__PatchBoundaries' for type 'resqml22:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__PatchBoundaries
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__PatchBoundaries (-1416)

#endif

/* std::vector<resqml22__ThreePoint3d *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ThreePoint3d' for type 'resqml22:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ThreePoint3d
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ThreePoint3d (-1413)

#endif

/* std::vector<eml23__AbstractGraphicalInformation *>  has binding name 'std__vectorTemplateOfPointerToeml23__AbstractGraphicalInformation' for type 'eml23:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractGraphicalInformation (-1405)

#endif

/* std::vector<eml23__FailingRule *>  has binding name 'std__vectorTemplateOfPointerToeml23__FailingRule' for type 'eml23:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__FailingRule
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__FailingRule (-1403)

#endif

/* std::vector<eml23__SingleCollectionAssociation *>  has binding name 'std__vectorTemplateOfPointerToeml23__SingleCollectionAssociation' for type 'eml23:SingleCollectionAssociation' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__SingleCollectionAssociation
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__SingleCollectionAssociation (-1399)

#endif

/* std::vector<eml23__EmailQualifierStruct *>  has binding name 'std__vectorTemplateOfPointerToeml23__EmailQualifierStruct' for type 'eml23:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__EmailQualifierStruct (-1395)

#endif

/* std::vector<eml23__PhoneNumberStruct *>  has binding name 'std__vectorTemplateOfPointerToeml23__PhoneNumberStruct' for type 'eml23:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PhoneNumberStruct (-1393)

#endif

/* std::vector<eml23__NameStruct *>  has binding name 'std__vectorTemplateOfPointerToeml23__NameStruct' for type 'eml23:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__NameStruct
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__NameStruct (-1390)

#endif

/* std::vector<eml23__AbstractObject *>  has binding name 'std__vectorTemplateOfPointerToeml23__AbstractObject' for type 'eml23:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractObject
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractObject (-1387)

#endif

/* std::vector<eml23__ParameterTemplate *>  has binding name 'std__vectorTemplateOfPointerToeml23__ParameterTemplate' for type 'eml23:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ParameterTemplate (-1385)

#endif

/* std::vector<eml23__GeologicTime *>  has binding name 'std__vectorTemplateOfPointerToeml23__GeologicTime' for type 'eml23:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__GeologicTime
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__GeologicTime (-1382)

#endif

/* std::vector<eml23__PropertyKind *>  has binding name 'std__vectorTemplateOfPointerToeml23__PropertyKind' for type 'eml23:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PropertyKind
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PropertyKind (-1381)

#endif

/* std::vector<LONG64>  has binding name 'std__vectorTemplateOfeml23__PositiveLong' for type 'eml23:PositiveLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__PositiveLong
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__PositiveLong (-1359)

#endif

/* std::vector<resqml22__AbstractGraphicalInformationForIndexableElement *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractGraphicalInformationForIndexableElement' for type 'resqml22:AbstractGraphicalInformationForIndexableElement' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractGraphicalInformationForIndexableElement
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractGraphicalInformationForIndexableElement (-1355)

#endif

/* std::vector<resqml22__AbstractColorMap *>  has binding name 'std__vectorTemplateOfPointerToresqml22__AbstractColorMap' for type 'resqml22:AbstractColorMap' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractColorMap
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__AbstractColorMap (-1352)

#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfdouble
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfdouble (-1349)

#endif

/* std::vector<resqml22__ColumnSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ColumnSubnodePatch' for type 'resqml22:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ColumnSubnodePatch (-1346)

#endif

/* std::vector<resqml22__ElementIndices *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ElementIndices' for type 'resqml22:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ElementIndices
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ElementIndices (-1343)

#endif

/* std::vector<resqml22__RepresentationIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml22__RepresentationIdentity' for type 'resqml22:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__RepresentationIdentity
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__RepresentationIdentity (-1341)

#endif

/* std::vector<LONG64>  has binding name 'std__vectorTemplateOfeml23__NonNegativeLong' for type 'eml23:NonNegativeLong' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__NonNegativeLong (-1338)

#endif

/* std::vector<resqml22__EdgePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__EdgePatch' for type 'resqml22:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__EdgePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__EdgePatch (-1332)

#endif

/* std::vector<resqml22__ContactPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ContactPatch' for type 'resqml22:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContactPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ContactPatch (-1329)

#endif

/* std::vector<resqml22__Point3dLatticeDimension *>  has binding name 'std__vectorTemplateOfPointerToresqml22__Point3dLatticeDimension' for type 'resqml22:Point3dLatticeDimension' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__Point3dLatticeDimension
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__Point3dLatticeDimension (-1325)

#endif

/* std::vector<eml23__Column *>  has binding name 'std__vectorTemplateOfPointerToeml23__Column' for type 'eml23:Column' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__Column
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__Column (-1314)

#endif

/* std::vector<eml23__PropertyKindFacet *>  has binding name 'std__vectorTemplateOfPointerToeml23__PropertyKindFacet' for type 'eml23:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__PropertyKindFacet (-1312)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml23__String64' for type 'eml23:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__String64
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__String64 (-1307)

#endif

/* std::vector<eml23__AbstractActivityParameter *>  has binding name 'std__vectorTemplateOfPointerToeml23__AbstractActivityParameter' for type 'eml23:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractActivityParameter (-1306)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml23__String2000' for type 'eml23:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__String2000
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__String2000 (-1304)

#endif

/* std::vector<eml23__ActivityParameterKind>  has binding name 'std__vectorTemplateOfeml23__ActivityParameterKind' for type 'eml23:ActivityParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfeml23__ActivityParameterKind (-1303)

#endif

/* std::vector<eml23__AbstractParameterKey *>  has binding name 'std__vectorTemplateOfPointerToeml23__AbstractParameterKey' for type 'eml23:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__AbstractParameterKey (-1302)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfstd__string
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfstd__string (-1299)

#endif

/* std::vector<eml23__ExternalDataArrayPart *>  has binding name 'std__vectorTemplateOfPointerToeml23__ExternalDataArrayPart' for type 'eml23:ExternalDataArrayPart' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ExternalDataArrayPart
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ExternalDataArrayPart (-1291)

#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOf_XML
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOf_XML (-1285)

#endif

/* std::vector<eml23__ExtensionNameValue *>  has binding name 'std__vectorTemplateOfPointerToeml23__ExtensionNameValue' for type 'eml23:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ExtensionNameValue (-1282)

#endif

/* std::vector<eml23__ObjectAlias *>  has binding name 'std__vectorTemplateOfPointerToeml23__ObjectAlias' for type 'eml23:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__ObjectAlias (-1277)

#endif

/* std::vector<resqml22__UniformSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__UniformSubnodePatch' for type 'resqml22:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UniformSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UniformSubnodePatch (-1267)

#endif

/* std::vector<resqml22__VariableSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__VariableSubnodePatch' for type 'resqml22:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VariableSubnodePatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VariableSubnodePatch (-1265)

#endif

/* std::vector<resqml22__UnstructuredColumnLayerGpGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__UnstructuredColumnLayerGpGridPatch' for type 'resqml22:UnstructuredColumnLayerGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UnstructuredColumnLayerGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__UnstructuredColumnLayerGpGridPatch (-1258)

#endif

/* std::vector<resqml22__IjkGpGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml22__IjkGpGridPatch' for type 'resqml22:IjkGpGridPatch' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__IjkGpGridPatch
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__IjkGpGridPatch (-1256)

#endif

/* std::vector<resqml22__ElementIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml22__ElementIdentity' for type 'resqml22:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ElementIdentity
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__ElementIdentity (-1241)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfresqml22__ThrowKindExt' for type 'resqml22:ThrowKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfresqml22__ThrowKindExt
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfresqml22__ThrowKindExt (-1233)

#endif

/* std::vector<resqml22__VolumeShell *>  has binding name 'std__vectorTemplateOfPointerToresqml22__VolumeShell' for type 'resqml22:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VolumeShell
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__VolumeShell (-1229)

#endif

/* std::vector<eml23__DataObjectReference *>  has binding name 'std__vectorTemplateOfPointerToeml23__DataObjectReference' for type 'eml23:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToeml23__DataObjectReference (-1227)

#endif

/* std::vector<resqml22__Point3d *>  has binding name 'std__vectorTemplateOfPointerToresqml22__Point3d' for type 'resqml22:Point3d' */
#ifndef SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__Point3d
#define SOAP_TYPE_gsoap_eml2_3_std__vectorTemplateOfPointerToresqml22__Point3d (-1226)

#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_eml2_3


#endif

/* End of gsoap_eml2_3Stub.h */
