/* gsoap_uom1_0Stub.h
   Generated by gSOAP 2.8.127E for uom1_0ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use and protected by law.
**  REDISTRIBUTION, RESALE OR ANY OTHER FORM OF SHARING IS STRICTLY PROHIBITED.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_uom10	"http://www.energistics.org/energyml/data/uomv1"

#ifndef gsoap_uom1_0Stub_H
#define gsoap_uom1_0Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 208127
# error "GSOAP VERSION 208127 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_uom1_0 {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* uom1_0ForGsoap.h:225 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum
#define SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum (-35)

/* uom10:stateEnum */
enum class uom10__stateEnum {
	identical = 0,
	precision = 1,
	corrected = 2,
	conditional = 3,
	conversion = 4,
	unsupported = 5
};
#endif

/* uom1_0ForGsoap.h:371 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__zero
#define SOAP_TYPE_gsoap_uom1_0_uom10__zero (-39)

/* uom10:zero */
enum class uom10__zero {
	_0 = 0
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class uom10__uomAggregate;	/* uom1_0ForGsoap.h:165 */
class uom10__uomDictionary;	/* uom1_0ForGsoap.h:167 */
class uom10__unitDimensionSet;	/* uom1_0ForGsoap.h:169 */
class uom10__unitDimension;	/* uom1_0ForGsoap.h:171 */
class uom10__quantityClassSet;	/* uom1_0ForGsoap.h:173 */
class uom10__quantityClass;	/* uom1_0ForGsoap.h:175 */
class uom10__unitSet;	/* uom1_0ForGsoap.h:177 */
class uom10__unit;	/* uom1_0ForGsoap.h:179 */
class uom10__referenceSet;	/* uom1_0ForGsoap.h:181 */
class uom10__reference;	/* uom1_0ForGsoap.h:183 */
class uom10__prefixSet;	/* uom1_0ForGsoap.h:185 */
class uom10__prefix;	/* uom1_0ForGsoap.h:187 */
class uom10__integerCodeSet;	/* uom1_0ForGsoap.h:189 */
class uom10__classCodeSet;	/* uom1_0ForGsoap.h:191 */
class uom10__unitCodeSet;	/* uom1_0ForGsoap.h:193 */
class uom10__classCode;	/* uom1_0ForGsoap.h:195 */
class uom10__unitCode;	/* uom1_0ForGsoap.h:197 */
class uom10__unitMappingSet;	/* uom1_0ForGsoap.h:199 */
class uom10__mapFromToUnit;	/* uom1_0ForGsoap.h:201 */
class uom10__classMappingSet;	/* uom1_0ForGsoap.h:203 */
class uom10__mapFromToClass;	/* uom1_0ForGsoap.h:205 */
class uom10__emptyElement;	/* uom1_0ForGsoap.h:207 */
class uom10__unitCodeStruct;	/* uom1_0ForGsoap.h:209 */

/* uom1_0ForGsoap.h:165 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate
#define SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate (-10)
/* complex XML schema type 'uom10:uomAggregate': */
class SOAP_CMAC uom10__uomAggregate {
      public:
        /// Optional element 'uom10:uomDictionary' of XML schema type 'uom10:uomDictionary'
        uom10__uomDictionary *uomDictionary;
        /// Optional element 'uom10:integerCodeSet' of XML schema type 'uom10:integerCodeSet'
        uom10__integerCodeSet *integerCodeSet;
        /// Optional element 'uom10:classMappingSet' of XML schema type 'uom10:classMappingSet'
        std::vector<uom10__classMappingSet *> classMappingSet;
        /// Optional element 'uom10:unitMappingSet' of XML schema type 'uom10:unitMappingSet'
        std::vector<uom10__unitMappingSet *> unitMappingSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__uomAggregate, default initialized and not managed by a soap context
        virtual uom10__uomAggregate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__uomAggregate); }
      public:
        /// Constructor with default initializations
        uom10__uomAggregate() : uomDictionary(), integerCodeSet(), classMappingSet(), unitMappingSet(), soap() { }
        /// Destructor
        virtual ~uom10__uomAggregate() { }
        /// Friend allocator used by soap_new_uom10__uomAggregate(struct soap*, int)
        friend SOAP_FMAC1 uom10__uomAggregate * SOAP_FMAC2 soap_instantiate_uom10__uomAggregate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:167 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary
#define SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary (-11)
/* complex XML schema type 'uom10:uomDictionary': */
class SOAP_CMAC uom10__uomDictionary {
      public:
        /// Required element 'uom10:title' of XML schema type 'uom10:descriptionString'
        std::string title;
        /// Required element 'uom10:originator' of XML schema type 'uom10:nameString'
        std::string originator;
        /// Required element 'uom10:description' of XML schema type 'uom10:commentString'
        std::string description;
        /// Required element 'uom10:unitDimensionSet' of XML schema type 'uom10:unitDimensionSet'
        uom10__unitDimensionSet *unitDimensionSet;
        /// Required element 'uom10:quantityClassSet' of XML schema type 'uom10:quantityClassSet'
        uom10__quantityClassSet *quantityClassSet;
        /// Required element 'uom10:unitSet' of XML schema type 'uom10:unitSet'
        uom10__unitSet *unitSet;
        /// Required element 'uom10:referenceSet' of XML schema type 'uom10:referenceSet'
        uom10__referenceSet *referenceSet;
        /// Required element 'uom10:prefixSet' of XML schema type 'uom10:prefixSet'
        uom10__prefixSet *prefixSet;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__uomDictionary, default initialized and not managed by a soap context
        virtual uom10__uomDictionary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__uomDictionary); }
      public:
        /// Constructor with default initializations
        uom10__uomDictionary() : title(), originator(), description(), unitDimensionSet(), quantityClassSet(), unitSet(), referenceSet(), prefixSet(), version(), soap() { }
        /// Destructor
        virtual ~uom10__uomDictionary() { }
        /// Friend allocator used by soap_new_uom10__uomDictionary(struct soap*, int)
        friend SOAP_FMAC1 uom10__uomDictionary * SOAP_FMAC2 soap_instantiate_uom10__uomDictionary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:169 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet (-12)
/* complex XML schema type 'uom10:unitDimensionSet': */
class SOAP_CMAC uom10__unitDimensionSet {
      public:
        /// Required element 'uom10:unitDimension' of XML schema type 'uom10:unitDimension'
        std::vector<uom10__unitDimension *> unitDimension;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitDimensionSet, default initialized and not managed by a soap context
        virtual uom10__unitDimensionSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitDimensionSet); }
      public:
        /// Constructor with default initializations
        uom10__unitDimensionSet() : unitDimension(), version(), soap() { }
        /// Destructor
        virtual ~uom10__unitDimensionSet() { }
        /// Friend allocator used by soap_new_uom10__unitDimensionSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitDimensionSet * SOAP_FMAC2 soap_instantiate_uom10__unitDimensionSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:171 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension (-13)
/* complex XML schema type 'uom10:unitDimension': */
class SOAP_CMAC uom10__unitDimension {
      public:
        /// Required element 'uom10:name' of XML schema type 'uom10:nameString'
        std::string name;
        /// Required element 'uom10:dimension' of XML schema type 'uom10:quantityDimension'
        std::string dimension;
        /// Required element 'uom10:baseForConversion' of XML schema type 'uom10:dimemsionalSymbolString'
        std::string baseForConversion;
        /// Required element 'uom10:canonicalUnit' of XML schema type 'uom10:dimemsionalSymbolString'
        std::string canonicalUnit;
        /// Optional element 'uom10:description' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitDimension, default initialized and not managed by a soap context
        virtual uom10__unitDimension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitDimension); }
      public:
        /// Constructor with default initializations
        uom10__unitDimension() : name(), dimension(), baseForConversion(), canonicalUnit(), description(), soap() { }
        /// Destructor
        virtual ~uom10__unitDimension() { }
        /// Friend allocator used by soap_new_uom10__unitDimension(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitDimension * SOAP_FMAC2 soap_instantiate_uom10__unitDimension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:173 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet (-14)
/* complex XML schema type 'uom10:quantityClassSet': */
class SOAP_CMAC uom10__quantityClassSet {
      public:
        /// Required element 'uom10:quantityClass' of XML schema type 'uom10:quantityClass'
        std::vector<uom10__quantityClass *> quantityClass;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__quantityClassSet, default initialized and not managed by a soap context
        virtual uom10__quantityClassSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__quantityClassSet); }
      public:
        /// Constructor with default initializations
        uom10__quantityClassSet() : quantityClass(), version(), soap() { }
        /// Destructor
        virtual ~uom10__quantityClassSet() { }
        /// Friend allocator used by soap_new_uom10__quantityClassSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__quantityClassSet * SOAP_FMAC2 soap_instantiate_uom10__quantityClassSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:175 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass (-15)
/* complex XML schema type 'uom10:quantityClass': */
class SOAP_CMAC uom10__quantityClass {
      public:
        /// Required element 'uom10:name' of XML schema type 'uom10:nameString'
        std::string name;
        /// Required element 'uom10:dimension' of XML schema type 'uom10:quantityDimension'
        std::string dimension;
        /// Required element 'uom10:baseForConversion' of XML schema type 'uom10:symbolString'
        std::string baseForConversion;
        /// Optional element 'uom10:alternativeBase' of XML schema type 'uom10:symbolString'
        std::string *alternativeBase;
        /// Optional element 'uom10:description' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *description;
        /// Required element 'uom10:memberUnit' of XML schema type 'uom10:symbolString'
        std::vector<std::string> memberUnit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__quantityClass, default initialized and not managed by a soap context
        virtual uom10__quantityClass *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__quantityClass); }
      public:
        /// Constructor with default initializations
        uom10__quantityClass() : name(), dimension(), baseForConversion(), alternativeBase(), description(), memberUnit(), soap() { }
        /// Destructor
        virtual ~uom10__quantityClass() { }
        /// Friend allocator used by soap_new_uom10__quantityClass(struct soap*, int)
        friend SOAP_FMAC1 uom10__quantityClass * SOAP_FMAC2 soap_instantiate_uom10__quantityClass(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:177 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitSet (-16)
/* complex XML schema type 'uom10:unitSet': */
class SOAP_CMAC uom10__unitSet {
      public:
        /// Required element 'uom10:unit' of XML schema type 'uom10:unit'
        std::vector<uom10__unit *> unit;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitSet, default initialized and not managed by a soap context
        virtual uom10__unitSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitSet); }
      public:
        /// Constructor with default initializations
        uom10__unitSet() : unit(), version(), soap() { }
        /// Destructor
        virtual ~uom10__unitSet() { }
        /// Friend allocator used by soap_new_uom10__unitSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitSet * SOAP_FMAC2 soap_instantiate_uom10__unitSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:179 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unit
#define SOAP_TYPE_gsoap_uom1_0_uom10__unit (-17)
/* complex XML schema type 'uom10:unit': */
class SOAP_CMAC uom10__unit {
      public:
        /// Required element 'uom10:symbol' of XML schema type 'uom10:symbolString'
        std::string symbol;
        /// Required element 'uom10:name' of XML schema type 'uom10:nameString'
        std::string name;
        /// Required element 'uom10:dimension' of XML schema type 'uom10:quantityDimension'
        std::string dimension;
        /// Required element 'uom10:isSI' of XML schema type 'xsd:boolean'
        bool isSI;
        /// Required element 'uom10:category' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string category;
        /// Optional element 'uom10:isBase' of XML schema type 'uom10:emptyElement'
        uom10__emptyElement *isBase;
        /// Optional element 'uom10:baseUnit' of XML schema type 'uom10:symbolString'
        std::string *baseUnit;
        /// Optional element 'uom10:conversionRef' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *conversionRef;
        /// Optional element 'uom10:isExact' of XML schema type 'xsd:boolean'
        bool *isExact;
        /// Optional element 'uom10:A' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *A;
        /// Optional element 'uom10:B' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *B;
        /// Optional element 'uom10:C' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *C;
        /// Optional element 'uom10:D' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *D;
        /// Optional element 'uom10:underlyingDef' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *underlyingDef;
        /// Optional element 'uom10:description' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unit
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unit, default initialized and not managed by a soap context
        virtual uom10__unit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unit); }
      public:
        /// Constructor with default initializations
        uom10__unit() : symbol(), name(), dimension(), isSI(), category(), isBase(), baseUnit(), conversionRef(), isExact(), A(), B(), C(), D(), underlyingDef(), description(), soap() { }
        /// Destructor
        virtual ~uom10__unit() { }
        /// Friend allocator used by soap_new_uom10__unit(struct soap*, int)
        friend SOAP_FMAC1 uom10__unit * SOAP_FMAC2 soap_instantiate_uom10__unit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:181 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet (-18)
/* complex XML schema type 'uom10:referenceSet': */
class SOAP_CMAC uom10__referenceSet {
      public:
        /// Required element 'uom10:reference' of XML schema type 'uom10:reference'
        std::vector<uom10__reference *> reference;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__referenceSet, default initialized and not managed by a soap context
        virtual uom10__referenceSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__referenceSet); }
      public:
        /// Constructor with default initializations
        uom10__referenceSet() : reference(), version(), soap() { }
        /// Destructor
        virtual ~uom10__referenceSet() { }
        /// Friend allocator used by soap_new_uom10__referenceSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__referenceSet * SOAP_FMAC2 soap_instantiate_uom10__referenceSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:183 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__reference
#define SOAP_TYPE_gsoap_uom1_0_uom10__reference (-19)
/* complex XML schema type 'uom10:reference': */
class SOAP_CMAC uom10__reference {
      public:
        /// Required element 'uom10:ID' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string ID;
        /// Required element 'uom10:description' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__reference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__reference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__reference, default initialized and not managed by a soap context
        virtual uom10__reference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__reference); }
      public:
        /// Constructor with default initializations
        uom10__reference() : ID(), description(), soap() { }
        /// Destructor
        virtual ~uom10__reference() { }
        /// Friend allocator used by soap_new_uom10__reference(struct soap*, int)
        friend SOAP_FMAC1 uom10__reference * SOAP_FMAC2 soap_instantiate_uom10__reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:185 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet (-20)
/* complex XML schema type 'uom10:prefixSet': */
class SOAP_CMAC uom10__prefixSet {
      public:
        /// Required element 'uom10:prefix' of XML schema type 'uom10:prefix'
        std::vector<uom10__prefix *> prefix;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__prefixSet, default initialized and not managed by a soap context
        virtual uom10__prefixSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__prefixSet); }
      public:
        /// Constructor with default initializations
        uom10__prefixSet() : prefix(), version(), soap() { }
        /// Destructor
        virtual ~uom10__prefixSet() { }
        /// Friend allocator used by soap_new_uom10__prefixSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__prefixSet * SOAP_FMAC2 soap_instantiate_uom10__prefixSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:187 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__prefix
#define SOAP_TYPE_gsoap_uom1_0_uom10__prefix (-21)
/* complex XML schema type 'uom10:prefix': */
class SOAP_CMAC uom10__prefix {
      public:
        /// Required element 'uom10:symbol' of XML schema type 'uom10:symbolString'
        std::string symbol;
        /// Required element 'uom10:name' of XML schema type 'uom10:nameString'
        std::string name;
        /// Required element 'uom10:multiplier' of XML schema type 'uom10:nameString'
        std::string multiplier;
        /// Optional element 'uom10:commonName' of XML schema type 'uom10:nameString'
        std::string *commonName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__prefix
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__prefix; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__prefix, default initialized and not managed by a soap context
        virtual uom10__prefix *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__prefix); }
      public:
        /// Constructor with default initializations
        uom10__prefix() : symbol(), name(), multiplier(), commonName(), soap() { }
        /// Destructor
        virtual ~uom10__prefix() { }
        /// Friend allocator used by soap_new_uom10__prefix(struct soap*, int)
        friend SOAP_FMAC1 uom10__prefix * SOAP_FMAC2 soap_instantiate_uom10__prefix(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:189 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet (-22)
/* complex XML schema type 'uom10:integerCodeSet': */
class SOAP_CMAC uom10__integerCodeSet {
      public:
        /// Required element 'uom10:title' of XML schema type 'uom10:descriptionString'
        std::string title;
        /// Required element 'uom10:originator' of XML schema type 'uom10:nameString'
        std::string originator;
        /// Required element 'uom10:description' of XML schema type 'uom10:commentString'
        std::string description;
        /// Required element 'uom10:classCodeSet' of XML schema type 'uom10:classCodeSet'
        uom10__classCodeSet *classCodeSet;
        /// Required element 'uom10:unitCodeSet' of XML schema type 'uom10:unitCodeSet'
        uom10__unitCodeSet *unitCodeSet;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__integerCodeSet, default initialized and not managed by a soap context
        virtual uom10__integerCodeSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__integerCodeSet); }
      public:
        /// Constructor with default initializations
        uom10__integerCodeSet() : title(), originator(), description(), classCodeSet(), unitCodeSet(), version(), soap() { }
        /// Destructor
        virtual ~uom10__integerCodeSet() { }
        /// Friend allocator used by soap_new_uom10__integerCodeSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__integerCodeSet * SOAP_FMAC2 soap_instantiate_uom10__integerCodeSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:191 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet (-23)
/* complex XML schema type 'uom10:classCodeSet': */
class SOAP_CMAC uom10__classCodeSet {
      public:
        /// Required element 'uom10:classCode' of XML schema type 'uom10:classCode'
        std::vector<uom10__classCode *> classCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__classCodeSet, default initialized and not managed by a soap context
        virtual uom10__classCodeSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__classCodeSet); }
      public:
        /// Constructor with default initializations
        uom10__classCodeSet() : classCode(), soap() { }
        /// Destructor
        virtual ~uom10__classCodeSet() { }
        /// Friend allocator used by soap_new_uom10__classCodeSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__classCodeSet * SOAP_FMAC2 soap_instantiate_uom10__classCodeSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:193 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet (-24)
/* complex XML schema type 'uom10:unitCodeSet': */
class SOAP_CMAC uom10__unitCodeSet {
      public:
        /// Required element 'uom10:unitCode' of XML schema type 'uom10:unitCode'
        std::vector<uom10__unitCode *> unitCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitCodeSet, default initialized and not managed by a soap context
        virtual uom10__unitCodeSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitCodeSet); }
      public:
        /// Constructor with default initializations
        uom10__unitCodeSet() : unitCode(), soap() { }
        /// Destructor
        virtual ~uom10__unitCodeSet() { }
        /// Friend allocator used by soap_new_uom10__unitCodeSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitCodeSet * SOAP_FMAC2 soap_instantiate_uom10__unitCodeSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:195 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classCode
#define SOAP_TYPE_gsoap_uom1_0_uom10__classCode (-25)
/* complex XML schema type 'uom10:classCode': */
class SOAP_CMAC uom10__classCode {
      public:
        /// Required element 'uom10:term' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string term;
        /// Required element 'uom10:code' of XML schema type 'xsd:positiveInteger'
        ULONG64 code;
        /// Optional element 'uom10:deprecated' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *deprecated;
        /// Required element 'uom10:unit' of XML schema type 'uom10:unitCodeStruct'
        uom10__unitCodeStruct *unit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__classCode
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__classCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__classCode, default initialized and not managed by a soap context
        virtual uom10__classCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__classCode); }
      public:
        /// Constructor with default initializations
        uom10__classCode() : term(), code(), deprecated(), unit(), soap() { }
        /// Destructor
        virtual ~uom10__classCode() { }
        /// Friend allocator used by soap_new_uom10__classCode(struct soap*, int)
        friend SOAP_FMAC1 uom10__classCode * SOAP_FMAC2 soap_instantiate_uom10__classCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:197 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCode
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCode (-26)
/* complex XML schema type 'uom10:unitCode': */
class SOAP_CMAC uom10__unitCode {
      public:
        /// Required element 'uom10:term' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string term;
        /// Required element 'uom10:code' of XML schema type 'xsd:positiveInteger'
        ULONG64 code;
        /// Optional element 'uom10:deprecated' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string *deprecated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitCode
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitCode, default initialized and not managed by a soap context
        virtual uom10__unitCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitCode); }
      public:
        /// Constructor with default initializations
        uom10__unitCode() : term(), code(), deprecated(), soap() { }
        /// Destructor
        virtual ~uom10__unitCode() { }
        /// Friend allocator used by soap_new_uom10__unitCode(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitCode * SOAP_FMAC2 soap_instantiate_uom10__unitCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:199 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet (-27)
/* complex XML schema type 'uom10:unitMappingSet': */
class SOAP_CMAC uom10__unitMappingSet {
      public:
        /// Required element 'uom10:title' of XML schema type 'uom10:descriptionString'
        std::string title;
        /// Required element 'uom10:originator' of XML schema type 'uom10:nameString'
        std::string originator;
        /// Required element 'uom10:description' of XML schema type 'uom10:commentString'
        std::string description;
        /// Required element 'uom10:unitMap' of XML schema type 'uom10:mapFromToUnit'
        std::vector<uom10__mapFromToUnit *> unitMap;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitMappingSet, default initialized and not managed by a soap context
        virtual uom10__unitMappingSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitMappingSet); }
      public:
        /// Constructor with default initializations
        uom10__unitMappingSet() : title(), originator(), description(), unitMap(), version(), soap() { }
        /// Destructor
        virtual ~uom10__unitMappingSet() { }
        /// Friend allocator used by soap_new_uom10__unitMappingSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitMappingSet * SOAP_FMAC2 soap_instantiate_uom10__unitMappingSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:201 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit
#define SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit (-28)
/* complex XML schema type 'uom10:mapFromToUnit': */
class SOAP_CMAC uom10__mapFromToUnit {
      public:
        /// Required element 'uom10:mapsFrom' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string mapsFrom;
        /// Required element 'uom10:mapsTo' of XML schema type 'xsd:string'
        std::string mapsTo;
        /// Required element 'uom10:state' of XML schema type 'uom10:stateEnum'
        uom10__stateEnum state;
        /// Optional element 'uom10:note' of XML schema type 'xsd:string'
        std::string *note;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__mapFromToUnit, default initialized and not managed by a soap context
        virtual uom10__mapFromToUnit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__mapFromToUnit); }
      public:
        /// Constructor with default initializations
        uom10__mapFromToUnit() : mapsFrom(), mapsTo(), state(), note(), soap() { }
        /// Destructor
        virtual ~uom10__mapFromToUnit() { }
        /// Friend allocator used by soap_new_uom10__mapFromToUnit(struct soap*, int)
        friend SOAP_FMAC1 uom10__mapFromToUnit * SOAP_FMAC2 soap_instantiate_uom10__mapFromToUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:203 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet (-29)
/* complex XML schema type 'uom10:classMappingSet': */
class SOAP_CMAC uom10__classMappingSet {
      public:
        /// Required element 'uom10:title' of XML schema type 'uom10:descriptionString'
        std::string title;
        /// Required element 'uom10:originator' of XML schema type 'uom10:nameString'
        std::string originator;
        /// Required element 'uom10:description' of XML schema type 'uom10:commentString'
        std::string description;
        /// Required element 'uom10:classMap' of XML schema type 'uom10:mapFromToClass'
        std::vector<uom10__mapFromToClass *> classMap;
        /// Required attribute 'version' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__classMappingSet, default initialized and not managed by a soap context
        virtual uom10__classMappingSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__classMappingSet); }
      public:
        /// Constructor with default initializations
        uom10__classMappingSet() : title(), originator(), description(), classMap(), version(), soap() { }
        /// Destructor
        virtual ~uom10__classMappingSet() { }
        /// Friend allocator used by soap_new_uom10__classMappingSet(struct soap*, int)
        friend SOAP_FMAC1 uom10__classMappingSet * SOAP_FMAC2 soap_instantiate_uom10__classMappingSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:205 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass
#define SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass (-30)
/* complex XML schema type 'uom10:mapFromToClass': */
class SOAP_CMAC uom10__mapFromToClass {
      public:
        /// Required element 'uom10:mapsFrom' of XML schema type 'uom10:collapsedNonEmptyString'
        std::string mapsFrom;
        /// Required element 'uom10:mapsTo' of XML schema type 'xsd:string'
        std::string mapsTo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__mapFromToClass, default initialized and not managed by a soap context
        virtual uom10__mapFromToClass *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__mapFromToClass); }
      public:
        /// Constructor with default initializations
        uom10__mapFromToClass() : mapsFrom(), mapsTo(), soap() { }
        /// Destructor
        virtual ~uom10__mapFromToClass() { }
        /// Friend allocator used by soap_new_uom10__mapFromToClass(struct soap*, int)
        friend SOAP_FMAC1 uom10__mapFromToClass * SOAP_FMAC2 soap_instantiate_uom10__mapFromToClass(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:207 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement
#define SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement (-31)
/* complex XML schema type 'uom10:emptyElement': */
class SOAP_CMAC uom10__emptyElement {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__emptyElement, default initialized and not managed by a soap context
        virtual uom10__emptyElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__emptyElement); }
      public:
        /// Constructor with default initializations
        uom10__emptyElement() : soap() { }
        /// Destructor
        virtual ~uom10__emptyElement() { }
        /// Friend allocator used by soap_new_uom10__emptyElement(struct soap*, int)
        friend SOAP_FMAC1 uom10__emptyElement * SOAP_FMAC2 soap_instantiate_uom10__emptyElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:209 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct (-32)
/* simple XML schema type 'uom10:unitCodeStruct': */
class SOAP_CMAC uom10__unitCodeStruct {
      public:
        /// Simple content of XML schema type 'uom10:symbolString' wrapped by this struct
        std::string __item;
        /// Required attribute 'code' of XML schema type 'xsd:positiveInteger'
        ULONG64 code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type uom10__unitCodeStruct, default initialized and not managed by a soap context
        virtual uom10__unitCodeStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(uom10__unitCodeStruct); }
      public:
        /// Constructor with default initializations
        uom10__unitCodeStruct() : __item(), code(), soap() { }
        /// Destructor
        virtual ~uom10__unitCodeStruct() { }
        /// Friend allocator used by soap_new_uom10__unitCodeStruct(struct soap*, int)
        friend SOAP_FMAC1 uom10__unitCodeStruct * SOAP_FMAC2 soap_instantiate_uom10__unitCodeStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* uom1_0ForGsoap.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header (-1187758080)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* uom1_0ForGsoap.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code (-1187758081)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* uom1_0ForGsoap.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail (-1187758083)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* uom1_0ForGsoap.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason (-1187758086)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* uom1_0ForGsoap.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault (-1187758087)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_uom1_0__XML
#define SOAP_TYPE_gsoap_uom1_0__XML (-5)

typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_uom1_0__QName
#define SOAP_TYPE_gsoap_uom1_0__QName (-6)

typedef char *_QName;
#endif

/* uom1_0ForGsoap.h:155 */
#ifndef SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger
#define SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger (-9)

typedef ULONG64 xsd__positiveInteger;
#endif

/* uom1_0ForGsoap.h:220 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString
#define SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString (-34)

typedef std::string uom10__dimemsionalSymbolString;
#endif

/* uom1_0ForGsoap.h:294 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension (-36)

typedef std::string uom10__quantityDimension;
#endif

/* uom1_0ForGsoap.h:310 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString
#define SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString (-37)

typedef std::string uom10__collapsedNonEmptyString;
#endif

/* uom1_0ForGsoap.h:366 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__symbolString
#define SOAP_TYPE_gsoap_uom1_0_uom10__symbolString (-38)

typedef std::string uom10__symbolString;
#endif

/* uom1_0ForGsoap.h:382 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__nameString
#define SOAP_TYPE_gsoap_uom1_0_uom10__nameString (-40)

typedef std::string uom10__nameString;
#endif

/* uom1_0ForGsoap.h:391 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString
#define SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString (-41)

typedef std::string uom10__descriptionString;
#endif

/* uom1_0ForGsoap.h:404 */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__commentString
#define SOAP_TYPE_gsoap_uom1_0_uom10__commentString (-42)

typedef std::string uom10__commentString;
#endif

/* uom1_0ForGsoap.h:1524 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate
#define SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate (-84)

typedef uom10__uomAggregate _uom10__uomAggregate;
#endif

/* uom1_0ForGsoap.h:1531 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary
#define SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary (-85)

typedef uom10__uomDictionary _uom10__uomDictionary;
#endif

/* uom1_0ForGsoap.h:1538 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet (-86)

typedef uom10__unitDimensionSet _uom10__unitDimensionSet;
#endif

/* uom1_0ForGsoap.h:1545 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet (-87)

typedef uom10__quantityClassSet _uom10__quantityClassSet;
#endif

/* uom1_0ForGsoap.h:1552 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitSet (-88)

typedef uom10__unitSet _uom10__unitSet;
#endif

/* uom1_0ForGsoap.h:1559 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet (-89)

typedef uom10__referenceSet _uom10__referenceSet;
#endif

/* uom1_0ForGsoap.h:1566 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet (-90)

typedef uom10__prefixSet _uom10__prefixSet;
#endif

/* uom1_0ForGsoap.h:1573 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet (-91)

typedef uom10__integerCodeSet _uom10__integerCodeSet;
#endif

/* uom1_0ForGsoap.h:1580 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet (-92)

typedef uom10__unitMappingSet _uom10__unitMappingSet;
#endif

/* uom1_0ForGsoap.h:1587 */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet (-93)

typedef uom10__classMappingSet _uom10__classMappingSet;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_gsoap_uom1_0_byte
#define SOAP_TYPE_gsoap_uom1_0_byte (-3)

#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_uom1_0_int
#define SOAP_TYPE_gsoap_uom1_0_int (-1)

#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger
#define SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger (-9)

#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_uom1_0_ULONG64
#define SOAP_TYPE_gsoap_uom1_0_ULONG64 (-8)

#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_uom1_0_bool
#define SOAP_TYPE_gsoap_uom1_0_bool (-64)

#endif

/* uom10__zero has binding name 'uom10__zero' for type 'uom10:zero' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__zero
#define SOAP_TYPE_gsoap_uom1_0_uom10__zero (-39)

#endif

/* uom10__stateEnum has binding name 'uom10__stateEnum' for type 'uom10:stateEnum' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum
#define SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum (-35)

#endif

/* _uom10__classMappingSet has binding name '_uom10__classMappingSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet (-93)

#endif

/* _uom10__unitMappingSet has binding name '_uom10__unitMappingSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet (-92)

#endif

/* _uom10__integerCodeSet has binding name '_uom10__integerCodeSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet (-91)

#endif

/* _uom10__prefixSet has binding name '_uom10__prefixSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet (-90)

#endif

/* _uom10__referenceSet has binding name '_uom10__referenceSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet (-89)

#endif

/* _uom10__unitSet has binding name '_uom10__unitSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitSet (-88)

#endif

/* _uom10__quantityClassSet has binding name '_uom10__quantityClassSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet (-87)

#endif

/* _uom10__unitDimensionSet has binding name '_uom10__unitDimensionSet' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet
#define SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet (-86)

#endif

/* _uom10__uomDictionary has binding name '_uom10__uomDictionary' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary
#define SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary (-85)

#endif

/* _uom10__uomAggregate has binding name '_uom10__uomAggregate' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate
#define SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate (-84)

#endif

/* uom10__commentString has binding name 'uom10__commentString' for type 'uom10:commentString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__commentString
#define SOAP_TYPE_gsoap_uom1_0_uom10__commentString (-42)

#endif

/* uom10__descriptionString has binding name 'uom10__descriptionString' for type 'uom10:descriptionString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString
#define SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString (-41)

#endif

/* uom10__nameString has binding name 'uom10__nameString' for type 'uom10:nameString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__nameString
#define SOAP_TYPE_gsoap_uom1_0_uom10__nameString (-40)

#endif

/* uom10__symbolString has binding name 'uom10__symbolString' for type 'uom10:symbolString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__symbolString
#define SOAP_TYPE_gsoap_uom1_0_uom10__symbolString (-38)

#endif

/* uom10__collapsedNonEmptyString has binding name 'uom10__collapsedNonEmptyString' for type 'uom10:collapsedNonEmptyString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString
#define SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString (-37)

#endif

/* uom10__quantityDimension has binding name 'uom10__quantityDimension' for type 'uom10:quantityDimension' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension (-36)

#endif

/* uom10__dimemsionalSymbolString has binding name 'uom10__dimemsionalSymbolString' for type 'uom10:dimemsionalSymbolString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString
#define SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString (-34)

#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__string
#define SOAP_TYPE_gsoap_uom1_0_std__string (-33)

#endif

/* uom10__unitCodeStruct has binding name 'uom10__unitCodeStruct' for type 'uom10:unitCodeStruct' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct (-32)

#endif

/* uom10__emptyElement has binding name 'uom10__emptyElement' for type 'uom10:emptyElement' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement
#define SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement (-31)

#endif

/* uom10__mapFromToClass has binding name 'uom10__mapFromToClass' for type 'uom10:mapFromToClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass
#define SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass (-30)

#endif

/* uom10__classMappingSet has binding name 'uom10__classMappingSet' for type 'uom10:classMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet (-29)

#endif

/* uom10__mapFromToUnit has binding name 'uom10__mapFromToUnit' for type 'uom10:mapFromToUnit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit
#define SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit (-28)

#endif

/* uom10__unitMappingSet has binding name 'uom10__unitMappingSet' for type 'uom10:unitMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet (-27)

#endif

/* uom10__unitCode has binding name 'uom10__unitCode' for type 'uom10:unitCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCode
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCode (-26)

#endif

/* uom10__classCode has binding name 'uom10__classCode' for type 'uom10:classCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classCode
#define SOAP_TYPE_gsoap_uom1_0_uom10__classCode (-25)

#endif

/* uom10__unitCodeSet has binding name 'uom10__unitCodeSet' for type 'uom10:unitCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet (-24)

#endif

/* uom10__classCodeSet has binding name 'uom10__classCodeSet' for type 'uom10:classCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet (-23)

#endif

/* uom10__integerCodeSet has binding name 'uom10__integerCodeSet' for type 'uom10:integerCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet (-22)

#endif

/* uom10__prefix has binding name 'uom10__prefix' for type 'uom10:prefix' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__prefix
#define SOAP_TYPE_gsoap_uom1_0_uom10__prefix (-21)

#endif

/* uom10__prefixSet has binding name 'uom10__prefixSet' for type 'uom10:prefixSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet (-20)

#endif

/* uom10__reference has binding name 'uom10__reference' for type 'uom10:reference' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__reference
#define SOAP_TYPE_gsoap_uom1_0_uom10__reference (-19)

#endif

/* uom10__referenceSet has binding name 'uom10__referenceSet' for type 'uom10:referenceSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet (-18)

#endif

/* uom10__unit has binding name 'uom10__unit' for type 'uom10:unit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unit
#define SOAP_TYPE_gsoap_uom1_0_uom10__unit (-17)

#endif

/* uom10__unitSet has binding name 'uom10__unitSet' for type 'uom10:unitSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitSet (-16)

#endif

/* uom10__quantityClass has binding name 'uom10__quantityClass' for type 'uom10:quantityClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass (-15)

#endif

/* uom10__quantityClassSet has binding name 'uom10__quantityClassSet' for type 'uom10:quantityClassSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet (-14)

#endif

/* uom10__unitDimension has binding name 'uom10__unitDimension' for type 'uom10:unitDimension' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension (-13)

#endif

/* uom10__unitDimensionSet has binding name 'uom10__unitDimensionSet' for type 'uom10:unitDimensionSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet
#define SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet (-12)

#endif

/* uom10__uomDictionary has binding name 'uom10__uomDictionary' for type 'uom10:uomDictionary' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary
#define SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary (-11)

#endif

/* uom10__uomAggregate has binding name 'uom10__uomAggregate' for type 'uom10:uomAggregate' */
#ifndef SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate
#define SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate (-10)

#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault (-1187758087)

#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason (-1187758086)

#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail (-1187758083)

#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code (-1187758081)

#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header (-1187758080)

#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Reason (-1187758089)

#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Detail (-1187758088)

#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Code
#define SOAP_TYPE_gsoap_uom1_0_PointerToSOAP_ENV__Code (-1187758082)

#endif

/* uom10__mapFromToClass * has binding name 'PointerTouom10__mapFromToClass' for type 'uom10:mapFromToClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToClass
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToClass (-82)

#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTostd__string
#define SOAP_TYPE_gsoap_uom1_0_PointerTostd__string (-81)

#endif

/* uom10__mapFromToUnit * has binding name 'PointerTouom10__mapFromToUnit' for type 'uom10:mapFromToUnit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToUnit
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToUnit (-79)

#endif

/* uom10__unitCodeStruct * has binding name 'PointerTouom10__unitCodeStruct' for type 'uom10:unitCodeStruct' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeStruct
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeStruct (-78)

#endif

/* uom10__unitCode * has binding name 'PointerTouom10__unitCode' for type 'uom10:unitCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCode
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCode (-76)

#endif

/* uom10__classCode * has binding name 'PointerTouom10__classCode' for type 'uom10:classCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCode
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCode (-74)

#endif

/* uom10__unitCodeSet * has binding name 'PointerTouom10__unitCodeSet' for type 'uom10:unitCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeSet (-73)

#endif

/* uom10__classCodeSet * has binding name 'PointerTouom10__classCodeSet' for type 'uom10:classCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCodeSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCodeSet (-72)

#endif

/* std::string * has binding name 'PointerTouom10__nameString' for type 'uom10:nameString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__nameString
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__nameString (-71)

#endif

/* uom10__prefix * has binding name 'PointerTouom10__prefix' for type 'uom10:prefix' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefix
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefix (-69)

#endif

/* uom10__reference * has binding name 'PointerTouom10__reference' for type 'uom10:reference' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__reference
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__reference (-67)

#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTobool
#define SOAP_TYPE_gsoap_uom1_0_PointerTobool (-66)

#endif

/* uom10__emptyElement * has binding name 'PointerTouom10__emptyElement' for type 'uom10:emptyElement' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__emptyElement
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__emptyElement (-65)

#endif

/* uom10__unit * has binding name 'PointerTouom10__unit' for type 'uom10:unit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unit
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unit (-62)

#endif

/* std::string * has binding name 'PointerTouom10__symbolString' for type 'uom10:symbolString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__symbolString
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__symbolString (-60)

#endif

/* uom10__quantityClass * has binding name 'PointerTouom10__quantityClass' for type 'uom10:quantityClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClass
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClass (-58)

#endif

/* std::string * has binding name 'PointerTouom10__collapsedNonEmptyString' for type 'uom10:collapsedNonEmptyString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__collapsedNonEmptyString
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__collapsedNonEmptyString (-57)

#endif

/* uom10__unitDimension * has binding name 'PointerTouom10__unitDimension' for type 'uom10:unitDimension' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimension
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimension (-55)

#endif

/* uom10__prefixSet * has binding name 'PointerTouom10__prefixSet' for type 'uom10:prefixSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefixSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefixSet (-54)

#endif

/* uom10__referenceSet * has binding name 'PointerTouom10__referenceSet' for type 'uom10:referenceSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__referenceSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__referenceSet (-53)

#endif

/* uom10__unitSet * has binding name 'PointerTouom10__unitSet' for type 'uom10:unitSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitSet (-52)

#endif

/* uom10__quantityClassSet * has binding name 'PointerTouom10__quantityClassSet' for type 'uom10:quantityClassSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClassSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClassSet (-51)

#endif

/* uom10__unitDimensionSet * has binding name 'PointerTouom10__unitDimensionSet' for type 'uom10:unitDimensionSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimensionSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimensionSet (-50)

#endif

/* uom10__unitMappingSet * has binding name 'PointerTouom10__unitMappingSet' for type 'uom10:unitMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitMappingSet (-47)

#endif

/* uom10__classMappingSet * has binding name 'PointerTouom10__classMappingSet' for type 'uom10:classMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classMappingSet (-45)

#endif

/* uom10__integerCodeSet * has binding name 'PointerTouom10__integerCodeSet' for type 'uom10:integerCodeSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__integerCodeSet
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__integerCodeSet (-44)

#endif

/* uom10__uomDictionary * has binding name 'PointerTouom10__uomDictionary' for type 'uom10:uomDictionary' */
#ifndef SOAP_TYPE_gsoap_uom1_0_PointerTouom10__uomDictionary
#define SOAP_TYPE_gsoap_uom1_0_PointerTouom10__uomDictionary (-43)

#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_gsoap_uom1_0__QName
#define SOAP_TYPE_gsoap_uom1_0__QName (-6)

#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_uom1_0__XML
#define SOAP_TYPE_gsoap_uom1_0__XML (-5)

#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_uom1_0_string
#define SOAP_TYPE_gsoap_uom1_0_string (-4)

#endif

/* std::vector<uom10__mapFromToClass *>  has binding name 'std__vectorTemplateOfPointerTouom10__mapFromToClass' for type 'uom10:mapFromToClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass (-83)

#endif

/* std::vector<uom10__mapFromToUnit *>  has binding name 'std__vectorTemplateOfPointerTouom10__mapFromToUnit' for type 'uom10:mapFromToUnit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit (-80)

#endif

/* std::vector<uom10__unitCode *>  has binding name 'std__vectorTemplateOfPointerTouom10__unitCode' for type 'uom10:unitCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode (-77)

#endif

/* std::vector<uom10__classCode *>  has binding name 'std__vectorTemplateOfPointerTouom10__classCode' for type 'uom10:classCode' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode (-75)

#endif

/* std::vector<uom10__prefix *>  has binding name 'std__vectorTemplateOfPointerTouom10__prefix' for type 'uom10:prefix' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix (-70)

#endif

/* std::vector<uom10__reference *>  has binding name 'std__vectorTemplateOfPointerTouom10__reference' for type 'uom10:reference' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference (-68)

#endif

/* std::vector<uom10__unit *>  has binding name 'std__vectorTemplateOfPointerTouom10__unit' for type 'uom10:unit' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit (-63)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfuom10__symbolString' for type 'uom10:symbolString' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString (-61)

#endif

/* std::vector<uom10__quantityClass *>  has binding name 'std__vectorTemplateOfPointerTouom10__quantityClass' for type 'uom10:quantityClass' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass (-59)

#endif

/* std::vector<uom10__unitDimension *>  has binding name 'std__vectorTemplateOfPointerTouom10__unitDimension' for type 'uom10:unitDimension' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension (-56)

#endif

/* std::vector<uom10__unitMappingSet *>  has binding name 'std__vectorTemplateOfPointerTouom10__unitMappingSet' for type 'uom10:unitMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet (-48)

#endif

/* std::vector<uom10__classMappingSet *>  has binding name 'std__vectorTemplateOfPointerTouom10__classMappingSet' for type 'uom10:classMappingSet' */
#ifndef SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet
#define SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet (-46)

#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_uom1_0


#endif

/* End of gsoap_uom1_0Stub.h */
