/* gsoap_eml2_2Stub.h
   Generated by gSOAP 2.8.117E for eml2_2ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use and protected by law.
**  REDISTRIBUTION, RESALE OR ANY OTHER FORM OF SHARING IS STRICTLY PROHIBITED.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_prodml21	"http://www.energistics.org/energyml/data/prodmlv2"
#define SOAP_NAMESPACE_OF_eml22	"http://www.energistics.org/energyml/data/commonv2"
#include <time.h>

#ifndef gsoap_eml2_2Stub_H
#define gsoap_eml2_2Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_eml2_2 {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* eml2_2ForGsoap.h:2680 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GrowingStatusKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__GrowingStatusKind (-1145)

/* eml22:GrowingStatusKind */
enum class eml22__GrowingStatusKind {
	active = 0,
	inactive = 1
};
#endif

/* eml2_2ForGsoap.h:2706 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NorthReferenceKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__NorthReferenceKind (-1146)

/* eml22:NorthReferenceKind */
enum class eml22__NorthReferenceKind {
	astronomic_x0020north = 0,
	compass_x0020north = 1,
	grid_x0020north = 2,
	magnetic_x0020north = 3,
	plant_x0020north = 4,
	true_x0020north = 5
};
#endif

/* eml2_2ForGsoap.h:2763 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AxisDirectionKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__AxisDirectionKind (-1155)

/* eml22:AxisDirectionKind */
enum class eml22__AxisDirectionKind {
	aft = 0,
	away_from = 1,
	clockwise = 2,
	column_negative = 3,
	column_positive = 4,
	counter_clockwise = 5,
	display_down = 6,
	display_left = 7,
	display_right = 8,
	display_up = 9,
	down = 10,
	east = 11,
	east_north_east = 12,
	east_south_east = 13,
	forward = 14,
	future = 15,
	geocentric_x0020x = 16,
	geocentric_x0020y = 17,
	geocentric_x0020z = 18,
	north_east = 19,
	north_north_east = 20,
	north_north_west = 21,
	north_west = 22,
	past = 23,
	port = 24,
	row_negative = 25,
	row_positive = 26,
	south = 27,
	south_east = 28,
	south_south_east = 29,
	south_south_west = 30,
	south_west = 31,
	starboard = 32,
	towards = 33,
	up = 34,
	west = 35,
	west_north_west = 36,
	west_south_west = 37
};
#endif

/* eml2_2ForGsoap.h:2867 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyUnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyUnitOfMeasure (-1163)

/* eml22:LegacyUnitOfMeasure */
enum class eml22__LegacyUnitOfMeasure {
	_1000scf_x002fd = 0,
	_1000scf_x002fmo = 1,
	_1000scf_x002fstb = 2,
	_1000scm = 3,
	_1000scm_x002fd = 4,
	_1000scm_x002fmo = 5,
	_1000stb = 6,
	_1000stb_x002fd = 7,
	_1000stb_x002fmo = 8,
	_1E6scf = 9,
	_1E6scf_x002fd = 10,
	_1E6scf_x002fmo = 11,
	_1E6scf_x002fstb = 12,
	_1E6scm = 13,
	_1E6scm_x002fd = 14,
	_1E6scm_x002fmo = 15,
	_1E6stb = 16,
	_1E6stb_x002facre = 17,
	_1E6stb_x002facre_x002eft = 18,
	_1E6stb_x002fd = 19,
	_1E6stb_x002fmo = 20,
	_1E9scf = 21,
	acre_x002eft_x002f1E6stb = 22,
	bbl_x002f1000scf = 23,
	bbl_x002f1E6scf = 24,
	bbl_x002fscf = 25,
	bbl_x002fstb = 26,
	ft3_x002fscf = 27,
	ft3_x002fstb = 28,
	galUS_x002f1000scf = 29,
	kg_x002fscm = 30,
	kscf = 31,
	lbm_x002f1000scf = 32,
	lbm_x002f1E6scf = 33,
	m3_x002fscm = 34,
	ml_x002fscm = 35,
	Pa_x002fscm = 36,
	psi_x002f1000scf = 37,
	psi_x002f1E6scf = 38,
	psia = 39,
	psig = 40,
	scf = 41,
	scf_x002fbbl = 42,
	scf_x002fd = 43,
	scf_x002fft2 = 44,
	scf_x002fft3 = 45,
	scf_x002fscf = 46,
	scf_x002fstb = 47,
	scm = 48,
	scm_x002fd = 49,
	scm_x002fh = 50,
	scm_x002fm2 = 51,
	scm_x002fm3 = 52,
	scm_x002fmo = 53,
	scm_x002fs = 54,
	scm_x002fscm = 55,
	scm_x002fstb = 56,
	stb = 57,
	stb_x002f1000scf = 58,
	stb_x002f1000scm = 59,
	stb_x002f1E6scf = 60,
	stb_x002f1E6scm = 61,
	stb_x002facre = 62,
	stb_x002fbbl = 63,
	stb_x002fd = 64,
	stb_x002fmo = 'A',
	stb_x002fscm = 'B',
	stb_x002fstb = 'C'
};
#endif

/* eml2_2ForGsoap.h:2945 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasure (-1164)

/* eml22:UnitOfMeasure */
enum class eml22__UnitOfMeasure {
	A = 'A',
	a = 'a',
	B = 'B',
	b = 'b',
	C = 'C',
	d = 'd',
	D = 'D',
	F = 'F',
	g = 'g',
	H = 'H',
	h = 'h',
	J = 'J',
	K = 'K',
	L = 'L',
	m = 'm',
	N = 'N',
	O = 'O',
	P = 'P',
	S = 'S',
	s = 's',
	t = 't',
	T = 'T',
	V = 'V',
	W = 'W',
	_x0025 = 'u',
	_x0025_x005barea_x005d = 'v',
	_x0025_x005bmass_x005d = 'w',
	_x0025_x005bmolar_x005d = 'x',
	_x0025_x005bvol_x005d = 'y',
	_x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 'z',
	_x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 123,
	_x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 124,
	_0_x002e001_x0020bbl_x002fft3 = 125,
	_0_x002e001_x0020bbl_x002fm3 = 126,
	_0_x002e001_x0020d_x002fft3 = 127,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 128,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 129,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 130,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 131,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 132,
	_0_x002e001_x0020h_x002fft = 133,
	_0_x002e001_x0020kPa2_x002fcP = 134,
	_0_x002e001_x0020lbm_x002fbbl = 135,
	_0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 136,
	_0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 137,
	_0_x002e001_x0020psi_x002fft = 138,
	_0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 139,
	_0_x002e001_x0020seca = 140,
	_0_x002e01_x0020bbl_x002fbbl = 141,
	_0_x002e01_x0020dega_x002fft = 142,
	_0_x002e01_x0020degF_x002fft = 143,
	_0_x002e01_x0020dm3_x002fkm = 144,
	_0_x002e01_x0020ft_x002fft = 145,
	_0_x002e01_x0020grain_x002fft3 = 146,
	_0_x002e01_x0020L_x002fkg = 147,
	_0_x002e01_x0020L_x002fkm = 148,
	_0_x002e01_x0020lbf_x002fft = 149,
	_0_x002e01_x0020lbf_x002fft2 = 150,
	_0_x002e01_x0020lbm_x002fft2 = 151,
	_0_x002e01_x0020psi_x002fft = 152,
	_0_x002e1_x0020ft = 153,
	_0_x002e1_x0020ft_x005bUS_x005d = 154,
	_0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 155,
	_0_x002e1_x0020in = 156,
	_0_x002e1_x0020L_x002fbbl = 157,
	_0_x002e1_x0020lbm_x002fbbl = 158,
	_0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 159,
	_0_x002e1_x0020yd = 160,
	_1_x002f_x0028kg_x002es_x0029 = 161,
	_1_x002f16_x0020in = 162,
	_1_x002f2_x0020ft = 163,
	_1_x002f2_x0020ms = 164,
	_1_x002f30_x0020cm3_x002fmin = 165,
	_1_x002f30_x0020dega_x002fft = 166,
	_1_x002f30_x0020dega_x002fm = 167,
	_1_x002f30_x0020lbf_x002fm = 168,
	_1_x002f30_x0020m_x002fm = 169,
	_1_x002f30_x0020N_x002fm = 170,
	_1_x002f32_x0020in = 171,
	_1_x002f64_x0020in = 172,
	_1_x002fa = 173,
	_1_x002fangstrom = 174,
	_1_x002fbar = 175,
	_1_x002fbbl = 176,
	_1_x002fcm = 177,
	_1_x002fd = 178,
	_1_x002fdegC = 179,
	_1_x002fdegF = 180,
	_1_x002fdegR = 181,
	_1_x002fft = 182,
	_1_x002fft2 = 183,
	_1_x002fft3 = 184,
	_1_x002fg = 185,
	_1_x002fgal_x005bUK_x005d = 186,
	_1_x002fgal_x005bUS_x005d = 187,
	_1_x002fH = 188,
	_1_x002fh = 189,
	_1_x002fin = 190,
	_1_x002fK = 191,
	_1_x002fkg = 192,
	_1_x002fkm2 = 193,
	_1_x002fkPa = 194,
	_1_x002fL = 195,
	_1_x002flbf = 196,
	_1_x002flbm = 197,
	_1_x002fm = 198,
	_1_x002fm2 = 199,
	_1_x002fm3 = 200,
	_1_x002fmi = 201,
	_1_x002fmi2 = 202,
	_1_x002fmin = 203,
	_1_x002fmm = 204,
	_1_x002fms = 205,
	_1_x002fN = 206,
	_1_x002fnm = 207,
	_1_x002fPa = 208,
	_1_x002fpPa = 209,
	_1_x002fpsi = 210,
	_1_x002fs = 211,
	_1_x002fupsi = 212,
	_1_x002fus = 213,
	_1_x002fuV = 214,
	_1_x002fV = 215,
	_1_x002fwk = 216,
	_1_x002fyd = 217,
	_10_x0020ft = 218,
	_10_x0020in = 219,
	_10_x0020km = 220,
	_10_x0020kN = 221,
	_10_x0020Mg_x002fm3 = 222,
	_100_x0020ft = 223,
	_100_x0020ka_x005bt_x005d = 224,
	_100_x0020km = 225,
	_1000_x0020bbl = 226,
	_1000_x0020bbl_x002eft_x002fd = 227,
	_1000_x0020bbl_x002fd = 228,
	_1000_x0020ft = 229,
	_1000_x0020ft_x002fh = 230,
	_1000_x0020ft_x002fs = 231,
	_1000_x0020ft3 = 232,
	_1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 233,
	_1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 234,
	_1000_x0020ft3_x002fbbl = 235,
	_1000_x0020ft3_x002fd = 236,
	_1000_x0020gal_x005bUK_x005d = 237,
	_1000_x0020gal_x005bUS_x005d = 238,
	_1000_x0020lbf_x002eft = 239,
	_1000_x0020m3 = 240,
	_1000_x0020m3_x002f_x0028d_x002em_x0029 = 241,
	_1000_x0020m3_x002f_x0028h_x002em_x0029 = 242,
	_1000_x0020m3_x002fd = 243,
	_1000_x0020m3_x002fh = 244,
	_1000_x0020m3_x002fm3 = 245,
	_1000_x0020m4_x002fd = 246,
	_1E12_x0020ft3 = 247,
	_1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 248,
	_1E_6_x0020acre_x002eft_x002fbbl = 249,
	_1E6_x0020bbl = 250,
	_1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 251,
	_1E6_x0020bbl_x002facre = 252,
	_1E6_x0020bbl_x002fd = 253,
	_1E_6_x0020bbl_x002fft3 = 254,
	_1E_6_x0020bbl_x002fm3 = 255,
	_1E6_x0020Btu_x005bIT_x005d = 256,
	_1E6_x0020Btu_x005bIT_x005d_x002fh = 257,
	_1E6_x0020ft3 = 258,
	_1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 259,
	_1E6_x0020ft3_x002fbbl = 260,
	_1E6_x0020ft3_x002fd = 261,
	_1E_6_x0020gal_x005bUS_x005d = 262,
	_1E6_x0020lbm_x002fa = 263,
	_1E6_x0020m3 = 264,
	_1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = 265,
	_1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = 266,
	_1E6_x0020m3_x002fd = 267,
	_1E_9_x00201_x002fft = 268,
	_1E9_x0020bbl = 269,
	_1E9_x0020ft3 = 270,
	_30_x0020ft = 271,
	_30_x0020m = 272,
	A_x002eh = 273,
	A_x002em2 = 274,
	A_x002es = 275,
	A_x002es_x002fkg = 276,
	A_x002es_x002fm3 = 277,
	A_x002fcm2 = 278,
	A_x002fft2 = 279,
	A_x002fm = 280,
	A_x002fm2 = 281,
	A_x002fmm = 282,
	A_x002fmm2 = 283,
	a_x005bt_x005d = 284,
	acre = 285,
	acre_x002eft = 286,
	ag = 287,
	aJ = 288,
	angstrom = 289,
	at = 290,
	atm = 291,
	atm_x002fft = 292,
	atm_x002fh = 293,
	atm_x002fhm = 294,
	atm_x002fm = 295,
	B_x002eW = 296,
	b_x002fcm3 = 297,
	B_x002fm = 298,
	B_x002fO = 299,
	bar = 300,
	bar_x002fh = 301,
	bar_x002fkm = 302,
	bar_x002fm = 303,
	bar2 = 304,
	bar2_x002fcP = 305,
	bbl = 306,
	bbl_x002f_x0028acre_x002eft_x0029 = 307,
	bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 308,
	bbl_x002f_x0028d_x002eft_x0029 = 309,
	bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 310,
	bbl_x002f_x0028kPa_x002ed_x0029 = 311,
	bbl_x002f_x0028psi_x002ed_x0029 = 312,
	bbl_x002facre = 313,
	bbl_x002fbbl = 314,
	bbl_x002fd = 315,
	bbl_x002fd2 = 316,
	bbl_x002fft = 317,
	bbl_x002fft3 = 318,
	bbl_x002fh = 319,
	bbl_x002fh2 = 320,
	bbl_x002fin = 321,
	bbl_x002fm3 = 322,
	bbl_x002fmi = 323,
	bbl_x002fmin = 324,
	bbl_x002fpsi = 325,
	bbl_x002fton_x005bUK_x005d = 326,
	bbl_x002fton_x005bUS_x005d = 327,
	Bd = 328,
	bit = 329,
	bit_x002fs = 330,
	Bq = 331,
	Bq_x002fkg = 332,
	Btu_x005bIT_x005d = 333,
	Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = 334,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = 335,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 336,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = 337,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = 338,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 339,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = 340,
	Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 341,
	Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 342,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = 343,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = 344,
	Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = 345,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 346,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = 347,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 348,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = 349,
	Btu_x005bIT_x005d_x002fbbl = 350,
	Btu_x005bIT_x005d_x002fft3 = 351,
	Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 352,
	Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 353,
	Btu_x005bIT_x005d_x002fh = 354,
	Btu_x005bIT_x005d_x002flbm = 355,
	Btu_x005bIT_x005d_x002flbmol = 356,
	Btu_x005bIT_x005d_x002fmin = 357,
	Btu_x005bIT_x005d_x002fs = 358,
	Btu_x005bth_x005d = 359,
	Btu_x005bUK_x005d = 360,
	byte = 361,
	byte_x002fs = 362,
	C_x002em = 363,
	C_x002fcm2 = 364,
	C_x002fcm3 = 365,
	C_x002fg = 366,
	C_x002fkg = 367,
	C_x002fm2 = 368,
	C_x002fm3 = 369,
	C_x002fmm2 = 370,
	C_x002fmm3 = 371,
	ca = 372,
	cA = 373,
	cal_x005bIT_x005d = 374,
	cal_x005bth_x005d = 375,
	cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = 376,
	cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = 377,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 378,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = 379,
	cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 380,
	cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = 381,
	cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = 382,
	cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = 383,
	cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 384,
	cal_x005bth_x005d_x002fcm3 = 385,
	cal_x005bth_x005d_x002fg = 386,
	cal_x005bth_x005d_x002fh = 387,
	cal_x005bth_x005d_x002fkg = 388,
	cal_x005bth_x005d_x002flbm = 389,
	cal_x005bth_x005d_x002fmL = 390,
	cal_x005bth_x005d_x002fmm3 = 391,
	cC = 392,
	ccal_x005bth_x005d = 393,
	ccgr = 394,
	cd = 395,
	cd_x002fm2 = 396,
	cEuc = 397,
	ceV = 398,
	cF = 399,
	cg = 400,
	cgauss = 401,
	cgr = 402,
	cGy = 403,
	cH = 404,
	chain = 405,
	chain_x005bBnA_x005d = 406,
	chain_x005bBnB_x005d = 407,
	chain_x005bCla_x005d = 408,
	chain_x005bInd37_x005d = 409,
	chain_x005bSe_x005d = 410,
	chain_x005bSeT_x005d = 411,
	chain_x005bUS_x005d = 412,
	cHz = 413,
	Ci = 414,
	cJ = 415,
	cm = 416,
	cm_x002fa = 417,
	cm_x002fs = 418,
	cm_x002fs2 = 419,
	cm2 = 420,
	cm2_x002fg = 421,
	cm2_x002fs = 422,
	cm3 = 423,
	cm3_x002fcm3 = 424,
	cm3_x002fg = 425,
	cm3_x002fh = 426,
	cm3_x002fL = 427,
	cm3_x002fm3 = 428,
	cm3_x002fmin = 429,
	cm3_x002fs = 430,
	cm4 = 431,
	cmH2O_x005b4degC_x005d = 432,
	cN = 433,
	cohm = 434,
	cP = 435,
	cPa = 436,
	crd = 437,
	cS = 438,
	cs = 439,
	cSt = 440,
	cT = 441,
	ct = 442,
	cu = 443,
	cV = 444,
	cW = 445,
	cWb = 446,
	cwt_x005bUK_x005d = 447,
	cwt_x005bUS_x005d = 448,
	D_x002eft = 449,
	D_x002em = 450,
	D_x002f_x0028Pa_x002es_x0029 = 451,
	d_x002fbbl = 452,
	D_x002fcP = 453,
	d_x002fft3 = 454,
	d_x002fm3 = 455,
	D_x005bAPI_x005d = 456,
	dA = 457,
	dam = 458,
	daN = 459,
	daN_x002em = 460,
	dAPI = 461,
	dB = 462,
	dB_x002emW = 463,
	dB_x002eMW = 464,
	dB_x002eW = 465,
	dB_x002fft = 466,
	dB_x002fkm = 467,
	dB_x002fm = 468,
	dB_x002fO = 469,
	dC = 470,
	dcal_x005bth_x005d = 471,
	dega = 472,
	dega_x002fft = 473,
	dega_x002fh = 474,
	dega_x002fm = 475,
	dega_x002fmin = 476,
	dega_x002fs = 477,
	degC = 478,
	degC_x002em2_x002eh_x002fkcal_x005bth_x005d = 479,
	degC_x002fft = 480,
	degC_x002fh = 481,
	degC_x002fhm = 482,
	degC_x002fkm = 483,
	degC_x002fkPa = 484,
	degC_x002fm = 485,
	degC_x002fmin = 486,
	degC_x002fs = 487,
	degF = 488,
	degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 489,
	degF_x002fft = 490,
	degF_x002fh = 491,
	degF_x002fm = 492,
	degF_x002fmin = 493,
	degF_x002fpsi = 494,
	degF_x002fs = 495,
	degR = 496,
	dEuc = 497,
	deV = 498,
	dF = 499,
	dgauss = 500,
	dGy = 501,
	dH = 502,
	dHz = 503,
	dJ = 504,
	dm = 505,
	dm_x002fs = 506,
	dm3 = 507,
	dm3_x002f_x0028kW_x002eh_x0029 = 508,
	dm3_x002fkg = 509,
	dm3_x002fkmol = 510,
	dm3_x002fm = 511,
	dm3_x002fm3 = 512,
	dm3_x002fMJ = 513,
	dm3_x002fs = 514,
	dm3_x002fs2 = 515,
	dm3_x002ft = 516,
	dN = 517,
	dN_x002em = 518,
	dohm = 519,
	dP = 520,
	dPa = 521,
	drd = 522,
	dS = 523,
	ds = 524,
	dT = 525,
	dV = 526,
	dW = 527,
	dWb = 528,
	dyne = 529,
	dyne_x002ecm2 = 530,
	dyne_x002es_x002fcm2 = 531,
	dyne_x002fcm = 532,
	dyne_x002fcm2 = 533,
	EA = 534,
	Ea_x005bt_x005d = 535,
	EC = 536,
	Ecal_x005bth_x005d = 537,
	EEuc = 538,
	EeV = 539,
	EF = 540,
	Eg = 541,
	Egauss = 542,
	EGy = 543,
	EH = 544,
	EHz = 545,
	EJ = 546,
	EJ_x002fa = 547,
	Em = 548,
	EN = 549,
	Eohm = 550,
	EP = 551,
	EPa = 552,
	Erd = 553,
	erg = 554,
	erg_x002fa = 555,
	erg_x002fcm2 = 556,
	erg_x002fcm3 = 557,
	erg_x002fg = 558,
	erg_x002fkg = 559,
	erg_x002fm3 = 560,
	ES = 561,
	ET = 562,
	Euc = 563,
	eV = 564,
	EW = 565,
	EWb = 566,
	F_x002fm = 567,
	fa = 568,
	fA = 569,
	fathom = 570,
	fC = 571,
	fcal_x005bth_x005d = 572,
	fEuc = 573,
	feV = 574,
	fF = 575,
	fg = 576,
	fgauss = 577,
	fGy = 578,
	fH = 579,
	fHz = 580,
	fJ = 581,
	floz_x005bUK_x005d = 582,
	floz_x005bUS_x005d = 583,
	fm = 584,
	fN = 585,
	fohm = 586,
	footcandle = 587,
	footcandle_x002es = 588,
	fP = 589,
	fPa = 590,
	frd = 591,
	fS = 592,
	ft = 593,
	fT = 594,
	ft_x002fbbl = 595,
	ft_x002fd = 596,
	ft_x002fdegF = 597,
	ft_x002fft = 598,
	ft_x002fft3 = 599,
	ft_x002fgal_x005bUS_x005d = 600,
	ft_x002fh = 601,
	ft_x002fin = 602,
	ft_x002flbm = 603,
	ft_x002fm = 604,
	ft_x002fmi = 605,
	ft_x002fmin = 606,
	ft_x002fms = 607,
	ft_x002fpsi = 608,
	ft_x002fs = 609,
	ft_x002fs2 = 610,
	ft_x002fus = 611,
	ft_x005bBnA_x005d = 612,
	ft_x005bBnB_x005d = 613,
	ft_x005bBr36_x005d = 614,
	ft_x005bBr65_x005d = 615,
	ft_x005bCla_x005d = 616,
	ft_x005bGC_x005d = 617,
	ft_x005bInd_x005d = 618,
	ft_x005bInd37_x005d = 619,
	ft_x005bInd62_x005d = 620,
	ft_x005bInd75_x005d = 621,
	ft_x005bSe_x005d = 622,
	ft_x005bSeT_x005d = 623,
	ft_x005bUS_x005d = 624,
	ft2 = 625,
	ft2_x002fh = 626,
	ft2_x002fin3 = 627,
	ft2_x002flbm = 628,
	ft2_x002fs = 629,
	ft3 = 630,
	ft3_x002f_x0028d_x002eft_x0029 = 631,
	ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 632,
	ft3_x002f_x0028min_x002eft2_x0029 = 633,
	ft3_x002f_x0028s_x002eft2_x0029 = 634,
	ft3_x002fbbl = 635,
	ft3_x002fd = 636,
	ft3_x002fd2 = 637,
	ft3_x002fft = 638,
	ft3_x002fft2 = 639,
	ft3_x002fft3 = 640,
	ft3_x002fh = 641,
	ft3_x002fh2 = 642,
	ft3_x002fkg = 643,
	ft3_x002flbm = 644,
	ft3_x002flbmol = 645,
	ft3_x002fmin = 646,
	ft3_x002fmin2 = 647,
	ft3_x002frad = 648,
	ft3_x002fs = 649,
	ft3_x002fs2 = 650,
	ft3_x002fsack_x005b94lbm_x005d = 651,
	fur_x005bUS_x005d = 652,
	fV = 653,
	fW = 654,
	fWb = 655,
	g_x002eft_x002f_x0028cm3_x002es_x0029 = 656,
	g_x002em_x002f_x0028cm3_x002es_x0029 = 657,
	g_x002fcm3 = 658,
	g_x002fcm4 = 659,
	g_x002fdm3 = 660,
	g_x002fgal_x005bUK_x005d = 661,
	g_x002fgal_x005bUS_x005d = 662,
	g_x002fkg = 663,
	g_x002fL = 664,
	g_x002fm3 = 665,
	g_x002fmol = 666,
	g_x002fs = 667,
	g_x002ft = 668,
	GA = 669,
	Ga_x005bt_x005d = 670,
	Gal = 671,
	gal_x005bUK_x005d = 672,
	gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 673,
	gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 674,
	gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 675,
	gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 676,
	gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 677,
	gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 678,
	gal_x005bUK_x005d_x002fd = 679,
	gal_x005bUK_x005d_x002fft3 = 680,
	gal_x005bUK_x005d_x002fh = 681,
	gal_x005bUK_x005d_x002fh2 = 682,
	gal_x005bUK_x005d_x002flbm = 683,
	gal_x005bUK_x005d_x002fmi = 684,
	gal_x005bUK_x005d_x002fmin = 685,
	gal_x005bUK_x005d_x002fmin2 = 686,
	gal_x005bUS_x005d = 687,
	gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 688,
	gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 689,
	gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 690,
	gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 691,
	gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 692,
	gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 693,
	gal_x005bUS_x005d_x002fbbl = 694,
	gal_x005bUS_x005d_x002fd = 695,
	gal_x005bUS_x005d_x002fft = 696,
	gal_x005bUS_x005d_x002fft3 = 697,
	gal_x005bUS_x005d_x002fh = 698,
	gal_x005bUS_x005d_x002fh2 = 699,
	gal_x005bUS_x005d_x002flbm = 700,
	gal_x005bUS_x005d_x002fmi = 701,
	gal_x005bUS_x005d_x002fmin = 702,
	gal_x005bUS_x005d_x002fmin2 = 703,
	gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 704,
	gal_x005bUS_x005d_x002fton_x005bUK_x005d = 705,
	gal_x005bUS_x005d_x002fton_x005bUS_x005d = 706,
	gAPI = 707,
	gauss = 708,
	gauss_x002fcm = 709,
	GBq = 710,
	GC = 711,
	Gcal_x005bth_x005d = 712,
	GEuc = 713,
	GeV = 714,
	gf = 715,
	GF = 716,
	Gg = 717,
	Ggauss = 718,
	GGy = 719,
	GH = 720,
	GHz = 721,
	GJ = 722,
	Gm = 723,
	GN = 724,
	gn = 725,
	Gohm = 726,
	gon = 727,
	GP = 728,
	GPa = 729,
	GPa_x002fcm = 730,
	GPa2 = 731,
	grain = 732,
	grain_x002fft3 = 733,
	grain_x002fgal_x005bUS_x005d = 734,
	Grd = 735,
	GS = 736,
	GT = 737,
	GV = 738,
	GW = 739,
	GW_x002eh = 740,
	GWb = 741,
	Gy = 742,
	h_x002fft3 = 743,
	h_x002fkm = 744,
	H_x002fm = 745,
	h_x002fm3 = 746,
	ha = 747,
	ha_x002em = 748,
	hbar = 749,
	hg = 750,
	hL = 751,
	hm = 752,
	hN = 753,
	hp = 754,
	hp_x002eh = 755,
	hp_x002eh_x002fbbl = 756,
	hp_x002eh_x002flbm = 757,
	hp_x002fft3 = 758,
	hp_x002fin2 = 759,
	hp_x005belec_x005d = 760,
	hp_x005bhyd_x005d = 761,
	hp_x005bhyd_x005d_x002fin2 = 762,
	hp_x005bmetric_x005d = 763,
	hp_x005bmetric_x005d_x002eh = 764,
	hs = 765,
	Hz = 766,
	in = 767,
	in_x002f_x0028in_x002edegF_x0029 = 768,
	in_x002fa = 769,
	in_x002fmin = 770,
	in_x002fs = 771,
	in_x002fs2 = 772,
	in_x005bUS_x005d = 773,
	in2 = 774,
	in2_x002fft2 = 775,
	in2_x002fin2 = 776,
	in2_x002fs = 777,
	in3 = 778,
	in3_x002fft = 779,
	in4 = 780,
	inH2O_x005b39degF_x005d = 781,
	inH2O_x005b60degF_x005d = 782,
	inHg_x005b32degF_x005d = 783,
	inHg_x005b60degF_x005d = 784,
	J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = 785,
	J_x002em_x002fm2 = 786,
	J_x002f_x0028g_x002eK_x0029 = 787,
	J_x002f_x0028kg_x002eK_x0029 = 788,
	J_x002f_x0028mol_x002eK_x0029 = 789,
	J_x002f_x0028s_x002em2_x002edegC_x0029 = 790,
	J_x002fcm2 = 791,
	J_x002fdm3 = 792,
	J_x002fg = 793,
	J_x002fK = 794,
	J_x002fkg = 795,
	J_x002fm = 796,
	J_x002fm2 = 797,
	J_x002fm3 = 798,
	J_x002fmol = 799,
	J_x002fs = 800,
	K_x002em2_x002fkW = 801,
	K_x002em2_x002fW = 802,
	K_x002fkm = 803,
	K_x002fm = 804,
	K_x002fPa = 805,
	K_x002fs = 806,
	K_x002fW = 807,
	kA = 808,
	ka_x005bt_x005d = 809,
	kC = 810,
	kcal_x005bth_x005d = 811,
	kcal_x005bth_x005d_x002em_x002fcm2 = 812,
	kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = 813,
	kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 814,
	kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = 815,
	kcal_x005bth_x005d_x002fcm3 = 816,
	kcal_x005bth_x005d_x002fg = 817,
	kcal_x005bth_x005d_x002fh = 818,
	kcal_x005bth_x005d_x002fkg = 819,
	kcal_x005bth_x005d_x002fm3 = 820,
	kcal_x005bth_x005d_x002fmol = 821,
	kcd = 822,
	kdyne = 823,
	kEuc = 824,
	keV = 825,
	kF = 826,
	kg = 827,
	kg_x002em = 828,
	kg_x002em_x002fcm2 = 829,
	kg_x002em_x002fs = 830,
	kg_x002em2 = 831,
	kg_x002f_x0028kW_x002eh_x0029 = 832,
	kg_x002f_x0028m_x002es_x0029 = 833,
	kg_x002f_x0028m2_x002es_x0029 = 834,
	kg_x002fd = 835,
	kg_x002fdm3 = 836,
	kg_x002fdm4 = 837,
	kg_x002fh = 838,
	kg_x002fJ = 839,
	kg_x002fkg = 840,
	kg_x002fL = 841,
	kg_x002fm = 842,
	kg_x002fm2 = 843,
	kg_x002fm3 = 844,
	kg_x002fm4 = 845,
	kg_x002fmin = 846,
	kg_x002fMJ = 847,
	kg_x002fmol = 848,
	kg_x002fs = 849,
	kg_x002fsack_x005b94lbm_x005d = 850,
	kg_x002ft = 851,
	kgauss = 852,
	kgf = 853,
	kgf_x002em = 854,
	kgf_x002em_x002fcm2 = 855,
	kgf_x002em_x002fm = 856,
	kgf_x002em2 = 857,
	kgf_x002es_x002fm2 = 858,
	kgf_x002fcm = 859,
	kgf_x002fcm2 = 860,
	kgf_x002fkgf = 861,
	kgf_x002fm2 = 862,
	kgf_x002fmm2 = 863,
	kGy = 864,
	kH = 865,
	kHz = 866,
	Kibyte = 867,
	kJ = 868,
	kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = 869,
	kJ_x002f_x0028h_x002em2_x002eK_x0029 = 870,
	kJ_x002f_x0028kg_x002eK_x0029 = 871,
	kJ_x002f_x0028kmol_x002eK_x0029 = 872,
	kJ_x002fdm3 = 873,
	kJ_x002fkg = 874,
	kJ_x002fkmol = 875,
	kJ_x002fm3 = 876,
	klbf = 877,
	klbm = 878,
	klbm_x002fin = 879,
	klx = 880,
	km = 881,
	km_x002fcm = 882,
	km_x002fdm3 = 883,
	km_x002fh = 884,
	km_x002fL = 885,
	km_x002fs = 886,
	km2 = 887,
	km3 = 888,
	kmol = 889,
	kmol_x002fh = 890,
	kmol_x002fm3 = 891,
	kmol_x002fs = 892,
	kN = 893,
	kN_x002em = 894,
	kN_x002em2 = 895,
	kN_x002fm = 896,
	kN_x002fm2 = 897,
	knot = 898,
	kohm = 899,
	kohm_x002em = 900,
	kP = 901,
	kPa = 902,
	kPa_x002es_x002fm = 903,
	kPa_x002fh = 904,
	kPa_x002fhm = 905,
	kPa_x002fm = 906,
	kPa_x002fmin = 907,
	kPa2 = 908,
	kPa2_x002fcP = 909,
	kpsi = 910,
	kpsi2 = 911,
	krad = 912,
	krd = 913,
	kS = 914,
	kS_x002fm = 915,
	kT = 916,
	kV = 917,
	kW = 918,
	kW_x002eh = 919,
	kW_x002eh_x002f_x0028kg_x002edegC_x0029 = 920,
	kW_x002eh_x002fdm3 = 921,
	kW_x002eh_x002fkg = 922,
	kW_x002eh_x002fm3 = 923,
	kW_x002f_x0028m2_x002eK_x0029 = 924,
	kW_x002f_x0028m3_x002eK_x0029 = 925,
	kW_x002fcm2 = 926,
	kW_x002fm2 = 927,
	kW_x002fm3 = 928,
	kWb = 929,
	L_x002f_x0028bar_x002emin_x0029 = 930,
	L_x002fh = 931,
	L_x002fkg = 932,
	L_x002fkmol = 933,
	L_x002fm = 934,
	L_x002fm3 = 935,
	L_x002fmin = 936,
	L_x002fmol = 937,
	L_x002fs = 938,
	L_x002fs2 = 939,
	L_x002ft = 940,
	L_x002fton_x005bUK_x005d = 941,
	lbf = 942,
	lbf_x002eft = 943,
	lbf_x002eft_x002fbbl = 944,
	lbf_x002eft_x002fgal_x005bUS_x005d = 945,
	lbf_x002eft_x002fin = 946,
	lbf_x002eft_x002fin2 = 947,
	lbf_x002eft_x002flbm = 948,
	lbf_x002eft_x002fmin = 949,
	lbf_x002eft_x002fs = 950,
	lbf_x002ein = 951,
	lbf_x002ein_x002fin = 952,
	lbf_x002ein2 = 953,
	lbf_x002es_x002fft2 = 954,
	lbf_x002es_x002fin2 = 955,
	lbf_x002fft = 956,
	lbf_x002fft2 = 957,
	lbf_x002fft3 = 958,
	lbf_x002fgal_x005bUS_x005d = 959,
	lbf_x002fin = 960,
	lbf_x002flbf = 961,
	lbm = 962,
	lbm_x002eft = 963,
	lbm_x002eft_x002fs = 964,
	lbm_x002eft2 = 965,
	lbm_x002eft2_x002fs2 = 966,
	lbm_x002f_x0028ft_x002eh_x0029 = 967,
	lbm_x002f_x0028ft_x002es_x0029 = 968,
	lbm_x002f_x0028ft2_x002eh_x0029 = 969,
	lbm_x002f_x0028ft2_x002es_x0029 = 970,
	lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 971,
	lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 972,
	lbm_x002f_x0028hp_x002eh_x0029 = 973,
	lbm_x002fbbl = 974,
	lbm_x002fd = 975,
	lbm_x002fft = 976,
	lbm_x002fft2 = 977,
	lbm_x002fft3 = 978,
	lbm_x002fft4 = 979,
	lbm_x002fgal_x005bUK_x005d = 980,
	lbm_x002fgal_x005bUS_x005d = 981,
	lbm_x002fh = 982,
	lbm_x002fin3 = 983,
	lbm_x002flbmol = 984,
	lbm_x002fmin = 985,
	lbm_x002fs = 986,
	lbmol = 987,
	lbmol_x002f_x0028h_x002eft2_x0029 = 988,
	lbmol_x002f_x0028s_x002eft2_x0029 = 989,
	lbmol_x002fft3 = 990,
	lbmol_x002fgal_x005bUK_x005d = 991,
	lbmol_x002fgal_x005bUS_x005d = 992,
	lbmol_x002fh = 993,
	lbmol_x002fs = 994,
	link = 995,
	link_x005bBnA_x005d = 996,
	link_x005bBnB_x005d = 997,
	link_x005bCla_x005d = 998,
	link_x005bSe_x005d = 999,
	link_x005bSeT_x005d = 1000,
	link_x005bUS_x005d = 1001,
	lm = 1002,
	lm_x002es = 1003,
	lm_x002fm2 = 1004,
	lm_x002fW = 1005,
	lx = 1006,
	lx_x002es = 1007,
	m_x002f_x0028m_x002eK_x0029 = 1008,
	m_x002fcm = 1009,
	m_x002fd = 1010,
	m_x002fh = 1011,
	m_x002fK = 1012,
	m_x002fkg = 1013,
	m_x002fkm = 1014,
	m_x002fkPa = 1015,
	m_x002fm = 1016,
	m_x002fm3 = 1017,
	m_x002fmin = 1018,
	m_x002fms = 1019,
	m_x002fPa = 1020,
	m_x002fs = 1021,
	m_x002fs2 = 1022,
	m_x005bGer_x005d = 1023,
	m2 = 1024,
	m2_x002f_x0028kPa_x002ed_x0029 = 1025,
	m2_x002f_x0028Pa_x002es_x0029 = 1026,
	m2_x002fcm3 = 1027,
	m2_x002fd = 1028,
	m2_x002fg = 1029,
	m2_x002fh = 1030,
	m2_x002fkg = 1031,
	m2_x002fm2 = 1032,
	m2_x002fm3 = 1033,
	m2_x002fmol = 1034,
	m2_x002fs = 1035,
	m3 = 1036,
	m3_x002f_x0028bar_x002ed_x0029 = 1037,
	m3_x002f_x0028bar_x002eh_x0029 = 1038,
	m3_x002f_x0028bar_x002emin_x0029 = 1039,
	m3_x002f_x0028d_x002em_x0029 = 1040,
	m3_x002f_x0028h_x002em_x0029 = 1041,
	m3_x002f_x0028ha_x002em_x0029 = 1042,
	m3_x002f_x0028kPa_x002ed_x0029 = 1043,
	m3_x002f_x0028kPa_x002eh_x0029 = 1044,
	m3_x002f_x0028kW_x002eh_x0029 = 1045,
	m3_x002f_x0028m3_x002eK_x0029 = 1046,
	m3_x002f_x0028Pa_x002es_x0029 = 1047,
	m3_x002f_x0028psi_x002ed_x0029 = 1048,
	m3_x002f_x0028s_x002eft_x0029 = 1049,
	m3_x002f_x0028s_x002em_x0029 = 1050,
	m3_x002f_x0028s_x002em2_x0029 = 1051,
	m3_x002f_x0028s_x002em3_x0029 = 1052,
	m3_x002fbbl = 1053,
	m3_x002fd = 1054,
	m3_x002fd2 = 1055,
	m3_x002fg = 1056,
	m3_x002fh = 1057,
	m3_x002fJ = 1058,
	m3_x002fkg = 1059,
	m3_x002fkm = 1060,
	m3_x002fkmol = 1061,
	m3_x002fkPa = 1062,
	m3_x002fm = 1063,
	m3_x002fm2 = 1064,
	m3_x002fm3 = 1065,
	m3_x002fmin = 1066,
	m3_x002fmol = 1067,
	m3_x002fPa = 1068,
	m3_x002frad = 1069,
	m3_x002frev = 1070,
	m3_x002fs = 1071,
	m3_x002fs2 = 1072,
	m3_x002ft = 1073,
	m3_x002fton_x005bUK_x005d = 1074,
	m3_x002fton_x005bUS_x005d = 1075,
	m4 = 1076,
	m4_x002fs = 1077,
	MA = 1078,
	mA = 1079,
	mA_x002fcm2 = 1080,
	mA_x002fft2 = 1081,
	Ma_x005bt_x005d = 1082,
	mbar = 1083,
	MBq = 1084,
	MC = 1085,
	mC = 1086,
	mC_x002fm2 = 1087,
	Mcal_x005bth_x005d = 1088,
	mcal_x005bth_x005d = 1089,
	mCi = 1090,
	mD = 1091,
	mD_x002eft = 1092,
	mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 1093,
	mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 1094,
	mD_x002em = 1095,
	mD_x002f_x0028Pa_x002es_x0029 = 1096,
	mD_x002fcP = 1097,
	mEuc = 1098,
	MEuc = 1099,
	MeV = 1100,
	meV = 1101,
	MF = 1102,
	mF = 1103,
	mg = 1104,
	Mg = 1105,
	Mg_x002fa = 1106,
	Mg_x002fd = 1107,
	mg_x002fdm3 = 1108,
	mg_x002fg = 1109,
	mg_x002fgal_x005bUS_x005d = 1110,
	Mg_x002fh = 1111,
	Mg_x002fin = 1112,
	mg_x002fJ = 1113,
	mg_x002fkg = 1114,
	mg_x002fL = 1115,
	Mg_x002fm2 = 1116,
	mg_x002fm3 = 1117,
	Mg_x002fm3 = 1118,
	Mg_x002fmin = 1119,
	mGal = 1120,
	mgauss = 1121,
	Mgauss = 1122,
	Mgf = 1123,
	mgn = 1124,
	MGy = 1125,
	mGy = 1126,
	MH = 1127,
	mH = 1128,
	MHz = 1129,
	mHz = 1130,
	mi = 1131,
	mi_x002fgal_x005bUK_x005d = 1132,
	mi_x002fgal_x005bUS_x005d = 1133,
	mi_x002fh = 1134,
	mi_x002fin = 1135,
	mi_x005bnaut_x005d = 1136,
	mi_x005bnautUK_x005d = 1137,
	mi_x005bUS_x005d = 1138,
	mi_x005bUS_x005d2 = 1139,
	mi2 = 1140,
	mi3 = 1141,
	Mibyte = 1142,
	mil = 1143,
	mil_x002fa = 1144,
	mila = 1145,
	min_ = 1146,
	min_x002fft = 1147,
	min_x002fm = 1148,
	mina = 1149,
	MJ = 1150,
	mJ = 1151,
	MJ_x002fa = 1152,
	mJ_x002fcm2 = 1153,
	MJ_x002fkg = 1154,
	MJ_x002fkmol = 1155,
	MJ_x002fm = 1156,
	mJ_x002fm2 = 1157,
	MJ_x002fm3 = 1158,
	mL = 1159,
	mL_x002fgal_x005bUK_x005d = 1160,
	mL_x002fgal_x005bUS_x005d = 1161,
	mL_x002fmL = 1162,
	mm = 1163,
	Mm = 1164,
	mm_x002f_x0028mm_x002eK_x0029 = 1165,
	mm_x002fa = 1166,
	mm_x002fs = 1167,
	mm2 = 1168,
	mm2_x002fmm2 = 1169,
	mm2_x002fs = 1170,
	mm3 = 1171,
	mm3_x002fJ = 1172,
	mmHg_x005b0degC_x005d = 1173,
	mmol = 1174,
	MN = 1175,
	mN = 1176,
	mN_x002em2 = 1177,
	mN_x002fkm = 1178,
	mN_x002fm = 1179,
	Mohm = 1180,
	mohm = 1181,
	mol = 1182,
	mol_x002em2_x002f_x0028mol_x002es_x0029 = 1183,
	mol_x002f_x0028s_x002em2_x0029 = 1184,
	mol_x002fm2 = 1185,
	mol_x002fm3 = 1186,
	mol_x002fmol = 1187,
	mol_x002fs = 1188,
	MP = 1189,
	mP = 1190,
	MPa = 1191,
	mPa = 1192,
	mPa_x002es = 1193,
	MPa_x002es_x002fm = 1194,
	MPa_x002fh = 1195,
	MPa_x002fm = 1196,
	Mpsi = 1197,
	mrad = 1198,
	Mrad = 1199,
	Mrd = 1200,
	mrd = 1201,
	mrem = 1202,
	mrem_x002fh = 1203,
	ms = 1204,
	MS = 1205,
	mS = 1206,
	ms_x002fcm = 1207,
	mS_x002fcm = 1208,
	ms_x002fft = 1209,
	ms_x002fin = 1210,
	mS_x002fm = 1211,
	ms_x002fm = 1212,
	ms_x002fs = 1213,
	mSv = 1214,
	mSv_x002fh = 1215,
	mT = 1216,
	mT_x002fdm = 1217,
	mV = 1218,
	MV = 1219,
	mV_x002fft = 1220,
	mV_x002fm = 1221,
	mW = 1222,
	MW = 1223,
	MW_x002eh = 1224,
	MW_x002eh_x002fkg = 1225,
	MW_x002eh_x002fm3 = 1226,
	mW_x002fm2 = 1227,
	mWb = 1228,
	MWb = 1229,
	N_x002em = 1230,
	N_x002em_x002fm = 1231,
	N_x002em2 = 1232,
	N_x002es_x002fm2 = 1233,
	N_x002fm = 1234,
	N_x002fm2 = 1235,
	N_x002fm3 = 1236,
	N_x002fmm2 = 1237,
	N_x002fN = 1238,
	nA = 1239,
	na = 1240,
	nAPI = 1241,
	nC = 1242,
	ncal_x005bth_x005d = 1243,
	nCi = 1244,
	nEuc = 1245,
	neV = 1246,
	nF = 1247,
	ng = 1248,
	ng_x002fg = 1249,
	ng_x002fmg = 1250,
	ngauss = 1251,
	nGy = 1252,
	nH = 1253,
	nHz = 1254,
	nJ = 1255,
	nm = 1256,
	nm_x002fs = 1257,
	nN = 1258,
	nohm = 1259,
	nohm_x002emil2_x002fft = 1260,
	nohm_x002emm2_x002fm = 1261,
	nP = 1262,
	nPa = 1263,
	nrd = 1264,
	nS = 1265,
	ns = 1266,
	ns_x002fft = 1267,
	ns_x002fm = 1268,
	nT = 1269,
	nV = 1270,
	nW = 1271,
	nWb = 1272,
	Oe = 1273,
	ohm = 1274,
	ohm_x002ecm = 1275,
	ohm_x002em = 1276,
	ohm_x002em2_x002fm = 1277,
	ohm_x002fm = 1278,
	ozf = 1279,
	ozm = 1280,
	ozm_x005btroy_x005d = 1281,
	pA = 1282,
	Pa = 1283,
	Pa_x002es = 1284,
	Pa_x002es_x002em3_x002fkg = 1285,
	Pa_x002es_x002fm3 = 1286,
	Pa_x002es2_x002fm3 = 1287,
	Pa_x002fh = 1288,
	Pa_x002fm = 1289,
	Pa_x002fm3 = 1290,
	Pa_x002fs = 1291,
	Pa2 = 1292,
	Pa2_x002f_x0028Pa_x002es_x0029 = 1293,
	pC = 1294,
	pcal_x005bth_x005d = 1295,
	pCi = 1296,
	pCi_x002fg = 1297,
	pdl = 1298,
	pdl_x002ecm2 = 1299,
	pdl_x002eft = 1300,
	pdl_x002fcm = 1301,
	pEuc = 1302,
	peV = 1303,
	pF = 1304,
	pg = 1305,
	pgauss = 1306,
	pGy = 1307,
	pHz = 1308,
	pJ = 1309,
	pm = 1310,
	pN = 1311,
	pohm = 1312,
	pP = 1313,
	pPa = 1314,
	ppk = 1315,
	ppm = 1316,
	ppm_x005bmass_x005d = 1317,
	ppm_x005bvol_x005d = 1318,
	ppm_x005bvol_x005d_x002fdegC = 1319,
	ppm_x005bvol_x005d_x002fdegF = 1320,
	prd = 1321,
	pS = 1322,
	ps = 1323,
	psi = 1324,
	psi_x002ed_x002fbbl = 1325,
	psi_x002es = 1326,
	psi_x002fft = 1327,
	psi_x002fh = 1328,
	psi_x002fm = 1329,
	psi_x002fmin = 1330,
	psi2 = 1331,
	psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1332,
	psi2_x002fcP = 1333,
	pT = 1334,
	pt_x005bUK_x005d = 1335,
	pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 1336,
	pt_x005bUS_x005d = 1337,
	pV = 1338,
	pW = 1339,
	pWb = 1340,
	qt_x005bUK_x005d = 1341,
	qt_x005bUS_x005d = 1342,
	quad = 1343,
	quad_x002fa = 1344,
	rad = 1345,
	rad_x002fft = 1346,
	rad_x002fft3 = 1347,
	rad_x002fm = 1348,
	rad_x002fm3 = 1349,
	rad_x002fs = 1350,
	rad_x002fs2 = 1351,
	rd = 1352,
	rem = 1353,
	rem_x002fh = 1354,
	rev = 1355,
	rev_x002fft = 1356,
	rev_x002fm = 1357,
	rev_x002fs = 1358,
	rod_x005bUS_x005d = 1359,
	rpm = 1360,
	rpm_x002fs = 1361,
	s_x002fcm = 1362,
	s_x002fft = 1363,
	s_x002fft3 = 1364,
	s_x002fin = 1365,
	s_x002fkg = 1366,
	s_x002fL = 1367,
	S_x002fm = 1368,
	s_x002fm = 1369,
	s_x002fm3 = 1370,
	s_x002fqt_x005bUK_x005d = 1371,
	s_x002fqt_x005bUS_x005d = 1372,
	s_x002fs = 1373,
	sack_x005b94lbm_x005d = 1374,
	seca = 1375,
	section = 1376,
	sr = 1377,
	St = 1378,
	Sv = 1379,
	Sv_x002fh = 1380,
	Sv_x002fs = 1381,
	t_x002fa = 1382,
	t_x002fd = 1383,
	t_x002fh = 1384,
	T_x002fm = 1385,
	t_x002fm3 = 1386,
	t_x002fmin = 1387,
	TA = 1388,
	Ta_x005bt_x005d = 1389,
	TBq = 1390,
	TC = 1391,
	Tcal_x005bth_x005d = 1392,
	TD_x005bAPI_x005d = 1393,
	TD_x005bAPI_x005d_x002em = 1394,
	TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 1395,
	TEuc = 1396,
	TeV = 1397,
	TF = 1398,
	Tg = 1399,
	Tgauss = 1400,
	TGy = 1401,
	TH = 1402,
	therm_x005bEC_x005d = 1403,
	therm_x005bUK_x005d = 1404,
	therm_x005bUS_x005d = 1405,
	THz = 1406,
	TJ = 1407,
	TJ_x002fa = 1408,
	Tm = 1409,
	TN = 1410,
	Tohm = 1411,
	ton_x005bUK_x005d = 1412,
	ton_x005bUK_x005d_x002fa = 1413,
	ton_x005bUK_x005d_x002fd = 1414,
	ton_x005bUK_x005d_x002fh = 1415,
	ton_x005bUK_x005d_x002fmin = 1416,
	ton_x005bUS_x005d = 1417,
	ton_x005bUS_x005d_x002fa = 1418,
	ton_x005bUS_x005d_x002fd = 1419,
	ton_x005bUS_x005d_x002fft2 = 1420,
	ton_x005bUS_x005d_x002fh = 1421,
	ton_x005bUS_x005d_x002fmin = 1422,
	tonf_x005bUK_x005d = 1423,
	tonf_x005bUK_x005d_x002eft2 = 1424,
	tonf_x005bUK_x005d_x002fft = 1425,
	tonf_x005bUK_x005d_x002fft2 = 1426,
	tonf_x005bUS_x005d = 1427,
	tonf_x005bUS_x005d_x002eft = 1428,
	tonf_x005bUS_x005d_x002eft2 = 1429,
	tonf_x005bUS_x005d_x002emi = 1430,
	tonf_x005bUS_x005d_x002emi_x002fbbl = 1431,
	tonf_x005bUS_x005d_x002emi_x002fft = 1432,
	tonf_x005bUS_x005d_x002fft = 1433,
	tonf_x005bUS_x005d_x002fft2 = 1434,
	tonf_x005bUS_x005d_x002fin2 = 1435,
	tonRefrig = 1436,
	torr = 1437,
	TP = 1438,
	TPa = 1439,
	Trd = 1440,
	TS = 1441,
	TT = 1442,
	TV = 1443,
	TW = 1444,
	TW_x002eh = 1445,
	TWb = 1446,
	uA = 1447,
	uA_x002fcm2 = 1448,
	uA_x002fin2 = 1449,
	ubar = 1450,
	uC = 1451,
	ucal_x005bth_x005d = 1452,
	ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 1453,
	ucal_x005bth_x005d_x002fs = 1454,
	uCi = 1455,
	uEuc = 1456,
	ueV = 1457,
	uF = 1458,
	uF_x002fm = 1459,
	ug = 1460,
	ug_x002fcm3 = 1461,
	ug_x002fg = 1462,
	ug_x002fmg = 1463,
	ugauss = 1464,
	uGy = 1465,
	uH = 1466,
	uH_x002fm = 1467,
	uHz = 1468,
	uJ = 1469,
	um = 1470,
	um_x002fs = 1471,
	um2 = 1472,
	um2_x002em = 1473,
	umHg_x005b0degC_x005d = 1474,
	umol = 1475,
	uN = 1476,
	uohm = 1477,
	uohm_x002fft = 1478,
	uohm_x002fm = 1479,
	uP = 1480,
	uPa = 1481,
	upsi = 1482,
	urad = 1483,
	urd = 1484,
	us = 1485,
	uS = 1486,
	us_x002fft = 1487,
	us_x002fin = 1488,
	us_x002fm = 1489,
	uT = 1490,
	uV = 1491,
	uV_x002fft = 1492,
	uV_x002fm = 1493,
	uW = 1494,
	uW_x002fm3 = 1495,
	uWb = 1496,
	V_x002fB = 1497,
	V_x002fdB = 1498,
	V_x002fm = 1499,
	W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = 1500,
	W_x002f_x0028m_x002eK_x0029 = 1501,
	W_x002f_x0028m2_x002eK_x0029 = 1502,
	W_x002f_x0028m2_x002esr_x0029 = 1503,
	W_x002f_x0028m3_x002eK_x0029 = 1504,
	W_x002fcm2 = 1505,
	W_x002fK = 1506,
	W_x002fkW = 1507,
	W_x002fm2 = 1508,
	W_x002fm3 = 1509,
	W_x002fmm2 = 1510,
	W_x002fsr = 1511,
	W_x002fW = 1512,
	Wb = 1513,
	Wb_x002em = 1514,
	Wb_x002fm = 1515,
	Wb_x002fmm = 1516,
	wk = 1517,
	yd = 1518,
	yd_x005bBnA_x005d = 1519,
	yd_x005bBnB_x005d = 1520,
	yd_x005bCla_x005d = 1521,
	yd_x005bInd_x005d = 1522,
	yd_x005bInd37_x005d = 1523,
	yd_x005bInd62_x005d = 1524,
	yd_x005bInd75_x005d = 1525,
	yd_x005bSe_x005d = 1526,
	yd_x005bSeT_x005d = 1527,
	yd_x005bUS_x005d = 1528,
	yd2 = 1529,
	yd3 = 1530
};
#endif

/* eml2_2ForGsoap.h:4406 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUom (-1167)

/* eml22:AbsorbedDoseUom */
enum class eml22__AbsorbedDoseUom {
	cGy = 0,
	crd = 1,
	dGy = 2,
	drd = 3,
	EGy = 4,
	Erd = 5,
	fGy = 6,
	frd = 7,
	GGy = 8,
	Grd = 9,
	Gy = 10,
	kGy = 11,
	krd = 12,
	mGy = 13,
	MGy = 14,
	Mrd = 15,
	mrd = 16,
	nGy = 17,
	nrd = 18,
	pGy = 19,
	prd = 20,
	rd = 21,
	TGy = 22,
	Trd = 23,
	uGy = 24,
	urd = 25
};
#endif

/* eml2_2ForGsoap.h:4542 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUom (-1168)

/* eml22:ActivityOfRadioactivityUom */
enum class eml22__ActivityOfRadioactivityUom {
	Bq = 0,
	Ci = 1,
	GBq = 2,
	MBq = 3,
	mCi = 4,
	nCi = 5,
	pCi = 6,
	TBq = 7,
	uCi = 8
};
#endif

/* eml2_2ForGsoap.h:4593 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUom (-1169)

/* eml22:AmountOfSubstancePerAmountOfSubstanceUom */
enum class eml22__AmountOfSubstancePerAmountOfSubstanceUom {
	_x0025 = 0,
	_x0025_x005bmolar_x005d = 1,
	Euc = 2,
	mol_x002fmol = 3,
	nEuc = 4,
	ppk = 5,
	ppm = 6
};
#endif

/* eml2_2ForGsoap.h:4634 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUom (-1170)

/* eml22:AmountOfSubstancePerAreaUom */
enum class eml22__AmountOfSubstancePerAreaUom {
	mol_x002fm2 = 0
};
#endif

/* eml2_2ForGsoap.h:4645 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUom (-1171)

/* eml22:AmountOfSubstancePerTimePerAreaUom */
enum class eml22__AmountOfSubstancePerTimePerAreaUom {
	lbmol_x002f_x0028h_x002eft2_x0029 = 0,
	lbmol_x002f_x0028s_x002eft2_x0029 = 1,
	mol_x002f_x0028s_x002em2_x0029 = 2
};
#endif

/* eml2_2ForGsoap.h:4666 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUom (-1172)

/* eml22:AmountOfSubstancePerTimeUom */
enum class eml22__AmountOfSubstancePerTimeUom {
	kat = 0,
	kmol_x002fh = 1,
	kmol_x002fs = 2,
	lbmol_x002fh = 3,
	lbmol_x002fs = 4,
	mol_x002fs = 5
};
#endif

/* eml2_2ForGsoap.h:4702 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUom (-1173)

/* eml22:AmountOfSubstancePerVolumeUom */
enum class eml22__AmountOfSubstancePerVolumeUom {
	kmol_x002fm3 = 0,
	lbmol_x002fft3 = 1,
	lbmol_x002fgal_x005bUK_x005d = 2,
	lbmol_x002fgal_x005bUS_x005d = 3,
	mol_x002fm3 = 4
};
#endif

/* eml2_2ForGsoap.h:4733 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUom (-1174)

/* eml22:AmountOfSubstanceUom */
enum class eml22__AmountOfSubstanceUom {
	kmol = 0,
	lbmol = 1,
	mmol = 2,
	mol = 3,
	umol = 4
};
#endif

/* eml2_2ForGsoap.h:4764 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUom (-1175)

/* eml22:AnglePerLengthUom */
enum class eml22__AnglePerLengthUom {
	_0_x002e01_x0020dega_x002fft = 0,
	_1_x002f30_x0020dega_x002fft = 1,
	_1_x002f30_x0020dega_x002fm = 2,
	dega_x002fft = 3,
	dega_x002fm = 4,
	rad_x002fft = 5,
	rad_x002fm = 6,
	rev_x002fft = 7,
	rev_x002fm = 8
};
#endif

/* eml2_2ForGsoap.h:4815 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUom (-1176)

/* eml22:AnglePerVolumeUom */
enum class eml22__AnglePerVolumeUom {
	rad_x002fft3 = 0,
	rad_x002fm3 = 1
};
#endif

/* eml2_2ForGsoap.h:4831 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUom (-1177)

/* eml22:AngularAccelerationUom */
enum class eml22__AngularAccelerationUom {
	rad_x002fs2 = 0,
	rpm_x002fs = 1
};
#endif

/* eml2_2ForGsoap.h:4847 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUom (-1178)

/* eml22:AngularVelocityUom */
enum class eml22__AngularVelocityUom {
	dega_x002fh = 0,
	dega_x002fmin = 1,
	dega_x002fs = 2,
	rad_x002fs = 3,
	rev_x002fs = 4,
	rpm = 5
};
#endif

/* eml2_2ForGsoap.h:4883 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUom (-1179)

/* eml22:APIGammaRayUom */
enum class eml22__APIGammaRayUom {
	gAPI = 0
};
#endif

/* eml2_2ForGsoap.h:4894 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUom (-1180)

/* eml22:APIGravityUom */
enum class eml22__APIGravityUom {
	dAPI = 0
};
#endif

/* eml2_2ForGsoap.h:4905 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUom (-1181)

/* eml22:APINeutronUom */
enum class eml22__APINeutronUom {
	nAPI = 0
};
#endif

/* eml2_2ForGsoap.h:4916 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUom (-1182)

/* eml22:AreaPerAmountOfSubstanceUom */
enum class eml22__AreaPerAmountOfSubstanceUom {
	m2_x002fmol = 0
};
#endif

/* eml2_2ForGsoap.h:4927 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUom (-1183)

/* eml22:AreaPerAreaUom */
enum class eml22__AreaPerAreaUom {
	_x0025 = 0,
	_x0025_x005barea_x005d = 1,
	cEuc = 2,
	Euc = 3,
	in2_x002fft2 = 4,
	in2_x002fin2 = 5,
	m2_x002fm2 = 6,
	mm2_x002fmm2 = 7
};
#endif

/* eml2_2ForGsoap.h:4973 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUom (-1184)

/* eml22:AreaPerCountUom */
enum class eml22__AreaPerCountUom {
	b_x002felectron = 0
};
#endif

/* eml2_2ForGsoap.h:4980 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUom (-1185)

/* eml22:AreaPerMassUom */
enum class eml22__AreaPerMassUom {
	cm2_x002fg = 0,
	ft2_x002flbm = 1,
	m2_x002fg = 2,
	m2_x002fkg = 3
};
#endif

/* eml2_2ForGsoap.h:5006 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUom (-1186)

/* eml22:AreaPerTimeUom */
enum class eml22__AreaPerTimeUom {
	cm2_x002fs = 0,
	ft2_x002fh = 1,
	ft2_x002fs = 2,
	in2_x002fs = 3,
	m2_x002fd = 4,
	m2_x002fh = 5,
	m2_x002fs = 6,
	mm2_x002fs = 7
};
#endif

/* eml2_2ForGsoap.h:5052 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUom (-1187)

/* eml22:AreaPerVolumeUom */
enum class eml22__AreaPerVolumeUom {
	_1_x002fm = 0,
	b_x002fcm3 = 1,
	cu = 2,
	ft2_x002fin3 = 3,
	m2_x002fcm3 = 4,
	m2_x002fm3 = 5
};
#endif

/* eml2_2ForGsoap.h:5088 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaUom (-1188)

/* eml22:AreaUom */
enum class eml22__AreaUom {
	b = 'b',
	acre = 'c',
	cm2 = 'd',
	ft2 = 'e',
	ha = 'f',
	in2 = 'g',
	km2 = 'h',
	m2 = 'i',
	mi_x005bUS_x005d2 = 'j',
	mi2 = 'k',
	mm2 = 'l',
	section = 'm',
	um2 = 'n',
	yd2 = 'o'
};
#endif

/* eml2_2ForGsoap.h:5164 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUom (-1189)

/* eml22:AttenuationPerFrequencyIntervalUom */
enum class eml22__AttenuationPerFrequencyIntervalUom {
	B_x002fO = 0,
	dB_x002fO = 1
};
#endif

/* eml2_2ForGsoap.h:5180 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUom (-1190)

/* eml22:CapacitanceUom */
enum class eml22__CapacitanceUom {
	F = 'F',
	cF = 'G',
	dF = 'H',
	EF = 'I',
	fF = 'J',
	GF = 'K',
	kF = 'L',
	mF = 'M',
	MF = 'N',
	nF = 'O',
	pF = 'P',
	TF = 'Q',
	uF = 'R'
};
#endif

/* eml2_2ForGsoap.h:5251 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUom (-1191)

/* eml22:CationExchangeCapacityUom */
enum class eml22__CationExchangeCapacityUom {
	_x002e01_x0020meq_x002fg = 0
};
#endif

/* eml2_2ForGsoap.h:5258 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUom (-1192)

/* eml22:DataTransferSpeedUom */
enum class eml22__DataTransferSpeedUom {
	bit_x002fs = 0,
	byte_x002fs = 1
};
#endif

/* eml2_2ForGsoap.h:5274 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUom (-1193)

/* eml22:DiffusionCoefficientUom */
enum class eml22__DiffusionCoefficientUom {
	m2_x002fs = 0
};
#endif

/* eml2_2ForGsoap.h:5285 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUom (-1194)

/* eml22:DiffusiveTimeOfFlightUom */
enum class eml22__DiffusiveTimeOfFlightUom {
	h_x00280_x002e5_x0029 = 0,
	s_x00280_x002e5_x0029 = 1
};
#endif

/* eml2_2ForGsoap.h:5297 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUom (-1195)

/* eml22:DigitalStorageUom */
enum class eml22__DigitalStorageUom {
	bit = 0,
	byte = 1,
	Kibyte = 2,
	Mibyte = 3
};
#endif

/* eml2_2ForGsoap.h:5323 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUom (-1196)

/* eml22:DimensionlessUom */
enum class eml22__DimensionlessUom {
	_x0025 = 0,
	cEuc = 1,
	dEuc = 2,
	EEuc = 3,
	Euc = 4,
	fEuc = 5,
	GEuc = 6,
	kEuc = 7,
	MEuc = 8,
	mEuc = 9,
	nEuc = 10,
	pEuc = 11,
	ppk = 12,
	ppm = 13,
	TEuc = 14,
	uEuc = 15
};
#endif

/* eml2_2ForGsoap.h:5409 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUom (-1197)

/* eml22:DipoleMomentUom */
enum class eml22__DipoleMomentUom {
	C_x002em = 0
};
#endif

/* eml2_2ForGsoap.h:5420 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUom (-1198)

/* eml22:DoseEquivalentUom */
enum class eml22__DoseEquivalentUom {
	mrem = 0,
	mSv = 1,
	rem = 2,
	Sv = 3
};
#endif

/* eml2_2ForGsoap.h:5446 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUom (-1199)

/* eml22:DynamicViscosityUom */
enum class eml22__DynamicViscosityUom {
	P = 'P',
	cP = 'Q',
	dP = 'R',
	dyne_x002es_x002fcm2 = 'S',
	EP = 'T',
	fP = 'U',
	GP = 'V',
	kgf_x002es_x002fm2 = 'W',
	kP = 'X',
	lbf_x002es_x002fft2 = 'Y',
	lbf_x002es_x002fin2 = 'Z',
	mP = 91,
	MP = 92,
	mPa_x002es = 93,
	N_x002es_x002fm2 = 94,
	nP = 95,
	Pa_x002es = 96,
	pP = 'a',
	psi_x002es = 'b',
	TP = 'c',
	uP = 'd'
};
#endif

/* eml2_2ForGsoap.h:5557 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUom (-1200)

/* eml22:ElectricalResistivityUom */
enum class eml22__ElectricalResistivityUom {
	kohm_x002em = 0,
	nohm_x002emil2_x002fft = 1,
	nohm_x002emm2_x002fm = 2,
	ohm_x002ecm = 3,
	ohm_x002em = 4,
	ohm_x002em2_x002fm = 5
};
#endif

/* eml2_2ForGsoap.h:5593 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUom (-1201)

/* eml22:ElectricChargePerAreaUom */
enum class eml22__ElectricChargePerAreaUom {
	C_x002fcm2 = 0,
	C_x002fm2 = 1,
	C_x002fmm2 = 2,
	mC_x002fm2 = 3
};
#endif

/* eml2_2ForGsoap.h:5619 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUom (-1202)

/* eml22:ElectricChargePerMassUom */
enum class eml22__ElectricChargePerMassUom {
	A_x002es_x002fkg = 0,
	C_x002fg = 1,
	C_x002fkg = 2
};
#endif

/* eml2_2ForGsoap.h:5640 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUom (-1203)

/* eml22:ElectricChargePerVolumeUom */
enum class eml22__ElectricChargePerVolumeUom {
	A_x002es_x002fm3 = 0,
	C_x002fcm3 = 1,
	C_x002fm3 = 2,
	C_x002fmm3 = 3
};
#endif

/* eml2_2ForGsoap.h:5666 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUom (-1204)

/* eml22:ElectricChargeUom */
enum class eml22__ElectricChargeUom {
	C = 'C',
	A_x002eh = 'D',
	A_x002es = 'E',
	cC = 'F',
	dC = 'G',
	EC = 'H',
	fC = 'I',
	GC = 'J',
	kC = 'K',
	MC = 'L',
	mC = 'M',
	nC = 'N',
	pC = 'O',
	TC = 'P',
	uC = 'Q'
};
#endif

/* eml2_2ForGsoap.h:5747 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUom (-1205)

/* eml22:ElectricConductanceUom */
enum class eml22__ElectricConductanceUom {
	S = 'S',
	cS = 'T',
	dS = 'U',
	ES = 'V',
	fS = 'W',
	GS = 'X',
	kS = 'Y',
	mS = 'Z',
	MS = 91,
	nS = 92,
	pS = 93,
	TS = 94,
	uS = 95
};
#endif

/* eml2_2ForGsoap.h:5818 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUom (-1206)

/* eml22:ElectricConductivityUom */
enum class eml22__ElectricConductivityUom {
	kS_x002fm = 0,
	mS_x002fcm = 1,
	mS_x002fm = 2,
	S_x002fm = 3
};
#endif

/* eml2_2ForGsoap.h:5844 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUom (-1207)

/* eml22:ElectricCurrentDensityUom */
enum class eml22__ElectricCurrentDensityUom {
	A_x002fcm2 = 0,
	A_x002fft2 = 1,
	A_x002fm2 = 2,
	A_x002fmm2 = 3,
	mA_x002fcm2 = 4,
	mA_x002fft2 = 5,
	uA_x002fcm2 = 6,
	uA_x002fin2 = 7
};
#endif

/* eml2_2ForGsoap.h:5890 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUom (-1208)

/* eml22:ElectricCurrentUom */
enum class eml22__ElectricCurrentUom {
	A = 'A',
	cA = 'B',
	dA = 'C',
	EA = 'D',
	fA = 'E',
	GA = 'F',
	kA = 'G',
	MA = 'H',
	mA = 'I',
	nA = 'J',
	pA = 'K',
	TA = 'L',
	uA = 'M'
};
#endif

/* eml2_2ForGsoap.h:5961 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUom (-1209)

/* eml22:ElectricFieldStrengthUom */
enum class eml22__ElectricFieldStrengthUom {
	mV_x002fft = 0,
	mV_x002fm = 1,
	uV_x002fft = 2,
	uV_x002fm = 3,
	V_x002fm = 4
};
#endif

/* eml2_2ForGsoap.h:5992 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUom (-1210)

/* eml22:ElectricPotentialDifferenceUom */
enum class eml22__ElectricPotentialDifferenceUom {
	V = 'V',
	cV = 'W',
	dV = 'X',
	fV = 'Y',
	GV = 'Z',
	kV = 91,
	mV = 92,
	MV = 93,
	nV = 94,
	pV = 95,
	TV = 96,
	uV = 'a'
};
#endif

/* eml2_2ForGsoap.h:6058 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUom (-1211)

/* eml22:ElectricResistancePerLengthUom */
enum class eml22__ElectricResistancePerLengthUom {
	ohm_x002fm = 0,
	uohm_x002fft = 1,
	uohm_x002fm = 2
};
#endif

/* eml2_2ForGsoap.h:6079 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUom (-1212)

/* eml22:ElectricResistanceUom */
enum class eml22__ElectricResistanceUom {
	cohm = 0,
	dohm = 1,
	Eohm = 2,
	fohm = 3,
	Gohm = 4,
	kohm = 5,
	Mohm = 6,
	mohm = 7,
	nohm = 8,
	ohm = 9,
	pohm = 10,
	Tohm = 11,
	uohm = 12
};
#endif

/* eml2_2ForGsoap.h:6150 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUom (-1213)

/* eml22:ElectromagneticMomentUom */
enum class eml22__ElectromagneticMomentUom {
	A_x002em2 = 0
};
#endif

/* eml2_2ForGsoap.h:6161 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUom (-1214)

/* eml22:EnergyLengthPerAreaUom */
enum class eml22__EnergyLengthPerAreaUom {
	J_x002em_x002fm2 = 0,
	kcal_x005bth_x005d_x002em_x002fcm2 = 1
};
#endif

/* eml2_2ForGsoap.h:6177 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUom (-1215)

/* eml22:EnergyLengthPerTimeAreaTemperatureUom */
enum class eml22__EnergyLengthPerTimeAreaTemperatureUom {
	Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	J_x002em_x002f_x0028s_x002em2_x002edeltaK_x0029 = 1,
	kJ_x002em_x002f_x0028h_x002em2_x002edeltaK_x0029 = 2,
	W_x002f_x0028m_x002edeltaK_x0029 = 3
};
#endif

/* eml2_2ForGsoap.h:6203 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUom (-1216)

/* eml22:EnergyPerAreaUom */
enum class eml22__EnergyPerAreaUom {
	erg_x002fcm2 = 0,
	J_x002fcm2 = 1,
	J_x002fm2 = 2,
	kgf_x002em_x002fcm2 = 3,
	lbf_x002eft_x002fin2 = 4,
	mJ_x002fcm2 = 5,
	mJ_x002fm2 = 6,
	N_x002fm = 7
};
#endif

/* eml2_2ForGsoap.h:6249 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUom (-1217)

/* eml22:EnergyPerLengthUom */
enum class eml22__EnergyPerLengthUom {
	J_x002fm = 0,
	MJ_x002fm = 1
};
#endif

/* eml2_2ForGsoap.h:6265 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUom (-1218)

/* eml22:EnergyPerMassPerTimeUom */
enum class eml22__EnergyPerMassPerTimeUom {
	mrem_x002fh = 0,
	mSv_x002fh = 1,
	rem_x002fh = 2,
	Sv_x002fh = 3,
	Sv_x002fs = 4
};
#endif

/* eml2_2ForGsoap.h:6296 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUom (-1219)

/* eml22:EnergyPerMassUom */
enum class eml22__EnergyPerMassUom {
	Btu_x005bIT_x005d_x002flbm = 0,
	cal_x005bth_x005d_x002fg = 1,
	cal_x005bth_x005d_x002fkg = 2,
	cal_x005bth_x005d_x002flbm = 3,
	erg_x002fg = 4,
	erg_x002fkg = 5,
	hp_x002eh_x002flbm = 6,
	J_x002fg = 7,
	J_x002fkg = 8,
	kcal_x005bth_x005d_x002fg = 9,
	kcal_x005bth_x005d_x002fkg = 10,
	kJ_x002fkg = 11,
	kW_x002eh_x002fkg = 12,
	lbf_x002eft_x002flbm = 13,
	MJ_x002fkg = 14,
	MW_x002eh_x002fkg = 15
};
#endif

/* eml2_2ForGsoap.h:6382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUom (-1220)

/* eml22:EnergyPerVolumeUom */
enum class eml22__EnergyPerVolumeUom {
	Btu_x005bIT_x005d_x002fbbl = 0,
	Btu_x005bIT_x005d_x002fft3 = 1,
	Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 2,
	Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 3,
	cal_x005bth_x005d_x002fcm3 = 4,
	cal_x005bth_x005d_x002fmL = 5,
	cal_x005bth_x005d_x002fmm3 = 6,
	erg_x002fcm3 = 7,
	erg_x002fm3 = 8,
	hp_x002eh_x002fbbl = 9,
	J_x002fdm3 = 10,
	J_x002fm3 = 11,
	kcal_x005bth_x005d_x002fcm3 = 12,
	kcal_x005bth_x005d_x002fm3 = 13,
	kJ_x002fdm3 = 14,
	kJ_x002fm3 = 15,
	kW_x002eh_x002fdm3 = 16,
	kW_x002eh_x002fm3 = 17,
	lbf_x002eft_x002fbbl = 18,
	lbf_x002eft_x002fgal_x005bUS_x005d = 19,
	MJ_x002fm3 = 20,
	MW_x002eh_x002fm3 = 21,
	tonf_x005bUS_x005d_x002emi_x002fbbl = 22
};
#endif

/* eml2_2ForGsoap.h:6503 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUom (-1221)

/* eml22:EnergyUom */
enum class eml22__EnergyUom {
	J = 'J',
	_1E6_x0020Btu_x005bIT_x005d = 'K',
	aJ = 'L',
	Btu_x005bIT_x005d = 'M',
	Btu_x005bth_x005d = 'N',
	Btu_x005bUK_x005d = 'O',
	cal_x005bIT_x005d = 'P',
	cal_x005bth_x005d = 'Q',
	ccal_x005bth_x005d = 'R',
	ceV = 'S',
	cJ = 'T',
	dcal_x005bth_x005d = 'U',
	deV = 'V',
	dJ = 'W',
	Ecal_x005bth_x005d = 'X',
	EeV = 'Y',
	EJ = 'Z',
	erg = 91,
	eV = 92,
	fcal_x005bth_x005d = 93,
	feV = 94,
	fJ = 95,
	Gcal_x005bth_x005d = 96,
	GeV = 'a',
	GJ = 'b',
	GW_x002eh = 'c',
	hp_x002eh = 'd',
	hp_x005bmetric_x005d_x002eh = 'e',
	kcal_x005bth_x005d = 'f',
	keV = 'g',
	kJ = 'h',
	kW_x002eh = 'i',
	mcal_x005bth_x005d = 'j',
	Mcal_x005bth_x005d = 'k',
	meV = 'l',
	MeV = 'm',
	MJ = 'n',
	mJ = 'o',
	MW_x002eh = 'p',
	ncal_x005bth_x005d = 'q',
	neV = 'r',
	nJ = 's',
	pcal_x005bth_x005d = 't',
	peV = 'u',
	pJ = 'v',
	quad = 'w',
	Tcal_x005bth_x005d = 'x',
	TeV = 'y',
	therm_x005bEC_x005d = 'z',
	therm_x005bUK_x005d = 123,
	therm_x005bUS_x005d = 124,
	TJ = 125,
	TW_x002eh = 126,
	ucal_x005bth_x005d = 127,
	ueV = 128,
	uJ = 129
};
#endif

/* eml2_2ForGsoap.h:6789 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUom (-1222)

/* eml22:ForceAreaUom */
enum class eml22__ForceAreaUom {
	dyne_x002ecm2 = 0,
	kgf_x002em2 = 1,
	kN_x002em2 = 2,
	lbf_x002ein2 = 3,
	mN_x002em2 = 4,
	N_x002em2 = 5,
	pdl_x002ecm2 = 6,
	tonf_x005bUK_x005d_x002eft2 = 7,
	tonf_x005bUS_x005d_x002eft2 = 8
};
#endif

/* eml2_2ForGsoap.h:6840 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUom (-1223)

/* eml22:ForceLengthPerLengthUom */
enum class eml22__ForceLengthPerLengthUom {
	kgf_x002em_x002fm = 0,
	lbf_x002eft_x002fin = 1,
	lbf_x002ein_x002fin = 2,
	N_x002em_x002fm = 3,
	tonf_x005bUS_x005d_x002emi_x002fft = 4
};
#endif

/* eml2_2ForGsoap.h:6871 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUom (-1224)

/* eml22:ForcePerForceUom */
enum class eml22__ForcePerForceUom {
	_x0025 = 0,
	Euc = 1,
	kgf_x002fkgf = 2,
	lbf_x002flbf = 3,
	N_x002fN = 4
};
#endif

/* eml2_2ForGsoap.h:6902 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUom (-1225)

/* eml22:ForcePerLengthUom */
enum class eml22__ForcePerLengthUom {
	_0_x002e01_x0020lbf_x002fft = 0,
	_1_x002f30_x0020lbf_x002fm = 1,
	_1_x002f30_x0020N_x002fm = 2,
	dyne_x002fcm = 3,
	kgf_x002fcm = 4,
	kN_x002fm = 5,
	lbf_x002fft = 6,
	lbf_x002fin = 7,
	mN_x002fkm = 8,
	mN_x002fm = 9,
	N_x002fm = 10,
	pdl_x002fcm = 11,
	tonf_x005bUK_x005d_x002fft = 12,
	tonf_x005bUS_x005d_x002fft = 13
};
#endif

/* eml2_2ForGsoap.h:6978 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUom (-1226)

/* eml22:ForcePerVolumeUom */
enum class eml22__ForcePerVolumeUom {
	_0_x002e001_x0020psi_x002fft = 0,
	_0_x002e01_x0020psi_x002fft = 1,
	atm_x002fft = 2,
	atm_x002fhm = 3,
	atm_x002fm = 4,
	bar_x002fkm = 5,
	bar_x002fm = 6,
	GPa_x002fcm = 7,
	kPa_x002fhm = 8,
	kPa_x002fm = 9,
	lbf_x002fft3 = 10,
	lbf_x002fgal_x005bUS_x005d = 11,
	MPa_x002fm = 12,
	N_x002fm3 = 13,
	Pa_x002fm = 14,
	psi_x002fft = 15,
	psi_x002fm = 16
};
#endif

/* eml2_2ForGsoap.h:7069 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceUom (-1227)

/* eml22:ForceUom */
enum class eml22__ForceUom {
	N = 'N',
	_10_x0020kN = 'O',
	cN = 'P',
	daN = 'Q',
	dN = 'R',
	dyne = 'S',
	EN = 'T',
	fN = 'U',
	gf = 'V',
	GN = 'W',
	hN = 'X',
	kdyne = 'Y',
	kgf = 'Z',
	klbf = 91,
	kN = 92,
	lbf = 93,
	Mgf = 94,
	mN = 95,
	MN = 96,
	nN = 'a',
	ozf = 'b',
	pdl = 'c',
	pN = 'd',
	TN = 'e',
	tonf_x005bUK_x005d = 'f',
	tonf_x005bUS_x005d = 'g',
	uN = 'h'
};
#endif

/* eml2_2ForGsoap.h:7210 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUom (-1228)

/* eml22:FrequencyIntervalUom */
enum class eml22__FrequencyIntervalUom {
	O = 'O'
};
#endif

/* eml2_2ForGsoap.h:7221 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUom (-1229)

/* eml22:FrequencyUom */
enum class eml22__FrequencyUom {
	cHz = 0,
	dHz = 1,
	EHz = 2,
	fHz = 3,
	GHz = 4,
	Hz = 5,
	kHz = 6,
	mHz = 7,
	MHz = 8,
	nHz = 9,
	pHz = 10,
	THz = 11,
	uHz = 12
};
#endif

/* eml2_2ForGsoap.h:7292 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUom (-1230)

/* eml22:HeatCapacityUom */
enum class eml22__HeatCapacityUom {
	J_x002fdeltaK = 0
};
#endif

/* eml2_2ForGsoap.h:7303 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUom (-1231)

/* eml22:HeatFlowRateUom */
enum class eml22__HeatFlowRateUom {
	W = 'W',
	_1E6_x0020Btu_x005bIT_x005d_x002fh = 'X',
	Btu_x005bIT_x005d_x002fh = 'Y',
	Btu_x005bIT_x005d_x002fmin = 'Z',
	Btu_x005bIT_x005d_x002fs = 91,
	cal_x005bth_x005d_x002fh = 92,
	EJ_x002fa = 93,
	erg_x002fa = 94,
	GW = 95,
	J_x002fs = 96,
	kcal_x005bth_x005d_x002fh = 'a',
	kW = 'b',
	lbf_x002eft_x002fmin = 'c',
	lbf_x002eft_x002fs = 'd',
	MJ_x002fa = 'e',
	mW = 'f',
	MW = 'g',
	nW = 'h',
	quad_x002fa = 'i',
	TJ_x002fa = 'j',
	TW = 'k',
	ucal_x005bth_x005d_x002fs = 'l',
	uW = 'm'
};
#endif

/* eml2_2ForGsoap.h:7424 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUom (-1232)

/* eml22:HeatTransferCoefficientUom */
enum class eml22__HeatTransferCoefficientUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaR_x0029 = 1,
	Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 2,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edeltaF_x0029 = 3,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edeltaC_x0029 = 4,
	cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edeltaC_x0029 = 5,
	J_x002f_x0028s_x002em2_x002edeltaC_x0029 = 6,
	kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 7,
	kJ_x002f_x0028h_x002em2_x002edeltaK_x0029 = 8,
	kW_x002f_x0028m2_x002edeltaK_x0029 = 9,
	W_x002f_x0028m2_x002edeltaK_x0029 = 10
};
#endif

/* eml2_2ForGsoap.h:7485 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUom (-1233)

/* eml22:IlluminanceUom */
enum class eml22__IlluminanceUom {
	footcandle = 0,
	klx = 1,
	lm_x002fm2 = 2,
	lx = 3
};
#endif

/* eml2_2ForGsoap.h:7511 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUom (-1234)

/* eml22:InductanceUom */
enum class eml22__InductanceUom {
	H = 'H',
	cH = 'I',
	dH = 'J',
	EH = 'K',
	fH = 'L',
	GH = 'M',
	kH = 'N',
	MH = 'O',
	mH = 'P',
	nH = 'Q',
	TH = 'R',
	uH = 'S'
};
#endif

/* eml2_2ForGsoap.h:7577 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUom (-1235)

/* eml22:IsothermalCompressibilityUom */
enum class eml22__IsothermalCompressibilityUom {
	dm3_x002f_x0028kW_x002eh_x0029 = 0,
	dm3_x002fMJ = 1,
	m3_x002f_x0028kW_x002eh_x0029 = 2,
	m3_x002fJ = 3,
	mm3_x002fJ = 4,
	pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 5
};
#endif

/* eml2_2ForGsoap.h:7613 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUom (-1236)

/* eml22:KinematicViscosityUom */
enum class eml22__KinematicViscosityUom {
	cm2_x002fs = 0,
	cSt = 1,
	ft2_x002fh = 2,
	ft2_x002fs = 3,
	in2_x002fs = 4,
	m2_x002fh = 5,
	m2_x002fs = 6,
	mm2_x002fs = 7,
	Pa_x002es_x002em3_x002fkg = 8,
	St = 9
};
#endif

/* eml2_2ForGsoap.h:7669 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUom (-1237)

/* eml22:LengthPerLengthUom */
enum class eml22__LengthPerLengthUom {
	_x0025 = 0,
	_0_x002e01_x0020ft_x002fft = 1,
	_1_x002f30_x0020m_x002fm = 2,
	Euc = 3,
	ft_x002fft = 4,
	ft_x002fin = 5,
	ft_x002fm = 6,
	ft_x002fmi = 7,
	km_x002fcm = 8,
	m_x002fcm = 9,
	m_x002fkm = 10,
	m_x002fm = 11,
	mi_x002fin = 12
};
#endif

/* eml2_2ForGsoap.h:7740 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUom (-1238)

/* eml22:LengthPerMassUom */
enum class eml22__LengthPerMassUom {
	ft_x002flbm = 0,
	m_x002fkg = 1
};
#endif

/* eml2_2ForGsoap.h:7756 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUom (-1239)

/* eml22:LengthPerPressureUom */
enum class eml22__LengthPerPressureUom {
	ft_x002fpsi = 0,
	m_x002fkPa = 1,
	m_x002fPa = 2
};
#endif

/* eml2_2ForGsoap.h:7777 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUom (-1240)

/* eml22:LengthPerTemperatureUom */
enum class eml22__LengthPerTemperatureUom {
	ft_x002fdeltaF = 0,
	m_x002fdeltaK = 1
};
#endif

/* eml2_2ForGsoap.h:7793 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUom (-1241)

/* eml22:LengthPerTimeUom */
enum class eml22__LengthPerTimeUom {
	_1000_x0020ft_x002fh = 0,
	_1000_x0020ft_x002fs = 1,
	cm_x002fa = 2,
	cm_x002fs = 3,
	dm_x002fs = 4,
	ft_x002fd = 5,
	ft_x002fh = 6,
	ft_x002fmin = 7,
	ft_x002fms = 8,
	ft_x002fs = 9,
	ft_x002fus = 10,
	in_x002fa = 11,
	in_x002fmin = 12,
	in_x002fs = 13,
	km_x002fh = 14,
	km_x002fs = 15,
	knot = 16,
	m_x002fd = 17,
	m_x002fh = 18,
	m_x002fmin = 19,
	m_x002fms = 20,
	m_x002fs = 21,
	mi_x002fh = 22,
	mil_x002fa = 23,
	mm_x002fa = 24,
	mm_x002fs = 25,
	nm_x002fs = 26,
	um_x002fs = 27
};
#endif

/* eml2_2ForGsoap.h:7939 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUom (-1242)

/* eml22:LengthPerVolumeUom */
enum class eml22__LengthPerVolumeUom {
	ft_x002fbbl = 0,
	ft_x002fft3 = 1,
	ft_x002fgal_x005bUS_x005d = 2,
	km_x002fdm3 = 3,
	km_x002fL = 4,
	m_x002fm3 = 5,
	mi_x002fgal_x005bUK_x005d = 6,
	mi_x002fgal_x005bUS_x005d = 7
};
#endif

/* eml2_2ForGsoap.h:7985 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthUom (-1243)

/* eml22:LengthUom */
enum class eml22__LengthUom {
	m = 'm',
	_0_x002e1_x0020ft = 'n',
	_0_x002e1_x0020ft_x005bUS_x005d = 'o',
	_0_x002e1_x0020in = 'p',
	_0_x002e1_x0020yd = 'q',
	_1_x002f16_x0020in = 'r',
	_1_x002f2_x0020ft = 's',
	_1_x002f32_x0020in = 't',
	_1_x002f64_x0020in = 'u',
	_10_x0020ft = 'v',
	_10_x0020in = 'w',
	_10_x0020km = 'x',
	_100_x0020ft = 'y',
	_100_x0020km = 'z',
	_1000_x0020ft = 123,
	_30_x0020ft = 124,
	_30_x0020m = 125,
	angstrom = 126,
	chain = 127,
	chain_x005bBnA_x005d = 128,
	chain_x005bBnB_x005d = 129,
	chain_x005bCla_x005d = 130,
	chain_x005bInd37_x005d = 131,
	chain_x005bSe_x005d = 132,
	chain_x005bSeT_x005d = 133,
	chain_x005bUS_x005d = 134,
	cm = 135,
	dam = 136,
	dm = 137,
	Em = 138,
	fathom = 139,
	fm = 140,
	ft = 141,
	ft_x005bBnA_x005d = 142,
	ft_x005bBnB_x005d = 143,
	ft_x005bBr36_x005d = 144,
	ft_x005bBr65_x005d = 145,
	ft_x005bCla_x005d = 146,
	ft_x005bGC_x005d = 147,
	ft_x005bInd_x005d = 148,
	ft_x005bInd37_x005d = 149,
	ft_x005bInd62_x005d = 150,
	ft_x005bInd75_x005d = 151,
	ft_x005bSe_x005d = 152,
	ft_x005bSeT_x005d = 153,
	ft_x005bUS_x005d = 154,
	fur_x005bUS_x005d = 155,
	Gm = 156,
	hm = 157,
	in = 158,
	in_x005bUS_x005d = 159,
	km = 160,
	link = 161,
	link_x005bBnA_x005d = 162,
	link_x005bBnB_x005d = 163,
	link_x005bCla_x005d = 164,
	link_x005bSe_x005d = 165,
	link_x005bSeT_x005d = 166,
	link_x005bUS_x005d = 167,
	m_x005bGer_x005d = 168,
	mi = 169,
	mi_x005bnaut_x005d = 170,
	mi_x005bnautUK_x005d = 171,
	mi_x005bUS_x005d = 172,
	mil = 173,
	mm = 174,
	Mm = 175,
	nm = 176,
	pm = 177,
	rod_x005bUS_x005d = 178,
	Tm = 179,
	um = 180,
	yd = 181,
	yd_x005bBnA_x005d = 182,
	yd_x005bBnB_x005d = 183,
	yd_x005bCla_x005d = 184,
	yd_x005bInd_x005d = 185,
	yd_x005bInd37_x005d = 186,
	yd_x005bInd62_x005d = 187,
	yd_x005bInd75_x005d = 188,
	yd_x005bSe_x005d = 189,
	yd_x005bSeT_x005d = 190,
	yd_x005bUS_x005d = 191
};
#endif

/* eml2_2ForGsoap.h:8406 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUom (-1244)

/* eml22:LightExposureUom */
enum class eml22__LightExposureUom {
	footcandle_x002es = 0,
	lx_x002es = 1
};
#endif

/* eml2_2ForGsoap.h:8422 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUom (-1245)

/* eml22:LinearAccelerationUom */
enum class eml22__LinearAccelerationUom {
	cm_x002fs2 = 0,
	ft_x002fs2 = 1,
	Gal = 2,
	gn = 3,
	in_x002fs2 = 4,
	m_x002fs2 = 5,
	mGal = 6,
	mgn = 7
};
#endif

/* eml2_2ForGsoap.h:8468 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUom (-1246)

/* eml22:LinearThermalExpansionUom */
enum class eml22__LinearThermalExpansionUom {
	_1_x002fdeltaK = 0,
	in_x002f_x0028in_x002edeltaF_x0029 = 1,
	m_x002f_x0028m_x002edeltaK_x0029 = 2,
	mm_x002f_x0028mm_x002edeltaK_x0029 = 3
};
#endif

/* eml2_2ForGsoap.h:8494 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUom (-1247)

/* eml22:LogarithmicPowerRatioPerLengthUom */
enum class eml22__LogarithmicPowerRatioPerLengthUom {
	B_x002fm = 0,
	dB_x002fft = 1,
	dB_x002fkm = 2,
	dB_x002fm = 3
};
#endif

/* eml2_2ForGsoap.h:8520 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUom (-1248)

/* eml22:LogarithmicPowerRatioUom */
enum class eml22__LogarithmicPowerRatioUom {
	B = 'B',
	dB = 'C'
};
#endif

/* eml2_2ForGsoap.h:8536 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUom (-1249)

/* eml22:LuminanceUom */
enum class eml22__LuminanceUom {
	cd_x002fm2 = 0
};
#endif

/* eml2_2ForGsoap.h:8547 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUom (-1250)

/* eml22:LuminousEfficacyUom */
enum class eml22__LuminousEfficacyUom {
	lm_x002fW = 0
};
#endif

/* eml2_2ForGsoap.h:8558 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUom (-1251)

/* eml22:LuminousFluxUom */
enum class eml22__LuminousFluxUom {
	lm = 0
};
#endif

/* eml2_2ForGsoap.h:8569 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUom (-1252)

/* eml22:LuminousIntensityUom */
enum class eml22__LuminousIntensityUom {
	cd = 0,
	kcd = 1
};
#endif

/* eml2_2ForGsoap.h:8585 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUom (-1253)

/* eml22:MagneticDipoleMomentUom */
enum class eml22__MagneticDipoleMomentUom {
	Wb_x002em = 0
};
#endif

/* eml2_2ForGsoap.h:8596 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUom (-1254)

/* eml22:MagneticFieldStrengthUom */
enum class eml22__MagneticFieldStrengthUom {
	A_x002fm = 0,
	A_x002fmm = 1,
	Oe = 2
};
#endif

/* eml2_2ForGsoap.h:8617 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUom (-1255)

/* eml22:MagneticFluxDensityPerLengthUom */
enum class eml22__MagneticFluxDensityPerLengthUom {
	gauss_x002fcm = 0,
	mT_x002fdm = 1,
	T_x002fm = 2
};
#endif

/* eml2_2ForGsoap.h:8638 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUom (-1256)

/* eml22:MagneticFluxDensityUom */
enum class eml22__MagneticFluxDensityUom {
	T = 'T',
	cgauss = 'U',
	cT = 'V',
	dgauss = 'W',
	dT = 'X',
	Egauss = 'Y',
	ET = 'Z',
	fgauss = 91,
	fT = 92,
	gauss = 93,
	Ggauss = 94,
	GT = 95,
	kgauss = 96,
	kT = 'a',
	mgauss = 'b',
	Mgauss = 'c',
	mT = 'd',
	ngauss = 'e',
	nT = 'f',
	pgauss = 'g',
	pT = 'h',
	Tgauss = 'i',
	TT = 'j',
	ugauss = 'k',
	uT = 'l'
};
#endif

/* eml2_2ForGsoap.h:8769 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUom (-1257)

/* eml22:MagneticFluxUom */
enum class eml22__MagneticFluxUom {
	cWb = 0,
	dWb = 1,
	EWb = 2,
	fWb = 3,
	GWb = 4,
	kWb = 5,
	mWb = 6,
	MWb = 7,
	nWb = 8,
	pWb = 9,
	TWb = 10,
	uWb = 11,
	Wb = 12
};
#endif

/* eml2_2ForGsoap.h:8840 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUom (-1258)

/* eml22:MagneticPermeabilityUom */
enum class eml22__MagneticPermeabilityUom {
	H_x002fm = 0,
	uH_x002fm = 1
};
#endif

/* eml2_2ForGsoap.h:8856 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUom (-1259)

/* eml22:MagneticVectorPotentialUom */
enum class eml22__MagneticVectorPotentialUom {
	Wb_x002fm = 0,
	Wb_x002fmm = 1
};
#endif

/* eml2_2ForGsoap.h:8872 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUom (-1260)

/* eml22:MassLengthUom */
enum class eml22__MassLengthUom {
	kg_x002em = 0,
	lbm_x002eft = 1
};
#endif

/* eml2_2ForGsoap.h:8888 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUom (-1261)

/* eml22:MassPerAreaUom */
enum class eml22__MassPerAreaUom {
	_0_x002e01_x0020lbm_x002fft2 = 0,
	kg_x002fm2 = 1,
	lbm_x002fft2 = 2,
	Mg_x002fm2 = 3,
	ton_x005bUS_x005d_x002fft2 = 4
};
#endif

/* eml2_2ForGsoap.h:8919 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUom (-1262)

/* eml22:MassPerEnergyUom */
enum class eml22__MassPerEnergyUom {
	kg_x002f_x0028kW_x002eh_x0029 = 0,
	kg_x002fJ = 1,
	kg_x002fMJ = 2,
	lbm_x002f_x0028hp_x002eh_x0029 = 3,
	mg_x002fJ = 4
};
#endif

/* eml2_2ForGsoap.h:8950 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUom (-1263)

/* eml22:MassPerLengthUom */
enum class eml22__MassPerLengthUom {
	kg_x002em_x002fcm2 = 0,
	kg_x002fm = 1,
	klbm_x002fin = 2,
	lbm_x002fft = 3,
	Mg_x002fin = 4
};
#endif

/* eml2_2ForGsoap.h:8981 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUom (-1264)

/* eml22:MassPerMassUom */
enum class eml22__MassPerMassUom {
	_x0025 = 0,
	_x0025_x005bmass_x005d = 1,
	Euc = 2,
	g_x002fkg = 3,
	g_x002ft = 4,
	kg_x002fkg = 5,
	kg_x002fsack_x005b94lbm_x005d = 6,
	kg_x002ft = 7,
	mg_x002fg = 8,
	mg_x002fkg = 9,
	ng_x002fg = 10,
	ng_x002fmg = 11,
	ppk = 12,
	ppm = 13,
	ppm_x005bmass_x005d = 14,
	ug_x002fg = 15,
	ug_x002fmg = 16
};
#endif

/* eml2_2ForGsoap.h:9072 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUom (-1265)

/* eml22:MassPerTimePerAreaUom */
enum class eml22__MassPerTimePerAreaUom {
	g_x002eft_x002f_x0028cm3_x002es_x0029 = 0,
	g_x002em_x002f_x0028cm3_x002es_x0029 = 1,
	kg_x002f_x0028m2_x002es_x0029 = 2,
	kPa_x002es_x002fm = 3,
	lbm_x002f_x0028ft2_x002eh_x0029 = 4,
	lbm_x002f_x0028ft2_x002es_x0029 = 5,
	MPa_x002es_x002fm = 6
};
#endif

/* eml2_2ForGsoap.h:9113 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUom (-1266)

/* eml22:MassPerTimePerLengthUom */
enum class eml22__MassPerTimePerLengthUom {
	kg_x002f_x0028m_x002es_x0029 = 0,
	lbm_x002f_x0028ft_x002eh_x0029 = 1,
	lbm_x002f_x0028ft_x002es_x0029 = 2,
	Pa_x002es = 3
};
#endif

/* eml2_2ForGsoap.h:9139 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUom (-1267)

/* eml22:MassPerTimeUom */
enum class eml22__MassPerTimeUom {
	_1E6_x0020lbm_x002fa = 0,
	g_x002fs = 1,
	kg_x002fd = 2,
	kg_x002fh = 3,
	kg_x002fmin = 4,
	kg_x002fs = 5,
	lbm_x002fd = 6,
	lbm_x002fh = 7,
	lbm_x002fmin = 8,
	lbm_x002fs = 9,
	Mg_x002fa = 10,
	Mg_x002fd = 11,
	Mg_x002fh = 12,
	Mg_x002fmin = 13,
	t_x002fa = 14,
	t_x002fd = 15,
	t_x002fh = 16,
	t_x002fmin = 17,
	ton_x005bUK_x005d_x002fa = 18,
	ton_x005bUK_x005d_x002fd = 19,
	ton_x005bUK_x005d_x002fh = 20,
	ton_x005bUK_x005d_x002fmin = 21,
	ton_x005bUS_x005d_x002fa = 22,
	ton_x005bUS_x005d_x002fd = 23,
	ton_x005bUS_x005d_x002fh = 24,
	ton_x005bUS_x005d_x002fmin = 25
};
#endif

/* eml2_2ForGsoap.h:9275 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUom (-1268)

/* eml22:MassPerVolumePerLengthUom */
enum class eml22__MassPerVolumePerLengthUom {
	g_x002fcm4 = 0,
	kg_x002fdm4 = 1,
	kg_x002fm4 = 2,
	lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 3,
	lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 4,
	lbm_x002fft4 = 5,
	Pa_x002es2_x002fm3 = 6
};
#endif

/* eml2_2ForGsoap.h:9316 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUom (-1269)

/* eml22:MassPerVolumePerPressureUom */
enum class eml22__MassPerVolumePerPressureUom {
	kg_x002fm3_x002ekPa = 0,
	lb_x002fft_x002epsi = 1
};
#endif

/* eml2_2ForGsoap.h:9324 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUom (-1270)

/* eml22:MassPerVolumePerTemperatureUom */
enum class eml22__MassPerVolumePerTemperatureUom {
	kg_x002fm3_x002edegC = 0,
	kg_x002fm3_x002eK = 1,
	lb_x002fft_x002edegF = 2
};
#endif

/* eml2_2ForGsoap.h:9333 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUom (-1271)

/* eml22:MassPerVolumeUom */
enum class eml22__MassPerVolumeUom {
	_0_x002e001_x0020lbm_x002fbbl = 0,
	_0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 1,
	_0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 2,
	_0_x002e01_x0020grain_x002fft3 = 3,
	_0_x002e1_x0020lbm_x002fbbl = 4,
	_10_x0020Mg_x002fm3 = 5,
	g_x002fcm3 = 6,
	g_x002fdm3 = 7,
	g_x002fgal_x005bUK_x005d = 8,
	g_x002fgal_x005bUS_x005d = 9,
	g_x002fL = 10,
	g_x002fm3 = 11,
	grain_x002fft3 = 12,
	grain_x002fgal_x005bUS_x005d = 13,
	kg_x002fdm3 = 14,
	kg_x002fL = 15,
	kg_x002fm3 = 16,
	lbm_x002fbbl = 17,
	lbm_x002fft3 = 18,
	lbm_x002fgal_x005bUK_x005d = 19,
	lbm_x002fgal_x005bUS_x005d = 20,
	lbm_x002fin3 = 21,
	mg_x002fdm3 = 22,
	mg_x002fgal_x005bUS_x005d = 23,
	mg_x002fL = 24,
	mg_x002fm3 = 25,
	Mg_x002fm3 = 26,
	t_x002fm3 = 27,
	ug_x002fcm3 = 28
};
#endif

/* eml2_2ForGsoap.h:9484 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassUom (-1272)

/* eml22:MassUom */
enum class eml22__MassUom {
	g = 'g',
	t = 't',
	ag = 'u',
	cg = 'v',
	ct = 'w',
	cwt_x005bUK_x005d = 'x',
	cwt_x005bUS_x005d = 'y',
	Eg = 'z',
	fg = 123,
	Gg = 124,
	grain = 125,
	hg = 126,
	kg = 127,
	klbm = 128,
	lbm = 129,
	mg = 130,
	Mg = 131,
	ng = 132,
	ozm = 133,
	ozm_x005btroy_x005d = 134,
	pg = 135,
	sack_x005b94lbm_x005d = 136,
	Tg = 137,
	ton_x005bUK_x005d = 138,
	ton_x005bUS_x005d = 139,
	ug = 140
};
#endif

/* eml2_2ForGsoap.h:9620 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUom (-1273)

/* eml22:MobilityUom */
enum class eml22__MobilityUom {
	D_x002f_x0028Pa_x002es_x0029 = 0,
	D_x002fcP = 1,
	mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 2,
	mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 3,
	mD_x002f_x0028Pa_x002es_x0029 = 4,
	mD_x002fcP = 5,
	TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 6
};
#endif

/* eml2_2ForGsoap.h:9661 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUom (-1274)

/* eml22:MolarEnergyUom */
enum class eml22__MolarEnergyUom {
	Btu_x005bIT_x005d_x002flbmol = 0,
	J_x002fmol = 1,
	kcal_x005bth_x005d_x002fmol = 2,
	kJ_x002fkmol = 3,
	MJ_x002fkmol = 4
};
#endif

/* eml2_2ForGsoap.h:9692 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUom (-1275)

/* eml22:MolarHeatCapacityUom */
enum class eml22__MolarHeatCapacityUom {
	Btu_x005bIT_x005d_x002f_x0028lbmol_x002edeltaF_x0029 = 0,
	cal_x005bth_x005d_x002f_x0028mol_x002edeltaC_x0029 = 1,
	J_x002f_x0028mol_x002edeltaK_x0029 = 2,
	kJ_x002f_x0028kmol_x002edeltaK_x0029 = 3
};
#endif

/* eml2_2ForGsoap.h:9718 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUom (-1276)

/* eml22:MolarVolumeUom */
enum class eml22__MolarVolumeUom {
	dm3_x002fkmol = 0,
	ft3_x002flbmol = 1,
	L_x002fkmol = 2,
	L_x002fmol = 3,
	m3_x002fkmol = 4,
	m3_x002fmol = 5
};
#endif

/* eml2_2ForGsoap.h:9754 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUom (-1277)

/* eml22:MolecularWeightUom */
enum class eml22__MolecularWeightUom {
	g_x002fmol = 0,
	kg_x002fmol = 1,
	lbm_x002flbmol = 2
};
#endif

/* eml2_2ForGsoap.h:9775 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUom (-1278)

/* eml22:MomentOfForceUom */
enum class eml22__MomentOfForceUom {
	J = 'J',
	_1000_x0020lbf_x002eft = 'K',
	daN_x002em = 'L',
	dN_x002em = 'M',
	kgf_x002em = 'N',
	kN_x002em = 'O',
	lbf_x002eft = 'P',
	lbf_x002ein = 'Q',
	lbm_x002eft2_x002fs2 = 'R',
	N_x002em = 'S',
	pdl_x002eft = 'T',
	tonf_x005bUS_x005d_x002eft = 'U',
	tonf_x005bUS_x005d_x002emi = 'V'
};
#endif

/* eml2_2ForGsoap.h:9846 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUom (-1279)

/* eml22:MomentOfInertiaUom */
enum class eml22__MomentOfInertiaUom {
	kg_x002em2 = 0,
	lbm_x002eft2 = 1
};
#endif

/* eml2_2ForGsoap.h:9862 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUom (-1280)

/* eml22:MomentumUom */
enum class eml22__MomentumUom {
	kg_x002em_x002fs = 0,
	lbm_x002eft_x002fs = 1
};
#endif

/* eml2_2ForGsoap.h:9878 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUom (-1281)

/* eml22:NormalizedPowerUom */
enum class eml22__NormalizedPowerUom {
	B_x002eW = 0,
	dB_x002emW = 1,
	dB_x002eMW = 2,
	dB_x002eW = 3
};
#endif

/* eml2_2ForGsoap.h:9904 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUom (-1282)

/* eml22:PermeabilityLengthUom */
enum class eml22__PermeabilityLengthUom {
	D_x002eft = 0,
	D_x002em = 1,
	mD_x002eft = 2,
	mD_x002em = 3,
	TD_x005bAPI_x005d_x002em = 4
};
#endif

/* eml2_2ForGsoap.h:9935 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUom (-1283)

/* eml22:PermeabilityRockUom */
enum class eml22__PermeabilityRockUom {
	D = 'D',
	D_x005bAPI_x005d = 'E',
	mD = 'F',
	TD_x005bAPI_x005d = 'G'
};
#endif

/* eml2_2ForGsoap.h:9961 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUom (-1284)

/* eml22:PermittivityUom */
enum class eml22__PermittivityUom {
	F_x002fm = 0,
	uF_x002fm = 1
};
#endif

/* eml2_2ForGsoap.h:9977 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUom (-1285)

/* eml22:PlaneAngleUom */
enum class eml22__PlaneAngleUom {
	_0_x002e001_x0020seca = 0,
	ccgr = 1,
	cgr = 2,
	dega = 3,
	gon = 4,
	krad = 5,
	mila = 6,
	mina = 7,
	Mrad = 8,
	mrad = 9,
	rad = 10,
	rev = 11,
	seca = 12,
	urad = 13
};
#endif

/* eml2_2ForGsoap.h:10053 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUom (-1286)

/* eml22:PotentialDifferencePerPowerDropUom */
enum class eml22__PotentialDifferencePerPowerDropUom {
	V_x002fB = 0,
	V_x002fdB = 1
};
#endif

/* eml2_2ForGsoap.h:10069 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUom (-1287)

/* eml22:PowerPerAreaUom */
enum class eml22__PowerPerAreaUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 2,
	hp_x002fin2 = 3,
	hp_x005bhyd_x005d_x002fin2 = 4,
	kW_x002fcm2 = 5,
	kW_x002fm2 = 6,
	mW_x002fm2 = 7,
	ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 8,
	W_x002fcm2 = 9,
	W_x002fm2 = 10,
	W_x002fmm2 = 11
};
#endif

/* eml2_2ForGsoap.h:10135 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUom (-1288)

/* eml22:PowerPerPowerUom */
enum class eml22__PowerPerPowerUom {
	_x0025 = 0,
	Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 1,
	Euc = 2,
	W_x002fkW = 3,
	W_x002fW = 4
};
#endif

/* eml2_2ForGsoap.h:10166 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUom (-1289)

/* eml22:PowerPerVolumeUom */
enum class eml22__PowerPerVolumeUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 2,
	cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 3,
	hp_x002fft3 = 4,
	kW_x002fm3 = 5,
	uW_x002fm3 = 6,
	W_x002fm3 = 7
};
#endif

/* eml2_2ForGsoap.h:10212 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerUom (-1290)

/* eml22:PowerUom */
enum class eml22__PowerUom {
	W = 'W',
	cW = 'X',
	dW = 'Y',
	EW = 'Z',
	fW = 91,
	GW = 92,
	hp = 93,
	hp_x005belec_x005d = 94,
	hp_x005bhyd_x005d = 95,
	hp_x005bmetric_x005d = 96,
	kW = 'a',
	MW = 'b',
	mW = 'c',
	nW = 'd',
	pW = 'e',
	tonRefrig = 'f',
	TW = 'g',
	uW = 'h'
};
#endif

/* eml2_2ForGsoap.h:10308 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUom (-1291)

/* eml22:PressurePerPressureUom */
enum class eml22__PressurePerPressureUom {
	atm_x002fatm = 0,
	bar_x002fbar = 1,
	Euc = 2,
	kPa_x002fkPa = 3,
	MPa_x002fMPa = 4,
	Pa_x002fPa = 5,
	psi_x002fpsi = 6
};
#endif

/* eml2_2ForGsoap.h:10349 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUom (-1292)

/* eml22:PressurePerTimeUom */
enum class eml22__PressurePerTimeUom {
	atm_x002fh = 0,
	bar_x002fh = 1,
	kPa_x002fh = 2,
	kPa_x002fmin = 3,
	MPa_x002fh = 4,
	Pa_x002fh = 5,
	Pa_x002fs = 6,
	psi_x002fh = 7,
	psi_x002fmin = 8
};
#endif

/* eml2_2ForGsoap.h:10400 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUom (-1293)

/* eml22:PressurePerVolumeUom */
enum class eml22__PressurePerVolumeUom {
	Pa_x002fm3 = 0,
	psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1
};
#endif

/* eml2_2ForGsoap.h:10416 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUom (-1294)

/* eml22:PressureSquaredPerForceTimePerAreaUom */
enum class eml22__PressureSquaredPerForceTimePerAreaUom {
	_0_x002e001_x0020kPa2_x002fcP = 0,
	bar2_x002fcP = 1,
	kPa2_x002fcP = 2,
	Pa2_x002f_x0028Pa_x002es_x0029 = 3,
	psi2_x002fcP = 4
};
#endif

/* eml2_2ForGsoap.h:10447 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUom (-1295)

/* eml22:PressureSquaredUom */
enum class eml22__PressureSquaredUom {
	bar2 = 0,
	GPa2 = 1,
	kPa2 = 2,
	kpsi2 = 3,
	Pa2 = 4,
	psi2 = 5
};
#endif

/* eml2_2ForGsoap.h:10483 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUom (-1296)

/* eml22:PressureTimePerVolumeUom */
enum class eml22__PressureTimePerVolumeUom {
	Pa_x002es_x002fm3 = 0,
	psi_x002ed_x002fbbl = 1
};
#endif

/* eml2_2ForGsoap.h:10499 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUom (-1297)

/* eml22:PressureUom */
enum class eml22__PressureUom {
	_0_x002e01_x0020lbf_x002fft2 = 0,
	at = 1,
	atm = 2,
	bar = 3,
	cmH2O_x005b4degC_x005d = 4,
	cPa = 5,
	dPa = 6,
	dyne_x002fcm2 = 7,
	EPa = 8,
	fPa = 9,
	GPa = 10,
	hbar = 11,
	inH2O_x005b39degF_x005d = 12,
	inH2O_x005b60degF_x005d = 13,
	inHg_x005b32degF_x005d = 14,
	inHg_x005b60degF_x005d = 15,
	kgf_x002fcm2 = 16,
	kgf_x002fm2 = 17,
	kgf_x002fmm2 = 18,
	kN_x002fm2 = 19,
	kPa = 20,
	kpsi = 21,
	lbf_x002fft2 = 22,
	mbar = 23,
	mmHg_x005b0degC_x005d = 24,
	mPa = 25,
	MPa = 26,
	Mpsi = 27,
	N_x002fm2 = 28,
	N_x002fmm2 = 29,
	nPa = 30,
	Pa = 31,
	pPa = 32,
	psi = 33,
	tonf_x005bUK_x005d_x002fft2 = 34,
	tonf_x005bUS_x005d_x002fft2 = 35,
	tonf_x005bUS_x005d_x002fin2 = 36,
	torr = 37,
	TPa = 38,
	ubar = 39,
	umHg_x005b0degC_x005d = 40,
	uPa = 41,
	upsi = 42
};
#endif

/* eml2_2ForGsoap.h:10720 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUom (-1298)

/* eml22:QuantityOfLightUom */
enum class eml22__QuantityOfLightUom {
	lm_x002es = 0
};
#endif

/* eml2_2ForGsoap.h:10731 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUom (-1299)

/* eml22:RadianceUom */
enum class eml22__RadianceUom {
	W_x002f_x0028m2_x002esr_x0029 = 0
};
#endif

/* eml2_2ForGsoap.h:10742 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUom (-1300)

/* eml22:RadiantIntensityUom */
enum class eml22__RadiantIntensityUom {
	W_x002fsr = 0
};
#endif

/* eml2_2ForGsoap.h:10753 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUom (-1301)

/* eml22:ReciprocalAreaUom */
enum class eml22__ReciprocalAreaUom {
	_1_x002fft2 = 0,
	_1_x002fkm2 = 1,
	_1_x002fm2 = 2,
	_1_x002fmi2 = 3
};
#endif

/* eml2_2ForGsoap.h:10779 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUom (-1302)

/* eml22:ReciprocalElectricPotentialDifferenceUom */
enum class eml22__ReciprocalElectricPotentialDifferenceUom {
	_1_x002fuV = 0,
	_1_x002fV = 1
};
#endif

/* eml2_2ForGsoap.h:10795 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUom (-1303)

/* eml22:ReciprocalForceUom */
enum class eml22__ReciprocalForceUom {
	_1_x002flbf = 0,
	_1_x002fN = 1
};
#endif

/* eml2_2ForGsoap.h:10811 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUom (-1304)

/* eml22:ReciprocalLengthUom */
enum class eml22__ReciprocalLengthUom {
	_1_x002fangstrom = 0,
	_1_x002fcm = 1,
	_1_x002fft = 2,
	_1_x002fin = 3,
	_1_x002fm = 4,
	_1_x002fmi = 5,
	_1_x002fmm = 6,
	_1_x002fnm = 7,
	_1_x002fyd = 8,
	_1E_9_x00201_x002fft = 9
};
#endif

/* eml2_2ForGsoap.h:10867 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUom (-1305)

/* eml22:ReciprocalMassTimeUom */
enum class eml22__ReciprocalMassTimeUom {
	_1_x002f_x0028kg_x002es_x0029 = 0,
	Bq_x002fkg = 1,
	pCi_x002fg = 2
};
#endif

/* eml2_2ForGsoap.h:10888 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUom (-1306)

/* eml22:ReciprocalMassUom */
enum class eml22__ReciprocalMassUom {
	_1_x002fg = 0,
	_1_x002fkg = 1,
	_1_x002flbm = 2
};
#endif

/* eml2_2ForGsoap.h:10909 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUom (-1307)

/* eml22:ReciprocalPressureUom */
enum class eml22__ReciprocalPressureUom {
	_1_x002fbar = 0,
	_1_x002fkPa = 1,
	_1_x002fPa = 2,
	_1_x002fpPa = 3,
	_1_x002fpsi = 4,
	_1_x002fupsi = 5
};
#endif

/* eml2_2ForGsoap.h:10945 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUom (-1308)

/* eml22:ReciprocalTimeUom */
enum class eml22__ReciprocalTimeUom {
	_1_x002fa = 0,
	_1_x002fd = 1,
	_1_x002fh = 2,
	_1_x002fmin = 3,
	_1_x002fms = 4,
	_1_x002fs = 5,
	_1_x002fus = 6,
	_1_x002fwk = 7
};
#endif

/* eml2_2ForGsoap.h:10991 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUom (-1309)

/* eml22:ReciprocalVolumeUom */
enum class eml22__ReciprocalVolumeUom {
	_1_x002fbbl = 0,
	_1_x002fft3 = 1,
	_1_x002fgal_x005bUK_x005d = 2,
	_1_x002fgal_x005bUS_x005d = 3,
	_1_x002fL = 4,
	_1_x002fm3 = 5
};
#endif

/* eml2_2ForGsoap.h:11027 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUom (-1310)

/* eml22:ReluctanceUom */
enum class eml22__ReluctanceUom {
	_1_x002fH = 0
};
#endif

/* eml2_2ForGsoap.h:11038 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUom (-1311)

/* eml22:SecondMomentOfAreaUom */
enum class eml22__SecondMomentOfAreaUom {
	cm4 = 0,
	in4 = 1,
	m4 = 2
};
#endif

/* eml2_2ForGsoap.h:11059 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUom (-1312)

/* eml22:SignalingEventPerTimeUom */
enum class eml22__SignalingEventPerTimeUom {
	Bd = 0
};
#endif

/* eml2_2ForGsoap.h:11070 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUom (-1313)

/* eml22:SolidAngleUom */
enum class eml22__SolidAngleUom {
	sr = 0
};
#endif

/* eml2_2ForGsoap.h:11081 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUom (-1314)

/* eml22:SpecificHeatCapacityUom */
enum class eml22__SpecificHeatCapacityUom {
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaR_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028g_x002edeltaK_x0029 = 2,
	J_x002f_x0028g_x002edeltaK_x0029 = 3,
	J_x002f_x0028kg_x002edeltaK_x0029 = 4,
	kcal_x005bth_x005d_x002f_x0028kg_x002edeltaC_x0029 = 5,
	kJ_x002f_x0028kg_x002edeltaK_x0029 = 6,
	kW_x002eh_x002f_x0028kg_x002edeltaC_x0029 = 7
};
#endif

/* eml2_2ForGsoap.h:11127 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUom (-1315)

/* eml22:TemperatureIntervalPerLengthUom */
enum class eml22__TemperatureIntervalPerLengthUom {
	_0_x002e01_x0020deltaF_x002fft = 0,
	deltaC_x002fft = 1,
	deltaC_x002fhm = 2,
	deltaC_x002fkm = 3,
	deltaC_x002fm = 4,
	deltaF_x002fft = 5,
	deltaF_x002fm = 6,
	deltaK_x002fkm = 7,
	deltaK_x002fm = 8
};
#endif

/* eml2_2ForGsoap.h:11178 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUom (-1316)

/* eml22:TemperatureIntervalPerPressureUom */
enum class eml22__TemperatureIntervalPerPressureUom {
	deltaC_x002fkPa = 0,
	deltaF_x002fpsi = 1,
	deltaK_x002fPa = 2
};
#endif

/* eml2_2ForGsoap.h:11199 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUom (-1317)

/* eml22:TemperatureIntervalPerTimeUom */
enum class eml22__TemperatureIntervalPerTimeUom {
	deltaC_x002fh = 0,
	deltaC_x002fmin = 1,
	deltaC_x002fs = 2,
	deltaF_x002fh = 3,
	deltaF_x002fmin = 4,
	deltaF_x002fs = 5,
	deltaK_x002fs = 6
};
#endif

/* eml2_2ForGsoap.h:11240 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUom (-1318)

/* eml22:TemperatureIntervalUom */
enum class eml22__TemperatureIntervalUom {
	deltaC = 0,
	deltaF = 1,
	deltaK = 2,
	deltaR = 3
};
#endif

/* eml2_2ForGsoap.h:11266 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUom (-1319)

/* eml22:ThermalConductanceUom */
enum class eml22__ThermalConductanceUom {
	W_x002fdeltaK = 0
};
#endif

/* eml2_2ForGsoap.h:11277 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUom (-1320)

/* eml22:ThermalConductivityUom */
enum class eml22__ThermalConductivityUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edeltaF_x0029 = 0,
	cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edeltaC_x0029 = 1,
	cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edeltaC_x0029 = 2,
	kcal_x005bth_x005d_x002f_x0028h_x002em_x002edeltaC_x0029 = 3,
	W_x002f_x0028m_x002edeltaK_x0029 = 4
};
#endif

/* eml2_2ForGsoap.h:11308 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUom (-1321)

/* eml22:ThermalDiffusivityUom */
enum class eml22__ThermalDiffusivityUom {
	cm2_x002fs = 0,
	ft2_x002fh = 1,
	ft2_x002fs = 2,
	in2_x002fs = 3,
	m2_x002fh = 4,
	m2_x002fs = 5,
	mm2_x002fs = 6
};
#endif

/* eml2_2ForGsoap.h:11349 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUom (-1322)

/* eml22:ThermalInsulanceUom */
enum class eml22__ThermalInsulanceUom {
	deltaC_x002em2_x002eh_x002fkcal_x005bth_x005d = 0,
	deltaF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 1,
	deltaK_x002em2_x002fkW = 2,
	deltaK_x002em2_x002fW = 3
};
#endif

/* eml2_2ForGsoap.h:11375 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUom (-1323)

/* eml22:ThermalResistanceUom */
enum class eml22__ThermalResistanceUom {
	deltaK_x002fW = 0
};
#endif

/* eml2_2ForGsoap.h:11386 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom (-1324)

/* eml22:ThermodynamicTemperaturePerThermodynamicTemperatureUom */
enum class eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom {
	degC_x002fdegC = 0,
	degF_x002fdegF = 1,
	degR_x002fdegR = 2,
	Euc = 3,
	K_x002fK = 4
};
#endif

/* eml2_2ForGsoap.h:11417 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUom (-1325)

/* eml22:ThermodynamicTemperatureUom */
enum class eml22__ThermodynamicTemperatureUom {
	K = 'K',
	degC = 'L',
	degF = 'M',
	degR = 'N'
};
#endif

/* eml2_2ForGsoap.h:11443 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUom (-1326)

/* eml22:TimePerLengthUom */
enum class eml22__TimePerLengthUom {
	_0_x002e001_x0020h_x002fft = 0,
	h_x002fkm = 1,
	min_x002fft = 2,
	min_x002fm = 3,
	ms_x002fcm = 4,
	ms_x002fft = 5,
	ms_x002fin = 6,
	ms_x002fm = 7,
	ns_x002fft = 8,
	ns_x002fm = 9,
	s_x002fcm = 10,
	s_x002fft = 11,
	s_x002fin = 12,
	s_x002fm = 13,
	us_x002fft = 14,
	us_x002fin = 15,
	us_x002fm = 16
};
#endif

/* eml2_2ForGsoap.h:11534 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUom (-1327)

/* eml22:TimePerMassUom */
enum class eml22__TimePerMassUom {
	s_x002fkg = 0
};
#endif

/* eml2_2ForGsoap.h:11545 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUom (-1328)

/* eml22:TimePerTimeUom */
enum class eml22__TimePerTimeUom {
	_x0025 = 0,
	Euc = 1,
	ms_x002fs = 2,
	s_x002fs = 3
};
#endif

/* eml2_2ForGsoap.h:11571 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUom (-1329)

/* eml22:TimePerVolumeUom */
enum class eml22__TimePerVolumeUom {
	_0_x002e001_x0020d_x002fft3 = 0,
	d_x002fbbl = 1,
	d_x002fft3 = 2,
	d_x002fm3 = 3,
	h_x002fft3 = 4,
	h_x002fm3 = 5,
	s_x002fft3 = 6,
	s_x002fL = 7,
	s_x002fm3 = 8,
	s_x002fqt_x005bUK_x005d = 9,
	s_x002fqt_x005bUS_x005d = 10
};
#endif

/* eml2_2ForGsoap.h:11632 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeUom (-1330)

/* eml22:TimeUom */
enum class eml22__TimeUom {
	a = 'a',
	d = 'd',
	h = 'h',
	s = 's',
	_1_x002f2_x0020ms = 't',
	_100_x0020ka_x005bt_x005d = 'u',
	a_x005bt_x005d = 'v',
	ca = 'w',
	cs = 'x',
	ds = 'y',
	Ea_x005bt_x005d = 'z',
	fa = 123,
	Ga_x005bt_x005d = 124,
	hs = 125,
	ka_x005bt_x005d = 126,
	Ma_x005bt_x005d = 127,
	min_ = 128,
	ms = 129,
	na = 130,
	ns = 131,
	ps = 132,
	Ta_x005bt_x005d = 133,
	us = 134,
	wk = 135
};
#endif

/* eml2_2ForGsoap.h:11762 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUom (-1331)

/* eml22:VerticalCoordinateUom */
enum class eml22__VerticalCoordinateUom {
	m = 'm',
	ft = 'n',
	ftUS = 'o',
	ftBr_x002865_x0029 = 'p'
};
#endif

/* eml2_2ForGsoap.h:11788 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUom (-1332)

/* eml22:VolumeFlowRatePerVolumeFlowRateUom */
enum class eml22__VolumeFlowRatePerVolumeFlowRateUom {
	_x0025 = 0,
	_x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 1,
	_x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 2,
	_x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 3,
	_1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 4,
	Euc = 5
};
#endif

/* eml2_2ForGsoap.h:11824 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUom (-1333)

/* eml22:VolumePerAreaUom */
enum class eml22__VolumePerAreaUom {
	_1E6_x0020bbl_x002facre = 0,
	bbl_x002facre = 1,
	ft3_x002fft2 = 2,
	m3_x002fm2 = 3
};
#endif

/* eml2_2ForGsoap.h:11850 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUom (-1334)

/* eml22:VolumePerLengthUom */
enum class eml22__VolumePerLengthUom {
	_0_x002e01_x0020dm3_x002fkm = 0,
	_0_x002e01_x0020L_x002fkm = 1,
	bbl_x002fft = 2,
	bbl_x002fin = 3,
	bbl_x002fmi = 4,
	dm3_x002fm = 5,
	ft3_x002fft = 6,
	gal_x005bUK_x005d_x002fmi = 7,
	gal_x005bUS_x005d_x002fft = 8,
	gal_x005bUS_x005d_x002fmi = 9,
	in3_x002fft = 10,
	L_x002fm = 11,
	m3_x002fkm = 12,
	m3_x002fm = 13
};
#endif

/* eml2_2ForGsoap.h:11926 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUom (-1335)

/* eml22:VolumePerMassUom */
enum class eml22__VolumePerMassUom {
	_0_x002e01_x0020L_x002fkg = 0,
	bbl_x002fton_x005bUK_x005d = 1,
	bbl_x002fton_x005bUS_x005d = 2,
	cm3_x002fg = 3,
	dm3_x002fkg = 4,
	dm3_x002ft = 5,
	ft3_x002fkg = 6,
	ft3_x002flbm = 7,
	ft3_x002fsack_x005b94lbm_x005d = 8,
	gal_x005bUK_x005d_x002flbm = 9,
	gal_x005bUS_x005d_x002flbm = 10,
	gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 11,
	gal_x005bUS_x005d_x002fton_x005bUK_x005d = 12,
	gal_x005bUS_x005d_x002fton_x005bUS_x005d = 13,
	L_x002fkg = 14,
	L_x002ft = 15,
	L_x002fton_x005bUK_x005d = 16,
	m3_x002fg = 17,
	m3_x002fkg = 18,
	m3_x002ft = 19,
	m3_x002fton_x005bUK_x005d = 20,
	m3_x002fton_x005bUS_x005d = 21
};
#endif

/* eml2_2ForGsoap.h:12042 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUom (-1336)

/* eml22:VolumePerPressureUom */
enum class eml22__VolumePerPressureUom {
	bbl_x002fpsi = 0,
	m3_x002fkPa = 1,
	m3_x002fPa = 2
};
#endif

/* eml2_2ForGsoap.h:12063 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUom (-1337)

/* eml22:VolumePerRotationUom */
enum class eml22__VolumePerRotationUom {
	ft3_x002frad = 0,
	m3_x002frad = 1,
	m3_x002frev = 2
};
#endif

/* eml2_2ForGsoap.h:12084 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUom (-1338)

/* eml22:VolumePerTimeLengthUom */
enum class eml22__VolumePerTimeLengthUom {
	_1000_x0020bbl_x002eft_x002fd = 0,
	_1000_x0020m4_x002fd = 1,
	m4_x002fs = 2
};
#endif

/* eml2_2ForGsoap.h:12105 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUom (-1339)

/* eml22:VolumePerTimePerAreaUom */
enum class eml22__VolumePerTimePerAreaUom {
	ft3_x002f_x0028min_x002eft2_x0029 = 0,
	ft3_x002f_x0028s_x002eft2_x0029 = 1,
	gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 2,
	gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 3,
	gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 4,
	gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 5,
	gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 6,
	gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 7,
	m3_x002f_x0028s_x002em2_x0029 = 8
};
#endif

/* eml2_2ForGsoap.h:12156 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUom (-1340)

/* eml22:VolumePerTimePerLengthUom */
enum class eml22__VolumePerTimePerLengthUom {
	_1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 0,
	_1000_x0020m3_x002f_x0028d_x002em_x0029 = 1,
	_1000_x0020m3_x002f_x0028h_x002em_x0029 = 2,
	bbl_x002f_x0028d_x002eft_x0029 = 3,
	ft3_x002f_x0028d_x002eft_x0029 = 4,
	gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 5,
	gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 6,
	gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 7,
	gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 8,
	gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 9,
	gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 10,
	m3_x002f_x0028d_x002em_x0029 = 11,
	m3_x002f_x0028h_x002em_x0029 = 12,
	m3_x002f_x0028s_x002eft_x0029 = 13,
	m3_x002f_x0028s_x002em_x0029 = 14
};
#endif

/* eml2_2ForGsoap.h:12237 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUom (-1341)

/* eml22:VolumePerTimePerPressureLengthUom */
enum class eml22__VolumePerTimePerPressureLengthUom {
	bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 0,
	ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 1,
	m2_x002f_x0028kPa_x002ed_x0029 = 2,
	m2_x002f_x0028Pa_x002es_x0029 = 3
};
#endif

/* eml2_2ForGsoap.h:12263 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUom (-1342)

/* eml22:VolumePerTimePerPressureUom */
enum class eml22__VolumePerTimePerPressureUom {
	_1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 0,
	bbl_x002f_x0028kPa_x002ed_x0029 = 1,
	bbl_x002f_x0028psi_x002ed_x0029 = 2,
	L_x002f_x0028bar_x002emin_x0029 = 3,
	m3_x002f_x0028bar_x002ed_x0029 = 4,
	m3_x002f_x0028bar_x002eh_x0029 = 5,
	m3_x002f_x0028bar_x002emin_x0029 = 6,
	m3_x002f_x0028kPa_x002ed_x0029 = 7,
	m3_x002f_x0028kPa_x002eh_x0029 = 8,
	m3_x002f_x0028Pa_x002es_x0029 = 9,
	m3_x002f_x0028psi_x002ed_x0029 = 10
};
#endif

/* eml2_2ForGsoap.h:12324 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUom (-1343)

/* eml22:VolumePerTimePerTimeUom */
enum class eml22__VolumePerTimePerTimeUom {
	bbl_x002fd2 = 0,
	bbl_x002fh2 = 1,
	dm3_x002fs2 = 2,
	ft3_x002fd2 = 3,
	ft3_x002fh2 = 4,
	ft3_x002fmin2 = 5,
	ft3_x002fs2 = 6,
	gal_x005bUK_x005d_x002fh2 = 7,
	gal_x005bUK_x005d_x002fmin2 = 8,
	gal_x005bUS_x005d_x002fh2 = 9,
	gal_x005bUS_x005d_x002fmin2 = 10,
	L_x002fs2 = 11,
	m3_x002fd2 = 12,
	m3_x002fs2 = 13
};
#endif

/* eml2_2ForGsoap.h:12400 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUom (-1344)

/* eml22:VolumePerTimePerVolumeUom */
enum class eml22__VolumePerTimePerVolumeUom {
	bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 0,
	m3_x002f_x0028s_x002em3_x0029 = 1
};
#endif

/* eml2_2ForGsoap.h:12416 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUom (-1345)

/* eml22:VolumePerTimeUom */
enum class eml22__VolumePerTimeUom {
	_1_x002f30_x0020cm3_x002fmin = 0,
	_1000_x0020bbl_x002fd = 1,
	_1000_x0020ft3_x002fd = 2,
	_1000_x0020m3_x002fd = 3,
	_1000_x0020m3_x002fh = 4,
	_1E6_x0020bbl_x002fd = 5,
	_1E6_x0020ft3_x002fd = 6,
	_1E6_x0020m3_x002fd = 7,
	bbl_x002fd = 8,
	bbl_x002fh = 9,
	bbl_x002fmin = 10,
	cm3_x002fh = 11,
	cm3_x002fmin = 12,
	cm3_x002fs = 13,
	dm3_x002fs = 14,
	ft3_x002fd = 15,
	ft3_x002fh = 16,
	ft3_x002fmin = 17,
	ft3_x002fs = 18,
	gal_x005bUK_x005d_x002fd = 19,
	gal_x005bUK_x005d_x002fh = 20,
	gal_x005bUK_x005d_x002fmin = 21,
	gal_x005bUS_x005d_x002fd = 22,
	gal_x005bUS_x005d_x002fh = 23,
	gal_x005bUS_x005d_x002fmin = 24,
	L_x002fh = 25,
	L_x002fmin = 26,
	L_x002fs = 27,
	m3_x002fd = 28,
	m3_x002fh = 29,
	m3_x002fmin = 30,
	m3_x002fs = 31
};
#endif

/* eml2_2ForGsoap.h:12582 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUom (-1346)

/* eml22:VolumePerVolumeUom */
enum class eml22__VolumePerVolumeUom {
	_x0025 = 0,
	_x0025_x005bvol_x005d = 1,
	_0_x002e001_x0020bbl_x002fft3 = 2,
	_0_x002e001_x0020bbl_x002fm3 = 3,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 4,
	_0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 5,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 6,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 7,
	_0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 8,
	_0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 9,
	_0_x002e01_x0020bbl_x002fbbl = 10,
	_0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 11,
	_0_x002e1_x0020L_x002fbbl = 12,
	_0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 13,
	_1000_x0020ft3_x002fbbl = 14,
	_1000_x0020m3_x002fm3 = 15,
	_1E_6_x0020acre_x002eft_x002fbbl = 16,
	_1E_6_x0020bbl_x002fft3 = 17,
	_1E_6_x0020bbl_x002fm3 = 18,
	_1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 19,
	_1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 20,
	_1E6_x0020ft3_x002fbbl = 21,
	bbl_x002f_x0028acre_x002eft_x0029 = 22,
	bbl_x002fbbl = 23,
	bbl_x002fft3 = 24,
	bbl_x002fm3 = 25,
	cEuc = 26,
	cm3_x002fcm3 = 27,
	cm3_x002fL = 28,
	cm3_x002fm3 = 29,
	dm3_x002fm3 = 30,
	Euc = 31,
	ft3_x002fbbl = 32,
	ft3_x002fft3 = 33,
	gal_x005bUK_x005d_x002fft3 = 34,
	gal_x005bUS_x005d_x002fbbl = 35,
	gal_x005bUS_x005d_x002fft3 = 36,
	L_x002fm3 = 37,
	m3_x002f_x0028ha_x002em_x0029 = 38,
	m3_x002fbbl = 39,
	m3_x002fm3 = 40,
	mL_x002fgal_x005bUK_x005d = 41,
	mL_x002fgal_x005bUS_x005d = 42,
	mL_x002fmL = 43,
	ppk = 44,
	ppm = 45,
	ppm_x005bvol_x005d = 46
};
#endif

/* eml2_2ForGsoap.h:12823 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUom (-1347)

/* eml22:VolumetricHeatTransferCoefficientUom */
enum class eml22__VolumetricHeatTransferCoefficientUom {
	Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edeltaF_x0029 = 0,
	Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edeltaF_x0029 = 1,
	kW_x002f_x0028m3_x002edeltaK_x0029 = 2,
	W_x002f_x0028m3_x002edeltaK_x0029 = 3
};
#endif

/* eml2_2ForGsoap.h:12849 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUom (-1348)

/* eml22:VolumetricThermalExpansionUom */
enum class eml22__VolumetricThermalExpansionUom {
	_1_x002fdeltaC = 0,
	_1_x002fdeltaF = 1,
	_1_x002fdeltaK = 2,
	_1_x002fdeltaR = 3,
	_1E_6_x0020m3_x002f_x0028m3_x002edeltaC_x0029 = 4,
	_1E_6_x0020m3_x002f_x0028m3_x002edeltaF_x0029 = 5,
	m3_x002f_x0028m3_x002edeltaK_x0029 = 6,
	ppm_x005bvol_x005d_x002fdeltaC = 7,
	ppm_x005bvol_x005d_x002fdeltaF = 8
};
#endif

/* eml2_2ForGsoap.h:12900 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUom (-1349)

/* eml22:VolumeUom */
enum class eml22__VolumeUom {
	L = 'L',
	_1000_x0020bbl = 'M',
	_1000_x0020ft3 = 'N',
	_1000_x0020gal_x005bUK_x005d = 'O',
	_1000_x0020gal_x005bUS_x005d = 'P',
	_1000_x0020m3 = 'Q',
	_1E_6_x0020gal_x005bUS_x005d = 'R',
	_1E12_x0020ft3 = 'S',
	_1E6_x0020bbl = 'T',
	_1E6_x0020ft3 = 'U',
	_1E6_x0020m3 = 'V',
	_1E9_x0020bbl = 'W',
	_1E9_x0020ft3 = 'X',
	acre_x002eft = 'Y',
	bbl = 'Z',
	cm3 = 91,
	dm3 = 92,
	floz_x005bUK_x005d = 93,
	floz_x005bUS_x005d = 94,
	ft3 = 95,
	gal_x005bUK_x005d = 96,
	gal_x005bUS_x005d = 'a',
	ha_x002em = 'b',
	hL = 'c',
	in3 = 'd',
	km3 = 'e',
	m3 = 'f',
	mi3 = 'g',
	mL = 'h',
	mm3 = 'i',
	pt_x005bUK_x005d = 'j',
	pt_x005bUS_x005d = 'k',
	qt_x005bUK_x005d = 'l',
	qt_x005bUS_x005d = 'm',
	um2_x002em = 'n',
	yd3 = 'o'
};
#endif

/* eml2_2ForGsoap.h:13086 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyMassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyMassPerVolumeUom (-1350)

/* eml22:LegacyMassPerVolumeUom */
enum class eml22__LegacyMassPerVolumeUom {
	kg_x002fscm = 0,
	lbm_x002f1000scf = 1,
	lbm_x002f1E6scf = 2
};
#endif

/* eml2_2ForGsoap.h:13095 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressurePerVolumeUom (-1351)

/* eml22:LegacyPressurePerVolumeUom */
enum class eml22__LegacyPressurePerVolumeUom {
	Pa_x002fscm = 0,
	psi_x002f1000scf = 1,
	psi_x002f1E6scf = 2
};
#endif

/* eml2_2ForGsoap.h:13104 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressureUom (-1352)

/* eml22:LegacyPressureUom */
enum class eml22__LegacyPressureUom {
	psia = 0,
	psig = 1
};
#endif

/* eml2_2ForGsoap.h:13112 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerAreaUom (-1353)

/* eml22:LegacyVolumePerAreaUom */
enum class eml22__LegacyVolumePerAreaUom {
	_1E6stb_x002facre = 0,
	scf_x002fft2 = 1,
	scm_x002fm2 = 2,
	stb_x002facre = 3
};
#endif

/* eml2_2ForGsoap.h:13122 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerTimeUom (-1354)

/* eml22:LegacyVolumePerTimeUom */
enum class eml22__LegacyVolumePerTimeUom {
	_1000scf_x002fd = 0,
	_1000scf_x002fmo = 1,
	_1000scm_x002fd = 2,
	_1000scm_x002fmo = 3,
	_1000stb_x002fd = 4,
	_1000stb_x002fmo = 5,
	_1E6scf_x002fd = 6,
	_1E6scf_x002fmo = 7,
	_1E6scm_x002fd = 8,
	_1E6scm_x002fmo = 9,
	_1E6stb_x002fd = 10,
	_1E6stb_x002fmo = 11,
	scf_x002fd = 12,
	scm_x002fd = 13,
	scm_x002fh = 14,
	scm_x002fmo = 15,
	scm_x002fs = 16,
	stb_x002fd = 17,
	stb_x002fmo = 18
};
#endif

/* eml2_2ForGsoap.h:13147 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerVolumeUom (-1355)

/* eml22:LegacyVolumePerVolumeUom */
enum class eml22__LegacyVolumePerVolumeUom {
	_1000scf_x002fstb = 0,
	_1E6scf_x002fstb = 1,
	_1E6stb_x002facre_x002eft = 2,
	acre_x002eft_x002f1E6stb = 3,
	bbl_x002f1000scf = 4,
	bbl_x002f1E6scf = 5,
	bbl_x002fscf = 6,
	bbl_x002fstb = 7,
	ft3_x002fscf = 8,
	ft3_x002fstb = 9,
	galUS_x002f1000scf = 10,
	m3_x002fscm = 11,
	ml_x002fscm = 12,
	scf_x002fbbl = 13,
	scf_x002fft3 = 14,
	scf_x002fscf = 15,
	scf_x002fstb = 16,
	scm_x002fm3 = 17,
	scm_x002fscm = 18,
	scm_x002fstb = 19,
	stb_x002f1000scf = 20,
	stb_x002f1000scm = 21,
	stb_x002f1E6scf = 22,
	stb_x002f1E6scm = 23,
	stb_x002fbbl = 24,
	stb_x002fscm = 25,
	stb_x002fstb = 26
};
#endif

/* eml2_2ForGsoap.h:13180 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumeUom (-1356)

/* eml22:LegacyVolumeUom */
enum class eml22__LegacyVolumeUom {
	_1000scm = 0,
	_1000stb = 1,
	_1E6scf = 2,
	_1E6scm = 3,
	_1E6stb = 4,
	_1E9scf = 5,
	kscf = 6,
	scf = 7,
	scm = 8,
	stb = 9
};
#endif

/* eml2_2ForGsoap.h:13227 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MixingRule
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MixingRule (-1360)

/* prodml21:MixingRule */
enum class prodml21__MixingRule {
	asymmetric = 0,
	classical = 1
};
#endif

/* eml2_2ForGsoap.h:13247 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidProperty (-1361)

/* prodml21:OutputFluidProperty */
enum class prodml21__OutputFluidProperty {
	Compressibility = 0,
	Density = 1,
	Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Pressure = 2,
	Derivative_x0020of_x0020Density_x0020w_x002er_x002et_x0020Temperature = 3,
	Enthalpy = 4,
	Entropy = 5,
	Expansion_x0020Factor = 6,
	Formation_x0020Volume_x0020Factor = 7,
	Gas_Oil_x0020Interfacial_x0020Tension = 8,
	Gas_Water_x0020Interfacial_x0020Tension = 9,
	Index = 10,
	K_x0020value = 11,
	Misc_x0020Bank_x0020Critical_x0020Solvent_x0020Saturation = 12,
	Misc_x0020Bank_x0020Phase_x0020Density = 13,
	Misc_x0020Bank_x0020Phase_x0020Viscosity = 14,
	Miscibility_x0020Parameter_x0020_x0028Alpha_x0029 = 15,
	Mixing_x0020Parameter_x0020Oil_Gas = 16,
	Normalized_x0020Pseudo_x0020Pressure = 17,
	Oil_Gas_x0020Ratio = 18,
	Oil_Water_x0020Interfacial_x0020Tension = 19,
	Parachor = 20,
	Pressure = 21,
	Pseudo_x0020Pressure = 22,
	P_T_x0020Cross_x0020Term = 23,
	Saturation_x0020Pressure = 24,
	Solution_x0020GOR = 25,
	Solvent_x0020Density = 26,
	Specific_x0020Heat = 27,
	Temperature = 28,
	Thermal_x0020Conductivity = 29,
	Viscosity = 30,
	Viscosity_x0020Compressibility = 31,
	Water_x0020vapor_x0020mass_x0020fraction_x0020in_x0020gas_x0020phase = 32,
	Z_x0020Factor = 33
};
#endif

/* eml2_2ForGsoap.h:13427 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKind (-1362)

/* prodml21:PvtModelParameterKind */
enum class prodml21__PvtModelParameterKind {
	b0 = 0,
	b1 = 1,
	b2 = 2,
	c1 = 3,
	c2 = 4,
	d1 = 5,
	d2 = 6,
	e1 = 7,
	e2 = 8,
	f1 = 9,
	f2 = 10,
	g1 = 11,
	g2 = 12,
	h1 = 13,
	h2 = 14,
	a0 = 15,
	a1 = 16,
	a2 = 17,
	a3 = 18,
	a4 = 19,
	a5 = 20,
	a6 = 21,
	a7 = 22,
	a8 = 23,
	a9 = 24,
	a10 = 25,
	c0 = 26,
	d0 = 27,
	e0 = 28,
	f0 = 29,
	g0 = 30,
	h0 = 31
};
#endif

/* eml2_2ForGsoap.h:13597 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__saturationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__saturationKind (-1363)

/* prodml21:saturationKind */
enum class prodml21__saturationKind {
	saturated = 0,
	undersaturated = 1
};
#endif

/* eml2_2ForGsoap.h:13617 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AddressKindEnum (-1364)

/* prodml21:AddressKindEnum */
enum class prodml21__AddressKindEnum {
	both = 0,
	mailing = 1,
	physical = 2
};
#endif

/* eml2_2ForGsoap.h:13634 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AddressQualifier (-1365)

/* prodml21:AddressQualifier */
enum class prodml21__AddressQualifier {
	permanent = 0,
	personal = 1,
	work = 2
};
#endif

/* eml2_2ForGsoap.h:13655 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessUnitKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessUnitKind (-1366)

/* prodml21:BusinessUnitKind */
enum class prodml21__BusinessUnitKind {
	businessarea = 0,
	company = 1,
	field = 2,
	license = 3,
	platform = 4,
	terminal = 5,
	unknown = 6
};
#endif

/* eml2_2ForGsoap.h:13672 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifier (-1367)

/* prodml21:EndpointQualifier */
enum class prodml21__EndpointQualifier {
	exclusive = 0,
	extensive = 1,
	inclusive = 2,
	overlap_x0020extensive = 3
};
#endif

/* eml2_2ForGsoap.h:13703 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifierInterval
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifierInterval (-1368)

/* prodml21:EndpointQualifierInterval */
enum class prodml21__EndpointQualifierInterval {
	exclusive = 0,
	inclusive = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:13728 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParameter (-1369)

/* prodml21:FacilityParameter */
enum class prodml21__FacilityParameter {
	absorbed_x0020dose_x0020class = 0,
	acceleration_x0020linear_x0020class = 1,
	activity_x0020_x0028of_x0020radioactivity_x0029_x0020class = 2,
	alarm_x0020absolute_x0020pressure = 3,
	amount_x0020of_x0020substance_x0020class = 4,
	angle_x0020per_x0020length = 5,
	angle_x0020per_x0020time = 6,
	angle_x0020per_x0020volume = 7,
	angular_x0020acceleration_x0020class = 8,
	annulus_x0020inner_x0020diameter = 9,
	annulus_x0020outer_x0020diameter = 10,
	area_x0020class = 11,
	area_x0020per_x0020area = 12,
	area_x0020per_x0020volume = 13,
	atmospheric_x0020pressure = 14,
	attenuation_x0020class = 15,
	attenuation_x0020per_x0020length = 16,
	available = 17,
	available_x0020room = 18,
	block_x0020valve_x0020status = 19,
	capacitance_x0020class = 20,
	categorical = 21,
	cathodic_x0020protection_x0020output_x0020current = 22,
	cathodic_x0020protection_x0020output_x0020voltage = 23,
	charge_x0020density_x0020class = 24,
	chemical_x0020potential_x0020class = 25,
	choke_x0020position = 26,
	choke_x0020setting = 27,
	code = 28,
	compressibility_x0020class = 29,
	concentration_x0020of_x0020B_x0020class = 30,
	conductivity_x0020class = 31,
	continuous = 32,
	cross_x0020section_x0020absorption_x0020class = 33,
	current_x0020density_x0020class = 34,
	darcy_x0020flow_x0020coefficient_x0020class = 35,
	data_x0020transmission_x0020speed_x0020class = 36,
	delta_x0020temperature_x0020class = 37,
	density = 38,
	density_x0020class = 39,
	density_x0020flow_x0020rate = 40,
	density_x0020standard = 41,
	dewpoint_x0020temperature = 42,
	differential_x0020pressure = 43,
	differential_x0020temperature = 44,
	diffusion_x0020coefficient_x0020class = 45,
	digital_x0020storage_x0020class = 46,
	dimensionless_x0020class = 47,
	discrete = 48,
	dose_x0020equivalent_x0020class = 49,
	dose_x0020equivalent_x0020rate_x0020class = 50,
	dynamic_x0020viscosity_x0020class = 51,
	electric_x0020charge_x0020class = 52,
	electric_x0020conductance_x0020class = 53,
	electric_x0020current_x0020class = 54,
	electric_x0020dipole_x0020moment_x0020class = 55,
	electric_x0020field_x0020strength_x0020class = 56,
	electric_x0020polarization_x0020class = 57,
	electric_x0020potential_x0020class = 58,
	electrical_x0020resistivity_x0020class = 59,
	electrochemical_x0020equivalent_x0020class = 60,
	electromagnetic_x0020moment_x0020class = 61,
	energy_x0020length_x0020per_x0020area = 62,
	energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 63,
	energy_x0020per_x0020area = 64,
	energy_x0020per_x0020length = 'A',
	equivalent_x0020per_x0020mass = 'B',
	equivalent_x0020per_x0020volume = 'C',
	exposure_x0020_x0028radioactivity_x0029_x0020class = 'D',
	facility_x0020uptime = 'E',
	flow_x0020rate = 'F',
	flow_x0020rate_x0020standard = 'G',
	force_x0020area_x0020class = 'H',
	force_x0020class = 'I',
	force_x0020length_x0020per_x0020length = 'J',
	force_x0020per_x0020force = 'K',
	force_x0020per_x0020length = 'L',
	force_x0020per_x0020volume = 'M',
	frequency_x0020class = 'N',
	frequency_x0020interval_x0020class = 'O',
	gamma_x0020ray_x0020API_x0020unit_x0020class = 'P',
	gas_x0020liquid_x0020ratio = 'Q',
	gas_x0020oil_x0020ratio = 'R',
	gross_x0020calorific_x0020value_x0020standard = 'S',
	heat_x0020capacity_x0020class = 'T',
	heat_x0020flow_x0020rate_x0020class = 'U',
	heat_x0020transfer_x0020coefficient_x0020class = 'V',
	illuminance_x0020class = 'W',
	internal_x0020control_x0020valve_x0020status = 'X',
	irradiance_x0020class = 'Y',
	isothermal_x0020compressibility_x0020class = 'Z',
	kinematic_x0020viscosity_x0020class = 91,
	length_x0020class = 92,
	length_x0020per_x0020length = 93,
	length_x0020per_x0020temperature = 94,
	length_x0020per_x0020volume = 95,
	level_x0020of_x0020power_x0020intensity_x0020class = 96,
	light_x0020exposure_x0020class = 'a',
	linear_x0020thermal_x0020expansion_x0020class = 'b',
	luminance_x0020class = 'c',
	luminous_x0020efficacy_x0020class = 'd',
	luminous_x0020flux_x0020class = 'e',
	luminous_x0020intensity_x0020class = 'f',
	magnetic_x0020dipole_x0020moment_x0020class = 'g',
	magnetic_x0020field_x0020strength_x0020class = 'h',
	magnetic_x0020flux_x0020class = 'i',
	magnetic_x0020induction_x0020class = 'j',
	magnetic_x0020permeability_x0020class = 'k',
	magnetic_x0020vector_x0020potential_x0020class = 'l',
	mass = 'm',
	mass_x0020attenuation_x0020coefficient_x0020class = 'n',
	mass_x0020class = 'o',
	mass_x0020concentration = 'p',
	mass_x0020concentration_x0020class = 'q',
	mass_x0020flow_x0020rate_x0020class = 'r',
	mass_x0020length_x0020class = 's',
	mass_x0020per_x0020energy = 't',
	mass_x0020per_x0020length = 'u',
	mass_x0020per_x0020time_x0020per_x0020area = 'v',
	mass_x0020per_x0020time_x0020per_x0020length = 'w',
	mass_x0020per_x0020volume_x0020per_x0020length = 'x',
	measured_x0020depth = 'y',
	mobility_x0020class = 'z',
	modulus_x0020of_x0020compression_x0020class = 123,
	molar_x0020concentration = 124,
	molar_x0020fraction = 125,
	molar_x0020heat_x0020capacity_x0020class = 126,
	molar_x0020volume_x0020class = 127,
	mole_x0020per_x0020area = 128,
	mole_x0020per_x0020time = 129,
	mole_x0020per_x0020time_x0020per_x0020area = 130,
	molecular_x0020weight = 131,
	moment_x0020of_x0020force_x0020class = 132,
	moment_x0020of_x0020inertia_x0020class = 133,
	moment_x0020of_x0020section_x0020class = 134,
	momentum_x0020class = 135,
	motor_x0020current = 136,
	motor_x0020current_x0020leakage = 137,
	motor_x0020speed = 138,
	motor_x0020temperature = 139,
	motor_x0020vibration = 140,
	motor_x0020voltage = 141,
	neutron_x0020API_x0020unit_x0020class = 142,
	nonDarcy_x0020flow_x0020coefficient_x0020class = 143,
	opening_x0020size = 144,
	operations_x0020per_x0020time = 145,
	parachor_x0020class = 146,
	per_x0020area = 147,
	per_x0020electric_x0020potential = 148,
	per_x0020force = 149,
	per_x0020length = 150,
	per_x0020mass = 151,
	per_x0020volume = 152,
	permeability_x0020length_x0020class = 153,
	permeability_x0020rock_x0020class = 154,
	permeance_x0020class = 155,
	permittivity_x0020class = 156,
	pH_x0020class = 157,
	plane_x0020angle_x0020class = 158,
	potential_x0020difference_x0020per_x0020power_x0020drop = 159,
	power_x0020class = 160,
	power_x0020per_x0020volume = 161,
	pressure = 162,
	pressure_x0020class = 163,
	pressure_x0020per_x0020time = 164,
	pressure_x0020squared_x0020class = 165,
	pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 166,
	pressure_x0020time_x0020per_x0020volume = 167,
	productivity_x0020index_x0020class = 168,
	pump_x0020count_x0020online = 169,
	pump_x0020status = 170,
	quantity = 171,
	quantity_x0020of_x0020light_x0020class = 172,
	radiance_x0020class = 173,
	radiant_x0020intensity_x0020class = 174,
	reciprocating_x0020speed = 175,
	rectifier_x0020structure_x0020potential = 176,
	reid_x0020vapor_x0020pressure = 177,
	relative_x0020opening_x0020size = 178,
	relative_x0020power_x0020class = 179,
	relative_x0020tank_x0020level = 180,
	relative_x0020time_x0020class = 181,
	relative_x0020valve_x0020opening = 182,
	reluctance_x0020class = 183,
	resistance_x0020class = 184,
	resistivity_x0020per_x0020length = 185,
	root_x0020property = 186,
	scheduled_x0020downtime = 187,
	second_x0020moment_x0020of_x0020area_x0020class = 188,
	shutdown_x0020order = 189,
	shutin_x0020pressure = 190,
	shutin_x0020temperature = 191,
	solid_x0020angle_x0020class = 192,
	specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029 = 193,
	specific_x0020energy_x0020class = 194,
	specific_x0020gravity = 195,
	specific_x0020heat_x0020capacity_x0020class = 196,
	specific_x0020productivity_x0020index_x0020class = 197,
	specific_x0020volume_x0020class = 198,
	sub_x0020surface_x0020safety_x0020valve_x0020status = 199,
	surface_x0020density_x0020class = 200,
	surface_x0020safety_x0020valve_x0020status = 201,
	tank_x0020fluid_x0020level = 202,
	tank_x0020product_x0020standard_x0020volume = 203,
	tank_x0020product_x0020volume = 204,
	temperature = 205,
	temperature_x0020per_x0020length = 206,
	temperature_x0020per_x0020time = 207,
	thermal_x0020conductance_x0020class = 208,
	thermal_x0020conductivity_x0020class = 209,
	thermal_x0020diffusivity_x0020class = 210,
	thermal_x0020insulance_x0020class = 211,
	thermal_x0020resistance_x0020class = 212,
	thermodynamic_x0020temperature_x0020class = 213,
	time_x0020class = 214,
	time_x0020per_x0020length = 215,
	time_x0020per_x0020volume = 216,
	true_x0020vapor_x0020pressure = 217,
	unit_x0020productivity_x0020index_x0020class = 218,
	unitless = 219,
	unknown = 220,
	valve_x0020opening = 221,
	valve_x0020status = 222,
	velocity_x0020class = 223,
	volume = 224,
	volume_x0020class = 225,
	volume_x0020concentration = 226,
	volume_x0020flow_x0020rate_x0020class = 227,
	volume_x0020length_x0020per_x0020time = 228,
	volume_x0020per_x0020area = 229,
	volume_x0020per_x0020length = 230,
	volume_x0020per_x0020time_x0020per_x0020area = 231,
	volume_x0020per_x0020time_x0020per_x0020length = 232,
	volume_x0020per_x0020time_x0020per_x0020time = 233,
	volume_x0020per_x0020time_x0020per_x0020volume = 234,
	volume_x0020per_x0020volume = 235,
	volume_x0020standard = 236,
	volumetric_x0020efficiency = 237,
	volumetric_x0020heat_x0020transfer_x0020coefficient = 238,
	volumetric_x0020thermal_x0020expansion_x0020class = 239,
	well_x0020operating_x0020status = 240,
	well_x0020operation_x0020type = 241,
	wobbe_x0020index = 242,
	work = 243,
	work_x0020class = 244
};
#endif

/* eml2_2ForGsoap.h:14964 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FiberMode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FiberMode (-1370)

/* prodml21:FiberMode */
enum class prodml21__FiberMode {
	multimode = 0,
	other = 1,
	singlemode = 2
};
#endif

/* eml2_2ForGsoap.h:14977 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowQualifier (-1371)

/* prodml21:FlowQualifier */
enum class prodml21__FlowQualifier {
	allocated = 0,
	budget = 1,
	constraint = 2,
	derived = 3,
	difference = 4,
	estimate = 5,
	forecast = 6,
	mass_x0020adjusted = 7,
	measured = 8,
	metered = 9,
	metered_x0020__x0020fiscal = 10,
	nominated = 11,
	potential = 12,
	processed = 13,
	quota = 14,
	recommended = 15,
	simulated = 16,
	target = 17,
	tariff_x0020basis = 18,
	value_x0020adjusted = 19
};
#endif

/* eml2_2ForGsoap.h:15007 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowSubQualifier (-1372)

/* prodml21:FlowSubQualifier */
enum class prodml21__FlowSubQualifier {
	decline_x0020curve = 0,
	difference = 1,
	fiscal = 2,
	fixed = 3,
	maximum = 4,
	minimum = 5,
	raw = 6,
	recalibrated = 7,
	standard = 8
};
#endif

/* eml2_2ForGsoap.h:15026 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyType (-1373)

/* prodml21:GeologyType */
enum class prodml21__GeologyType {
	aquifer = 0,
	reservoir = 1
};
#endif

/* eml2_2ForGsoap.h:15046 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneType (-1374)

/* prodml21:PhoneType */
enum class prodml21__PhoneType {
	fax = 0,
	mobile = 1,
	pager = 2,
	unknown = 3,
	voice = 4,
	voice_x002ffax = 5,
	voicemail = 6
};
#endif

/* eml2_2ForGsoap.h:15063 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnum (-1375)

/* prodml21:PlusComponentEnum */
enum class prodml21__PlusComponentEnum {
	c10_x002b = 0,
	c11_x002b = 1,
	c12_x002b = 2,
	c20_x002b = 3,
	c25_x002b = 4,
	c30_x002b = 5,
	c36_x002b = 6,
	c5_x002b = 7,
	c6_x002b = 8,
	c7_x002b = 9,
	c8_x002b = 10,
	c9_x002b = 11
};
#endif

/* eml2_2ForGsoap.h:15081 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredUom
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredUom (-1376)

/* prodml21:PressurePerFlowrateSquaredUom */
enum class prodml21__PressurePerFlowrateSquaredUom {
	bar_x002f_x00281000m3_x002fday_x00292 = 0,
	bar_x002f_x0028m3_x002fday_x00292 = 1,
	Pa_x002f_x00281000m3_x002fday_x00292 = 2,
	Pa_x002f_x0028m3_x002fday_x00292 = 3,
	psi_x002f_x00281000000ft3_x002fday_x00292 = 4,
	psi_x002f_x00281000ft3_x002fday_x00292 = 5,
	psi_x002f_x0028bbl_x002fday_x00292 = 6
};
#endif

/* eml2_2ForGsoap.h:15094 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateUom
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateUom (-1377)

/* prodml21:PressurePerFlowrateUom */
enum class prodml21__PressurePerFlowrateUom {
	bar_x002f_x00281000m3_x002fday_x0029 = 0,
	bar_x002f_x0028m3_x002fday_x0029 = 1,
	Pa_x002f_x00281000m3_x002fday_x0029 = 2,
	Pa_x002f_x0028m3_x002fday_x0029 = 3,
	psi_x002f_x00281000000ft3_x002fday_x0029 = 4,
	psi_x002f_x00281000ft3_x002fday_x0029 = 5,
	psi_x002f_x0028bbl_x002fday_x0029 = 6
};
#endif

/* eml2_2ForGsoap.h:15111 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPortType (-1378)

/* prodml21:ProductFlowPortType */
enum class prodml21__ProductFlowPortType {
	inlet = 0,
	outlet = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:15124 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKind (-1379)

/* prodml21:ProductFluidKind */
enum class prodml21__ProductFluidKind {
	condensate = 0,
	condensate_x0020__x0020gross = 1,
	condensate_x0020__x0020net = 2,
	crude_x0020__x0020stabilized = 3,
	gas_x0020__x0020component_x0020in_x0020oil = 4,
	gas_x0020__x0020dry = 5,
	gas_x0020__x0020rich = 6,
	gas_x0020__x0020wet = 7,
	liquefied_x0020natural_x0020gas = 8,
	liquefied_x0020petroleum_x0020gas = 9,
	liquid = 10,
	naphtha = 11,
	natural_x0020gas_x0020liquid = 12,
	NGL_x0020__x0020component_x0020in_x0020gas = 13,
	oil_x0020__x0020component_x0020in_x0020water = 14,
	oil_x0020__x0020gross = 15,
	oil_x0020__x0020net = 16,
	oil_x0020and_x0020gas = 17,
	petroleum_x0020gas_x0020liquid = 18,
	vapor = 19,
	sand = 20,
	water_x0020__x0020discharge = 21,
	water_x0020__x0020processed = 22
};
#endif

/* eml2_2ForGsoap.h:15157 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnum (-1380)

/* prodml21:PseudoComponentEnum */
enum class prodml21__PseudoComponentEnum {
	c10 = 0,
	c11 = 1,
	c12 = 2,
	c13 = 3,
	c14 = 4,
	c15 = 5,
	c16 = 6,
	c17 = 7,
	c18 = 8,
	c19 = 9,
	c20 = 10,
	c21 = 11,
	c22 = 12,
	c23 = 13,
	c24 = 14,
	c25 = 15,
	c26 = 16,
	c27 = 17,
	c28 = 18,
	c29 = 19,
	c2_c4_x002bn2 = 20,
	c30 = 21,
	c31 = 22,
	c32 = 23,
	c33 = 24,
	c34 = 25,
	c35 = 26,
	c4 = 27,
	c5 = 28,
	c6 = 29,
	c7 = 30,
	c8 = 31,
	c9 = 32
};
#endif

/* eml2_2ForGsoap.h:15204 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnum (-1381)

/* prodml21:PureComponentEnum */
enum class prodml21__PureComponentEnum {
	_1_2_4_trimethylbenzene = 0,
	_2_dimethylbutane = 1,
	_3_dimethylbutane = 2,
	ar = 3,
	c1 = 4,
	c2 = 5,
	c3 = 6,
	co2 = 7,
	h2 = 8,
	h2o = 9,
	h2s = 10,
	he = 11,
	hg = 12,
	i_c4 = 13,
	i_c5 = 14,
	n2 = 15,
	n_c10 = 16,
	n_c4 = 17,
	n_c5 = 18,
	n_c6 = 19,
	n_c7 = 20,
	n_c8 = 21,
	n_c9 = 22,
	neo_c5 = 23,
	benzene = 24,
	_2_methylpentane = 25,
	_3_methylpentane = 26,
	_2_methylhexane = 27,
	_3_methylhexane = 28,
	_2_methylheptane = 29,
	_3_methylheptane = 30,
	cyclohexane = 31,
	ethylbenzene = 32,
	ethylcyclohexane = 33,
	methylcyclohexane = 34,
	methylcyclopentane = 35,
	toluene = 36,
	m_xylene = 37,
	o_xylene = 38,
	p_xylene = 39
};
#endif

/* eml2_2ForGsoap.h:15258 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKind (-1382)

/* prodml21:ReportingDurationKind */
enum class prodml21__ReportingDurationKind {
	day = 0,
	life_x0020to_x0020date = 1,
	month = 2,
	month_x0020to_x0020date = 3,
	total_x0020cumulative = 4,
	week = 5,
	year = 6,
	year_x0020to_x0020date = 7
};
#endif

/* eml2_2ForGsoap.h:15276 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityKind (-1383)

/* prodml21:ReportingEntityKind */
enum class prodml21__ReportingEntityKind {
	business_x0020unit = 0,
	fpso = 1,
	well_x0020completion = 2,
	wellbore_x0020completion = 3,
	commercial_x0020entity = 4,
	company = 5,
	contact_x0020interval = 6,
	country = 7,
	county = 8,
	facility = 9,
	field = 10,
	field_x0020__x0020part = 11,
	flow_x0020meter = 12,
	formation = 13,
	gas_x0020plant = 14,
	lease = 15,
	license = 16,
	pipeline = 17,
	platform = 18,
	production_x0020processing_x0020facility = 19,
	reservoir = 20,
	rock_fluid_x0020unit_x0020feature = 21,
	state = 22,
	tank = 23,
	terminal = 24,
	well = 25,
	well_x0020group = 26,
	wellbore = 27,
	oil_x0020tanker = 28,
	tanker_x0020truck = 29
};
#endif

/* eml2_2ForGsoap.h:15436 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacility (-1384)

/* prodml21:ReportingFacility */
enum class prodml21__ReportingFacility {
	block_x0020valve = 0,
	bottomhole = 1,
	casing = 2,
	choke = 3,
	cluster = 4,
	commercial_x0020entity = 5,
	company = 6,
	completion = 7,
	compressor = 8,
	controller = 9,
	controller_x0020_x002d__x0020lift = 10,
	country = 11,
	county = 12,
	downhole_x0020monitoring_x0020system = 13,
	electric_x0020submersible_x0020pump = 14,
	field = 15,
	field_x0020__x0020area = 16,
	field_x0020__x0020group = 17,
	field_x0020__x0020part = 18,
	flow_x0020meter = 19,
	flowline = 20,
	formation = 21,
	gas_x0020lift_x0020valve_x0020mandrel = 22,
	generator = 23,
	installation = 24,
	lease = 25,
	license = 26,
	manifold = 27,
	organizational_x0020unit = 28,
	packer = 29,
	perforated_x0020interval = 30,
	pipeline = 31,
	plant_x0020__x0020processing = 32,
	platform = 33,
	pressure_x0020meter = 34,
	processing_x0020facility = 35,
	production_x0020tubing = 36,
	pump = 37,
	rectifier = 38,
	regulating_x0020valve = 39,
	remote_x0020terminal_x0020unit = 40,
	reservoir = 41,
	separator = 42,
	sleeve_x0020valve = 43,
	state = 44,
	storage = 45,
	tank = 46,
	temperature_x0020meter = 47,
	template_ = 48,
	terminal = 49,
	trap = 50,
	trunkline = 51,
	tubing_x0020head = 52,
	turbine = 53,
	unknown = 54,
	well = 55,
	well_x0020group = 56,
	wellbore = 57,
	wellhead = 58,
	zone = 59
};
#endif

/* eml2_2ForGsoap.h:15746 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFlow (-1385)

/* prodml21:ReportingFlow */
enum class prodml21__ReportingFlow {
	consume = 0,
	consume_x0020__x0020black_x0020start = 1,
	consume_x0020__x0020compressor = 2,
	consume_x0020__x0020emitted = 3,
	consume_x0020__x0020flare = 4,
	consume_x0020__x0020fuel = 5,
	consume_x0020__x0020HP_x0020flare = 6,
	consume_x0020__x0020LP_x0020flare = 7,
	consume_x0020__x0020non_x0020compressor = 8,
	consume_x0020__x0020venting = 9,
	disposal = 10,
	export_ = 11,
	export_x0020__x0020nominated = 12,
	export_x0020__x0020requested = 13,
	export_x0020__x0020shortfall = 14,
	gas_x0020lift = 15,
	hydrocarbon_x0020accounting = 16,
	import = 17,
	injection = 18,
	inventory = 19,
	overboard = 20,
	production = 21,
	sale = 22,
	storage = 23,
	unknown = 24
};
#endif

/* eml2_2ForGsoap.h:15881 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingProduct (-1386)

/* prodml21:ReportingProduct */
enum class prodml21__ReportingProduct {
	aqueous = 0,
	c10 = 1,
	c10_x002d = 2,
	c10_x002b = 3,
	c2_x002d = 4,
	c2_x002b = 5,
	c3_x002d = 6,
	c3_x002b = 7,
	c4_x002d = 8,
	c4_x002b = 9,
	c5_x002d = 10,
	c5_x002b = 11,
	c6_x002d = 12,
	c6_x002b = 13,
	c7 = 14,
	c7_x002d = 15,
	c7_x002b = 16,
	c8 = 17,
	c8_x002d = 18,
	c8_x002b = 19,
	c9 = 20,
	c9_x002d = 21,
	c9_x002b = 22,
	carbon_x0020dioxide_x0020gas = 23,
	carbon_x0020monoxide_x0020gas = 24,
	chemical = 25,
	condensate = 26,
	condensate_x0020__x0020gross = 27,
	condensate_x0020__x0020net = 28,
	crude_x0020__x0020stabilized = 29,
	cuttings = 30,
	diesel = 31,
	diethylene_x0020glycol = 32,
	dioxygen = 33,
	electric_x0020power = 34,
	ethane = 35,
	ethane_x0020__x0020component = 36,
	gas = 37,
	gas_x0020__x0020component_x0020in_x0020oil = 38,
	gas_x0020__x0020dry = 39,
	gas_x0020__x0020rich = 40,
	gas_x0020__x0020wet = 41,
	helium_x0020gas = 42,
	heptane = 43,
	hydraulic_x0020control_x0020fluid = 44,
	hydrogen_x0020gas = 45,
	hydrogen_x0020sulfide = 46,
	i_butane_x0020__x0020component = 47,
	isobutane = 48,
	isopentane = 49,
	liquefied_x0020natural_x0020gas = 50,
	liquefied_x0020petroleum_x0020gas = 51,
	liquid = 52,
	methane = 53,
	methane_x0020__x0020component = 54,
	methanol = 55,
	mixed_x0020butane = 56,
	monoethylene_x0020glycol = 57,
	naphtha = 58,
	natural_x0020gas_x0020liquid = 59,
	n_butane_x0020__x0020component = 60,
	neopentane = 61,
	NGL_x0020__x0020component_x0020in_x0020gas = 62,
	nitrogen_x0020gas = 63,
	nitrogen_x0020oxide_x0020gas = 64,
	normal_x0020butane = 'A',
	normal_x0020pentane = 'B',
	oil = 'C',
	oil_x0020__x0020component_x0020in_x0020water = 'D',
	oil_x0020__x0020gross = 'E',
	oil_x0020__x0020net = 'F',
	oil_x0020and_x0020gas = 'G',
	oleic = 'H',
	pentane_x0020__x0020component = 'I',
	petroleum_x0020gas_x0020liquid = 'J',
	propane = 'K',
	propane_x0020__x0020component = 'L',
	salt = 'M',
	sand_x0020__x0020component = 'N',
	triethylene_x0020glycol = 'O',
	unknown = 'P',
	vapor = 'Q',
	water = 'R',
	water_x0020__x0020discharge = 'S',
	water_x0020__x0020processed = 'T'
};
#endif

/* eml2_2ForGsoap.h:16316 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirFluidKind (-1387)

/* prodml21:ReservoirFluidKind */
enum class prodml21__ReservoirFluidKind {
	black_x0020oil = 0,
	critical_x0020or_x0020near_x0020critical = 1,
	dry_x0020gas = 2,
	heavy_x0020oil = 3,
	wet_x0020gas_x0020or_x0020condensate = 4,
	volatile_x0020oil = 5,
	unknown = 6
};
#endif

/* eml2_2ForGsoap.h:16361 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SafetyType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SafetyType (-1388)

/* prodml21:SafetyType */
enum class prodml21__SafetyType {
	drill_x0020or_x0020exercise = 0,
	fire = 1,
	first_x0020aid = 2,
	hazard_x0020report_x0020card = 3,
	job_x0020observation = 4,
	lost_x0020time_x0020accident = 5,
	lost_x0020time_x0020incident = 6,
	miscellaneous = 7,
	near_x0020miss = 8,
	permit_x0020with_x0020SJA = 9,
	released_x0020to_x0020air = 10,
	released_x0020to_x0020water = 11,
	restricted_x0020work = 12,
	safety_x0020meeting = 13,
	sent_x0020ashore = 14,
	severe_x0020accident = 15,
	sick_x0020on_x0020board = 16,
	spill_x0020or_x0020leak = 17,
	total_x0020permits = 18,
	traffic_x0020accident = 19,
	year_to_date_x0020incidents = 20
};
#endif

/* eml2_2ForGsoap.h:16476 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPointKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPointKind (-1389)

/* prodml21:SaturationPointKind */
enum class prodml21__SaturationPointKind {
	bubble_x0020point = 0,
	dew_x0020point = 1,
	retrograde_x0020dew_x0020point = 2,
	critical_x0020point = 3
};
#endif

/* eml2_2ForGsoap.h:16506 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKind (-1390)

/* prodml21:ServiceFluidKind */
enum class prodml21__ServiceFluidKind {
	alkaline_x0020solutions = 0,
	biocide = 1,
	carbon_x0020dioxide = 2,
	carbon_x0020monoxide = 3,
	corrosion_x0020inhibitor = 4,
	demulsifier = 5,
	diesel = 6,
	diethylene_x0020glycol = 7,
	dispersant = 8,
	drag_x0020reducing_x0020agent = 9,
	emulsifier = 10,
	flocculant = 11,
	hydraulic_x0020control_x0020fluid = 12,
	isopropanol = 13,
	lubricant = 14,
	methanol = 15,
	monoethylene_x0020glycol = 16,
	oil = 17,
	other_x0020chemical = 18,
	other_x0020hydrate_x0020inhibitor = 19,
	polymer = 20,
	scale_x0020inhibitor = 21,
	solvent = 22,
	stabilizing_x0020agent = 23,
	surfactant = 24,
	thinner = 25,
	triethylene_x0020glycol = 26
};
#endif

/* eml2_2ForGsoap.h:16651 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesKeyword
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesKeyword (-1391)

/* prodml21:TimeSeriesKeyword */
enum class prodml21__TimeSeriesKeyword {
	asset_x0020identifier = 0,
	flow = 1,
	product = 2,
	qualifier = 3,
	subqualifier = 4,
	unknown = 5
};
#endif

/* eml2_2ForGsoap.h:16691 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ValueStatus
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ValueStatus (-1392)

/* prodml21:ValueStatus */
enum class prodml21__ValueStatus {
	access_x0020denied = 0,
	bad = 1,
	bad_x0020calibration = 2,
	calculation_x0020failure = 3,
	comm_x0020failure = 4,
	device_x0020failure = 5,
	frozen = 6,
	not_x0020available = 7,
	overflow = 8,
	questionable = 9,
	range_x0020limit = 10,
	sensor_x0020failure = 11,
	substituted = 12,
	timeout = 13
};
#endif

/* eml2_2ForGsoap.h:16771 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellDirection (-1393)

/* prodml21:WellDirection */
enum class prodml21__WellDirection {
	huff_n_puff = 0,
	injector = 1,
	producer = 2,
	uncertain = 3
};
#endif

/* eml2_2ForGsoap.h:16801 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellFluid (-1394)

/* prodml21:WellFluid */
enum class prodml21__WellFluid {
	air = 0,
	condensate = 1,
	dry = 2,
	gas = 3,
	gas_water = 4,
	non_x0020HC_x0020gas = 5,
	non_x0020HC_x0020gas_x0020_x002d__x0020CO2 = 6,
	oil = 7,
	oil_gas = 8,
	oil_water = 9,
	steam = 10,
	water = 11,
	water_x0020_x002d__x0020brine = 12,
	water_x0020_x002d__x0020fresh_x0020water = 13
};
#endif

/* eml2_2ForGsoap.h:16881 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceDestinationType (-1395)

/* prodml21:BalanceDestinationType */
enum class prodml21__BalanceDestinationType {
	harbor = 0,
	terminal = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:16906 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceEventKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceEventKind (-1396)

/* prodml21:BalanceEventKind */
enum class prodml21__BalanceEventKind {
	bill_x0020of_x0020lading = 0,
	transaction_x0020date = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:16931 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceFlowPart (-1397)

/* prodml21:BalanceFlowPart */
enum class prodml21__BalanceFlowPart {
	adjusted_x0020closing = 0,
	closing_x0020balance = 1,
	closing_x0020storage_x0020inventory = 2,
	completed_x0020lifting = 3,
	gain_x002floss = 4,
	input_x0020to_x0020storage = 5,
	lifted = 6,
	lifting_x0020entitlement = 7,
	lifting_x0020entitlement_x0020remaining = 8,
	linepack = 9,
	opening_x0020balance = 10,
	opflex = 11,
	partial_x0020lifting = 12,
	pipeline_x0020lifting = 13,
	production_x0020__x0020mass_x0020adjustment = 14,
	production_x0020_x002d__x0020value_x0020adjustment = 15,
	production_x0020imbalance = 16,
	swap = 17,
	tanker_x0020lifting = 18,
	transaction = 19,
	transfer = 20,
	unknown = 21
};
#endif

/* eml2_2ForGsoap.h:17051 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalculationMethod (-1398)

/* prodml21:CalculationMethod */
enum class prodml21__CalculationMethod {
	none = 0,
	step_x0020wise_x0020constant = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:17076 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentBasis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentBasis (-1399)

/* prodml21:FluidComponentBasis */
enum class prodml21__FluidComponentBasis {
	_1 = 1,
	_2 = 2,
	_3 = 3,
	_1_dimethylcyclopentane = 4,
	_2_x0020dimethylbenzene = 5,
	_2_x0020dimethylpropane = 6,
	_2_dimethylbutane = 7,
	_2_dimethylcyclopentane = 8,
	_2_dimethylhexane = 9,
	_2_dimethylpentane = 10,
	_2_methylbutane = 11,
	_2_methylhexane = 12,
	_2_methylpentane = 13,
	_2_methylpropane = 14,
	_3_x0020dimethylbenzene = 15,
	_3_dimethylbutane = 16,
	_3_dimethylcyclopentane = 17,
	_3_dimethylpentane = 18,
	_3_ethylpentane = 19,
	_3_methylhexane = 20,
	_3_methylpentane = 21,
	_3_trimethylbutane = 22,
	_3_trimethylpentane = 23,
	_4_dimethylbenzene = 24,
	_4_dimethylhexane = 25,
	_4_Dimethylpentane = 26,
	_4_trimethylbenzene = 27,
	_5_dimethylhexane = 28,
	argon = 29,
	benzene = 30,
	butane = 31,
	c11_x0020fraction = 32,
	c12_x0020fraction = 33,
	c13_x0020fraction = 34,
	c14_x0020fraction = 35,
	c15_x0020fraction = 36,
	c16_x0020fraction = 37,
	c17_x0020fraction = 38,
	c18_x0020fraction = 39,
	c19_x0020fraction = 40,
	c20_x0020fraction = 41,
	c21_x0020fraction = 42,
	c22_x0020fraction = 43,
	c23_x0020fraction = 44,
	c24_x0020fraction = 45,
	c25_x0020fraction = 46,
	c26_x0020fraction = 47,
	c27_x0020fraction = 48,
	c28_x0020fraction = 49,
	c29_x0020fraction = 50,
	c30_x0020fraction = 51,
	c31_x0020fraction = 52,
	c32_x0020fraction = 53,
	c33_x0020fraction = 54,
	c34_x0020fraction = 55,
	c35_x0020fraction = 56,
	c36_x0020fraction = 57,
	c37_x0020fraction = 58,
	c38_x0020fraction = 59,
	c39_x0020fraction = 60,
	c40_x0020fraction = 61,
	c41_x0020fraction = 62,
	c42_x0020fraction = 63,
	c43_x0020fraction = 64,
	c44_x0020fraction = 'A',
	c45_x0020fraction = 'B',
	c46_x0020fraction = 'C',
	c47_x0020fraction = 'D',
	c48_x0020fraction = 'E',
	c49_x0020fraction = 'F',
	carbon_x0020dioxide = 'G',
	cis_1 = 'H',
	cyclohexane = 'I',
	cyclopentane = 'J',
	decanes = 'K',
	ethane = 'L',
	ethylbenzene = 'M',
	ethylcyclopentane = 'N',
	heptanes = 'O',
	hexane = 'P',
	hexanes = 'Q',
	hydrogen = 'R',
	hydrogen_x0020sulfide = 'S',
	methane = 'T',
	methylbenzene = 'U',
	methylcyclohexane = 'V',
	methylcyclopentane = 'W',
	nitrogen = 'X',
	nonanes = 'Y',
	octanes = 'Z',
	oxygen = 91,
	pentane = 92,
	propane = 93,
	trans_1 = 94,
	unknown = 95,
	water = 96
};
#endif

/* eml2_2ForGsoap.h:17566 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellOperationMethod (-1400)

/* prodml21:WellOperationMethod */
enum class prodml21__WellOperationMethod {
	continuous_x0020gas_x0020lift = 0,
	electric_x0020submersible_x0020pump_x0020lift = 1,
	foam_x0020lift = 2,
	hydraulic_x0020pump_x0020lift = 3,
	intermittent_x0020gas_x0020lift = 4,
	jet_x0020pump_x0020lift = 5,
	natural_x0020flow = 6,
	plunger_x0020gas_x0020lift = 7,
	progressive_x0020cavity_x0020pump_x0020lift = 8,
	sucker_x0020rod_x0020pump_x0020lift = 9,
	unknown = 10
};
#endif

/* eml2_2ForGsoap.h:17631 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhasePresent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhasePresent (-1401)

/* prodml21:PhasePresent */
enum class prodml21__PhasePresent {
	gas_x0020and_x0020oil_x0020and_x0020water = 0,
	water = 1,
	gas = 2,
	oil = 3,
	oil_x0020and_x0020gas = 4,
	oil_x0020and_x0020water = 5,
	gas_x0020and_x0020water = 6
};
#endif

/* eml2_2ForGsoap.h:17676 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirLifeCycleState
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirLifeCycleState (-1402)

/* prodml21:ReservoirLifeCycleState */
enum class prodml21__ReservoirLifeCycleState {
	abandoned = 0,
	primary_x0020production = 1,
	prospect = 2,
	tertiary_x0020production = 3,
	undeveloped = 4,
	secondary_x0020recovery = 5
};
#endif

/* eml2_2ForGsoap.h:17688 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityKind (-1403)

/* prodml21:CompressibilityKind */
enum class prodml21__CompressibilityKind {
	average = 0,
	point = 1
};
#endif

/* eml2_2ForGsoap.h:17700 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisStepCondition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisStepCondition (-1404)

/* prodml21:FluidAnalysisStepCondition */
enum class prodml21__FluidAnalysisStepCondition {
	current_x0020reservoir_x0020conditions = 0,
	initial_x0020reservoir_x0020conditions = 1,
	initial_x0020saturation_x0020conditions = 2,
	stock_x0020tank_x0020conditions = 3
};
#endif

/* eml2_2ForGsoap.h:17730 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidContaminant
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidContaminant (-1405)

/* prodml21:FluidContaminant */
enum class prodml21__FluidContaminant {
	cement_x0020fluids = 0,
	completion_x0020fluid = 1,
	drilling_x0020mud = 2,
	extraneous_x0020gas = 3,
	extraneous_x0020oil = 4,
	extraneous_x0020water = 5,
	formation_x0020water = 6,
	treatment_x0020chemicals = 7,
	solid = 8,
	unknown = 9
};
#endif

/* eml2_2ForGsoap.h:17790 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleQuality
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleQuality (-1406)

/* prodml21:SampleQuality */
enum class prodml21__SampleQuality {
	invalid = 0,
	unknown = 1,
	valid = 2
};
#endif

/* eml2_2ForGsoap.h:17815 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ThermodynamicPhase
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ThermodynamicPhase (-1407)

/* prodml21:ThermodynamicPhase */
enum class prodml21__ThermodynamicPhase {
	aqueous = 0,
	oleic = 1,
	vapor = 2,
	total_x0020hydrocarbon = 3
};
#endif

/* eml2_2ForGsoap.h:17845 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeReferenceKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeReferenceKind (-1408)

/* prodml21:VolumeReferenceKind */
enum class prodml21__VolumeReferenceKind {
	initial_x0020reservoir = 0,
	saturation_calculated = 1,
	saturation_measured = 2,
	separator_x0020stage_x00201 = 3,
	separator_x0020stage_x002010 = 4,
	separator_x0020stage_x00202 = 5,
	separator_x0020stage_x00203 = 6,
	separator_x0020stage_x00204 = 7,
	separator_x0020stage_x00205 = 8,
	separator_x0020stage_x00206 = 9,
	separator_x0020stage_x00207 = 10,
	separator_x0020stage_x00208 = 11,
	separator_x0020stage_x00209 = 12,
	stock_x0020tank = 13,
	unknown = 14
};
#endif

/* eml2_2ForGsoap.h:17930 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleKind (-1409)

/* prodml21:FluidSampleKind */
enum class prodml21__FluidSampleKind {
	synthetic = 0,
	separator_x0020water = 1,
	separator_x0020oil = 2,
	separator_x0020gas = 3,
	downhole_x0020cased = 4,
	downhole_x0020open = 5,
	recombined = 6,
	wellhead = 7,
	commingled = 8
};
#endif

/* eml2_2ForGsoap.h:17985 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleAction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleAction (-1410)

/* prodml21:SampleAction */
enum class prodml21__SampleAction {
	custodyTransfer = 0,
	destroyed = 1,
	sampleTransfer = 2,
	stored = 3,
	subSample_x0020Dead = 4,
	subSample_x0020Live = 5
};
#endif

/* eml2_2ForGsoap.h:18025 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftEventKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftEventKind (-1411)

/* prodml21:WftEventKind */
enum class prodml21__WftEventKind {
	tool_x0020retract = 0,
	tool_x0020set = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18050 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftFlowingIntervalKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftFlowingIntervalKind (-1412)

/* prodml21:WftFlowingIntervalKind */
enum class prodml21__WftFlowingIntervalKind {
	packed_x0020interval = 0,
	probe = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18075 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftStationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftStationKind (-1413)

/* prodml21:WftStationKind */
enum class prodml21__WftStationKind {
	conventional = 0,
	observation = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18100 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestDataRole
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestDataRole (-1414)

/* prodml21:WftTestDataRole */
enum class prodml21__WftTestDataRole {
	flow_x0020history = 0,
	pressure_x0020stream = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18125 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestKind (-1415)

/* prodml21:WftTestKind */
enum class prodml21__WftTestKind {
	buildup = 0,
	drawdown = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18150 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResultKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResultKind (-1416)

/* prodml21:WftTestResultKind */
enum class prodml21__WftTestResultKind {
	buildup_x0020result = 0,
	drawdown_x0020result = 1,
	unknown = 2
};
#endif

/* eml2_2ForGsoap.h:18175 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredKind (-1417)

/* prodml21:DeferredKind */
enum class prodml21__DeferredKind {
	planned = 0,
	unplanned = 1
};
#endif

/* eml2_2ForGsoap.h:18187 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKind (-1418)

/* prodml21:DispositionKind */
enum class prodml21__DispositionKind {
	buyback = 0,
	flared = 1,
	sold = 2,
	used_x0020on_site = 3,
	fuel = 4,
	vented = 5,
	disposal = 6,
	gas_x0020lift = 7,
	lost_x0020or_x0020stolen = 8,
	other = 9
};
#endif

/* eml2_2ForGsoap.h:18247 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethod (-1419)

/* prodml21:EstimationMethod */
enum class prodml21__EstimationMethod {
	analytics_x0020model = 0,
	decline_x0020curve = 1,
	expert_x0020recommendation = 2,
	flowing_x0020material_x0020balance = 3,
	from_x0020last_x0020allocated_x0020volume = 4,
	numerical_x0020reservoir_x0020simulation = 5,
	production_x0020profile = 6,
	rate_x0020transient_x0020analysis = 7,
	ratio_x0020analysis = 8,
	reservoir_x0020model = 9,
	well_x0020model = 10
};
#endif

/* eml2_2ForGsoap.h:18312 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethod (-1420)

/* prodml21:QuantityMethod */
enum class prodml21__QuantityMethod {
	allocated = 0,
	allowed = 1,
	estimated = 2,
	target = 3,
	measured = 4,
	budget = 5,
	constraint = 6,
	forecast = 7
};
#endif

/* eml2_2ForGsoap.h:18362 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransferKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransferKind (-1421)

/* prodml21:TransferKind */
enum class prodml21__TransferKind {
	input = 0,
	output = 1
};
#endif

/* eml2_2ForGsoap.h:18382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioning
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioning (-1422)

/* prodml21:DataConditioning */
enum class prodml21__DataConditioning {
	data_x0020outliers_x0020removed = 0,
	data_x0020reduced = 1,
	data_x0020smoothed = 2,
	data_x0020time_x0020shifted = 3,
	tide_x0020corrected = 4,
	trend_x0020removal = 5,
	data_x0020value_x0020shifted = 6,
	flow_x0020to_x0020volume = 7,
	fluid_x0020level_x0020to_x0020pressure = 8,
	fluid_x0020level_x0020to_x0020volume = 9,
	gauge_x0020to_x0020datum_x0020pressure = 10,
	pressure_x0020to_x0020flow = 11,
	volume_x0020to_x0020flow = 12,
	data_x0020difference = 13,
	data_x0020channel_x0020spliced = 14,
	data_x0020channels_x0020averaged = 15,
	rate_x0020reallocation = 16,
	total_x0020rate_x0020calculation_x0020from_x0020phase_x0020rates = 17
};
#endif

/* eml2_2ForGsoap.h:18410 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseMeasuredKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseMeasuredKind (-1423)

/* prodml21:FluidPhaseMeasuredKind */
enum class prodml21__FluidPhaseMeasuredKind {
	_3_x0020phase = 0,
	gas = 1,
	oil = 2,
	oil_x002bwater = 3,
	water = 4
};
#endif

/* eml2_2ForGsoap.h:18425 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodKind (-1424)

/* prodml21:TestPeriodKind */
enum class prodml21__TestPeriodKind {
	buildup = 0,
	constant_x0020rate_x0020injection = 1,
	fall_off = 2,
	post_test_x0020pull_x0020out_x0020of_x0020hole = 3,
	pre_test_x0020run_x0020in_x0020hole = 4,
	production_x0020well_x0020test = 5,
	variable_x0020rate_x0020injection = 6,
	constant_x0020rate_x0020drawdown = 7,
	shut_in_x0020observation = 8,
	variable_x0020rate_x0020drawdown = 9
};
#endif

/* eml2_2ForGsoap.h:18445 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesPointRepresentation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesPointRepresentation (-1425)

/* prodml21:TimeSeriesPointRepresentation */
enum class prodml21__TimeSeriesPointRepresentation {
	point_x0020by_x0020point = 0,
	stepwise_x0020value_x0020at_x0020end_x0020of_x0020period = 1
};
#endif

/* eml2_2ForGsoap.h:18453 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseKind (-1426)

/* prodml21:FluidPhaseKind */
enum class prodml21__FluidPhaseKind {
	multiphase_x0020gas_x002bwater = 0,
	multiphase_x0020oil_x002bgas = 1,
	multiphase_x0020oil_x002bwater = 2,
	multiphase_x0020oil_x002bwater_x002bgas = 3,
	single_x0020phase_x0020gas = 4,
	single_x0020phase_x0020oil = 5,
	single_x0020phase_x0020water = 6
};
#endif

/* eml2_2ForGsoap.h:18470 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogPressureTransform
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogPressureTransform (-1427)

/* prodml21:LogLogPressureTransform */
enum class prodml21__LogLogPressureTransform {
	delta_x0020pressure_x0020function = 0,
	delta_x0020pressure_x0020function_x002frate = 1,
	integral_x0020rate_x0020normal_x0020delta_x0020p_x0020funct_x002ftime = 2,
	rate_x0020normalized_x0020delta_x0020p_x0020function_x002frate = 3,
	other = 4
};
#endif

/* eml2_2ForGsoap.h:18501 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogTimeTransform
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogTimeTransform (-1428)

/* prodml21:LogLogTimeTransform */
enum class prodml21__LogLogTimeTransform {
	agarwal_x0020time = 0,
	delta_x0020time = 1,
	equivalent_x0020time_x0020cumulative_x002fflowrate = 2,
	superposition_x0020time = 3
};
#endif

/* eml2_2ForGsoap.h:18515 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureNonLinearTransformKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureNonLinearTransformKind (-1429)

/* prodml21:PressureNonLinearTransformKind */
enum class prodml21__PressureNonLinearTransformKind {
	pressure_x0020_x0028un_transformed_x0029 = 0,
	pressure_x0020squared = 1,
	gas_x0020pseudo_pressure = 2,
	normalised_x0020gas_x0020pseudo_pressure = 3,
	normalised_x0020multi_phase_x0020pseudo_pressure = 4
};
#endif

/* eml2_2ForGsoap.h:18530 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoPressureEffectApplied
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoPressureEffectApplied (-1430)

/* prodml21:PseudoPressureEffectApplied */
enum class prodml21__PseudoPressureEffectApplied {
	gas_x0020properties_x0020with_x0020pressure = 0,
	multiphase_x0020flow_x0020properties_x0020with_x0020pressure = 1,
	other = 2,
	variable_x0020desorption_x0020with_x0020pressure = 3,
	variable_x0020poroperm_x0020with_x0020pressure = 4
};
#endif

/* eml2_2ForGsoap.h:18545 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeNonLinearTransformKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeNonLinearTransformKind (-1431)

/* prodml21:TimeNonLinearTransformKind */
enum class prodml21__TimeNonLinearTransformKind {
	material_x0020balance_x0020pseudo_time = 0,
	pseudo_time_x0020transform = 1,
	time_x0020_x0028un_transformed_x0029 = 2
};
#endif

/* eml2_2ForGsoap.h:18554 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary1Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary1Type (-1432)

/* prodml21:Boundary1Type */
enum class prodml21__Boundary1Type {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18562 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary2Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary2Type (-1433)

/* prodml21:Boundary2Type */
enum class prodml21__Boundary2Type {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18570 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary3Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary3Type (-1434)

/* prodml21:Boundary3Type */
enum class prodml21__Boundary3Type {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18578 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary4Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary4Type (-1435)

/* prodml21:Boundary4Type */
enum class prodml21__Boundary4Type {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18586 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureModelType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureModelType (-1436)

/* prodml21:FractureModelType */
enum class prodml21__FractureModelType {
	compressible_x0020finite_x0020conductivity = 0,
	finite_x0020conductivity = 1,
	infinite_x0020conductivity = 2,
	uniform_x0020flux = 3
};
#endif

/* eml2_2ForGsoap.h:18596 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LowerBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LowerBoundaryType (-1437)

/* prodml21:LowerBoundaryType */
enum class prodml21__LowerBoundaryType {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18608 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ParameterDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ParameterDirection (-1438)

/* prodml21:ParameterDirection */
enum class prodml21__ParameterDirection {
	input = 0,
	output = 1
};
#endif

/* eml2_2ForGsoap.h:18616 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__UpperBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__UpperBoundaryType (-1439)

/* prodml21:UpperBoundaryType */
enum class prodml21__UpperBoundaryType {
	constant_x0020pressure = 0,
	no_flow = 1
};
#endif

/* eml2_2ForGsoap.h:18624 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageMechanismType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageMechanismType (-1440)

/* prodml21:WellboreStorageMechanismType */
enum class prodml21__WellboreStorageMechanismType {
	closed_x0020chamber = 0,
	full_x0020well = 1,
	rising_x0020level = 2
};
#endif

/* eml2_2ForGsoap.h:18641 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Facet
#define SOAP_TYPE_gsoap_eml2_2_eml22__Facet (-1441)

/* eml22:Facet */
enum class eml22__Facet {
	I = 'I',
	J = 'J',
	K = 'K',
	X = 'X',
	Y = 'Y',
	Z = 'Z',
	I_x002b = 91,
	J_x002b = 92,
	K_x002b = 93,
	X_x002b = 94,
	Y_x002b = 95,
	Z_x002b = 96,
	I_x002d = 'a',
	J_x002d = 'b',
	K_x002d = 'c',
	X_x002d = 'd',
	Y_x002d = 'e',
	Z_x002d = 'f',
	net = 'g',
	gross = 'h',
	plus = 'i',
	minus = 'j',
	average = 'k',
	maximum = 'l',
	minimum = 'm',
	maximum_x0020threshold = 'n',
	minimum_x0020threshold = 'o',
	surface_x0020condition = 'p',
	reservoir_x0020condition = 'q',
	oil = 'r',
	water = 's',
	gas = 't',
	condensate = 'u',
	cumulative = 'v'
};
#endif

/* eml2_2ForGsoap.h:18813 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FacetKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__FacetKind (-1442)

/* eml22:FacetKind */
enum class eml22__FacetKind {
	conditions = 0,
	side = 1,
	direction = 2,
	netgross = 3,
	qualifier = 4,
	statistics = 5,
	what = 6
};
#endif

/* eml2_2ForGsoap.h:18858 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ChannelStatusKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ChannelStatusKind (-1443)

/* eml22:ChannelStatusKind */
enum class eml22__ChannelStatusKind {
	active = 0,
	closed = 1,
	inactive = 2
};
#endif

/* eml2_2ForGsoap.h:18883 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExistenceKind (-1444)

/* eml22:ExistenceKind */
enum class eml22__ExistenceKind {
	actual = 0,
	planned = 1,
	simulated = 2
};
#endif

/* eml2_2ForGsoap.h:18908 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeochronologicalRank (-1445)

/* eml22:GeochronologicalRank */
enum class eml22__GeochronologicalRank {
	eon = 0,
	era = 1,
	period = 2,
	epoch = 3,
	age = 4,
	chron = 5
};
#endif

/* eml2_2ForGsoap.h:18924 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKind (-1446)

/* eml22:LithologyKind */
enum class eml22__LithologyKind {
	alkali_x0020feldspar_x0020rhyolite = 0,
	alkali_x0020olivine_x0020basalt = 1,
	amphibolite = 2,
	andesite = 3,
	anhydrite = 4,
	anorthositic_x0020rock = 5,
	anthracite = 6,
	aplite = 7,
	arenite = 8,
	argillaceous = 9,
	arkose = 10,
	basalt = 11,
	basanite = 12,
	bauxite = 13,
	bituminous_x0020coal = 14,
	blueschist_x0020metamorphic_x0020rock = 15,
	boninite = 16,
	breccia = 17,
	carbonate_x0020ooze = 18,
	carbonatite = 19,
	chalk = 20,
	chert = 21,
	clay = 22,
	claystone = 23,
	coal = 24,
	conglomerate = 25,
	dacite = 26,
	diabase = 27,
	diamictite = 28,
	diorite = 29,
	dioritoid = 30,
	doleritic_x0020rock = 31,
	dolomite = 32,
	dolomitic = 33,
	eclogite = 34,
	exotic_x0020alkaline_x0020rock = 35,
	feldspar = 36,
	feldspathic_x0020arenite = 37,
	fine_x0020grained_x0020igneous_x0020rock = 38,
	foid_x0020dioritoid = 39,
	foid_x0020gabbroid = 40,
	foid_x0020syenitoid = 41,
	foidite = 42,
	foiditoid = 43,
	foidolite = 44,
	foliated_x0020metamorphic_x0020rock = 45,
	fragmental_x0020igneous_x0020rock = 46,
	gabbro = 47,
	gabbroic_x0020rock = 48,
	gabbroid = 49,
	glauconite = 50,
	gneiss = 51,
	granite = 52,
	granodiorite = 53,
	granofels = 54,
	granulite = 55,
	gravel = 56,
	greenstone = 57,
	gumbo = 58,
	gypsum = 59,
	halite = 60,
	hornfels = 61,
	igneous_x0020rock = 62,
	impact_x0020generated_x0020material = 63,
	impure_x0020dolomite = 64,
	impure_x0020limestone = 'A',
	intrusive_x0020rock_x0020_x0028plutonic_x0029 = 'B',
	iron_x0020rich_x0020sedimentary_x0020rock = 'C',
	kalsilitic_x0020and_x0020melilitic_x0020rocks = 'D',
	komatiitic_x0020rock = 'E',
	latitic_x0020rock = 'F',
	lignite = 'G',
	lime_x0020boundstone = 'H',
	lime_x0020framestone = 'I',
	lime_x0020grainstone = 'J',
	lime_x0020mudstone = 'K',
	lime_x0020packstone = 'L',
	lime_x0020wackestone = 'M',
	limestone = 'N',
	marble = 'O',
	marl = 'P',
	metamorphic_x0020rock = 'Q',
	mica_x0020schist = 'R',
	migmatite = 'S',
	monzogabbro = 'T',
	mud = 'U',
	mudstone = 'V',
	mylonitic_x0020rock = 'W',
	no_x0020description = 'X',
	no_x0020sample = 'Y',
	ooze = 'Z',
	ophiolite = 91,
	organic_x0020bearing_x0020mudstone = 92,
	peat = 93,
	pegmatite = 94,
	peridotite = 95,
	phaneritic_x0020igneous_x0020rock = 96,
	phonolite = 'a',
	phonolitoid = 'b',
	phosphate = 'c',
	phosphate_x0020rock = 'd',
	phyllite = 'e',
	porphyry = 'f',
	potassium_x0020and_x0020magnesium_x0020salts = 'g',
	pyroclastic_x0020breccia = 'h',
	pyroclastic_x0020rock = 'i',
	pyroxenite = 'j',
	quartz_x0020arenite = 'k',
	quartzite = 'l',
	rhyolite = 'm',
	rock_x0020salt = 'n',
	sand = 'o',
	sandstone = 'p',
	sandy = 'q',
	sapropel = 'r',
	schist = 's',
	serpentinite = 't',
	shale = 'u',
	siliceous_x0020ooze = 'v',
	silt = 'w',
	siltstone = 'x',
	skarn = 'y',
	slate = 'z',
	spilite = 123,
	syenite = 124,
	syenitoid = 125,
	sylvite = 126,
	tephrite = 127,
	tephritoid = 128,
	tholeiitic_x0020basalt = 129,
	tonalite = 130,
	trachyte = 131,
	trachytic_x0020rock = 132,
	trachytoid = 133,
	travertine = 134,
	tuff = 135,
	tuffite = 136,
	ultrabasic = 137,
	undifferentiated = 138,
	unknown = 139,
	wacke = 140
};
#endif

/* eml2_2ForGsoap.h:19071 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKind (-1447)

/* eml22:LithologyQualifierKind */
enum class eml22__LithologyQualifierKind {
	alkali_x0020feldspar_x0020rhyolite = 0,
	alkali_x0020olivine_x0020basalt = 1,
	amphibolite = 2,
	amphibolitic = 3,
	andesite = 4,
	andesitic = 5,
	anhydrite = 6,
	anhydritic = 7,
	ankerite = 8,
	ankeritic = 9,
	anorthositic_x0020rock = 10,
	anthracite = 11,
	anthracitic = 12,
	aplite = 13,
	aplitic = 14,
	arenite = 15,
	arenitic = 16,
	argillaceous = 17,
	arkose = 18,
	arkosic = 19,
	barite = 20,
	baritic = 21,
	basalt = 22,
	basaltic = 23,
	basanite = 24,
	basanitic = 25,
	bauxite = 26,
	bauxitic = 27,
	belemnites = 28,
	belemnitic = 29,
	bioturbated = 30,
	bioturbation = 31,
	bitumen = 32,
	bituminous = 33,
	bituminous_x0020coal = 34,
	blueschist_x0020metamorphic_x0020rock = 35,
	boninite = 36,
	breccia = 37,
	brecciated = 38,
	bryozoan = 39,
	bryozoans = 40,
	burrowed = 41,
	burrows = 42,
	calcareous = 43,
	calcite = 44,
	calcite_x0020concretion = 45,
	calcitic = 46,
	carbonaceous = 47,
	carbonate_x0020ooze = 48,
	carbonatite = 49,
	carbonatitic = 50,
	chalk = 51,
	chalky = 52,
	chamosite = 53,
	chamositic = 54,
	chert = 55,
	cherty = 56,
	chlorite = 57,
	chloritic = 58,
	clay = 59,
	claystone = 60,
	coal = 61,
	concretionary = 62,
	concretions = 63,
	conglomerate = 64,
	conglomeratic = 'A',
	coral_x0020fragments = 'B',
	coralline = 'C',
	crinoidal = 'D',
	crinoids = 'E',
	dacite = 'F',
	dacitic = 'G',
	diabase = 'H',
	diabasic = 'I',
	diamictite = 'J',
	diamictitic = 'K',
	diatomaceous = 'L',
	diatoms = 'M',
	diorite = 'N',
	dioritic = 'O',
	dioritoid = 'P',
	dioritoidic = 'Q',
	doleritic_x0020rock = 'R',
	dolomite = 'S',
	dolomite_x0020concretion = 'T',
	dolomite_x0020stringer = 'U',
	dolomitic = 'V',
	eclogite = 'W',
	eclogitic = 'X',
	exotic_x0020alkaline_x0020rock = 'Y',
	feldspar = 'Z',
	feldsparic = 91,
	feldspathic = 92,
	feldspathic_x0020arenite = 93,
	ferruginous = 94,
	fine_x0020grained_x0020igneous_x0020rock = 95,
	foid_x0020dioritoid = 96,
	foid_x0020gabbroid = 'a',
	foid_x0020syenitoid = 'b',
	foidite = 'c',
	foiditic = 'd',
	foiditoid = 'e',
	foidolite = 'f',
	foidolitic = 'g',
	foliated_x0020metamorphic_x0020rock = 'h',
	foraminifera = 'i',
	foraminiferous = 'j',
	forams = 'k',
	fossil_x0020fragments = 'l',
	fossiliferous = 'm',
	fossils_x0020undifferentiated = 'n',
	fragmental_x0020igneous_x0020rock = 'o',
	gabbro = 'p',
	gabbroic = 'q',
	gabbroic_x0020rock = 'r',
	gabbroid = 's',
	gabbroidic = 't',
	gilsonite = 'u',
	gilsonitic = 'v',
	glauconite = 'w',
	glauconitic = 'x',
	gneiss = 'y',
	gneissic = 'z',
	granite = 123,
	granitic = 124,
	granodiorite = 125,
	granodioritic = 126,
	granofels = 127,
	granulite = 128,
	granulitic = 129,
	gravel = 130,
	gravelly = 131,
	greenstone = 132,
	gumbo = 133,
	gypsiferous = 134,
	gypsum = 135,
	halite = 136,
	halitic = 137,
	hornfels = 138,
	hornfelsic = 139,
	igneous = 140,
	igneous_x0020rock = 141,
	illite = 142,
	illitic = 143,
	impact_x0020generated_x0020material = 144,
	impure_x0020dolomite = 145,
	impure_x0020limestone = 146,
	intrusive_x0020rock_x0020_x0028plutonic_x0029 = 147,
	iron_x0020rich_x0020sedimentary_x0020rock = 148,
	kalsilitic_x0020and_x0020melilitic_x0020rocks = 149,
	kaolinite = 150,
	kaolinitic = 151,
	komatiitic_x0020rock = 152,
	latitic_x0020rock = 153,
	lignite = 154,
	lignitic = 155,
	lime_x0020boundstone = 156,
	lime_x0020framestone = 157,
	lime_x0020grainstone = 158,
	lime_x0020mudstone = 159,
	lime_x0020packstone = 160,
	lime_x0020wackestone = 161,
	limestone = 162,
	limestone_x0020stringer = 163,
	lithic = 164,
	lithic_x0020fragments = 165,
	marble = 166,
	marcasite = 167,
	marcasitic = 168,
	marl = 169,
	marly = 170,
	metamorphic_x0020rock = 171,
	mica = 172,
	mica_x0020schist = 173,
	micaceous = 174,
	microfossiliferous = 175,
	microfossils = 176,
	migmatite = 177,
	migmatitic = 178,
	monzogabbro = 179,
	monzogabbroic = 180,
	mud = 181,
	muddy = 182,
	mudstone = 183,
	mylonitic_x0020rock = 184,
	no_x0020sample = 185,
	oncolite = 186,
	oncoliths = 187,
	oncolitic = 188,
	ooids = 189,
	ooliths = 190,
	oolitic = 191,
	ooze = 192,
	ophiolite = 193,
	ophiolitic = 194,
	organic_x0020bearing_x0020mudstone = 195,
	ostracodal = 196,
	ostracods = 197,
	peat = 198,
	peaty = 199,
	pebble = 200,
	pebbly = 201,
	pegmatite = 202,
	pegmatitic = 203,
	pelletal = 204,
	pellets = 205,
	peloidal = 206,
	peloids = 207,
	peridotite = 208,
	peridotitic = 209,
	phaneritic_x0020igneous_x0020rock = 210,
	phonolite = 211,
	phonolitic = 212,
	phonolitoid = 213,
	phosphate = 214,
	phosphate_x0020rock = 215,
	phosphatic = 216,
	phyllite = 217,
	phyllitic = 218,
	pisolite = 219,
	pisoliths = 220,
	pisolitic = 221,
	plant_x0020remains = 222,
	porphyritic = 223,
	porphyry = 224,
	potassium_x0020and_x0020magnesium_x0020salts = 225,
	pyrite = 226,
	pyritic = 227,
	pyroclastic_x0020breccia = 228,
	pyroclastic_x0020rock = 229,
	pyroxenite = 230,
	pyroxenitic = 231,
	quartiferous = 232,
	quartz = 233,
	quartz_x0020arenite = 234,
	quartzite = 235,
	quartzitic = 236,
	radiolaria = 237,
	radiolarian = 238,
	rhyolite = 239,
	rhyolitic = 240,
	rock_x0020salt = 241,
	rootlets = 242,
	salty = 243,
	sand = 244,
	sandstone = 245,
	sandy = 246,
	sapropel = 247,
	sapropelic = 248,
	schist = 249,
	schisty = 250,
	sepentinitic = 251,
	serpentinite = 252,
	shale = 253,
	shaly = 254,
	shell_x0020fragments = 255,
	shelly = 256,
	siderite = 257,
	siderite_x0020concretion = 258,
	sideritic = 259,
	siliceous_x0020ooze = 260,
	silt = 261,
	siltstone = 262,
	silty = 263,
	skarn = 264,
	skarny = 265,
	slate = 266,
	slaty = 267,
	smectite = 268,
	smectitic = 269,
	spicular = 270,
	spicules = 271,
	spilite = 272,
	spilitic = 273,
	stylolites = 274,
	stylolitic = 275,
	syenite = 276,
	syenitic = 277,
	syenitoid = 278,
	sylvite = 279,
	sylvitic = 280,
	tarry = 281,
	tephrite = 282,
	tephritic = 283,
	tephritoid = 284,
	tholeiitic_x0020basalt = 285,
	tonalite = 286,
	tonalitic = 287,
	trachyte = 288,
	trachytic = 289,
	trachytic_x0020rock = 290,
	trachytoid = 291,
	travertine = 292,
	tuff = 293,
	tuffaceous = 294,
	tuffite = 295,
	tuffitic = 296,
	ultrabasic = 297,
	undifferentiated = 298,
	unknown = 299,
	wacke = 300
};
#endif

/* eml2_2ForGsoap.h:19382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithostratigraphicRank (-1448)

/* eml22:LithostratigraphicRank */
enum class eml22__LithostratigraphicRank {
	group = 0,
	formation = 1,
	member = 2,
	bed = 3
};
#endif

/* eml2_2ForGsoap.h:19430 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__MatrixCementKind (-1449)

/* eml22:MatrixCementKind */
enum class eml22__MatrixCementKind {
	ankerite = 0,
	calcite = 1,
	chlorite = 2,
	dolomite = 3,
	illite = 4,
	kaolinite = 5,
	quartz = 6,
	siderite = 7,
	smectite = 8
};
#endif

/* eml2_2ForGsoap.h:19449 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MeasureClass
#define SOAP_TYPE_gsoap_eml2_2_eml22__MeasureClass (-1450)

/* eml22:MeasureClass */
enum class eml22__MeasureClass {
	absorbed_x0020dose = 0,
	activity_x0020of_x0020radioactivity = 1,
	amount_x0020of_x0020substance = 2,
	amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	amount_x0020of_x0020substance_x0020per_x0020area = 4,
	amount_x0020of_x0020substance_x0020per_x0020time = 5,
	amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	angle_x0020per_x0020length = 8,
	angle_x0020per_x0020volume = 9,
	angular_x0020acceleration = 10,
	angular_x0020velocity = 11,
	api_x0020gamma_x0020ray = 12,
	api_x0020gravity = 13,
	api_x0020neutron = 14,
	area = 15,
	area_x0020per_x0020amount_x0020of_x0020substance = 16,
	area_x0020per_x0020area = 17,
	area_x0020per_x0020count = 18,
	area_x0020per_x0020mass = 19,
	area_x0020per_x0020time = 20,
	area_x0020per_x0020volume = 21,
	attenuation_x0020per_x0020frequency_x0020interval = 22,
	capacitance = 23,
	cation_x0020exchange_x0020capacity = 24,
	data_x0020transfer_x0020speed = 25,
	diffusion_x0020coefficient = 26,
	diffusive_x0020time_x0020of_x0020flight = 27,
	digital_x0020storage = 28,
	dimensionless = 29,
	dipole_x0020moment = 30,
	dose_x0020equivalent = 31,
	dynamic_x0020viscosity = 32,
	electric_x0020charge = 33,
	electric_x0020charge_x0020per_x0020area = 34,
	electric_x0020charge_x0020per_x0020mass = 35,
	electric_x0020charge_x0020per_x0020volume = 36,
	electric_x0020conductance = 37,
	electric_x0020conductivity = 38,
	electric_x0020current = 39,
	electric_x0020current_x0020density = 40,
	electric_x0020field_x0020strength = 41,
	electric_x0020potential_x0020difference = 42,
	electric_x0020resistance = 43,
	electric_x0020resistance_x0020per_x0020length = 44,
	electrical_x0020resistivity = 45,
	electromagnetic_x0020moment = 46,
	energy = 47,
	energy_x0020length_x0020per_x0020area = 48,
	energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	energy_x0020per_x0020area = 50,
	energy_x0020per_x0020length = 51,
	energy_x0020per_x0020mass = 52,
	energy_x0020per_x0020mass_x0020per_x0020time = 53,
	energy_x0020per_x0020volume = 54,
	force = 55,
	force_x0020area = 56,
	force_x0020length_x0020per_x0020length = 57,
	force_x0020per_x0020force = 58,
	force_x0020per_x0020length = 59,
	force_x0020per_x0020volume = 60,
	frequency = 61,
	frequency_x0020interval = 62,
	heat_x0020capacity = 63,
	heat_x0020flow_x0020rate = 64,
	heat_x0020transfer_x0020coefficient = 'A',
	illuminance = 'B',
	inductance = 'C',
	isothermal_x0020compressibility = 'D',
	kinematic_x0020viscosity = 'E',
	length = 'F',
	length_x0020per_x0020length = 'G',
	length_x0020per_x0020mass = 'H',
	length_x0020per_x0020pressure = 'I',
	length_x0020per_x0020temperature = 'J',
	length_x0020per_x0020time = 'K',
	length_x0020per_x0020volume = 'L',
	light_x0020exposure = 'M',
	linear_x0020acceleration = 'N',
	linear_x0020thermal_x0020expansion = 'O',
	logarithmic_x0020power_x0020ratio = 'P',
	logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	luminance = 'R',
	luminous_x0020efficacy = 'S',
	luminous_x0020flux = 'T',
	luminous_x0020intensity = 'U',
	magnetic_x0020dipole_x0020moment = 'V',
	magnetic_x0020field_x0020strength = 'W',
	magnetic_x0020flux = 'X',
	magnetic_x0020flux_x0020density = 'Y',
	magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	magnetic_x0020permeability = 91,
	magnetic_x0020vector_x0020potential = 92,
	mass = 93,
	mass_x0020length = 94,
	mass_x0020per_x0020area = 95,
	mass_x0020per_x0020energy = 96,
	mass_x0020per_x0020length = 'a',
	mass_x0020per_x0020mass = 'b',
	mass_x0020per_x0020time = 'c',
	mass_x0020per_x0020time_x0020per_x0020area = 'd',
	mass_x0020per_x0020time_x0020per_x0020length = 'e',
	mass_x0020per_x0020volume = 'f',
	mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	mobility = 'j',
	molar_x0020energy = 'k',
	molar_x0020heat_x0020capacity = 'l',
	molar_x0020volume = 'm',
	molecular_x0020weight = 'n',
	moment_x0020of_x0020force = 'o',
	moment_x0020of_x0020inertia = 'p',
	momentum = 'q',
	normalized_x0020power = 'r',
	permeability_x0020length = 's',
	permeability_x0020rock = 't',
	permittivity = 'u',
	plane_x0020angle = 'v',
	potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	power = 'x',
	power_x0020per_x0020area = 'y',
	power_x0020per_x0020power = 'z',
	power_x0020per_x0020volume = 123,
	pressure = 124,
	pressure_x0020per_x0020pressure = 125,
	pressure_x0020per_x0020time = 126,
	pressure_x0020per_x0020volume = 127,
	pressure_x0020squared = 128,
	pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	pressure_x0020time_x0020per_x0020volume = 130,
	quantity_x0020of_x0020light = 131,
	radiance = 132,
	radiant_x0020intensity = 133,
	reciprocal_x0020area = 134,
	reciprocal_x0020electric_x0020potential_x0020difference = 135,
	reciprocal_x0020force = 136,
	reciprocal_x0020length = 137,
	reciprocal_x0020mass = 138,
	reciprocal_x0020mass_x0020time = 139,
	reciprocal_x0020pressure = 140,
	reciprocal_x0020time = 141,
	reciprocal_x0020volume = 142,
	reluctance = 143,
	second_x0020moment_x0020of_x0020area = 144,
	signaling_x0020event_x0020per_x0020time = 145,
	solid_x0020angle = 146,
	specific_x0020heat_x0020capacity = 147,
	temperature_x0020interval = 148,
	temperature_x0020interval_x0020per_x0020length = 149,
	temperature_x0020interval_x0020per_x0020pressure = 150,
	temperature_x0020interval_x0020per_x0020time = 151,
	thermal_x0020conductance = 152,
	thermal_x0020conductivity = 153,
	thermal_x0020diffusivity = 154,
	thermal_x0020insulance = 155,
	thermal_x0020resistance = 156,
	thermodynamic_x0020temperature = 157,
	thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	time = 159,
	time_x0020per_x0020length = 160,
	time_x0020per_x0020mass = 161,
	time_x0020per_x0020time = 162,
	time_x0020per_x0020volume = 163,
	vertical_x0020coordinate = 164,
	volume = 165,
	volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	volume_x0020per_x0020area = 167,
	volume_x0020per_x0020length = 168,
	volume_x0020per_x0020mass = 169,
	volume_x0020per_x0020pressure = 170,
	volume_x0020per_x0020rotation = 171,
	volume_x0020per_x0020time = 172,
	volume_x0020per_x0020time_x0020length = 173,
	volume_x0020per_x0020time_x0020per_x0020area = 174,
	volume_x0020per_x0020time_x0020per_x0020length = 175,
	volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	volume_x0020per_x0020time_x0020per_x0020time = 178,
	volume_x0020per_x0020time_x0020per_x0020volume = 179,
	volume_x0020per_x0020volume = 180,
	volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	volumetric_x0020thermal_x0020expansion = 182,
	unitless = 183
};
#endif

/* eml2_2ForGsoap.h:19639 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKind (-1451)

/* eml22:QuantityClassKind */
enum class eml22__QuantityClassKind {
	absorbed_x0020dose = 0,
	activity_x0020of_x0020radioactivity = 1,
	amount_x0020of_x0020substance = 2,
	amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	amount_x0020of_x0020substance_x0020per_x0020area = 4,
	amount_x0020of_x0020substance_x0020per_x0020time = 5,
	amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	angle_x0020per_x0020length = 8,
	angle_x0020per_x0020volume = 9,
	angular_x0020acceleration = 10,
	angular_x0020velocity = 11,
	api_x0020gamma_x0020ray = 12,
	api_x0020gravity = 13,
	api_x0020neutron = 14,
	area = 15,
	area_x0020per_x0020amount_x0020of_x0020substance = 16,
	area_x0020per_x0020area = 17,
	area_x0020per_x0020count = 18,
	area_x0020per_x0020mass = 19,
	area_x0020per_x0020time = 20,
	area_x0020per_x0020volume = 21,
	attenuation_x0020per_x0020frequency_x0020interval = 22,
	capacitance = 23,
	cation_x0020exchange_x0020capacity = 24,
	data_x0020transfer_x0020speed = 25,
	diffusion_x0020coefficient = 26,
	diffusive_x0020time_x0020of_x0020flight = 27,
	digital_x0020storage = 28,
	dimensionless = 29,
	dipole_x0020moment = 30,
	dose_x0020equivalent = 31,
	dynamic_x0020viscosity = 32,
	electric_x0020charge = 33,
	electric_x0020charge_x0020per_x0020area = 34,
	electric_x0020charge_x0020per_x0020mass = 35,
	electric_x0020charge_x0020per_x0020volume = 36,
	electric_x0020conductance = 37,
	electric_x0020conductivity = 38,
	electric_x0020current = 39,
	electric_x0020current_x0020density = 40,
	electric_x0020field_x0020strength = 41,
	electric_x0020potential_x0020difference = 42,
	electric_x0020resistance = 43,
	electric_x0020resistance_x0020per_x0020length = 44,
	electrical_x0020resistivity = 45,
	electromagnetic_x0020moment = 46,
	energy = 47,
	energy_x0020length_x0020per_x0020area = 48,
	energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	energy_x0020per_x0020area = 50,
	energy_x0020per_x0020length = 51,
	energy_x0020per_x0020mass = 52,
	energy_x0020per_x0020mass_x0020per_x0020time = 53,
	energy_x0020per_x0020volume = 54,
	force = 55,
	force_x0020area = 56,
	force_x0020length_x0020per_x0020length = 57,
	force_x0020per_x0020force = 58,
	force_x0020per_x0020length = 59,
	force_x0020per_x0020volume = 60,
	frequency = 61,
	frequency_x0020interval = 62,
	heat_x0020capacity = 63,
	heat_x0020flow_x0020rate = 64,
	heat_x0020transfer_x0020coefficient = 'A',
	illuminance = 'B',
	inductance = 'C',
	isothermal_x0020compressibility = 'D',
	kinematic_x0020viscosity = 'E',
	length = 'F',
	length_x0020per_x0020length = 'G',
	length_x0020per_x0020mass = 'H',
	length_x0020per_x0020pressure = 'I',
	length_x0020per_x0020temperature = 'J',
	length_x0020per_x0020time = 'K',
	length_x0020per_x0020volume = 'L',
	light_x0020exposure = 'M',
	linear_x0020acceleration = 'N',
	linear_x0020thermal_x0020expansion = 'O',
	logarithmic_x0020power_x0020ratio = 'P',
	logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	luminance = 'R',
	luminous_x0020efficacy = 'S',
	luminous_x0020flux = 'T',
	luminous_x0020intensity = 'U',
	magnetic_x0020dipole_x0020moment = 'V',
	magnetic_x0020field_x0020strength = 'W',
	magnetic_x0020flux = 'X',
	magnetic_x0020flux_x0020density = 'Y',
	magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	magnetic_x0020permeability = 91,
	magnetic_x0020vector_x0020potential = 92,
	mass = 93,
	mass_x0020length = 94,
	mass_x0020per_x0020area = 95,
	mass_x0020per_x0020energy = 96,
	mass_x0020per_x0020length = 'a',
	mass_x0020per_x0020mass = 'b',
	mass_x0020per_x0020time = 'c',
	mass_x0020per_x0020time_x0020per_x0020area = 'd',
	mass_x0020per_x0020time_x0020per_x0020length = 'e',
	mass_x0020per_x0020volume = 'f',
	mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	mobility = 'j',
	molar_x0020energy = 'k',
	molar_x0020heat_x0020capacity = 'l',
	molar_x0020volume = 'm',
	molecular_x0020weight = 'n',
	moment_x0020of_x0020force = 'o',
	moment_x0020of_x0020inertia = 'p',
	momentum = 'q',
	normalized_x0020power = 'r',
	permeability_x0020length = 's',
	permeability_x0020rock = 't',
	permittivity = 'u',
	plane_x0020angle = 'v',
	potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	power = 'x',
	power_x0020per_x0020area = 'y',
	power_x0020per_x0020power = 'z',
	power_x0020per_x0020volume = 123,
	pressure = 124,
	pressure_x0020per_x0020pressure = 125,
	pressure_x0020per_x0020time = 126,
	pressure_x0020per_x0020volume = 127,
	pressure_x0020squared = 128,
	pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	pressure_x0020time_x0020per_x0020volume = 130,
	quantity_x0020of_x0020light = 131,
	radiance = 132,
	radiant_x0020intensity = 133,
	reciprocal_x0020area = 134,
	reciprocal_x0020electric_x0020potential_x0020difference = 135,
	reciprocal_x0020force = 136,
	reciprocal_x0020length = 137,
	reciprocal_x0020mass = 138,
	reciprocal_x0020mass_x0020time = 139,
	reciprocal_x0020pressure = 140,
	reciprocal_x0020time = 141,
	reciprocal_x0020volume = 142,
	reluctance = 143,
	second_x0020moment_x0020of_x0020area = 144,
	signaling_x0020event_x0020per_x0020time = 145,
	solid_x0020angle = 146,
	specific_x0020heat_x0020capacity = 147,
	temperature_x0020interval = 148,
	temperature_x0020interval_x0020per_x0020length = 149,
	temperature_x0020interval_x0020per_x0020pressure = 150,
	temperature_x0020interval_x0020per_x0020time = 151,
	thermal_x0020conductance = 152,
	thermal_x0020conductivity = 153,
	thermal_x0020diffusivity = 154,
	thermal_x0020insulance = 155,
	thermal_x0020resistance = 156,
	thermodynamic_x0020temperature = 157,
	thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	time = 159,
	time_x0020per_x0020length = 160,
	time_x0020per_x0020mass = 161,
	time_x0020per_x0020time = 162,
	time_x0020per_x0020volume = 163,
	vertical_x0020coordinate = 164,
	volume = 165,
	volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	volume_x0020per_x0020area = 167,
	volume_x0020per_x0020length = 168,
	volume_x0020per_x0020mass = 169,
	volume_x0020per_x0020pressure = 170,
	volume_x0020per_x0020rotation = 171,
	volume_x0020per_x0020time = 172,
	volume_x0020per_x0020time_x0020length = 173,
	volume_x0020per_x0020time_x0020per_x0020area = 174,
	volume_x0020per_x0020time_x0020per_x0020length = 175,
	volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	volume_x0020per_x0020time_x0020per_x0020time = 178,
	volume_x0020per_x0020time_x0020per_x0020volume = 179,
	volume_x0020per_x0020volume = 180,
	volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	volumetric_x0020thermal_x0020expansion = 182,
	unitless = 183,
	not_x0020a_x0020measure = 184
};
#endif

/* eml2_2ForGsoap.h:19844 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceCondition (-1452)

/* eml22:ReferenceCondition */
enum class eml22__ReferenceCondition {
	_0_x0020degC_x00201_x0020atm = 0,
	_0_x0020degC_x00201_x0020bar = 1,
	_15_x0020degC_x00201_x0020atm = 2,
	_15_x0020degC_x00201_x0020bar = 3,
	_20_x0020degC_x00201_x0020atm = 4,
	_20_x0020degC_x00201_x0020bar = 5,
	_25_x0020degC_x00201_x0020bar = 6,
	_60_x0020degF_x00201_x0020atm = 7,
	_60_x0020degF_x002030_x0020in_x0020Hg = 8,
	ambient = 9
};
#endif

/* eml2_2ForGsoap.h:19877 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellboreDatumReference (-1453)

/* eml22:WellboreDatumReference */
enum class eml22__WellboreDatumReference {
	ground_x0020level = 0,
	kelly_x0020bushing = 1,
	mean_x0020sea_x0020level = 2,
	derrick_x0020floor = 3,
	casing_x0020flange = 4,
	crown_x0020valve = 5,
	rotary_x0020bushing = 6,
	rotary_x0020table = 7,
	sea_x0020floor = 8,
	lowest_x0020astronomical_x0020tide = 9,
	mean_x0020higher_x0020high_x0020water = 10,
	mean_x0020high_x0020water = 11,
	mean_x0020lower_x0020low_x0020water = 12,
	mean_x0020low_x0020water = 13,
	mean_x0020tide_x0020level = 14,
	kickoff_x0020point = 15
};
#endif

/* eml2_2ForGsoap.h:19939 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellStatus
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellStatus (-1454)

/* eml22:WellStatus */
enum class eml22__WellStatus {
	abandoned = 0,
	active = 1,
	active_x0020_x002d__x0020injecting = 2,
	active_x0020_x002d__x0020producing = 3,
	completed = 4,
	drilling = 5,
	partially_x0020plugged = 6,
	permitted = 7,
	plugged_x0020and_x0020abandoned = 8,
	proposed = 9,
	sold = 10,
	suspended = 11,
	temporarily_x0020abandoned = 12,
	testing = 13,
	tight = 14,
	working_x0020over = 15,
	unknown = 16
};
#endif

/* eml2_2ForGsoap.h:20032 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityParameterKind (-1455)

/* eml22:ActivityParameterKind */
enum class eml22__ActivityParameterKind {
	dataObject = 0,
	double_ = 1,
	integer = 2,
	string = 3,
	timestamp = 4,
	subActivity = 5
};
#endif

/* eml2_2ForGsoap.h:20048 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressureKind (-1456)

/* eml22:ReferencePressureKind */
enum class eml22__ReferencePressureKind {
	absolute = 0,
	ambient = 1,
	legal = 2
};
#endif

/* eml2_2ForGsoap.h:20069 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_2_eml22__AxisOrder2d (-1457)

/* eml22:AxisOrder2d */
enum class eml22__AxisOrder2d {
	easting_x0020northing = 0,
	northing_x0020easting = 1,
	westing_x0020southing = 2,
	southing_x0020westing = 3,
	northing_x0020westing = 4,
	westing_x0020northing = 5
};
#endif

/* eml2_2ForGsoap.h:20109 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EastOrWest
#define SOAP_TYPE_gsoap_eml2_2_eml22__EastOrWest (-1458)

/* eml22:EastOrWest */
enum class eml22__EastOrWest {
	east = 0,
	west = 1
};
#endif

/* eml2_2ForGsoap.h:20129 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_2_eml22__NorthOrSouth (-1459)

/* eml22:NorthOrSouth */
enum class eml22__NorthOrSouth {
	north = 0,
	south = 1
};
#endif

/* eml2_2ForGsoap.h:20149 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_2_eml22__PrincipalMeridian (-1460)

/* eml22:PrincipalMeridian */
enum class eml22__PrincipalMeridian {
	_1st_x0020Principal_x0020Meridian = 0,
	_2nd_x0020Principal_x0020Meridian = 1,
	_3rd_x0020Principal_x0020Meridian = 2,
	_4th_x0020Principal_x0020Meridian = 3,
	_5th_x0020Principal_x0020Meridian = 4,
	_6th_x0020Principal_x0020Meridian = 5,
	Black_x0020Hills_x0020Meridian = 6,
	Boise_x0020Meridian = 7,
	Chickasaw_x0020Meridian = 8,
	Choctaw_x0020Meridian = 9,
	Cimarron_x0020Meridian = 10,
	Copper_x0020River_x0020Meridian = 11,
	Fairbanks_x0020Meridian = 12,
	Gila_x0020and_x0020Salt_x0020River_x0020Meridian = 13,
	Humboldt_x0020Meridian = 14,
	Huntsville_x0020Meridian = 15,
	Indian_x0020Meridian = 16,
	Kateel_x0020River_x0020Meridian = 17,
	Lousiana_x0020Meridian = 18,
	Michigan_x0020Meridian = 19,
	Montana_x0020Meridian = 20,
	Mount_x0020Diablo_x0020Meridian = 21,
	Navajo_x0020Meridian = 22,
	New_x0020Mexico_x0020Meridian = 23,
	Saint_x0020Helena_x0020Meridian = 24,
	Saint_x0020Stephens_x0020Meridian = 25,
	Salt_x0020Lake_x0020Meridian = 26,
	San_x0020Bernardo_x0020Meridian = 27,
	Seward_x0020Meridian = 28,
	Tallahassee_x0020Meridian = 29,
	Uintah_x0020Meridian = 30,
	Umiat_x0020Meridian = 31,
	Ute_x0020Meridian = 32,
	Washington_x0020Meridian = 33,
	Williamette_x0020Meridian = 34,
	Wind_x0020River_x0020Meridian = 35
};
#endif

/* eml2_2ForGsoap.h:20335 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalDirection (-1461)

/* eml22:VerticalDirection */
enum class eml22__VerticalDirection {
	up = 0,
	down = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/struct_tm.h:67 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (-9)

typedef struct tm xsd__dateTime;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class prodml21__AbstractPvtModel;	/* eml2_2ForGsoap.h:184 */
class prodml21__ApplicationInfo;	/* eml2_2ForGsoap.h:186 */
class prodml21__BinaryInteractionCoefficientSet;	/* eml2_2ForGsoap.h:196 */
class prodml21__ComponentPropertySet;	/* eml2_2ForGsoap.h:200 */
class prodml21__CustomPvtModelExtension;	/* eml2_2ForGsoap.h:210 */
class prodml21__CustomPvtModelParameter;	/* eml2_2ForGsoap.h:212 */
class prodml21__FluidCharacterizationModel;	/* eml2_2ForGsoap.h:228 */
class prodml21__FluidCharacterizationParameter;	/* eml2_2ForGsoap.h:230 */
class prodml21__FluidCharacterizationParameterSet;	/* eml2_2ForGsoap.h:232 */
class prodml21__FluidCharacterizationSource;	/* eml2_2ForGsoap.h:234 */
class prodml21__FluidCharacterizationTable;	/* eml2_2ForGsoap.h:236 */
class prodml21__FluidCharacterizationTableColumn;	/* eml2_2ForGsoap.h:238 */
class prodml21__FluidCharacterizationTableFormat;	/* eml2_2ForGsoap.h:240 */
class prodml21__FluidCharacterizationTableFormatSet;	/* eml2_2ForGsoap.h:242 */
class prodml21__FluidComponentProperty;	/* eml2_2ForGsoap.h:244 */
class prodml21__PrsvParameter;	/* eml2_2ForGsoap.h:266 */
class prodml21__PvtModelParameterSet;	/* eml2_2ForGsoap.h:270 */
class prodml21__ReferenceSeparatorStage;	/* eml2_2ForGsoap.h:272 */
class prodml21__TableDelimiter;	/* eml2_2ForGsoap.h:282 */
class prodml21__AbstractDateTimeClass;	/* eml2_2ForGsoap.h:284 */
class prodml21__AbstractFluidComponent;	/* eml2_2ForGsoap.h:286 */
class prodml21__BusinessAssociate;	/* eml2_2ForGsoap.h:288 */
class prodml21__CalibrationParameter;	/* eml2_2ForGsoap.h:290 */
class prodml21__DatedComment;	/* eml2_2ForGsoap.h:292 */
class prodml21__EndpointQualifiedDate;	/* eml2_2ForGsoap.h:296 */
class prodml21__EndpointQualifiedDateTime;	/* eml2_2ForGsoap.h:298 */
class prodml21__FacilityIdentifier;	/* eml2_2ForGsoap.h:300 */
class prodml21__FacilityIdentifierStruct;	/* eml2_2ForGsoap.h:302 */
class prodml21__FluidComponent;	/* eml2_2ForGsoap.h:304 */
class prodml21__FluidComponentCatalog;	/* eml2_2ForGsoap.h:306 */
class prodml21__GeneralAddress;	/* eml2_2ForGsoap.h:310 */
class prodml21__GeneralMeasureType;	/* eml2_2ForGsoap.h:312 */
class prodml21__GeographicContext;	/* eml2_2ForGsoap.h:316 */
class prodml21__GeologyFeature;	/* eml2_2ForGsoap.h:318 */
class prodml21__LiquidComposition;	/* eml2_2ForGsoap.h:326 */
class prodml21__NorthSeaOffshore;	/* eml2_2ForGsoap.h:336 */
class prodml21__OffshoreLocation;	/* eml2_2ForGsoap.h:338 */
class prodml21__OverallComposition;	/* eml2_2ForGsoap.h:340 */
class prodml21__PersonName;	/* eml2_2ForGsoap.h:342 */
class prodml21__PhoneNumberStruct;	/* eml2_2ForGsoap.h:344 */
class prodml21__ProductFlowExternalReference;	/* eml2_2ForGsoap.h:352 */
class prodml21__ProductFlowNetwork;	/* eml2_2ForGsoap.h:354 */
class prodml21__VaporComposition;	/* eml2_2ForGsoap.h:366 */
class prodml21__VolumeQualifiedMeasure;	/* eml2_2ForGsoap.h:368 */
class prodml21__WellElevationCoord;	/* eml2_2ForGsoap.h:370 */
class prodml21__WellVerticalDepthCoord;	/* eml2_2ForGsoap.h:372 */
class prodml21__CommonPropertiesProductVolume;	/* eml2_2ForGsoap.h:374 */
class prodml21__AbstractMeasureData;	/* eml2_2ForGsoap.h:376 */
union _prodml21__union_AbstractRefProductFlow;	/* eml2_2ForGsoap.h:22813 */
class prodml21__AbstractRefProductFlow;	/* eml2_2ForGsoap.h:378 */
class prodml21__AbstractRelatedFacilityObject;	/* eml2_2ForGsoap.h:380 */
class prodml21__CurveDefinition;	/* eml2_2ForGsoap.h:384 */
union _prodml21__union_OwnershipBusinessAcct;	/* eml2_2ForGsoap.h:22931 */
class prodml21__OwnershipBusinessAcct;	/* eml2_2ForGsoap.h:392 */
class prodml21__ProductVolumeAlert;	/* eml2_2ForGsoap.h:398 */
class prodml21__ProductVolumeBalanceDetail;	/* eml2_2ForGsoap.h:400 */
class prodml21__ProductVolumeBalanceEvent;	/* eml2_2ForGsoap.h:402 */
class prodml21__ProductVolumeBalanceSet;	/* eml2_2ForGsoap.h:404 */
class prodml21__ProductVolumeBusinessSubUnit;	/* eml2_2ForGsoap.h:406 */
class prodml21__ProductVolumeBusinessUnit;	/* eml2_2ForGsoap.h:408 */
class prodml21__ProductVolumeComponentContent;	/* eml2_2ForGsoap.h:410 */
class prodml21__ProductVolumeDestination;	/* eml2_2ForGsoap.h:412 */
class prodml21__ProductVolumeFacility;	/* eml2_2ForGsoap.h:414 */
class prodml21__ProductVolumeFlow;	/* eml2_2ForGsoap.h:416 */
class prodml21__ProductVolumeParameterSet;	/* eml2_2ForGsoap.h:418 */
class prodml21__ProductVolumeParameterValue;	/* eml2_2ForGsoap.h:420 */
class prodml21__ProductVolumePeriod;	/* eml2_2ForGsoap.h:422 */
class prodml21__ProductVolumePortDifference;	/* eml2_2ForGsoap.h:424 */
class prodml21__ProductVolumeProduct;	/* eml2_2ForGsoap.h:426 */
class prodml21__ProductVolumeRelatedFacility;	/* eml2_2ForGsoap.h:428 */
class prodml21__ConnectedNode;	/* eml2_2ForGsoap.h:434 */
class prodml21__ExpectedFlowQualifier;	/* eml2_2ForGsoap.h:436 */
class prodml21__ProductFlowChangeLog;	/* eml2_2ForGsoap.h:438 */
class prodml21__ProductFlowExpectedUnitProperty;	/* eml2_2ForGsoap.h:440 */
class prodml21__ProductFlowExternalPort;	/* eml2_2ForGsoap.h:442 */
class prodml21__ProductFlowNetworkPlan;	/* eml2_2ForGsoap.h:446 */
class prodml21__ProductFlowPort;	/* eml2_2ForGsoap.h:448 */
class prodml21__ProductFlowUnit;	/* eml2_2ForGsoap.h:452 */
class prodml21__RelativeCoordinate;	/* eml2_2ForGsoap.h:456 */
union _prodml21__union_AbstractGasProducedRatioVolume;	/* eml2_2ForGsoap.h:24563 */
class prodml21__AbstractGasProducedRatioVolume;	/* eml2_2ForGsoap.h:460 */
class prodml21__AbstractLiquidDropoutPercVolume;	/* eml2_2ForGsoap.h:462 */
class prodml21__AbstractOilVolShrinkage;	/* eml2_2ForGsoap.h:464 */
class prodml21__AtmosphericFlashTestAndCompositionalAnalysis;	/* eml2_2ForGsoap.h:466 */
class prodml21__ConstantCompositionExpansionTest;	/* eml2_2ForGsoap.h:468 */
class prodml21__ConstantCompositionExpansionTestStep;	/* eml2_2ForGsoap.h:470 */
class prodml21__ConstantVolumeDepletionTest;	/* eml2_2ForGsoap.h:472 */
class prodml21__DifferentialLiberationTest;	/* eml2_2ForGsoap.h:478 */
class prodml21__FlashedGas;	/* eml2_2ForGsoap.h:480 */
class prodml21__FlashedLiquid;	/* eml2_2ForGsoap.h:482 */
class prodml21__FluidAnalysisReport;	/* eml2_2ForGsoap.h:486 */
class prodml21__FluidCvdTestStep;	/* eml2_2ForGsoap.h:488 */
class prodml21__FluidDifferentialLiberationTestStep;	/* eml2_2ForGsoap.h:490 */
class prodml21__FluidSeparatorTest;	/* eml2_2ForGsoap.h:492 */
class prodml21__FluidSeparatorTestStep;	/* eml2_2ForGsoap.h:494 */
class prodml21__FluidVolumeReference;	/* eml2_2ForGsoap.h:496 */
class prodml21__InjectedGas;	/* eml2_2ForGsoap.h:500 */
class prodml21__InterfacialTensionTest;	/* eml2_2ForGsoap.h:502 */
class prodml21__InterfacialTensionTestStep;	/* eml2_2ForGsoap.h:504 */
class prodml21__MassBalance;	/* eml2_2ForGsoap.h:510 */
class prodml21__MassIn;	/* eml2_2ForGsoap.h:512 */
class prodml21__MassOut;	/* eml2_2ForGsoap.h:514 */
class prodml21__MultipleContactMiscibilityTest;	/* eml2_2ForGsoap.h:516 */
class prodml21__OtherMeasurementTest;	/* eml2_2ForGsoap.h:524 */
class prodml21__OtherMeasurementTestStep;	/* eml2_2ForGsoap.h:526 */
class prodml21__PhaseDensity;	/* eml2_2ForGsoap.h:528 */
class prodml21__PhaseViscosity;	/* eml2_2ForGsoap.h:530 */
class prodml21__ProducedGasProperties;	/* eml2_2ForGsoap.h:532 */
class prodml21__ProducedOilProperties;	/* eml2_2ForGsoap.h:534 */
class prodml21__ReportLocation;	/* eml2_2ForGsoap.h:540 */
class prodml21__SampleContaminant;	/* eml2_2ForGsoap.h:542 */
class prodml21__SampleIntegrityAndPreparation;	/* eml2_2ForGsoap.h:544 */
class prodml21__SampleRestoration;	/* eml2_2ForGsoap.h:546 */
class prodml21__Sara;	/* eml2_2ForGsoap.h:548 */
class prodml21__SaturationTest;	/* eml2_2ForGsoap.h:554 */
class prodml21__SeparatorConditions;	/* eml2_2ForGsoap.h:556 */
class prodml21__SlimTubeSpecification;	/* eml2_2ForGsoap.h:558 */
class prodml21__SlimTubeTest;	/* eml2_2ForGsoap.h:560 */
class prodml21__SlimTubeTestStep;	/* eml2_2ForGsoap.h:562 */
class prodml21__SlimTubeTestVolumeStep;	/* eml2_2ForGsoap.h:564 */
class prodml21__STOAnalysis;	/* eml2_2ForGsoap.h:566 */
class prodml21__STOFlashedLiquid;	/* eml2_2ForGsoap.h:568 */
class prodml21__SwellingTest;	/* eml2_2ForGsoap.h:570 */
class prodml21__SwellingTestStep;	/* eml2_2ForGsoap.h:572 */
class prodml21__VaporLiquidEquilibriumTest;	/* eml2_2ForGsoap.h:574 */
class prodml21__ViscosityAtTemperature;	/* eml2_2ForGsoap.h:576 */
class prodml21__WaterAnalysisTest;	/* eml2_2ForGsoap.h:580 */
class prodml21__WaterAnalysisTestStep;	/* eml2_2ForGsoap.h:582 */
class prodml21__WaterSampleComponent;	/* eml2_2ForGsoap.h:584 */
class prodml21__FluidSampleAcquisitionJobSource;	/* eml2_2ForGsoap.h:588 */
class prodml21__FluidSampleChainofCustodyEvent;	/* eml2_2ForGsoap.h:590 */
class prodml21__FluidSampleComposition;	/* eml2_2ForGsoap.h:592 */
class prodml21__SampleRecombinationRequirement;	/* eml2_2ForGsoap.h:594 */
class prodml21__FluidSampleAcquisition;	/* eml2_2ForGsoap.h:602 */
class prodml21__WftCurveSection;	/* eml2_2ForGsoap.h:612 */
class prodml21__WftEvent;	/* eml2_2ForGsoap.h:614 */
class prodml21__WftInOutParameter;	/* eml2_2ForGsoap.h:616 */
class prodml21__WftResultReference;	/* eml2_2ForGsoap.h:618 */
class prodml21__WftSampleAcquisition;	/* eml2_2ForGsoap.h:622 */
class prodml21__WftStation;	/* eml2_2ForGsoap.h:624 */
class prodml21__WftTest;	/* eml2_2ForGsoap.h:626 */
class prodml21__WftTestData;	/* eml2_2ForGsoap.h:628 */
class prodml21__WftTestResult;	/* eml2_2ForGsoap.h:630 */
class prodml21__AbstractDisposition;	/* eml2_2ForGsoap.h:632 */
class prodml21__AbstractProductQuantity;	/* eml2_2ForGsoap.h:634 */
class prodml21__DeferredProductionEvent;	/* eml2_2ForGsoap.h:640 */
class prodml21__DeferredProductionVolume;	/* eml2_2ForGsoap.h:642 */
class prodml21__DowntimeReasonCode;	/* eml2_2ForGsoap.h:644 */
class prodml21__Injection;	/* eml2_2ForGsoap.h:646 */
class prodml21__Production;	/* eml2_2ForGsoap.h:652 */
class prodml21__ProductionWellPeriod;	/* eml2_2ForGsoap.h:654 */
class prodml21__ProductionWellTest;	/* eml2_2ForGsoap.h:656 */
class prodml21__ProductRate;	/* eml2_2ForGsoap.h:660 */
class prodml21__ReportingEntityVolumes;	/* eml2_2ForGsoap.h:662 */
class prodml21__TestPeriod;	/* eml2_2ForGsoap.h:670 */
class prodml21__WellFlowingCondition;	/* eml2_2ForGsoap.h:676 */
class prodml21__AbstractFlowTestData;	/* eml2_2ForGsoap.h:680 */
class prodml21__FlowTestLocation;	/* eml2_2ForGsoap.h:692 */
class prodml21__FlowTestMeasurementSet;	/* eml2_2ForGsoap.h:694 */
class prodml21__AbstractAnalysis;	/* eml2_2ForGsoap.h:708 */
class prodml21__AbstractDeconvolutionOutput;	/* eml2_2ForGsoap.h:710 */
class prodml21__AbstractRateHistory;	/* eml2_2ForGsoap.h:714 */
class prodml21__AnalysisLine;	/* eml2_2ForGsoap.h:716 */
class prodml21__CompressibilityParameters;	/* eml2_2ForGsoap.h:720 */
class prodml21__DeconvolutionOutput;	/* eml2_2ForGsoap.h:724 */
class prodml21__DistributedParametersSubModel;	/* eml2_2ForGsoap.h:732 */
class prodml21__InterferingFlowTestInterval;	/* eml2_2ForGsoap.h:734 */
struct __prodml21__InternalFaultSubModel_sequence;	/* eml2_2ForGsoap.h:30472 */
class prodml21__InternalFaultSubModel;	/* eml2_2ForGsoap.h:736 */
class prodml21__LayerModel;	/* eml2_2ForGsoap.h:738 */
class prodml21__LayerToLayerConnection;	/* eml2_2ForGsoap.h:740 */
class prodml21__LocationIn2D;	/* eml2_2ForGsoap.h:742 */
struct __prodml21__LogLogAnalysis_sequence;	/* eml2_2ForGsoap.h:30704 */
class prodml21__LogLogAnalysis;	/* eml2_2ForGsoap.h:744 */
class prodml21__ReservoirZoneSubModel;	/* eml2_2ForGsoap.h:766 */
class prodml21__ResqmlModelRef;	/* eml2_2ForGsoap.h:768 */
struct __prodml21__SingleBoundarySubModel_sequence;	/* eml2_2ForGsoap.h:30841 */
class prodml21__SingleBoundarySubModel;	/* eml2_2ForGsoap.h:772 */
struct __prodml21__SingleFractureSubModel_sequence;	/* eml2_2ForGsoap.h:30882 */
class prodml21__SingleFractureSubModel;	/* eml2_2ForGsoap.h:776 */
class prodml21__SpecializedAnalysis;	/* eml2_2ForGsoap.h:778 */
class prodml21__AbstractModelSection;	/* eml2_2ForGsoap.h:782 */
class prodml21__AbstractParameter;	/* eml2_2ForGsoap.h:880 */
class prodml21__ReportingHierarchyNode;	/* eml2_2ForGsoap.h:1022 */
class prodml21__AbstractValue;	/* eml2_2ForGsoap.h:1024 */
class eml22__AbstractGrowingObjectPart;	/* eml2_2ForGsoap.h:1038 */
class eml22__AbstractObject;	/* eml2_2ForGsoap.h:1044 */
class eml22__Citation;	/* eml2_2ForGsoap.h:1050 */
class eml22__CustomData;	/* eml2_2ForGsoap.h:1052 */
class eml22__ExtensionNameValue;	/* eml2_2ForGsoap.h:1054 */
class eml22__ObjectAlias;	/* eml2_2ForGsoap.h:1056 */
class eml22__DateTimeInterval;	/* eml2_2ForGsoap.h:1058 */
class eml22__GeologicTime;	/* eml2_2ForGsoap.h:1060 */
class eml22__PropertyKindFacet;	/* eml2_2ForGsoap.h:1066 */
class eml22__TimeIndex;	/* eml2_2ForGsoap.h:1068 */
class eml22__TimeIndices;	/* eml2_2ForGsoap.h:1070 */
class eml22__TimeSeriesParentage;	/* eml2_2ForGsoap.h:1074 */
class eml22__AbstractValueArray;	/* eml2_2ForGsoap.h:1086 */
class eml22__Cost;	/* eml2_2ForGsoap.h:1096 */
class eml22__DummyType;	/* eml2_2ForGsoap.h:1100 */
class eml22__JaggedArray;	/* eml2_2ForGsoap.h:1122 */
class eml22__MdInterval;	/* eml2_2ForGsoap.h:1124 */
class eml22__TvdInterval;	/* eml2_2ForGsoap.h:1134 */
class eml22__DataObjectReference;	/* eml2_2ForGsoap.h:1874 */
class eml22__ExternalDataset;	/* eml2_2ForGsoap.h:1878 */
class eml22__ExternalDatasetPart;	/* eml2_2ForGsoap.h:1880 */
class eml22__AbstractActivityParameter;	/* eml2_2ForGsoap.h:1882 */
class eml22__AbstractParameterKey;	/* eml2_2ForGsoap.h:1884 */
class eml22__ParameterTemplate;	/* eml2_2ForGsoap.h:1898 */
class eml22__AbstractPressureValue;	/* eml2_2ForGsoap.h:1908 */
union _eml22__union_AbstractTemperaturePressure;	/* eml2_2ForGsoap.h:32303 */
class eml22__AbstractTemperaturePressure;	/* eml2_2ForGsoap.h:1910 */
class eml22__DensityValue;	/* eml2_2ForGsoap.h:1912 */
class eml22__FlowRateValue;	/* eml2_2ForGsoap.h:1914 */
class eml22__PressureValue;	/* eml2_2ForGsoap.h:1918 */
class eml22__VolumeValue;	/* eml2_2ForGsoap.h:1928 */
class eml22__AbstractGeodeticCrs;	/* eml2_2ForGsoap.h:1930 */
class eml22__AbstractProjectedCrs;	/* eml2_2ForGsoap.h:1932 */
class eml22__AbstractVerticalCrs;	/* eml2_2ForGsoap.h:1934 */
class eml22__HorizontalAxes;	/* eml2_2ForGsoap.h:1950 */
class eml22__PublicLandSurveySystem;	/* eml2_2ForGsoap.h:1964 */
class eml22__Vector;	/* eml2_2ForGsoap.h:1966 */
class eml22__VerticalAxis;	/* eml2_2ForGsoap.h:1968 */
class eml22__FailingRule;	/* eml2_2ForGsoap.h:1982 */
class eml22__IndexRange;	/* eml2_2ForGsoap.h:1984 */
class eml22__AbstractGraphicalInformation;	/* eml2_2ForGsoap.h:1986 */
class prodml21__AbstractCompositionalModel;	/* eml2_2ForGsoap.h:164 */
class prodml21__AbstractCorrelationModel;	/* eml2_2ForGsoap.h:166 */
class prodml21__FluidCharacterization;	/* eml2_2ForGsoap.h:226 */
class prodml21__FormationWater;	/* eml2_2ForGsoap.h:308 */
class prodml21__GeneralQualifiedMeasure;	/* eml2_2ForGsoap.h:314 */
class prodml21__IntegerQualifiedCount;	/* eml2_2ForGsoap.h:320 */
class prodml21__KindQualifiedString;	/* eml2_2ForGsoap.h:324 */
class prodml21__NaturalGas;	/* eml2_2ForGsoap.h:334 */
class prodml21__PlusFluidComponent;	/* eml2_2ForGsoap.h:346 */
class prodml21__PseudoFluidComponent;	/* eml2_2ForGsoap.h:356 */
class prodml21__PureFluidComponent;	/* eml2_2ForGsoap.h:358 */
class prodml21__StartEndDate;	/* eml2_2ForGsoap.h:360 */
class prodml21__StartEndTime;	/* eml2_2ForGsoap.h:362 */
class prodml21__StockTankOil;	/* eml2_2ForGsoap.h:364 */
class prodml21__CurveData;	/* eml2_2ForGsoap.h:382 */
class prodml21__FacilityParent;	/* eml2_2ForGsoap.h:386 */
class prodml21__FacilityUnitPort;	/* eml2_2ForGsoap.h:388 */
class prodml21__IntegerData;	/* eml2_2ForGsoap.h:390 */
class prodml21__Parentfacility;	/* eml2_2ForGsoap.h:394 */
class prodml21__ProductVolume;	/* eml2_2ForGsoap.h:396 */
class prodml21__ReferenceFlow;	/* eml2_2ForGsoap.h:430 */
class prodml21__StringData;	/* eml2_2ForGsoap.h:432 */
class prodml21__ProductFlowModel;	/* eml2_2ForGsoap.h:444 */
class prodml21__ProductFlowQualifierExpected;	/* eml2_2ForGsoap.h:450 */
class prodml21__Qualifier;	/* eml2_2ForGsoap.h:454 */
class prodml21__FluidSystem;	/* eml2_2ForGsoap.h:458 */
class prodml21__CumulativeGasProducedRatioStd;	/* eml2_2ForGsoap.h:474 */
class prodml21__CumulativeGasProducedVol;	/* eml2_2ForGsoap.h:476 */
class prodml21__FluidAnalysis;	/* eml2_2ForGsoap.h:484 */
class prodml21__LiquidDropoutFraction;	/* eml2_2ForGsoap.h:506 */
class prodml21__LiquidVolume;	/* eml2_2ForGsoap.h:508 */
class prodml21__OilShrinkageFactor;	/* eml2_2ForGsoap.h:520 */
class prodml21__OilVolume;	/* eml2_2ForGsoap.h:522 */
class prodml21__FluidSample;	/* eml2_2ForGsoap.h:586 */
class prodml21__FluidSampleContainer;	/* eml2_2ForGsoap.h:596 */
class prodml21__DownholeSampleAcquisition;	/* eml2_2ForGsoap.h:598 */
class prodml21__FacilitySampleAcquisition;	/* eml2_2ForGsoap.h:600 */
class prodml21__FluidSampleAcquisitionJob;	/* eml2_2ForGsoap.h:604 */
class prodml21__SeparatorSampleAcquisition;	/* eml2_2ForGsoap.h:606 */
class prodml21__WellheadSampleAcquisition;	/* eml2_2ForGsoap.h:608 */
class prodml21__WftSampleAcquisitionJob;	/* eml2_2ForGsoap.h:610 */
class prodml21__WftRun;	/* eml2_2ForGsoap.h:620 */
class prodml21__AbstractSimpleProductVolume;	/* eml2_2ForGsoap.h:636 */
class prodml21__ProductDisposition;	/* eml2_2ForGsoap.h:648 */
class prodml21__ProductFluid;	/* eml2_2ForGsoap.h:650 */
class prodml21__ServiceFluid;	/* eml2_2ForGsoap.h:664 */
class prodml21__TerminalLiftingDisposition;	/* eml2_2ForGsoap.h:668 */
class prodml21__TransferDisposition;	/* eml2_2ForGsoap.h:674 */
class prodml21__AbstractPtaFlowData;	/* eml2_2ForGsoap.h:682 */
class prodml21__Channel;	/* eml2_2ForGsoap.h:684 */
class prodml21__ChannelSet;	/* eml2_2ForGsoap.h:686 */
class prodml21__FlowTestActivity;	/* eml2_2ForGsoap.h:690 */
class prodml21__OtherData;	/* eml2_2ForGsoap.h:700 */
class prodml21__AbstractPtaPressureData;	/* eml2_2ForGsoap.h:712 */
class prodml21__ChannelFlowrateData;	/* eml2_2ForGsoap.h:718 */
class prodml21__DeconvolutionMultipleOutput;	/* eml2_2ForGsoap.h:722 */
class prodml21__DeconvolutionSingleOutput;	/* eml2_2ForGsoap.h:726 */
class prodml21__PressureTransientAnalysis;	/* eml2_2ForGsoap.h:758 */
class prodml21__PtaAnalysis;	/* eml2_2ForGsoap.h:760 */
class prodml21__PtaDataPreProcess;	/* eml2_2ForGsoap.h:762 */
class prodml21__PtaDeconvolution;	/* eml2_2ForGsoap.h:764 */
class prodml21__RtaAnalysis;	/* eml2_2ForGsoap.h:770 */
class prodml21__SingleFlowrateData;	/* eml2_2ForGsoap.h:774 */
class prodml21__TestPeriodsFlowrateData;	/* eml2_2ForGsoap.h:780 */
class prodml21__BoundaryBaseModel;	/* eml2_2ForGsoap.h:784 */
class prodml21__NearWellboreBaseModel;	/* eml2_2ForGsoap.h:850 */
class prodml21__ReservoirBaseModel;	/* eml2_2ForGsoap.h:864 */
class prodml21__WellboreBaseModel;	/* eml2_2ForGsoap.h:878 */
class prodml21__AngleBetweenBoundaries;	/* eml2_2ForGsoap.h:882 */
class prodml21__AveragePressure;	/* eml2_2ForGsoap.h:884 */
class prodml21__ConvergenceSkinRelativeToTotalThickness;	/* eml2_2ForGsoap.h:886 */
class prodml21__CustomParameter;	/* eml2_2ForGsoap.h:888 */
class prodml21__DeltaPressureTotalSkin;	/* eml2_2ForGsoap.h:890 */
class prodml21__DeltaTimeStorageChanges;	/* eml2_2ForGsoap.h:892 */
class prodml21__DistanceFractureToBottomBoundary;	/* eml2_2ForGsoap.h:894 */
class prodml21__DistanceMidFractureHeightToBottomBoundary;	/* eml2_2ForGsoap.h:896 */
class prodml21__DistanceMidPerforationsToBottomBoundary;	/* eml2_2ForGsoap.h:898 */
class prodml21__DistanceToBoundary1;	/* eml2_2ForGsoap.h:900 */
class prodml21__DistanceToBoundary2;	/* eml2_2ForGsoap.h:902 */
class prodml21__DistanceToBoundary3;	/* eml2_2ForGsoap.h:904 */
class prodml21__DistanceToBoundary4;	/* eml2_2ForGsoap.h:906 */
class prodml21__DistanceToMobilityInterface;	/* eml2_2ForGsoap.h:908 */
class prodml21__DistanceToPinchOut;	/* eml2_2ForGsoap.h:910 */
class prodml21__DistanceWellboreToBottomBoundary;	/* eml2_2ForGsoap.h:912 */
class prodml21__DrainageAreaMeasured;	/* eml2_2ForGsoap.h:914 */
class prodml21__FaultConductivity;	/* eml2_2ForGsoap.h:916 */
class prodml21__FluidDensity;	/* eml2_2ForGsoap.h:918 */
class prodml21__FractureAngleToWellbore;	/* eml2_2ForGsoap.h:920 */
class prodml21__FractureConductivity;	/* eml2_2ForGsoap.h:922 */
class prodml21__FractureFaceSkin;	/* eml2_2ForGsoap.h:924 */
class prodml21__FractureHalfLength;	/* eml2_2ForGsoap.h:926 */
class prodml21__FractureHeight;	/* eml2_2ForGsoap.h:928 */
class prodml21__FractureRadius;	/* eml2_2ForGsoap.h:930 */
class prodml21__FractureStorativityRatio;	/* eml2_2ForGsoap.h:932 */
class prodml21__HorizontalAnisotropyKxToKy;	/* eml2_2ForGsoap.h:934 */
class prodml21__HorizontalRadialPermeability;	/* eml2_2ForGsoap.h:936 */
class prodml21__InitialPressure;	/* eml2_2ForGsoap.h:938 */
class prodml21__InnerToOuterZoneDiffusivityRatio;	/* eml2_2ForGsoap.h:940 */
class prodml21__InnerToOuterZoneMobilityRatio;	/* eml2_2ForGsoap.h:942 */
class prodml21__InterporosityFlowParameter;	/* eml2_2ForGsoap.h:944 */
class prodml21__Layer2Thickness;	/* eml2_2ForGsoap.h:946 */
class prodml21__LeakSkin;	/* eml2_2ForGsoap.h:948 */
class prodml21__LengthHorizontalWellboreFlowing;	/* eml2_2ForGsoap.h:950 */
class prodml21__MechanicalSkinRelativeToTotalThickness;	/* eml2_2ForGsoap.h:952 */
class prodml21__ModelName;	/* eml2_2ForGsoap.h:954 */
class prodml21__NumberOfFractures;	/* eml2_2ForGsoap.h:956 */
class prodml21__OrientationOfAnisotropyXDirection;	/* eml2_2ForGsoap.h:958 */
class prodml21__OrientationOfFracturePlane;	/* eml2_2ForGsoap.h:960 */
class prodml21__OrientationOfLinearFront;	/* eml2_2ForGsoap.h:962 */
class prodml21__OrientationOfNormalToBoundary1;	/* eml2_2ForGsoap.h:964 */
class prodml21__OrientationWellTrajectory;	/* eml2_2ForGsoap.h:966 */
class prodml21__PerforatedLength;	/* eml2_2ForGsoap.h:968 */
class prodml21__PermeabilityThicknessProduct;	/* eml2_2ForGsoap.h:970 */
class prodml21__PoreVolumeMeasured;	/* eml2_2ForGsoap.h:972 */
class prodml21__PoreVolumeOfInvestigation;	/* eml2_2ForGsoap.h:974 */
class prodml21__Porosity;	/* eml2_2ForGsoap.h:976 */
class prodml21__PressureDatumTVD;	/* eml2_2ForGsoap.h:978 */
class prodml21__RadiusOfInvestigation;	/* eml2_2ForGsoap.h:980 */
class prodml21__RateDependentSkinFactor;	/* eml2_2ForGsoap.h:982 */
class prodml21__RatioDpSkinToTotalDrawdown;	/* eml2_2ForGsoap.h:984 */
class prodml21__RatioInitialToFinalWellboreStorage;	/* eml2_2ForGsoap.h:986 */
class prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct;	/* eml2_2ForGsoap.h:988 */
class prodml21__Region2Thickness;	/* eml2_2ForGsoap.h:990 */
class prodml21__SkinLayer2RelativeToTotalThickness;	/* eml2_2ForGsoap.h:992 */
class prodml21__SkinRelativeToTotalThickness;	/* eml2_2ForGsoap.h:994 */
class prodml21__StorativityRatio;	/* eml2_2ForGsoap.h:996 */
class prodml21__TotalThickness;	/* eml2_2ForGsoap.h:998 */
class prodml21__TransmissibilityReductionFactorOfLinearFront;	/* eml2_2ForGsoap.h:1000 */
class prodml21__TubingInteralDiameter;	/* eml2_2ForGsoap.h:1002 */
class prodml21__VerticalAnisotropyKvToKr;	/* eml2_2ForGsoap.h:1004 */
class prodml21__WellboreDeviationAngle;	/* eml2_2ForGsoap.h:1006 */
class prodml21__WellboreFluidCompressibility;	/* eml2_2ForGsoap.h:1008 */
class prodml21__WellboreRadius;	/* eml2_2ForGsoap.h:1010 */
class prodml21__WellboreStorageCoefficient;	/* eml2_2ForGsoap.h:1012 */
class prodml21__WellboreVolume;	/* eml2_2ForGsoap.h:1014 */
class prodml21__Facility;	/* eml2_2ForGsoap.h:1016 */
class prodml21__ReportingEntity;	/* eml2_2ForGsoap.h:1018 */
class prodml21__ReportingHierarchy;	/* eml2_2ForGsoap.h:1020 */
class prodml21__DoubleValue;	/* eml2_2ForGsoap.h:1026 */
class prodml21__StringValue;	/* eml2_2ForGsoap.h:1028 */
class prodml21__TimeSeriesData;	/* eml2_2ForGsoap.h:1030 */
class eml22__AbstractGrowingObject;	/* eml2_2ForGsoap.h:1036 */
class eml22__AbstractMdGrowingPart;	/* eml2_2ForGsoap.h:1040 */
class eml22__AbstractMdIntervalGrowingPart;	/* eml2_2ForGsoap.h:1042 */
class eml22__AbstractTimeGrowingPart;	/* eml2_2ForGsoap.h:1046 */
class eml22__AbstractTimeIntervalGrowingPart;	/* eml2_2ForGsoap.h:1048 */
class eml22__PropertyKind;	/* eml2_2ForGsoap.h:1062 */
class eml22__PropertyKindDictionary;	/* eml2_2ForGsoap.h:1064 */
class eml22__TimeSeries;	/* eml2_2ForGsoap.h:1072 */
class eml22__AbstractBooleanArray;	/* eml2_2ForGsoap.h:1076 */
class eml22__AbstractNumericArray;	/* eml2_2ForGsoap.h:1082 */
class eml22__AbstractStringArray;	/* eml2_2ForGsoap.h:1084 */
class eml22__EpcExternalPartReference;	/* eml2_2ForGsoap.h:1876 */
class eml22__Activity;	/* eml2_2ForGsoap.h:1886 */
class eml22__ActivityTemplate;	/* eml2_2ForGsoap.h:1888 */
class eml22__DataObjectParameter;	/* eml2_2ForGsoap.h:1890 */
class eml22__DoubleQuantityParameter;	/* eml2_2ForGsoap.h:1892 */
class eml22__IntegerQuantityParameter;	/* eml2_2ForGsoap.h:1894 */
class eml22__ObjectParameterKey;	/* eml2_2ForGsoap.h:1896 */
class eml22__StringParameter;	/* eml2_2ForGsoap.h:1900 */
class eml22__TimeIndexParameter;	/* eml2_2ForGsoap.h:1902 */
class eml22__TimeIndexParameterKey;	/* eml2_2ForGsoap.h:1904 */
class eml22__AbsolutePressure;	/* eml2_2ForGsoap.h:1906 */
class eml22__GaugePressure;	/* eml2_2ForGsoap.h:1916 */
union _eml22__union_ReferenceTemperaturePressure_;	/* eml2_2ForGsoap.h:41486 */
class eml22__ReferenceTemperaturePressure;	/* eml2_2ForGsoap.h:1922 */
class eml22__RelativePressure;	/* eml2_2ForGsoap.h:1924 */
class eml22__TemperaturePressure;	/* eml2_2ForGsoap.h:1926 */
class eml22__GeodeticCrs;	/* eml2_2ForGsoap.h:1940 */
class eml22__GeodeticEpsgCrs;	/* eml2_2ForGsoap.h:1942 */
class eml22__GeodeticLocalAuthorityCrs;	/* eml2_2ForGsoap.h:1944 */
class eml22__GeodeticUnknownCrs;	/* eml2_2ForGsoap.h:1946 */
class eml22__GeodeticWktCrs;	/* eml2_2ForGsoap.h:1948 */
class eml22__LocalEngineeringCompoundCrs;	/* eml2_2ForGsoap.h:1952 */
class eml22__ProjectedCrs;	/* eml2_2ForGsoap.h:1954 */
class eml22__ProjectedEpsgCrs;	/* eml2_2ForGsoap.h:1956 */
class eml22__ProjectedLocalAuthorityCrs;	/* eml2_2ForGsoap.h:1958 */
class eml22__ProjectedUnknownCrs;	/* eml2_2ForGsoap.h:1960 */
class eml22__ProjectedWktCrs;	/* eml2_2ForGsoap.h:1962 */
class eml22__VerticalCrs;	/* eml2_2ForGsoap.h:1970 */
class eml22__VerticalEpsgCrs;	/* eml2_2ForGsoap.h:1972 */
class eml22__VerticalLocalAuthorityCrs;	/* eml2_2ForGsoap.h:1974 */
class eml22__VerticalUnknownCrs;	/* eml2_2ForGsoap.h:1976 */
class eml22__VerticalWktCrs;	/* eml2_2ForGsoap.h:1978 */
class eml22__DataAssuranceRecord;	/* eml2_2ForGsoap.h:1980 */
class eml22__GraphicalInformationSet;	/* eml2_2ForGsoap.h:1988 */
class prodml21__FluidCharacterizationTableRow;	/* eml2_2ForGsoap.h:170 */
class prodml21__AbstractCompositionalEoSModel;	/* eml2_2ForGsoap.h:172 */
class prodml21__AbstractCompositionalViscosityModel;	/* eml2_2ForGsoap.h:174 */
class prodml21__AbstractCorrelationViscosityModel;	/* eml2_2ForGsoap.h:180 */
class prodml21__BinaryInteractionCoefficient;	/* eml2_2ForGsoap.h:194 */
class prodml21__CompositionalThermalModel;	/* eml2_2ForGsoap.h:202 */
class prodml21__CorrelationThermalModel;	/* eml2_2ForGsoap.h:204 */
class prodml21__PvtModelParameter;	/* eml2_2ForGsoap.h:268 */
class prodml21__KeywordValueStruct;	/* eml2_2ForGsoap.h:322 */
class prodml21__MeasuredDepthCoord;	/* eml2_2ForGsoap.h:328 */
class prodml21__MeasureOrQuantity;	/* eml2_2ForGsoap.h:330 */
class prodml21__PressurePerFlowrateMeasure;	/* eml2_2ForGsoap.h:348 */
class prodml21__PressurePerFlowrateSquaredMeasure;	/* eml2_2ForGsoap.h:350 */
class prodml21__HydrocarbonAnalysis;	/* eml2_2ForGsoap.h:498 */
class prodml21__WaterAnalysis;	/* eml2_2ForGsoap.h:578 */
class prodml21__AssetProductionVolumes;	/* eml2_2ForGsoap.h:638 */
class prodml21__ProductionWellTests;	/* eml2_2ForGsoap.h:658 */
class prodml21__TerminalLifting;	/* eml2_2ForGsoap.h:666 */
class prodml21__Transfer;	/* eml2_2ForGsoap.h:672 */
class prodml21__WellProductionParameters;	/* eml2_2ForGsoap.h:678 */
class prodml21__DrillStemTest;	/* eml2_2ForGsoap.h:688 */
class prodml21__FormationTesterStation;	/* eml2_2ForGsoap.h:696 */
class prodml21__InterwellTest;	/* eml2_2ForGsoap.h:698 */
class prodml21__ProductionFlowTest;	/* eml2_2ForGsoap.h:702 */
class prodml21__ProductionTransientTest;	/* eml2_2ForGsoap.h:704 */
class prodml21__VerticalInterferenceTest;	/* eml2_2ForGsoap.h:706 */
class prodml21__DeconvolvedFlowData;	/* eml2_2ForGsoap.h:728 */
class prodml21__DeconvolvedPressureData;	/* eml2_2ForGsoap.h:730 */
class prodml21__MeasuredFlowData;	/* eml2_2ForGsoap.h:746 */
class prodml21__MeasuredPressureData;	/* eml2_2ForGsoap.h:748 */
class prodml21__OutputFlowData;	/* eml2_2ForGsoap.h:750 */
class prodml21__OutputPressureData;	/* eml2_2ForGsoap.h:752 */
class prodml21__PreProcessedFlowData;	/* eml2_2ForGsoap.h:754 */
class prodml21__PreProcessedPressureData;	/* eml2_2ForGsoap.h:756 */
class prodml21__ChangingStorageFairModel;	/* eml2_2ForGsoap.h:786 */
class prodml21__ChangingStorageHegemanModel;	/* eml2_2ForGsoap.h:788 */
class prodml21__ChangingStorageSpiveyFissuresModel;	/* eml2_2ForGsoap.h:790 */
class prodml21__ChangingStorageSpiveyPackerModel;	/* eml2_2ForGsoap.h:792 */
class prodml21__ClosedCircleModel;	/* eml2_2ForGsoap.h:794 */
class prodml21__ClosedRectangleModel;	/* eml2_2ForGsoap.h:796 */
class prodml21__ConstantStorageModel;	/* eml2_2ForGsoap.h:798 */
class prodml21__CustomBoundaryModel;	/* eml2_2ForGsoap.h:800 */
class prodml21__CustomNearWellboreModel;	/* eml2_2ForGsoap.h:802 */
class prodml21__CustomReservoirModel;	/* eml2_2ForGsoap.h:804 */
class prodml21__CustomWellboreModel;	/* eml2_2ForGsoap.h:806 */
class prodml21__DualPermeabilityWithCrossflowModel;	/* eml2_2ForGsoap.h:808 */
class prodml21__DualPorosityPseudoSteadyStateModel;	/* eml2_2ForGsoap.h:810 */
class prodml21__DualPorosityTransientSlabsModel;	/* eml2_2ForGsoap.h:812 */
class prodml21__DualPorosityTransientSpheresModel;	/* eml2_2ForGsoap.h:814 */
class prodml21__FiniteRadiusModel;	/* eml2_2ForGsoap.h:816 */
class prodml21__FracturedFiniteConductivityModel;	/* eml2_2ForGsoap.h:818 */
class prodml21__FracturedHorizontalFiniteConductivityModel;	/* eml2_2ForGsoap.h:820 */
class prodml21__FracturedHorizontalInfiniteConductivityModel;	/* eml2_2ForGsoap.h:822 */
class prodml21__FracturedHorizontalUniformFluxModel;	/* eml2_2ForGsoap.h:824 */
class prodml21__FracturedInfiniteConductivityModel;	/* eml2_2ForGsoap.h:826 */
class prodml21__FracturedUniformFluxModel;	/* eml2_2ForGsoap.h:828 */
class prodml21__HomogeneousModel;	/* eml2_2ForGsoap.h:830 */
class prodml21__HorizontalWellbore2LayerModel;	/* eml2_2ForGsoap.h:832 */
class prodml21__HorizontalWellboreModel;	/* eml2_2ForGsoap.h:834 */
class prodml21__HorizontalWellboreMultipleEqualFracturedModel;	/* eml2_2ForGsoap.h:836 */
class prodml21__HorizontalWellboreMultipleVariableFracturedModel;	/* eml2_2ForGsoap.h:838 */
class prodml21__InfiniteBoundaryModel;	/* eml2_2ForGsoap.h:840 */
class prodml21__LinearCompositeModel;	/* eml2_2ForGsoap.h:842 */
class prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel;	/* eml2_2ForGsoap.h:844 */
class prodml21__LinearCompositeWithConductiveFaultModel;	/* eml2_2ForGsoap.h:846 */
class prodml21__LinearCompositeWithLeakyFaultModel;	/* eml2_2ForGsoap.h:848 */
class prodml21__NumericalBoundaryModel;	/* eml2_2ForGsoap.h:852 */
class prodml21__NumericalDualPorosityReservoirModel;	/* eml2_2ForGsoap.h:854 */
class prodml21__NumericalHomogeneousReservoirModel;	/* eml2_2ForGsoap.h:856 */
class prodml21__PartiallyPenetratingModel;	/* eml2_2ForGsoap.h:858 */
class prodml21__PinchOutModel;	/* eml2_2ForGsoap.h:860 */
class prodml21__RadialCompositeModel;	/* eml2_2ForGsoap.h:862 */
class prodml21__SingleFaultModel;	/* eml2_2ForGsoap.h:866 */
class prodml21__SlantedFullyPenetratingModel;	/* eml2_2ForGsoap.h:868 */
class prodml21__SlantedPartiallyPenetratingModel;	/* eml2_2ForGsoap.h:870 */
class prodml21__TwoIntersectingFaultsModel;	/* eml2_2ForGsoap.h:872 */
class prodml21__TwoParallelFaultsModel;	/* eml2_2ForGsoap.h:874 */
class prodml21__UShapedFaultsModel;	/* eml2_2ForGsoap.h:876 */
class prodml21__TimeSeriesDoubleSample;	/* eml2_2ForGsoap.h:1032 */
class prodml21__TimeSeriesStringSample;	/* eml2_2ForGsoap.h:1034 */
class eml22__AbstractFloatingPointArray;	/* eml2_2ForGsoap.h:1078 */
class eml22__AbstractIntegerArray;	/* eml2_2ForGsoap.h:1080 */
class eml22__BooleanArrayFromIndexArray;	/* eml2_2ForGsoap.h:1090 */
class eml22__BooleanConstantArray;	/* eml2_2ForGsoap.h:1092 */
class eml22__BooleanExternalArray;	/* eml2_2ForGsoap.h:1094 */
class eml22__GenericMeasure;	/* eml2_2ForGsoap.h:1110 */
class eml22__MeasuredDepthCoord;	/* eml2_2ForGsoap.h:1126 */
class eml22__StringConstantArray;	/* eml2_2ForGsoap.h:1128 */
class eml22__StringExternalArray;	/* eml2_2ForGsoap.h:1130 */
class eml22__WellVerticalDepthCoord;	/* eml2_2ForGsoap.h:1136 */
class eml22__AbsorbedDoseMeasure;	/* eml2_2ForGsoap.h:1138 */
class eml22__AbsorbedDoseMeasureExt;	/* eml2_2ForGsoap.h:1140 */
class eml22__ActivityOfRadioactivityMeasure;	/* eml2_2ForGsoap.h:1142 */
class eml22__ActivityOfRadioactivityMeasureExt;	/* eml2_2ForGsoap.h:1144 */
class eml22__AmountOfSubstanceMeasure;	/* eml2_2ForGsoap.h:1146 */
class eml22__AmountOfSubstanceMeasureExt;	/* eml2_2ForGsoap.h:1148 */
class eml22__AmountOfSubstancePerAmountOfSubstanceMeasure;	/* eml2_2ForGsoap.h:1150 */
class eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt;	/* eml2_2ForGsoap.h:1152 */
class eml22__AmountOfSubstancePerAreaMeasure;	/* eml2_2ForGsoap.h:1154 */
class eml22__AmountOfSubstancePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1156 */
class eml22__AmountOfSubstancePerTimeMeasure;	/* eml2_2ForGsoap.h:1158 */
class eml22__AmountOfSubstancePerTimeMeasureExt;	/* eml2_2ForGsoap.h:1160 */
class eml22__AmountOfSubstancePerTimePerAreaMeasure;	/* eml2_2ForGsoap.h:1162 */
class eml22__AmountOfSubstancePerTimePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1164 */
class eml22__AmountOfSubstancePerVolumeMeasure;	/* eml2_2ForGsoap.h:1166 */
class eml22__AmountOfSubstancePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1168 */
class eml22__AnglePerLengthMeasure;	/* eml2_2ForGsoap.h:1170 */
class eml22__AnglePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1172 */
class eml22__AnglePerVolumeMeasure;	/* eml2_2ForGsoap.h:1174 */
class eml22__AnglePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1176 */
class eml22__AngularAccelerationMeasure;	/* eml2_2ForGsoap.h:1178 */
class eml22__AngularAccelerationMeasureExt;	/* eml2_2ForGsoap.h:1180 */
class eml22__AngularVelocityMeasure;	/* eml2_2ForGsoap.h:1182 */
class eml22__AngularVelocityMeasureExt;	/* eml2_2ForGsoap.h:1184 */
class eml22__APIGammaRayMeasure;	/* eml2_2ForGsoap.h:1186 */
class eml22__APIGammaRayMeasureExt;	/* eml2_2ForGsoap.h:1188 */
class eml22__APIGravityMeasure;	/* eml2_2ForGsoap.h:1190 */
class eml22__APIGravityMeasureExt;	/* eml2_2ForGsoap.h:1192 */
class eml22__APINeutronMeasure;	/* eml2_2ForGsoap.h:1194 */
class eml22__APINeutronMeasureExt;	/* eml2_2ForGsoap.h:1196 */
class eml22__AreaMeasure;	/* eml2_2ForGsoap.h:1198 */
class eml22__AreaMeasureExt;	/* eml2_2ForGsoap.h:1200 */
class eml22__AreaPerAmountOfSubstanceMeasure;	/* eml2_2ForGsoap.h:1202 */
class eml22__AreaPerAmountOfSubstanceMeasureExt;	/* eml2_2ForGsoap.h:1204 */
class eml22__AreaPerAreaMeasure;	/* eml2_2ForGsoap.h:1206 */
class eml22__AreaPerAreaMeasureExt;	/* eml2_2ForGsoap.h:1208 */
class eml22__AreaPerCountMeasure;	/* eml2_2ForGsoap.h:1210 */
class eml22__AreaPerCountMeasureExt;	/* eml2_2ForGsoap.h:1212 */
class eml22__AreaPerMassMeasure;	/* eml2_2ForGsoap.h:1214 */
class eml22__AreaPerMassMeasureExt;	/* eml2_2ForGsoap.h:1216 */
class eml22__AreaPerTimeMeasure;	/* eml2_2ForGsoap.h:1218 */
class eml22__AreaPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1220 */
class eml22__AreaPerVolumeMeasure;	/* eml2_2ForGsoap.h:1222 */
class eml22__AreaPerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1224 */
class eml22__AttenuationPerFrequencyIntervalMeasure;	/* eml2_2ForGsoap.h:1226 */
class eml22__AttenuationPerFrequencyIntervalMeasureExt;	/* eml2_2ForGsoap.h:1228 */
class eml22__CapacitanceMeasure;	/* eml2_2ForGsoap.h:1230 */
class eml22__CapacitanceMeasureExt;	/* eml2_2ForGsoap.h:1232 */
class eml22__CationExchangeCapacityMeasure;	/* eml2_2ForGsoap.h:1234 */
class eml22__CationExchangeCapacityMeasureExt;	/* eml2_2ForGsoap.h:1236 */
class eml22__DataTransferSpeedMeasure;	/* eml2_2ForGsoap.h:1238 */
class eml22__DataTransferSpeedMeasureExt;	/* eml2_2ForGsoap.h:1240 */
class eml22__DiffusionCoefficientMeasure;	/* eml2_2ForGsoap.h:1242 */
class eml22__DiffusionCoefficientMeasureExt;	/* eml2_2ForGsoap.h:1244 */
class eml22__DiffusiveTimeOfFlightMeasure;	/* eml2_2ForGsoap.h:1246 */
class eml22__DiffusiveTimeOfFlightMeasureExt;	/* eml2_2ForGsoap.h:1248 */
class eml22__DigitalStorageMeasure;	/* eml2_2ForGsoap.h:1250 */
class eml22__DigitalStorageMeasureExt;	/* eml2_2ForGsoap.h:1252 */
class eml22__DimensionlessMeasure;	/* eml2_2ForGsoap.h:1254 */
class eml22__DimensionlessMeasureExt;	/* eml2_2ForGsoap.h:1256 */
class eml22__DipoleMomentMeasure;	/* eml2_2ForGsoap.h:1258 */
class eml22__DipoleMomentMeasureExt;	/* eml2_2ForGsoap.h:1260 */
class eml22__DoseEquivalentMeasure;	/* eml2_2ForGsoap.h:1262 */
class eml22__DoseEquivalentMeasureExt;	/* eml2_2ForGsoap.h:1264 */
class eml22__DynamicViscosityMeasure;	/* eml2_2ForGsoap.h:1266 */
class eml22__DynamicViscosityMeasureExt;	/* eml2_2ForGsoap.h:1268 */
class eml22__ElectricalResistivityMeasure;	/* eml2_2ForGsoap.h:1270 */
class eml22__ElectricalResistivityMeasureExt;	/* eml2_2ForGsoap.h:1272 */
class eml22__ElectricChargeMeasure;	/* eml2_2ForGsoap.h:1274 */
class eml22__ElectricChargeMeasureExt;	/* eml2_2ForGsoap.h:1276 */
class eml22__ElectricChargePerAreaMeasure;	/* eml2_2ForGsoap.h:1278 */
class eml22__ElectricChargePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1280 */
class eml22__ElectricChargePerMassMeasure;	/* eml2_2ForGsoap.h:1282 */
class eml22__ElectricChargePerMassMeasureExt;	/* eml2_2ForGsoap.h:1284 */
class eml22__ElectricChargePerVolumeMeasure;	/* eml2_2ForGsoap.h:1286 */
class eml22__ElectricChargePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1288 */
class eml22__ElectricConductanceMeasure;	/* eml2_2ForGsoap.h:1290 */
class eml22__ElectricConductanceMeasureExt;	/* eml2_2ForGsoap.h:1292 */
class eml22__ElectricConductivityMeasure;	/* eml2_2ForGsoap.h:1294 */
class eml22__ElectricConductivityMeasureExt;	/* eml2_2ForGsoap.h:1296 */
class eml22__ElectricCurrentDensityMeasure;	/* eml2_2ForGsoap.h:1298 */
class eml22__ElectricCurrentDensityMeasureExt;	/* eml2_2ForGsoap.h:1300 */
class eml22__ElectricCurrentMeasure;	/* eml2_2ForGsoap.h:1302 */
class eml22__ElectricCurrentMeasureExt;	/* eml2_2ForGsoap.h:1304 */
class eml22__ElectricFieldStrengthMeasure;	/* eml2_2ForGsoap.h:1306 */
class eml22__ElectricFieldStrengthMeasureExt;	/* eml2_2ForGsoap.h:1308 */
class eml22__ElectricPotentialDifferenceMeasure;	/* eml2_2ForGsoap.h:1310 */
class eml22__ElectricPotentialDifferenceMeasureExt;	/* eml2_2ForGsoap.h:1312 */
class eml22__ElectricResistanceMeasure;	/* eml2_2ForGsoap.h:1314 */
class eml22__ElectricResistanceMeasureExt;	/* eml2_2ForGsoap.h:1316 */
class eml22__ElectricResistancePerLengthMeasure;	/* eml2_2ForGsoap.h:1318 */
class eml22__ElectricResistancePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1320 */
class eml22__ElectromagneticMomentMeasure;	/* eml2_2ForGsoap.h:1322 */
class eml22__ElectromagneticMomentMeasureExt;	/* eml2_2ForGsoap.h:1324 */
class eml22__EnergyLengthPerAreaMeasure;	/* eml2_2ForGsoap.h:1326 */
class eml22__EnergyLengthPerAreaMeasureExt;	/* eml2_2ForGsoap.h:1328 */
class eml22__EnergyLengthPerTimeAreaTemperatureMeasure;	/* eml2_2ForGsoap.h:1330 */
class eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt;	/* eml2_2ForGsoap.h:1332 */
class eml22__EnergyMeasure;	/* eml2_2ForGsoap.h:1334 */
class eml22__EnergyMeasureExt;	/* eml2_2ForGsoap.h:1336 */
class eml22__EnergyPerAreaMeasure;	/* eml2_2ForGsoap.h:1338 */
class eml22__EnergyPerAreaMeasureExt;	/* eml2_2ForGsoap.h:1340 */
class eml22__EnergyPerLengthMeasure;	/* eml2_2ForGsoap.h:1342 */
class eml22__EnergyPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1344 */
class eml22__EnergyPerMassMeasure;	/* eml2_2ForGsoap.h:1346 */
class eml22__EnergyPerMassMeasureExt;	/* eml2_2ForGsoap.h:1348 */
class eml22__EnergyPerMassPerTimeMeasure;	/* eml2_2ForGsoap.h:1350 */
class eml22__EnergyPerMassPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1352 */
class eml22__EnergyPerVolumeMeasure;	/* eml2_2ForGsoap.h:1354 */
class eml22__EnergyPerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1356 */
class eml22__ForceAreaMeasure;	/* eml2_2ForGsoap.h:1358 */
class eml22__ForceAreaMeasureExt;	/* eml2_2ForGsoap.h:1360 */
class eml22__ForceLengthPerLengthMeasure;	/* eml2_2ForGsoap.h:1362 */
class eml22__ForceLengthPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1364 */
class eml22__ForceMeasure;	/* eml2_2ForGsoap.h:1366 */
class eml22__ForceMeasureExt;	/* eml2_2ForGsoap.h:1368 */
class eml22__ForcePerForceMeasure;	/* eml2_2ForGsoap.h:1370 */
class eml22__ForcePerForceMeasureExt;	/* eml2_2ForGsoap.h:1372 */
class eml22__ForcePerLengthMeasure;	/* eml2_2ForGsoap.h:1374 */
class eml22__ForcePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1376 */
class eml22__ForcePerVolumeMeasure;	/* eml2_2ForGsoap.h:1378 */
class eml22__ForcePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1380 */
class eml22__FrequencyIntervalMeasure;	/* eml2_2ForGsoap.h:1382 */
class eml22__FrequencyIntervalMeasureExt;	/* eml2_2ForGsoap.h:1384 */
class eml22__FrequencyMeasure;	/* eml2_2ForGsoap.h:1386 */
class eml22__FrequencyMeasureExt;	/* eml2_2ForGsoap.h:1388 */
class eml22__HeatCapacityMeasure;	/* eml2_2ForGsoap.h:1390 */
class eml22__HeatCapacityMeasureExt;	/* eml2_2ForGsoap.h:1392 */
class eml22__HeatFlowRateMeasure;	/* eml2_2ForGsoap.h:1394 */
class eml22__HeatFlowRateMeasureExt;	/* eml2_2ForGsoap.h:1396 */
class eml22__HeatTransferCoefficientMeasure;	/* eml2_2ForGsoap.h:1398 */
class eml22__HeatTransferCoefficientMeasureExt;	/* eml2_2ForGsoap.h:1400 */
class eml22__IlluminanceMeasure;	/* eml2_2ForGsoap.h:1402 */
class eml22__IlluminanceMeasureExt;	/* eml2_2ForGsoap.h:1404 */
class eml22__InductanceMeasure;	/* eml2_2ForGsoap.h:1406 */
class eml22__InductanceMeasureExt;	/* eml2_2ForGsoap.h:1408 */
class eml22__IsothermalCompressibilityMeasure;	/* eml2_2ForGsoap.h:1410 */
class eml22__IsothermalCompressibilityMeasureExt;	/* eml2_2ForGsoap.h:1412 */
class eml22__KinematicViscosityMeasure;	/* eml2_2ForGsoap.h:1414 */
class eml22__KinematicViscosityMeasureExt;	/* eml2_2ForGsoap.h:1416 */
class eml22__LengthMeasure;	/* eml2_2ForGsoap.h:1418 */
class eml22__LengthMeasureExt;	/* eml2_2ForGsoap.h:1420 */
class eml22__LengthOrTimeMeasureExt;	/* eml2_2ForGsoap.h:1422 */
class eml22__LengthPerLengthMeasure;	/* eml2_2ForGsoap.h:1424 */
class eml22__LengthPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1426 */
class eml22__LengthPerMassMeasure;	/* eml2_2ForGsoap.h:1428 */
class eml22__LengthPerMassMeasureExt;	/* eml2_2ForGsoap.h:1430 */
class eml22__LengthPerPressureMeasure;	/* eml2_2ForGsoap.h:1432 */
class eml22__LengthPerPressureMeasureExt;	/* eml2_2ForGsoap.h:1434 */
class eml22__LengthPerTemperatureMeasure;	/* eml2_2ForGsoap.h:1436 */
class eml22__LengthPerTemperatureMeasureExt;	/* eml2_2ForGsoap.h:1438 */
class eml22__LengthPerTimeMeasure;	/* eml2_2ForGsoap.h:1440 */
class eml22__LengthPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1442 */
class eml22__LengthPerVolumeMeasure;	/* eml2_2ForGsoap.h:1444 */
class eml22__LengthPerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1446 */
class eml22__LightExposureMeasure;	/* eml2_2ForGsoap.h:1448 */
class eml22__LightExposureMeasureExt;	/* eml2_2ForGsoap.h:1450 */
class eml22__LinearAccelerationMeasure;	/* eml2_2ForGsoap.h:1452 */
class eml22__LinearAccelerationMeasureExt;	/* eml2_2ForGsoap.h:1454 */
class eml22__LinearThermalExpansionMeasure;	/* eml2_2ForGsoap.h:1456 */
class eml22__LinearThermalExpansionMeasureExt;	/* eml2_2ForGsoap.h:1458 */
class eml22__LogarithmicPowerRatioMeasure;	/* eml2_2ForGsoap.h:1460 */
class eml22__LogarithmicPowerRatioMeasureExt;	/* eml2_2ForGsoap.h:1462 */
class eml22__LogarithmicPowerRatioPerLengthMeasure;	/* eml2_2ForGsoap.h:1464 */
class eml22__LogarithmicPowerRatioPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1466 */
class eml22__LuminanceMeasure;	/* eml2_2ForGsoap.h:1468 */
class eml22__LuminanceMeasureExt;	/* eml2_2ForGsoap.h:1470 */
class eml22__LuminousEfficacyMeasure;	/* eml2_2ForGsoap.h:1472 */
class eml22__LuminousEfficacyMeasureExt;	/* eml2_2ForGsoap.h:1474 */
class eml22__LuminousFluxMeasure;	/* eml2_2ForGsoap.h:1476 */
class eml22__LuminousFluxMeasureExt;	/* eml2_2ForGsoap.h:1478 */
class eml22__LuminousIntensityMeasure;	/* eml2_2ForGsoap.h:1480 */
class eml22__LuminousIntensityMeasureExt;	/* eml2_2ForGsoap.h:1482 */
class eml22__MagneticDipoleMomentMeasure;	/* eml2_2ForGsoap.h:1484 */
class eml22__MagneticDipoleMomentMeasureExt;	/* eml2_2ForGsoap.h:1486 */
class eml22__MagneticFieldStrengthMeasure;	/* eml2_2ForGsoap.h:1488 */
class eml22__MagneticFieldStrengthMeasureExt;	/* eml2_2ForGsoap.h:1490 */
class eml22__MagneticFluxDensityMeasure;	/* eml2_2ForGsoap.h:1492 */
class eml22__MagneticFluxDensityMeasureExt;	/* eml2_2ForGsoap.h:1494 */
class eml22__MagneticFluxDensityPerLengthMeasure;	/* eml2_2ForGsoap.h:1496 */
class eml22__MagneticFluxDensityPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1498 */
class eml22__MagneticFluxMeasure;	/* eml2_2ForGsoap.h:1500 */
class eml22__MagneticFluxMeasureExt;	/* eml2_2ForGsoap.h:1502 */
class eml22__MagneticPermeabilityMeasure;	/* eml2_2ForGsoap.h:1504 */
class eml22__MagneticPermeabilityMeasureExt;	/* eml2_2ForGsoap.h:1506 */
class eml22__MagneticVectorPotentialMeasure;	/* eml2_2ForGsoap.h:1508 */
class eml22__MagneticVectorPotentialMeasureExt;	/* eml2_2ForGsoap.h:1510 */
class eml22__MassLengthMeasure;	/* eml2_2ForGsoap.h:1512 */
class eml22__MassLengthMeasureExt;	/* eml2_2ForGsoap.h:1514 */
class eml22__MassMeasure;	/* eml2_2ForGsoap.h:1516 */
class eml22__MassMeasureExt;	/* eml2_2ForGsoap.h:1518 */
class eml22__MassPerAreaMeasure;	/* eml2_2ForGsoap.h:1520 */
class eml22__MassPerAreaMeasureExt;	/* eml2_2ForGsoap.h:1522 */
class eml22__MassPerEnergyMeasure;	/* eml2_2ForGsoap.h:1524 */
class eml22__MassPerEnergyMeasureExt;	/* eml2_2ForGsoap.h:1526 */
class eml22__MassPerLengthMeasure;	/* eml2_2ForGsoap.h:1528 */
class eml22__MassPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1530 */
class eml22__MassPerMassMeasure;	/* eml2_2ForGsoap.h:1532 */
class eml22__MassPerMassMeasureExt;	/* eml2_2ForGsoap.h:1534 */
class eml22__MassPerTimeMeasure;	/* eml2_2ForGsoap.h:1536 */
class eml22__MassPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1538 */
class eml22__MassPerTimePerAreaMeasure;	/* eml2_2ForGsoap.h:1540 */
class eml22__MassPerTimePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1542 */
class eml22__MassPerTimePerLengthMeasure;	/* eml2_2ForGsoap.h:1544 */
class eml22__MassPerTimePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1546 */
class eml22__MassPerVolumeMeasure;	/* eml2_2ForGsoap.h:1548 */
class eml22__MassPerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1550 */
class eml22__MassPerVolumePerLengthMeasure;	/* eml2_2ForGsoap.h:1552 */
class eml22__MassPerVolumePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1554 */
class eml22__MassPerVolumePerPressureMeasure;	/* eml2_2ForGsoap.h:1556 */
class eml22__MassPerVolumePerPressureMeasureExt;	/* eml2_2ForGsoap.h:1558 */
class eml22__MassPerVolumePerTemperatureMeasure;	/* eml2_2ForGsoap.h:1560 */
class eml22__MassPerVolumePerTemperatureMeasureExt;	/* eml2_2ForGsoap.h:1562 */
class eml22__MobilityMeasure;	/* eml2_2ForGsoap.h:1564 */
class eml22__MobilityMeasureExt;	/* eml2_2ForGsoap.h:1566 */
class eml22__MolarEnergyMeasure;	/* eml2_2ForGsoap.h:1568 */
class eml22__MolarEnergyMeasureExt;	/* eml2_2ForGsoap.h:1570 */
class eml22__MolarHeatCapacityMeasure;	/* eml2_2ForGsoap.h:1572 */
class eml22__MolarHeatCapacityMeasureExt;	/* eml2_2ForGsoap.h:1574 */
class eml22__MolarVolumeMeasure;	/* eml2_2ForGsoap.h:1576 */
class eml22__MolarVolumeMeasureExt;	/* eml2_2ForGsoap.h:1578 */
class eml22__MolecularWeightMeasure;	/* eml2_2ForGsoap.h:1580 */
class eml22__MolecularWeightMeasureExt;	/* eml2_2ForGsoap.h:1582 */
class eml22__MomentOfForceMeasure;	/* eml2_2ForGsoap.h:1584 */
class eml22__MomentOfForceMeasureExt;	/* eml2_2ForGsoap.h:1586 */
class eml22__MomentOfInertiaMeasure;	/* eml2_2ForGsoap.h:1588 */
class eml22__MomentOfInertiaMeasureExt;	/* eml2_2ForGsoap.h:1590 */
class eml22__MomentumMeasure;	/* eml2_2ForGsoap.h:1592 */
class eml22__MomentumMeasureExt;	/* eml2_2ForGsoap.h:1594 */
class eml22__NormalizedPowerMeasure;	/* eml2_2ForGsoap.h:1596 */
class eml22__NormalizedPowerMeasureExt;	/* eml2_2ForGsoap.h:1598 */
class eml22__PermeabilityLengthMeasure;	/* eml2_2ForGsoap.h:1600 */
class eml22__PermeabilityLengthMeasureExt;	/* eml2_2ForGsoap.h:1602 */
class eml22__PermeabilityRockMeasure;	/* eml2_2ForGsoap.h:1604 */
class eml22__PermeabilityRockMeasureExt;	/* eml2_2ForGsoap.h:1606 */
class eml22__PermittivityMeasure;	/* eml2_2ForGsoap.h:1608 */
class eml22__PermittivityMeasureExt;	/* eml2_2ForGsoap.h:1610 */
class eml22__PlaneAngleMeasure;	/* eml2_2ForGsoap.h:1612 */
class eml22__PlaneAngleMeasureExt;	/* eml2_2ForGsoap.h:1614 */
class eml22__PotentialDifferencePerPowerDropMeasure;	/* eml2_2ForGsoap.h:1616 */
class eml22__PotentialDifferencePerPowerDropMeasureExt;	/* eml2_2ForGsoap.h:1618 */
class eml22__PowerMeasure;	/* eml2_2ForGsoap.h:1620 */
class eml22__PowerMeasureExt;	/* eml2_2ForGsoap.h:1622 */
class eml22__PowerPerAreaMeasure;	/* eml2_2ForGsoap.h:1624 */
class eml22__PowerPerAreaMeasureExt;	/* eml2_2ForGsoap.h:1626 */
class eml22__PowerPerPowerMeasure;	/* eml2_2ForGsoap.h:1628 */
class eml22__PowerPerPowerMeasureExt;	/* eml2_2ForGsoap.h:1630 */
class eml22__PowerPerVolumeMeasure;	/* eml2_2ForGsoap.h:1632 */
class eml22__PowerPerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1634 */
class eml22__PressureMeasure;	/* eml2_2ForGsoap.h:1636 */
class eml22__PressureMeasureExt;	/* eml2_2ForGsoap.h:1638 */
class eml22__PressurePerPressureMeasure;	/* eml2_2ForGsoap.h:1640 */
class eml22__PressurePerPressureMeasureExt;	/* eml2_2ForGsoap.h:1642 */
class eml22__PressurePerTimeMeasure;	/* eml2_2ForGsoap.h:1644 */
class eml22__PressurePerTimeMeasureExt;	/* eml2_2ForGsoap.h:1646 */
class eml22__PressurePerVolumeMeasure;	/* eml2_2ForGsoap.h:1648 */
class eml22__PressurePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1650 */
class eml22__PressureSquaredMeasure;	/* eml2_2ForGsoap.h:1652 */
class eml22__PressureSquaredMeasureExt;	/* eml2_2ForGsoap.h:1654 */
class eml22__PressureSquaredPerForceTimePerAreaMeasure;	/* eml2_2ForGsoap.h:1656 */
class eml22__PressureSquaredPerForceTimePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1658 */
class eml22__PressureTimePerVolumeMeasure;	/* eml2_2ForGsoap.h:1660 */
class eml22__PressureTimePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1662 */
class eml22__QuantityOfLightMeasure;	/* eml2_2ForGsoap.h:1664 */
class eml22__QuantityOfLightMeasureExt;	/* eml2_2ForGsoap.h:1666 */
class eml22__RadianceMeasure;	/* eml2_2ForGsoap.h:1668 */
class eml22__RadianceMeasureExt;	/* eml2_2ForGsoap.h:1670 */
class eml22__RadiantIntensityMeasure;	/* eml2_2ForGsoap.h:1672 */
class eml22__RadiantIntensityMeasureExt;	/* eml2_2ForGsoap.h:1674 */
class eml22__ReciprocalAreaMeasure;	/* eml2_2ForGsoap.h:1676 */
class eml22__ReciprocalAreaMeasureExt;	/* eml2_2ForGsoap.h:1678 */
class eml22__ReciprocalElectricPotentialDifferenceMeasure;	/* eml2_2ForGsoap.h:1680 */
class eml22__ReciprocalElectricPotentialDifferenceMeasureExt;	/* eml2_2ForGsoap.h:1682 */
class eml22__ReciprocalForceMeasure;	/* eml2_2ForGsoap.h:1684 */
class eml22__ReciprocalForceMeasureExt;	/* eml2_2ForGsoap.h:1686 */
class eml22__ReciprocalLengthMeasure;	/* eml2_2ForGsoap.h:1688 */
class eml22__ReciprocalLengthMeasureExt;	/* eml2_2ForGsoap.h:1690 */
class eml22__ReciprocalMassMeasure;	/* eml2_2ForGsoap.h:1692 */
class eml22__ReciprocalMassMeasureExt;	/* eml2_2ForGsoap.h:1694 */
class eml22__ReciprocalMassTimeMeasure;	/* eml2_2ForGsoap.h:1696 */
class eml22__ReciprocalMassTimeMeasureExt;	/* eml2_2ForGsoap.h:1698 */
class eml22__ReciprocalPressureMeasure;	/* eml2_2ForGsoap.h:1700 */
class eml22__ReciprocalPressureMeasureExt;	/* eml2_2ForGsoap.h:1702 */
class eml22__ReciprocalTimeMeasure;	/* eml2_2ForGsoap.h:1704 */
class eml22__ReciprocalTimeMeasureExt;	/* eml2_2ForGsoap.h:1706 */
class eml22__ReciprocalVolumeMeasure;	/* eml2_2ForGsoap.h:1708 */
class eml22__ReciprocalVolumeMeasureExt;	/* eml2_2ForGsoap.h:1710 */
class eml22__ReluctanceMeasure;	/* eml2_2ForGsoap.h:1712 */
class eml22__ReluctanceMeasureExt;	/* eml2_2ForGsoap.h:1714 */
class eml22__SecondMomentOfAreaMeasure;	/* eml2_2ForGsoap.h:1716 */
class eml22__SecondMomentOfAreaMeasureExt;	/* eml2_2ForGsoap.h:1718 */
class eml22__SignalingEventPerTimeMeasure;	/* eml2_2ForGsoap.h:1720 */
class eml22__SignalingEventPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1722 */
class eml22__SolidAngleMeasure;	/* eml2_2ForGsoap.h:1724 */
class eml22__SolidAngleMeasureExt;	/* eml2_2ForGsoap.h:1726 */
class eml22__SpecificHeatCapacityMeasure;	/* eml2_2ForGsoap.h:1728 */
class eml22__SpecificHeatCapacityMeasureExt;	/* eml2_2ForGsoap.h:1730 */
class eml22__TemperatureIntervalMeasure;	/* eml2_2ForGsoap.h:1732 */
class eml22__TemperatureIntervalMeasureExt;	/* eml2_2ForGsoap.h:1734 */
class eml22__TemperatureIntervalPerLengthMeasure;	/* eml2_2ForGsoap.h:1736 */
class eml22__TemperatureIntervalPerLengthMeasureExt;	/* eml2_2ForGsoap.h:1738 */
class eml22__TemperatureIntervalPerPressureMeasure;	/* eml2_2ForGsoap.h:1740 */
class eml22__TemperatureIntervalPerPressureMeasureExt;	/* eml2_2ForGsoap.h:1742 */
class eml22__TemperatureIntervalPerTimeMeasure;	/* eml2_2ForGsoap.h:1744 */
class eml22__TemperatureIntervalPerTimeMeasureExt;	/* eml2_2ForGsoap.h:1746 */
class eml22__ThermalConductanceMeasure;	/* eml2_2ForGsoap.h:1748 */
class eml22__ThermalConductanceMeasureExt;	/* eml2_2ForGsoap.h:1750 */
class eml22__ThermalConductivityMeasure;	/* eml2_2ForGsoap.h:1752 */
class eml22__ThermalConductivityMeasureExt;	/* eml2_2ForGsoap.h:1754 */
class eml22__ThermalDiffusivityMeasure;	/* eml2_2ForGsoap.h:1756 */
class eml22__ThermalDiffusivityMeasureExt;	/* eml2_2ForGsoap.h:1758 */
class eml22__ThermalInsulanceMeasure;	/* eml2_2ForGsoap.h:1760 */
class eml22__ThermalInsulanceMeasureExt;	/* eml2_2ForGsoap.h:1762 */
class eml22__ThermalResistanceMeasure;	/* eml2_2ForGsoap.h:1764 */
class eml22__ThermalResistanceMeasureExt;	/* eml2_2ForGsoap.h:1766 */
class eml22__ThermodynamicTemperatureMeasure;	/* eml2_2ForGsoap.h:1768 */
class eml22__ThermodynamicTemperatureMeasureExt;	/* eml2_2ForGsoap.h:1770 */
class eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure;	/* eml2_2ForGsoap.h:1772 */
class eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt;	/* eml2_2ForGsoap.h:1774 */
class eml22__TimeMeasure;	/* eml2_2ForGsoap.h:1776 */
class eml22__TimeMeasureExt;	/* eml2_2ForGsoap.h:1778 */
class eml22__TimePerLengthMeasure;	/* eml2_2ForGsoap.h:1780 */
class eml22__TimePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1782 */
class eml22__TimePerMassMeasure;	/* eml2_2ForGsoap.h:1784 */
class eml22__TimePerMassMeasureExt;	/* eml2_2ForGsoap.h:1786 */
class eml22__TimePerTimeMeasure;	/* eml2_2ForGsoap.h:1788 */
class eml22__TimePerTimeMeasureExt;	/* eml2_2ForGsoap.h:1790 */
class eml22__TimePerVolumeMeasure;	/* eml2_2ForGsoap.h:1792 */
class eml22__TimePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1794 */
class eml22__UnitlessMeasure;	/* eml2_2ForGsoap.h:1796 */
class eml22__VerticalCoordinateMeasure;	/* eml2_2ForGsoap.h:1798 */
class eml22__VerticalCoordinateMeasureExt;	/* eml2_2ForGsoap.h:1800 */
class eml22__VolumeFlowRatePerVolumeFlowRateMeasure;	/* eml2_2ForGsoap.h:1802 */
class eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt;	/* eml2_2ForGsoap.h:1804 */
class eml22__VolumeMeasure;	/* eml2_2ForGsoap.h:1806 */
class eml22__VolumeMeasureExt;	/* eml2_2ForGsoap.h:1808 */
class eml22__VolumePerAreaMeasure;	/* eml2_2ForGsoap.h:1810 */
class eml22__VolumePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1812 */
class eml22__VolumePerLengthMeasure;	/* eml2_2ForGsoap.h:1814 */
class eml22__VolumePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1816 */
class eml22__VolumePerMassMeasure;	/* eml2_2ForGsoap.h:1818 */
class eml22__VolumePerMassMeasureExt;	/* eml2_2ForGsoap.h:1820 */
class eml22__VolumePerPressureMeasure;	/* eml2_2ForGsoap.h:1822 */
class eml22__VolumePerPressureMeasureExt;	/* eml2_2ForGsoap.h:1824 */
class eml22__VolumePerRotationMeasure;	/* eml2_2ForGsoap.h:1826 */
class eml22__VolumePerRotationMeasureExt;	/* eml2_2ForGsoap.h:1828 */
class eml22__VolumePerTimeLengthMeasure;	/* eml2_2ForGsoap.h:1830 */
class eml22__VolumePerTimeLengthMeasureExt;	/* eml2_2ForGsoap.h:1832 */
class eml22__VolumePerTimeMeasure;	/* eml2_2ForGsoap.h:1834 */
class eml22__VolumePerTimeMeasureExt;	/* eml2_2ForGsoap.h:1836 */
class eml22__VolumePerTimePerAreaMeasure;	/* eml2_2ForGsoap.h:1838 */
class eml22__VolumePerTimePerAreaMeasureExt;	/* eml2_2ForGsoap.h:1840 */
class eml22__VolumePerTimePerLengthMeasure;	/* eml2_2ForGsoap.h:1842 */
class eml22__VolumePerTimePerLengthMeasureExt;	/* eml2_2ForGsoap.h:1844 */
class eml22__VolumePerTimePerPressureLengthMeasure;	/* eml2_2ForGsoap.h:1846 */
class eml22__VolumePerTimePerPressureLengthMeasureExt;	/* eml2_2ForGsoap.h:1848 */
class eml22__VolumePerTimePerPressureMeasure;	/* eml2_2ForGsoap.h:1850 */
class eml22__VolumePerTimePerPressureMeasureExt;	/* eml2_2ForGsoap.h:1852 */
class eml22__VolumePerTimePerTimeMeasure;	/* eml2_2ForGsoap.h:1854 */
class eml22__VolumePerTimePerTimeMeasureExt;	/* eml2_2ForGsoap.h:1856 */
class eml22__VolumePerTimePerVolumeMeasure;	/* eml2_2ForGsoap.h:1858 */
class eml22__VolumePerTimePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1860 */
class eml22__VolumePerVolumeMeasure;	/* eml2_2ForGsoap.h:1862 */
class eml22__VolumePerVolumeMeasureExt;	/* eml2_2ForGsoap.h:1864 */
class eml22__VolumetricHeatTransferCoefficientMeasure;	/* eml2_2ForGsoap.h:1866 */
class eml22__VolumetricHeatTransferCoefficientMeasureExt;	/* eml2_2ForGsoap.h:1868 */
class eml22__VolumetricThermalExpansionMeasure;	/* eml2_2ForGsoap.h:1870 */
class eml22__VolumetricThermalExpansionMeasureExt;	/* eml2_2ForGsoap.h:1872 */
class eml22__ReferencePressure;	/* eml2_2ForGsoap.h:1920 */
class eml22__DistanceEastWest;	/* eml2_2ForGsoap.h:1936 */
class eml22__DistanceNorthSouth;	/* eml2_2ForGsoap.h:1938 */
class prodml21__AbstractCorrelationViscosityDeadModel;	/* eml2_2ForGsoap.h:168 */
class prodml21__AbstractCorrelationGasViscosityModel;	/* eml2_2ForGsoap.h:176 */
class prodml21__AbstractCorrelationViscosityBubblePointModel;	/* eml2_2ForGsoap.h:178 */
class prodml21__AbstractCorrelationViscosityUndersaturatedModel;	/* eml2_2ForGsoap.h:182 */
class prodml21__CSPedersen84;	/* eml2_2ForGsoap.h:206 */
class prodml21__CSPedersen87;	/* eml2_2ForGsoap.h:208 */
class prodml21__FrictionTheory;	/* eml2_2ForGsoap.h:246 */
class prodml21__Lohrenz_Bray_ClarkCorrelation;	/* eml2_2ForGsoap.h:250 */
class prodml21__PengRobinson76_USCOREEOS;	/* eml2_2ForGsoap.h:256 */
class prodml21__PengRobinson78_USCOREEOS;	/* eml2_2ForGsoap.h:258 */
class prodml21__Srk_USCOREEOS;	/* eml2_2ForGsoap.h:274 */
class prodml21__EmailQualifierStruct;	/* eml2_2ForGsoap.h:294 */
class prodml21__NameStruct;	/* eml2_2ForGsoap.h:332 */
class prodml21__OilCompressibility;	/* eml2_2ForGsoap.h:518 */
class prodml21__RefInjectedGasAdded;	/* eml2_2ForGsoap.h:536 */
class prodml21__RelativeVolumeRatio;	/* eml2_2ForGsoap.h:538 */
class prodml21__SaturationPressure;	/* eml2_2ForGsoap.h:550 */
class prodml21__SaturationTemperature;	/* eml2_2ForGsoap.h:552 */
class eml22__AuthorityQualifiedName;	/* eml2_2ForGsoap.h:1088 */
class eml22__FloatingPointConstantArray;	/* eml2_2ForGsoap.h:1104 */
class eml22__FloatingPointExternalArray;	/* eml2_2ForGsoap.h:1106 */
class eml22__FloatingPointLatticeArray;	/* eml2_2ForGsoap.h:1108 */
class eml22__IntegerArrayFromBooleanMaskArray;	/* eml2_2ForGsoap.h:1112 */
class eml22__IntegerConstantArray;	/* eml2_2ForGsoap.h:1114 */
class eml22__IntegerExternalArray;	/* eml2_2ForGsoap.h:1116 */
class eml22__IntegerLatticeArray;	/* eml2_2ForGsoap.h:1118 */
class eml22__IntegerRangeArray;	/* eml2_2ForGsoap.h:1120 */
class eml22__StringMeasure;	/* eml2_2ForGsoap.h:1132 */
class prodml21__BerganAndSutton_Undersaturated;	/* eml2_2ForGsoap.h:188 */
class prodml21__BerganSutton_Dead;	/* eml2_2ForGsoap.h:190 */
class prodml21__BergmanSutton_BubblePoint;	/* eml2_2ForGsoap.h:192 */
class prodml21__CarrDempsey;	/* eml2_2ForGsoap.h:198 */
class prodml21__DeGhetto_BubblePoint;	/* eml2_2ForGsoap.h:214 */
class prodml21__DeGhetto_Dead;	/* eml2_2ForGsoap.h:216 */
class prodml21__DeGhetto_Undersaturated;	/* eml2_2ForGsoap.h:218 */
class prodml21__DindorukChristman_BubblePoint;	/* eml2_2ForGsoap.h:220 */
class prodml21__DindorukChristman_Dead;	/* eml2_2ForGsoap.h:222 */
class prodml21__DindorukChristman_Undersaturated;	/* eml2_2ForGsoap.h:224 */
class prodml21__LeeGonzalez;	/* eml2_2ForGsoap.h:248 */
class prodml21__LondonoArcherBlasinggame;	/* eml2_2ForGsoap.h:252 */
class prodml21__Lucas;	/* eml2_2ForGsoap.h:254 */
class prodml21__PetroskyFarshad_BubblePoint;	/* eml2_2ForGsoap.h:260 */
class prodml21__PetroskyFarshad_Dead;	/* eml2_2ForGsoap.h:262 */
class prodml21__PetroskyFarshad_Undersaturated;	/* eml2_2ForGsoap.h:264 */
class prodml21__Standing_BubblePoint;	/* eml2_2ForGsoap.h:276 */
class prodml21__Standing_Dead;	/* eml2_2ForGsoap.h:278 */
class prodml21__Standing_Undersaturated;	/* eml2_2ForGsoap.h:280 */
class eml22__DoubleExternalArray;	/* eml2_2ForGsoap.h:1098 */
class eml22__FloatExternalArray;	/* eml2_2ForGsoap.h:1102 */

/* custom/struct_tm.h:57 */
#ifndef SOAP_TYPE_gsoap_eml2_2_tm
#define SOAP_TYPE_gsoap_eml2_2_tm (-8)
#if 0 /* Volatile: declared external of the data binding interface and not redeclared here */
struct SOAP_CMAC tm {
      public:
        /** Required element 'tm-sec' of XML schema type 'xsd:int' */
        int tm_sec;
        /** Required element 'tm-min' of XML schema type 'xsd:int' */
        int tm_min;
        /** Required element 'tm-hour' of XML schema type 'xsd:int' */
        int tm_hour;
        /** Required element 'tm-mday' of XML schema type 'xsd:int' */
        int tm_mday;
        /** Required element 'tm-mon' of XML schema type 'xsd:int' */
        int tm_mon;
        /** Required element 'tm-year' of XML schema type 'xsd:int' */
        int tm_year;
        /** Required element 'tm-isdst' of XML schema type 'xsd:int' */
        int tm_isdst;
};
#endif
#endif

/* eml2_2ForGsoap.h:184 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel (-27)
/* complex XML schema type 'prodml21:AbstractPvtModel': */
class SOAP_CMAC prodml21__AbstractPvtModel {
      public:
        /// Optional element 'prodml21:CustomPvtModelExtension' of XML schema type 'prodml21:CustomPvtModelExtension'
        prodml21__CustomPvtModelExtension *CustomPvtModelExtension;
        /// Optional element 'prodml21:PvtModelParameterSet' of XML schema type 'prodml21:PvtModelParameterSet'
        prodml21__PvtModelParameterSet *PvtModelParameterSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractPvtModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractPvtModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractPvtModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractPvtModel() : CustomPvtModelExtension(), PvtModelParameterSet(), soap() { }
        virtual ~prodml21__AbstractPvtModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractPvtModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractPvtModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractPvtModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:186 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo (-28)
/* complex XML schema type 'prodml21:ApplicationInfo': */
class SOAP_CMAC prodml21__ApplicationInfo {
      public:
        /// Optional element 'prodml21:ApplicationName' of XML schema type 'eml22:String64'
        std::vector<std::string> ApplicationName;
        /// Optional attribute 'version' of XML schema type 'eml22:String64'
        std::string *version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ApplicationInfo, default initialized and not managed by a soap context
        virtual prodml21__ApplicationInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ApplicationInfo); }
      public:
        /// Constructor with default initializations
        prodml21__ApplicationInfo() : ApplicationName(), version(), soap() { }
        virtual ~prodml21__ApplicationInfo() { }
        /// Friend allocator used by soap_new_prodml21__ApplicationInfo(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ApplicationInfo * SOAP_FMAC2 soap_instantiate_prodml21__ApplicationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:196 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet (-33)
/* complex XML schema type 'prodml21:BinaryInteractionCoefficientSet': */
class SOAP_CMAC prodml21__BinaryInteractionCoefficientSet {
      public:
        /// Required element 'prodml21:BinaryInteractionCoefficient' of XML schema type 'prodml21:BinaryInteractionCoefficient'
        std::vector<prodml21__BinaryInteractionCoefficient *> BinaryInteractionCoefficient;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BinaryInteractionCoefficientSet, default initialized and not managed by a soap context
        virtual prodml21__BinaryInteractionCoefficientSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BinaryInteractionCoefficientSet); }
      public:
        /// Constructor with default initializations
        prodml21__BinaryInteractionCoefficientSet() : BinaryInteractionCoefficient(), soap() { }
        virtual ~prodml21__BinaryInteractionCoefficientSet() { }
        /// Friend allocator used by soap_new_prodml21__BinaryInteractionCoefficientSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BinaryInteractionCoefficientSet * SOAP_FMAC2 soap_instantiate_prodml21__BinaryInteractionCoefficientSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:200 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet (-35)
/* complex XML schema type 'prodml21:ComponentPropertySet': */
class SOAP_CMAC prodml21__ComponentPropertySet {
      public:
        /// Required element 'prodml21:FluidComponentProperty' of XML schema type 'prodml21:FluidComponentProperty'
        std::vector<prodml21__FluidComponentProperty *> FluidComponentProperty;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ComponentPropertySet, default initialized and not managed by a soap context
        virtual prodml21__ComponentPropertySet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ComponentPropertySet); }
      public:
        /// Constructor with default initializations
        prodml21__ComponentPropertySet() : FluidComponentProperty(), soap() { }
        virtual ~prodml21__ComponentPropertySet() { }
        /// Friend allocator used by soap_new_prodml21__ComponentPropertySet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ComponentPropertySet * SOAP_FMAC2 soap_instantiate_prodml21__ComponentPropertySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:210 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension (-40)
/* complex XML schema type 'prodml21:CustomPvtModelExtension': */
class SOAP_CMAC prodml21__CustomPvtModelExtension {
      public:
        /// Optional element 'prodml21:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Optional element 'prodml21:CustomPvtModelParameter' of XML schema type 'prodml21:CustomPvtModelParameter'
        std::vector<prodml21__CustomPvtModelParameter *> CustomPvtModelParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomPvtModelExtension, default initialized and not managed by a soap context
        virtual prodml21__CustomPvtModelExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomPvtModelExtension); }
      public:
        /// Constructor with default initializations
        prodml21__CustomPvtModelExtension() : Description(), CustomPvtModelParameter(), soap() { }
        virtual ~prodml21__CustomPvtModelExtension() { }
        /// Friend allocator used by soap_new_prodml21__CustomPvtModelExtension(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomPvtModelExtension * SOAP_FMAC2 soap_instantiate_prodml21__CustomPvtModelExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:212 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter (-41)
/* complex XML schema type 'prodml21:CustomPvtModelParameter': */
class SOAP_CMAC prodml21__CustomPvtModelParameter {
      public:
        /// Required element 'prodml21:CustomParameterValue' of XML schema type 'eml22:ExtensionNameValue'
        eml22__ExtensionNameValue *CustomParameterValue;
        /// Optional attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string *fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomPvtModelParameter, default initialized and not managed by a soap context
        virtual prodml21__CustomPvtModelParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomPvtModelParameter); }
      public:
        /// Constructor with default initializations
        prodml21__CustomPvtModelParameter() : CustomParameterValue(), fluidComponentReference(), soap() { }
        virtual ~prodml21__CustomPvtModelParameter() { }
        /// Friend allocator used by soap_new_prodml21__CustomPvtModelParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomPvtModelParameter * SOAP_FMAC2 soap_instantiate_prodml21__CustomPvtModelParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:228 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel (-49)
/* complex XML schema type 'prodml21:FluidCharacterizationModel': */
class SOAP_CMAC prodml21__FluidCharacterizationModel {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:ReferencePressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *ReferencePressure;
        /// Optional element 'prodml21:ReferenceStockTankPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *ReferenceStockTankPressure;
        /// Optional element 'prodml21:ReferenceTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReferenceTemperature;
        /// Optional element 'prodml21:ReferenceStockTankTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReferenceStockTankTemperature;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:ModelSpecification' of XML schema type 'prodml21:AbstractPvtModel'
        prodml21__AbstractPvtModel *ModelSpecification;
        /// Optional element 'prodml21:FluidCharacterizationTable' of XML schema type 'prodml21:FluidCharacterizationTable'
        std::vector<prodml21__FluidCharacterizationTable *> FluidCharacterizationTable;
        /// Optional element 'prodml21:ReferenceSeparatorStage' of XML schema type 'prodml21:ReferenceSeparatorStage'
        std::vector<prodml21__ReferenceSeparatorStage *> ReferenceSeparatorStage;
        /// Optional element 'prodml21:FluidCharacterizationParameterSet' of XML schema type 'prodml21:FluidCharacterizationParameterSet'
        prodml21__FluidCharacterizationParameterSet *FluidCharacterizationParameterSet;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationModel, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationModel); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationModel() : Name(), ReferencePressure(), ReferenceStockTankPressure(), ReferenceTemperature(), ReferenceStockTankTemperature(), Remark(), ModelSpecification(), FluidCharacterizationTable(), ReferenceSeparatorStage(), FluidCharacterizationParameterSet(), uid(), soap() { }
        virtual ~prodml21__FluidCharacterizationModel() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationModel * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:230 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter (-50)
/* complex XML schema type 'prodml21:FluidCharacterizationParameter': */
class SOAP_CMAC prodml21__FluidCharacterizationParameter {
      public:
        /// Required element 'prodml21:Property' of XML schema type 'prodml21:OutputFluidPropertyExt'
        std::string Property;
        /// Optional element 'prodml21:KeywordAlias' of XML schema type 'eml22:ObjectAlias'
        std::vector<eml22__ObjectAlias *> KeywordAlias;
        /// Optional element 'prodml21:Phase' of XML schema type 'prodml21:ThermodynamicPhase'
        prodml21__ThermodynamicPhase *Phase;
        /// Optional attribute 'name' of XML schema type 'eml22:String64'
        std::string *name;
        /// Required attribute 'value' of XML schema type 'xsd:double'
        double value;
        /// Required attribute 'uom' of XML schema type 'eml22:String64'
        std::string uom;
        /// Optional attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string *fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationParameter, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationParameter); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationParameter() : Property(), KeywordAlias(), Phase(), name(), value(), uom(), fluidComponentReference(), soap() { }
        virtual ~prodml21__FluidCharacterizationParameter() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationParameter * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:232 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet (-51)
/* complex XML schema type 'prodml21:FluidCharacterizationParameterSet': */
class SOAP_CMAC prodml21__FluidCharacterizationParameterSet {
      public:
        /// Required element 'prodml21:FluidCharacterizationParameter' of XML schema type 'prodml21:FluidCharacterizationParameter'
        std::vector<prodml21__FluidCharacterizationParameter *> FluidCharacterizationParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationParameterSet, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationParameterSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationParameterSet); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationParameterSet() : FluidCharacterizationParameter(), soap() { }
        virtual ~prodml21__FluidCharacterizationParameterSet() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationParameterSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationParameterSet * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationParameterSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:234 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource (-52)
/* complex XML schema type 'prodml21:FluidCharacterizationSource': */
class SOAP_CMAC prodml21__FluidCharacterizationSource {
      public:
        /// Optional element 'prodml21:FluidAnalysisTestReference' of XML schema type 'eml22:String64'
        std::vector<std::string> FluidAnalysisTestReference;
        /// Optional element 'prodml21:FluidAnalysis' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidAnalysis;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationSource, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationSource); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationSource() : FluidAnalysisTestReference(), FluidAnalysis(), soap() { }
        virtual ~prodml21__FluidCharacterizationSource() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationSource(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationSource * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:236 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable (-53)
/* complex XML schema type 'prodml21:FluidCharacterizationTable': */
class SOAP_CMAC prodml21__FluidCharacterizationTable {
      public:
        /// Optional element 'prodml21:TableConstant' of XML schema type 'prodml21:FluidCharacterizationParameter'
        std::vector<prodml21__FluidCharacterizationParameter *> TableConstant;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required element 'prodml21:TableRow' of XML schema type 'prodml21:FluidCharacterizationTableRow'
        std::vector<prodml21__FluidCharacterizationTableRow *> TableRow;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Required attribute 'tableFormat' of XML schema type 'eml22:String64'
        std::string tableFormat;
        /// Required attribute 'name' of XML schema type 'eml22:String64'
        std::string name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationTable, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationTable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationTable); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationTable() : TableConstant(), Remark(), TableRow(), uid(), tableFormat(), name(), soap() { }
        virtual ~prodml21__FluidCharacterizationTable() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationTable(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationTable * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationTable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:238 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn (-54)
/* complex XML schema type 'prodml21:FluidCharacterizationTableColumn': */
class SOAP_CMAC prodml21__FluidCharacterizationTableColumn {
      public:
        /// Required element 'prodml21:Property' of XML schema type 'prodml21:OutputFluidPropertyExt'
        std::string Property;
        /// Optional element 'prodml21:KeywordAlias' of XML schema type 'eml22:ObjectAlias'
        std::vector<eml22__ObjectAlias *> KeywordAlias;
        /// Optional element 'prodml21:Phase' of XML schema type 'prodml21:ThermodynamicPhase'
        prodml21__ThermodynamicPhase *Phase;
        /// Optional attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string *fluidComponentReference;
        /// Optional attribute 'name' of XML schema type 'eml22:String64'
        std::string *name;
        /// Optional attribute 'sequence' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *sequence;
        /// Required attribute 'uom' of XML schema type 'eml22:String64'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationTableColumn, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationTableColumn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationTableColumn); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationTableColumn() : Property(), KeywordAlias(), Phase(), fluidComponentReference(), name(), sequence(), uom(), soap() { }
        virtual ~prodml21__FluidCharacterizationTableColumn() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationTableColumn(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationTableColumn * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationTableColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:240 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat (-55)
/* complex XML schema type 'prodml21:FluidCharacterizationTableFormat': */
class SOAP_CMAC prodml21__FluidCharacterizationTableFormat {
      public:
        /// Optional element 'prodml21:NullValue' of XML schema type 'eml22:String64'
        std::string *NullValue;
        /// Optional element 'prodml21:Delimiter' of XML schema type 'prodml21:TableDelimiter'
        prodml21__TableDelimiter *Delimiter;
        /// Required element 'prodml21:TableColumn' of XML schema type 'prodml21:FluidCharacterizationTableColumn'
        std::vector<prodml21__FluidCharacterizationTableColumn *> TableColumn;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationTableFormat, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationTableFormat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationTableFormat); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationTableFormat() : NullValue(), Delimiter(), TableColumn(), uid(), soap() { }
        virtual ~prodml21__FluidCharacterizationTableFormat() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationTableFormat(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationTableFormat * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationTableFormat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:242 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet (-56)
/* complex XML schema type 'prodml21:FluidCharacterizationTableFormatSet': */
class SOAP_CMAC prodml21__FluidCharacterizationTableFormatSet {
      public:
        /// Required element 'prodml21:FluidCharacterizationTableFormat' of XML schema type 'prodml21:FluidCharacterizationTableFormat'
        std::vector<prodml21__FluidCharacterizationTableFormat *> FluidCharacterizationTableFormat;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationTableFormatSet, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationTableFormatSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationTableFormatSet); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationTableFormatSet() : FluidCharacterizationTableFormat(), soap() { }
        virtual ~prodml21__FluidCharacterizationTableFormatSet() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationTableFormatSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationTableFormatSet * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationTableFormatSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:244 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty (-57)
/* complex XML schema type 'prodml21:FluidComponentProperty': */
class SOAP_CMAC prodml21__FluidComponentProperty {
      public:
        /// Optional element 'prodml21:CriticalPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *CriticalPressure;
        /// Optional element 'prodml21:CriticalTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *CriticalTemperature;
        /// Optional element 'prodml21:CriticalViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *CriticalViscosity;
        /// Optional element 'prodml21:CompactVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *CompactVolume;
        /// Optional element 'prodml21:CriticalVolume' of XML schema type 'eml22:MolarVolumeMeasure'
        eml22__MolarVolumeMeasure *CriticalVolume;
        /// Optional element 'prodml21:AcentricFactor' of XML schema type 'xsd:double'
        double *AcentricFactor;
        /// Optional element 'prodml21:MassDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *MassDensity;
        /// Optional element 'prodml21:OmegaA' of XML schema type 'xsd:double'
        double *OmegaA;
        /// Optional element 'prodml21:OmegaB' of XML schema type 'xsd:double'
        double *OmegaB;
        /// Optional element 'prodml21:VolumeShiftParameter' of XML schema type 'xsd:double'
        double *VolumeShiftParameter;
        /// Optional element 'prodml21:PartialMolarDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *PartialMolarDensity;
        /// Optional element 'prodml21:Parachor' of XML schema type 'xsd:double'
        double *Parachor;
        /// Optional element 'prodml21:PartialMolarVolume' of XML schema type 'eml22:MolarVolumeMeasure'
        eml22__MolarVolumeMeasure *PartialMolarVolume;
        /// Optional element 'prodml21:ReferenceDensityZJ' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *ReferenceDensityZJ;
        /// Optional element 'prodml21:ReferenceGravityZJ' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *ReferenceGravityZJ;
        /// Optional element 'prodml21:ReferenceTemperatureZJ' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReferenceTemperatureZJ;
        /// Optional element 'prodml21:ViscousCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasure'
        eml22__ReciprocalPressureMeasure *ViscousCompressibility;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidComponentProperty, default initialized and not managed by a soap context
        virtual prodml21__FluidComponentProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidComponentProperty); }
      public:
        /// Constructor with default initializations
        prodml21__FluidComponentProperty() : CriticalPressure(), CriticalTemperature(), CriticalViscosity(), CompactVolume(), CriticalVolume(), AcentricFactor(), MassDensity(), OmegaA(), OmegaB(), VolumeShiftParameter(), PartialMolarDensity(), Parachor(), PartialMolarVolume(), ReferenceDensityZJ(), ReferenceGravityZJ(), ReferenceTemperatureZJ(), ViscousCompressibility(), Remark(), fluidComponentReference(), soap() { }
        virtual ~prodml21__FluidComponentProperty() { }
        /// Friend allocator used by soap_new_prodml21__FluidComponentProperty(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidComponentProperty * SOAP_FMAC2 soap_instantiate_prodml21__FluidComponentProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:266 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter (-68)
/* complex XML schema type 'prodml21:PrsvParameter': */
class SOAP_CMAC prodml21__PrsvParameter {
      public:
        /// Required element 'prodml21:a1' of XML schema type 'xsd:double'
        double a1;
        /// Required element 'prodml21:a2' of XML schema type 'xsd:double'
        double a2;
        /// Required element 'prodml21:b1' of XML schema type 'xsd:double'
        double b1;
        /// Required element 'prodml21:b2' of XML schema type 'xsd:double'
        double b2;
        /// Required element 'prodml21:c2' of XML schema type 'xsd:double'
        double c2;
        /// Required attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PrsvParameter, default initialized and not managed by a soap context
        virtual prodml21__PrsvParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PrsvParameter); }
      public:
        /// Constructor with default initializations
        prodml21__PrsvParameter() : a1(), a2(), b1(), b2(), c2(), fluidComponentReference(), soap() { }
        virtual ~prodml21__PrsvParameter() { }
        /// Friend allocator used by soap_new_prodml21__PrsvParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PrsvParameter * SOAP_FMAC2 soap_instantiate_prodml21__PrsvParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:270 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet (-70)
/* complex XML schema type 'prodml21:PvtModelParameterSet': */
class SOAP_CMAC prodml21__PvtModelParameterSet {
      public:
        /// Required element 'prodml21:Coefficient' of XML schema type 'prodml21:PvtModelParameter'
        std::vector<prodml21__PvtModelParameter *> Coefficient;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PvtModelParameterSet, default initialized and not managed by a soap context
        virtual prodml21__PvtModelParameterSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PvtModelParameterSet); }
      public:
        /// Constructor with default initializations
        prodml21__PvtModelParameterSet() : Coefficient(), soap() { }
        virtual ~prodml21__PvtModelParameterSet() { }
        /// Friend allocator used by soap_new_prodml21__PvtModelParameterSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PvtModelParameterSet * SOAP_FMAC2 soap_instantiate_prodml21__PvtModelParameterSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:272 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage (-71)
/* complex XML schema type 'prodml21:ReferenceSeparatorStage': */
class SOAP_CMAC prodml21__ReferenceSeparatorStage {
      public:
        /// Optional element 'prodml21:SeparatorPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *SeparatorPressure;
        /// Optional element 'prodml21:SeparatorTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasureExt'
        eml22__ThermodynamicTemperatureMeasureExt *SeparatorTemperature;
        /// Optional element 'prodml21:SeparatorNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *SeparatorNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReferenceSeparatorStage, default initialized and not managed by a soap context
        virtual prodml21__ReferenceSeparatorStage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReferenceSeparatorStage); }
      public:
        /// Constructor with default initializations
        prodml21__ReferenceSeparatorStage() : SeparatorPressure(), SeparatorTemperature(), SeparatorNumber(), soap() { }
        virtual ~prodml21__ReferenceSeparatorStage() { }
        /// Friend allocator used by soap_new_prodml21__ReferenceSeparatorStage(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReferenceSeparatorStage * SOAP_FMAC2 soap_instantiate_prodml21__ReferenceSeparatorStage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:282 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter (-76)
/* complex XML schema type 'prodml21:TableDelimiter': */
class SOAP_CMAC prodml21__TableDelimiter {
      public:
        /// Required attribute 'asciiCharacters' of XML schema type 'eml22:String64'
        std::string asciiCharacters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TableDelimiter, default initialized and not managed by a soap context
        virtual prodml21__TableDelimiter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TableDelimiter); }
      public:
        /// Constructor with default initializations
        prodml21__TableDelimiter() : asciiCharacters(), soap() { }
        virtual ~prodml21__TableDelimiter() { }
        /// Friend allocator used by soap_new_prodml21__TableDelimiter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TableDelimiter * SOAP_FMAC2 soap_instantiate_prodml21__TableDelimiter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:284 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass (-77)
/* complex XML schema type 'prodml21:AbstractDateTimeClass': */
class SOAP_CMAC prodml21__AbstractDateTimeClass {
      public:
        /// Optional element 'prodml21:DTime' of XML schema type 'eml22:TimeStamp'
        struct tm *DTime;
        /// Optional element 'prodml21:Date' of XML schema type 'xsd:date'
        std::string *Date;
        /// Optional element 'prodml21:Month' of XML schema type 'prodml21:CalendarMonth'
        std::string *Month;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractDateTimeClass, default initialized and not managed by a soap context
        virtual prodml21__AbstractDateTimeClass *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractDateTimeClass); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractDateTimeClass() : DTime(), Date(), Month(), soap() { }
        virtual ~prodml21__AbstractDateTimeClass() { }
        /// Friend allocator used by soap_new_prodml21__AbstractDateTimeClass(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractDateTimeClass * SOAP_FMAC2 soap_instantiate_prodml21__AbstractDateTimeClass(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:286 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent (-78)
/* complex XML schema type 'prodml21:AbstractFluidComponent': */
class SOAP_CMAC prodml21__AbstractFluidComponent {
      public:
        /// Optional element 'prodml21:MassFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml21:MoleFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractFluidComponent, default initialized and not managed by a soap context
        virtual prodml21__AbstractFluidComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractFluidComponent); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractFluidComponent() : MassFraction(), MoleFraction(), uid(), soap() { }
        virtual ~prodml21__AbstractFluidComponent() { }
        /// Friend allocator used by soap_new_prodml21__AbstractFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractFluidComponent * SOAP_FMAC2 soap_instantiate_prodml21__AbstractFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:288 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate (-79)
/* complex XML schema type 'prodml21:BusinessAssociate': */
class SOAP_CMAC prodml21__BusinessAssociate {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Optional element 'prodml21:Role' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> Role;
        /// Optional element 'prodml21:Alias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> Alias;
        /// Optional element 'prodml21:Address' of XML schema type 'prodml21:GeneralAddress'
        prodml21__GeneralAddress *Address;
        /// Optional element 'prodml21:PhoneNumber' of XML schema type 'prodml21:PhoneNumberStruct'
        std::vector<prodml21__PhoneNumberStruct *> PhoneNumber;
        /// Optional element 'prodml21:Email' of XML schema type 'prodml21:EmailQualifierStruct'
        std::vector<prodml21__EmailQualifierStruct *> Email;
        /// Optional element 'prodml21:AssociatedWith' of XML schema type 'eml22:String64'
        std::string *AssociatedWith;
        /// Optional element 'prodml21:Contact' of XML schema type 'eml22:String64'
        std::vector<std::string> Contact;
        /// Optional element 'prodml21:PersonnelCount' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *PersonnelCount;
        /// Optional element 'prodml21:PersonName' of XML schema type 'prodml21:PersonName'
        prodml21__PersonName *PersonName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BusinessAssociate, default initialized and not managed by a soap context
        virtual prodml21__BusinessAssociate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BusinessAssociate); }
      public:
        /// Constructor with default initializations
        prodml21__BusinessAssociate() : Name(), Role(), Alias(), Address(), PhoneNumber(), Email(), AssociatedWith(), Contact(), PersonnelCount(), PersonName(), soap() { }
        virtual ~prodml21__BusinessAssociate() { }
        /// Friend allocator used by soap_new_prodml21__BusinessAssociate(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BusinessAssociate * SOAP_FMAC2 soap_instantiate_prodml21__BusinessAssociate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:290 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter (-80)
/* complex XML schema type 'prodml21:CalibrationParameter': */
class SOAP_CMAC prodml21__CalibrationParameter {
      public:
        /// Optional attribute 'uom' of XML schema type 'eml22:UomEnum'
        std::string *uom;
        /// Required attribute 'name' of XML schema type 'eml22:String64'
        std::string name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CalibrationParameter, default initialized and not managed by a soap context
        virtual prodml21__CalibrationParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CalibrationParameter); }
      public:
        /// Constructor with default initializations
        prodml21__CalibrationParameter() : uom(), name(), soap() { }
        virtual ~prodml21__CalibrationParameter() { }
        /// Friend allocator used by soap_new_prodml21__CalibrationParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CalibrationParameter * SOAP_FMAC2 soap_instantiate_prodml21__CalibrationParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:292 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment (-81)
/* complex XML schema type 'prodml21:DatedComment': */
class SOAP_CMAC prodml21__DatedComment {
      public:
        /// Optional element 'prodml21:Who' of XML schema type 'eml22:String64'
        std::string *Who;
        /// Optional element 'prodml21:Role' of XML schema type 'eml22:String64'
        std::string *Role;
        /// Optional element 'prodml21:StartTime' of XML schema type 'eml22:TimeStamp'
        struct tm *StartTime;
        /// Optional element 'prodml21:EndTime' of XML schema type 'eml22:TimeStamp'
        struct tm *EndTime;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DatedComment, default initialized and not managed by a soap context
        virtual prodml21__DatedComment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DatedComment); }
      public:
        /// Constructor with default initializations
        prodml21__DatedComment() : Who(), Role(), StartTime(), EndTime(), Remark(), uid(), soap() { }
        virtual ~prodml21__DatedComment() { }
        /// Friend allocator used by soap_new_prodml21__DatedComment(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DatedComment * SOAP_FMAC2 soap_instantiate_prodml21__DatedComment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:296 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate (-83)
/* complex XML schema type 'prodml21:EndpointQualifiedDate': */
class SOAP_CMAC prodml21__EndpointQualifiedDate {
      public:
        /// Optional attribute 'endpoint' of XML schema type 'prodml21:EndpointQualifier'
        prodml21__EndpointQualifier *endpoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__EndpointQualifiedDate, default initialized and not managed by a soap context
        virtual prodml21__EndpointQualifiedDate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__EndpointQualifiedDate); }
      public:
        /// Constructor with default initializations
        prodml21__EndpointQualifiedDate() : endpoint(), soap() { }
        virtual ~prodml21__EndpointQualifiedDate() { }
        /// Friend allocator used by soap_new_prodml21__EndpointQualifiedDate(struct soap*, int)
        friend SOAP_FMAC1 prodml21__EndpointQualifiedDate * SOAP_FMAC2 soap_instantiate_prodml21__EndpointQualifiedDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:298 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime (-84)
/* complex XML schema type 'prodml21:EndpointQualifiedDateTime': */
class SOAP_CMAC prodml21__EndpointQualifiedDateTime {
      public:
        /// Optional attribute 'endpoint' of XML schema type 'prodml21:EndpointQualifier'
        prodml21__EndpointQualifier *endpoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__EndpointQualifiedDateTime, default initialized and not managed by a soap context
        virtual prodml21__EndpointQualifiedDateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__EndpointQualifiedDateTime); }
      public:
        /// Constructor with default initializations
        prodml21__EndpointQualifiedDateTime() : endpoint(), soap() { }
        virtual ~prodml21__EndpointQualifiedDateTime() { }
        /// Friend allocator used by soap_new_prodml21__EndpointQualifiedDateTime(struct soap*, int)
        friend SOAP_FMAC1 prodml21__EndpointQualifiedDateTime * SOAP_FMAC2 soap_instantiate_prodml21__EndpointQualifiedDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:300 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier (-85)
/* complex XML schema type 'prodml21:FacilityIdentifier': */
class SOAP_CMAC prodml21__FacilityIdentifier {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'prodml21:NameStruct'
        prodml21__NameStruct *Name;
        /// Optional element 'prodml21:Installation' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml21:Kind' of XML schema type 'eml22:String64'
        std::string *Kind;
        /// Optional element 'prodml21:ContextFacility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *ContextFacility;
        /// Optional element 'prodml21:Operator' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *Operator;
        /// Optional element 'prodml21:GeographicContext' of XML schema type 'prodml21:GeographicContext'
        prodml21__GeographicContext *GeographicContext;
        /// Optional element 'prodml21:BusinessUnit' of XML schema type 'prodml21:ProductVolumeBusinessUnit'
        prodml21__ProductVolumeBusinessUnit *BusinessUnit;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FacilityIdentifier, default initialized and not managed by a soap context
        virtual prodml21__FacilityIdentifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FacilityIdentifier); }
      public:
        /// Constructor with default initializations
        prodml21__FacilityIdentifier() : Name(), Installation(), Kind(), ContextFacility(), Operator(), GeographicContext(), BusinessUnit(), uid(), __mixed(), soap() { }
        virtual ~prodml21__FacilityIdentifier() { }
        /// Friend allocator used by soap_new_prodml21__FacilityIdentifier(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FacilityIdentifier * SOAP_FMAC2 soap_instantiate_prodml21__FacilityIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:302 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct (-86)
/* complex XML schema type 'prodml21:FacilityIdentifierStruct': */
class SOAP_CMAC prodml21__FacilityIdentifierStruct {
      public:
        /// Optional attribute 'kind' of XML schema type 'prodml21:ReportingFacility'
        prodml21__ReportingFacility *kind;
        /// Optional attribute 'siteKind' of XML schema type 'eml22:String64'
        std::string *siteKind;
        /// Optional attribute 'namingSystem' of XML schema type 'eml22:String64'
        std::string *namingSystem;
        /// Optional attribute 'uidRef' of XML schema type 'eml22:String64'
        std::string *uidRef;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FacilityIdentifierStruct, default initialized and not managed by a soap context
        virtual prodml21__FacilityIdentifierStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FacilityIdentifierStruct); }
      public:
        /// Constructor with default initializations
        prodml21__FacilityIdentifierStruct() : kind(), siteKind(), namingSystem(), uidRef(), __mixed(), soap() { }
        virtual ~prodml21__FacilityIdentifierStruct() { }
        /// Friend allocator used by soap_new_prodml21__FacilityIdentifierStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FacilityIdentifierStruct * SOAP_FMAC2 soap_instantiate_prodml21__FacilityIdentifierStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:304 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent (-87)
/* complex XML schema type 'prodml21:FluidComponent': */
class SOAP_CMAC prodml21__FluidComponent {
      public:
        /// Optional element 'prodml21:MassFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml21:MoleFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Optional element 'prodml21:KValue' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *KValue;
        /// Required attribute 'fluidComponentReference' of XML schema type 'eml22:String64'
        std::string fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidComponent, default initialized and not managed by a soap context
        virtual prodml21__FluidComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidComponent); }
      public:
        /// Constructor with default initializations
        prodml21__FluidComponent() : MassFraction(), MoleFraction(), KValue(), fluidComponentReference(), soap() { }
        virtual ~prodml21__FluidComponent() { }
        /// Friend allocator used by soap_new_prodml21__FluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidComponent * SOAP_FMAC2 soap_instantiate_prodml21__FluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:306 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog (-88)
/* complex XML schema type 'prodml21:FluidComponentCatalog': */
class SOAP_CMAC prodml21__FluidComponentCatalog {
      public:
        /// Optional element 'prodml21:StockTankOil' of XML schema type 'prodml21:StockTankOil'
        std::vector<prodml21__StockTankOil *> StockTankOil;
        /// Optional element 'prodml21:NaturalGas' of XML schema type 'prodml21:NaturalGas'
        std::vector<prodml21__NaturalGas *> NaturalGas;
        /// Optional element 'prodml21:FormationWater' of XML schema type 'prodml21:FormationWater'
        std::vector<prodml21__FormationWater *> FormationWater;
        /// Optional element 'prodml21:PureFluidComponent' of XML schema type 'prodml21:PureFluidComponent'
        std::vector<prodml21__PureFluidComponent *> PureFluidComponent;
        /// Optional element 'prodml21:PseudoFluidComponent' of XML schema type 'prodml21:PseudoFluidComponent'
        std::vector<prodml21__PseudoFluidComponent *> PseudoFluidComponent;
        /// Optional element 'prodml21:PlusFluidComponent' of XML schema type 'prodml21:PlusFluidComponent'
        std::vector<prodml21__PlusFluidComponent *> PlusFluidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidComponentCatalog, default initialized and not managed by a soap context
        virtual prodml21__FluidComponentCatalog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidComponentCatalog); }
      public:
        /// Constructor with default initializations
        prodml21__FluidComponentCatalog() : StockTankOil(), NaturalGas(), FormationWater(), PureFluidComponent(), PseudoFluidComponent(), PlusFluidComponent(), soap() { }
        virtual ~prodml21__FluidComponentCatalog() { }
        /// Friend allocator used by soap_new_prodml21__FluidComponentCatalog(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidComponentCatalog * SOAP_FMAC2 soap_instantiate_prodml21__FluidComponentCatalog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:310 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress (-90)
/* complex XML schema type 'prodml21:GeneralAddress': */
class SOAP_CMAC prodml21__GeneralAddress {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Sequence of 1 to 4 elements 'prodml21:Street' of XML schema type 'eml22:String64'
        std::vector<std::string> Street;
        /// Required element 'prodml21:City' of XML schema type 'eml22:String64'
        std::string City;
        /// Optional element 'prodml21:Country' of XML schema type 'eml22:String64'
        std::string *Country;
        /// Required element 'prodml21:County' of XML schema type 'eml22:String64'
        std::string County;
        /// Optional element 'prodml21:PostalCode' of XML schema type 'eml22:String64'
        std::string *PostalCode;
        /// Required element 'prodml21:State' of XML schema type 'eml22:String64'
        std::string State;
        /// Required element 'prodml21:Province' of XML schema type 'eml22:String64'
        std::string Province;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Optional attribute 'kind' of XML schema type 'prodml21:AddressKindEnum'
        prodml21__AddressKindEnum *kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__GeneralAddress, default initialized and not managed by a soap context
        virtual prodml21__GeneralAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__GeneralAddress); }
      public:
        /// Constructor with default initializations
        prodml21__GeneralAddress() : Name(), Street(), City(), Country(), County(), PostalCode(), State(), Province(), uid(), kind(), soap() { }
        virtual ~prodml21__GeneralAddress() { }
        /// Friend allocator used by soap_new_prodml21__GeneralAddress(struct soap*, int)
        friend SOAP_FMAC1 prodml21__GeneralAddress * SOAP_FMAC2 soap_instantiate_prodml21__GeneralAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:312 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType (-91)
/* complex XML schema type 'prodml21:GeneralMeasureType': */
class SOAP_CMAC prodml21__GeneralMeasureType {
      public:
        /// Optional attribute 'uom' of XML schema type 'eml22:UomEnum'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__GeneralMeasureType, default initialized and not managed by a soap context
        virtual prodml21__GeneralMeasureType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__GeneralMeasureType); }
      public:
        /// Constructor with default initializations
        prodml21__GeneralMeasureType() : uom(), soap() { }
        virtual ~prodml21__GeneralMeasureType() { }
        /// Friend allocator used by soap_new_prodml21__GeneralMeasureType(struct soap*, int)
        friend SOAP_FMAC1 prodml21__GeneralMeasureType * SOAP_FMAC2 soap_instantiate_prodml21__GeneralMeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:316 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext (-93)
/* complex XML schema type 'prodml21:GeographicContext': */
class SOAP_CMAC prodml21__GeographicContext {
      public:
        /// Optional element 'prodml21:Country' of XML schema type 'eml22:String64'
        std::string *Country;
        /// Optional element 'prodml21:State' of XML schema type 'eml22:String64'
        std::string *State;
        /// Optional element 'prodml21:County' of XML schema type 'eml22:String64'
        std::string *County;
        /// Optional element 'prodml21:Field' of XML schema type 'prodml21:NameStruct'
        prodml21__NameStruct *Field;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:OffshoreLocation' of XML schema type 'prodml21:OffshoreLocation'
        prodml21__OffshoreLocation *OffshoreLocation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__GeographicContext, default initialized and not managed by a soap context
        virtual prodml21__GeographicContext *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__GeographicContext); }
      public:
        /// Constructor with default initializations
        prodml21__GeographicContext() : Country(), State(), County(), Field(), Comment(), OffshoreLocation(), soap() { }
        virtual ~prodml21__GeographicContext() { }
        /// Friend allocator used by soap_new_prodml21__GeographicContext(struct soap*, int)
        friend SOAP_FMAC1 prodml21__GeographicContext * SOAP_FMAC2 soap_instantiate_prodml21__GeographicContext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:318 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature (-94)
/* complex XML schema type 'prodml21:GeologyFeature': */
class SOAP_CMAC prodml21__GeologyFeature {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:GeologyType' of XML schema type 'prodml21:GeologyType'
        prodml21__GeologyType *GeologyType;
        /// Optional element 'prodml21:MdBottom' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdBottom;
        /// Optional element 'prodml21:MdTop' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdTop;
        /// Optional element 'prodml21:TvdBottom' of XML schema type 'prodml21:WellVerticalDepthCoord'
        prodml21__WellVerticalDepthCoord *TvdBottom;
        /// Optional element 'prodml21:TvdTop' of XML schema type 'prodml21:WellVerticalDepthCoord'
        prodml21__WellVerticalDepthCoord *TvdTop;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__GeologyFeature, default initialized and not managed by a soap context
        virtual prodml21__GeologyFeature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__GeologyFeature); }
      public:
        /// Constructor with default initializations
        prodml21__GeologyFeature() : Name(), GeologyType(), MdBottom(), MdTop(), TvdBottom(), TvdTop(), uid(), soap() { }
        virtual ~prodml21__GeologyFeature() { }
        /// Friend allocator used by soap_new_prodml21__GeologyFeature(struct soap*, int)
        friend SOAP_FMAC1 prodml21__GeologyFeature * SOAP_FMAC2 soap_instantiate_prodml21__GeologyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:326 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition (-98)
/* complex XML schema type 'prodml21:LiquidComposition': */
class SOAP_CMAC prodml21__LiquidComposition {
      public:
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:LiquidComponent' of XML schema type 'prodml21:FluidComponent'
        std::vector<prodml21__FluidComponent *> LiquidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LiquidComposition, default initialized and not managed by a soap context
        virtual prodml21__LiquidComposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LiquidComposition); }
      public:
        /// Constructor with default initializations
        prodml21__LiquidComposition() : Remark(), LiquidComponent(), soap() { }
        virtual ~prodml21__LiquidComposition() { }
        /// Friend allocator used by soap_new_prodml21__LiquidComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LiquidComposition * SOAP_FMAC2 soap_instantiate_prodml21__LiquidComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:336 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore (-103)
/* complex XML schema type 'prodml21:NorthSeaOffshore': */
class SOAP_CMAC prodml21__NorthSeaOffshore {
      public:
        /// Optional element 'prodml21:AreaName' of XML schema type 'eml22:String64'
        std::string *AreaName;
        /// Required element 'prodml21:Quadrant' of XML schema type 'eml22:String64'
        std::string Quadrant;
        /// Optional element 'prodml21:BlockSuffix' of XML schema type 'eml22:String64'
        std::string *BlockSuffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NorthSeaOffshore, default initialized and not managed by a soap context
        virtual prodml21__NorthSeaOffshore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NorthSeaOffshore); }
      public:
        /// Constructor with default initializations
        prodml21__NorthSeaOffshore() : AreaName(), Quadrant(), BlockSuffix(), soap() { }
        virtual ~prodml21__NorthSeaOffshore() { }
        /// Friend allocator used by soap_new_prodml21__NorthSeaOffshore(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NorthSeaOffshore * SOAP_FMAC2 soap_instantiate_prodml21__NorthSeaOffshore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:338 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation (-104)
/* complex XML schema type 'prodml21:OffshoreLocation': */
class SOAP_CMAC prodml21__OffshoreLocation {
      public:
        /// Optional element 'prodml21:AreaName' of XML schema type 'eml22:String64'
        std::string *AreaName;
        /// Required element 'prodml21:BlockID' of XML schema type 'eml22:String64'
        std::vector<std::string> BlockID;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:NorthSeaOffshore' of XML schema type 'prodml21:NorthSeaOffshore'
        prodml21__NorthSeaOffshore *NorthSeaOffshore;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OffshoreLocation, default initialized and not managed by a soap context
        virtual prodml21__OffshoreLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OffshoreLocation); }
      public:
        /// Constructor with default initializations
        prodml21__OffshoreLocation() : AreaName(), BlockID(), Comment(), NorthSeaOffshore(), soap() { }
        virtual ~prodml21__OffshoreLocation() { }
        /// Friend allocator used by soap_new_prodml21__OffshoreLocation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OffshoreLocation * SOAP_FMAC2 soap_instantiate_prodml21__OffshoreLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:340 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition (-105)
/* complex XML schema type 'prodml21:OverallComposition': */
class SOAP_CMAC prodml21__OverallComposition {
      public:
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidComponent' of XML schema type 'prodml21:FluidComponent'
        std::vector<prodml21__FluidComponent *> FluidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OverallComposition, default initialized and not managed by a soap context
        virtual prodml21__OverallComposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OverallComposition); }
      public:
        /// Constructor with default initializations
        prodml21__OverallComposition() : Remark(), FluidComponent(), soap() { }
        virtual ~prodml21__OverallComposition() { }
        /// Friend allocator used by soap_new_prodml21__OverallComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OverallComposition * SOAP_FMAC2 soap_instantiate_prodml21__OverallComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:342 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName (-106)
/* complex XML schema type 'prodml21:PersonName': */
class SOAP_CMAC prodml21__PersonName {
      public:
        /// Optional element 'prodml21:Prefix' of XML schema type 'eml22:String64'
        std::string *Prefix;
        /// Required element 'prodml21:First' of XML schema type 'eml22:String64'
        std::string First;
        /// Optional element 'prodml21:Middle' of XML schema type 'eml22:String64'
        std::string *Middle;
        /// Required element 'prodml21:Last' of XML schema type 'eml22:String64'
        std::string Last;
        /// Sequence of 0 to 9 elements 'prodml21:Suffix' of XML schema type 'eml22:String64'
        std::vector<std::string> Suffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PersonName, default initialized and not managed by a soap context
        virtual prodml21__PersonName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PersonName); }
      public:
        /// Constructor with default initializations
        prodml21__PersonName() : Prefix(), First(), Middle(), Last(), Suffix(), soap() { }
        virtual ~prodml21__PersonName() { }
        /// Friend allocator used by soap_new_prodml21__PersonName(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PersonName * SOAP_FMAC2 soap_instantiate_prodml21__PersonName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:344 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct (-107)
/* complex XML schema type 'prodml21:PhoneNumberStruct': */
class SOAP_CMAC prodml21__PhoneNumberStruct {
      public:
        /// Required attribute 'type' of XML schema type 'prodml21:PhoneType'
        prodml21__PhoneType type;
        /// Optional attribute 'qualifier' of XML schema type 'prodml21:AddressQualifier'
        prodml21__AddressQualifier *qualifier;
        /// Optional attribute 'extension' of XML schema type 'eml22:String64'
        std::string *extension;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PhoneNumberStruct, default initialized and not managed by a soap context
        virtual prodml21__PhoneNumberStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PhoneNumberStruct); }
      public:
        /// Constructor with default initializations
        prodml21__PhoneNumberStruct() : type(), qualifier(), extension(), __mixed(), soap() { }
        virtual ~prodml21__PhoneNumberStruct() { }
        /// Friend allocator used by soap_new_prodml21__PhoneNumberStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PhoneNumberStruct * SOAP_FMAC2 soap_instantiate_prodml21__PhoneNumberStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:352 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference (-111)
/* complex XML schema type 'prodml21:ProductFlowExternalReference': */
class SOAP_CMAC prodml21__ProductFlowExternalReference {
      public:
        /// Required element 'prodml21:PortReference' of XML schema type 'eml22:String64'
        std::string PortReference;
        /// Required element 'prodml21:ConnectedPortReference' of XML schema type 'eml22:String64'
        std::string ConnectedPortReference;
        /// Required element 'prodml21:ConnectedModelReference' of XML schema type 'eml22:String64'
        std::string ConnectedModelReference;
        /// Optional element 'prodml21:ConnectedInstallation' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *ConnectedInstallation;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowExternalReference, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowExternalReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowExternalReference); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowExternalReference() : PortReference(), ConnectedPortReference(), ConnectedModelReference(), ConnectedInstallation(), uid(), soap() { }
        virtual ~prodml21__ProductFlowExternalReference() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowExternalReference(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowExternalReference * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowExternalReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:354 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork (-112)
/* complex XML schema type 'prodml21:ProductFlowNetwork': */
class SOAP_CMAC prodml21__ProductFlowNetwork {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Optional element 'prodml21:PlanName' of XML schema type 'eml22:String64'
        std::string *PlanName;
        /// Optional element 'prodml21:ParentNetworkReference' of XML schema type 'eml22:String64'
        std::string *ParentNetworkReference;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:ChangeLog' of XML schema type 'prodml21:ProductFlowChangeLog'
        std::vector<prodml21__ProductFlowChangeLog *> ChangeLog;
        /// Required element 'prodml21:Unit' of XML schema type 'prodml21:ProductFlowUnit'
        std::vector<prodml21__ProductFlowUnit *> Unit;
        /// Optional element 'prodml21:Port' of XML schema type 'prodml21:ProductFlowExternalPort'
        std::vector<prodml21__ProductFlowExternalPort *> Port;
        /// Optional element 'prodml21:Plan' of XML schema type 'prodml21:ProductFlowNetworkPlan'
        std::vector<prodml21__ProductFlowNetworkPlan *> Plan;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowNetwork, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowNetwork *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowNetwork); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowNetwork() : Name(), PlanName(), ParentNetworkReference(), Comment(), ChangeLog(), Unit(), Port(), Plan(), uid(), soap() { }
        virtual ~prodml21__ProductFlowNetwork() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowNetwork(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowNetwork * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowNetwork(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:366 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition (-118)
/* complex XML schema type 'prodml21:VaporComposition': */
class SOAP_CMAC prodml21__VaporComposition {
      public:
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:VaporComponent' of XML schema type 'prodml21:FluidComponent'
        std::vector<prodml21__FluidComponent *> VaporComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__VaporComposition, default initialized and not managed by a soap context
        virtual prodml21__VaporComposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__VaporComposition); }
      public:
        /// Constructor with default initializations
        prodml21__VaporComposition() : Remark(), VaporComponent(), soap() { }
        virtual ~prodml21__VaporComposition() { }
        /// Friend allocator used by soap_new_prodml21__VaporComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__VaporComposition * SOAP_FMAC2 soap_instantiate_prodml21__VaporComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:368 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure (-119)
/* complex XML schema type 'prodml21:VolumeQualifiedMeasure': */
class SOAP_CMAC prodml21__VolumeQualifiedMeasure {
      public:
        /// Optional attribute 'status' of XML schema type 'prodml21:ValueStatus'
        prodml21__ValueStatus *status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__VolumeQualifiedMeasure, default initialized and not managed by a soap context
        virtual prodml21__VolumeQualifiedMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__VolumeQualifiedMeasure); }
      public:
        /// Constructor with default initializations
        prodml21__VolumeQualifiedMeasure() : status(), soap() { }
        virtual ~prodml21__VolumeQualifiedMeasure() { }
        /// Friend allocator used by soap_new_prodml21__VolumeQualifiedMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__VolumeQualifiedMeasure * SOAP_FMAC2 soap_instantiate_prodml21__VolumeQualifiedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:370 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord (-120)
/* complex XML schema type 'prodml21:WellElevationCoord': */
class SOAP_CMAC prodml21__WellElevationCoord {
      public:
        /// Required attribute 'uom' of XML schema type 'eml22:VerticalCoordinateUom'
        eml22__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellElevationCoord, default initialized and not managed by a soap context
        virtual prodml21__WellElevationCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellElevationCoord); }
      public:
        /// Constructor with default initializations
        prodml21__WellElevationCoord() : uom(), soap() { }
        virtual ~prodml21__WellElevationCoord() { }
        /// Friend allocator used by soap_new_prodml21__WellElevationCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellElevationCoord * SOAP_FMAC2 soap_instantiate_prodml21__WellElevationCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:372 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord (-121)
/* complex XML schema type 'prodml21:WellVerticalDepthCoord': */
class SOAP_CMAC prodml21__WellVerticalDepthCoord {
      public:
        /// Required attribute 'uom' of XML schema type 'eml22:VerticalCoordinateUom'
        eml22__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellVerticalDepthCoord, default initialized and not managed by a soap context
        virtual prodml21__WellVerticalDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellVerticalDepthCoord); }
      public:
        /// Constructor with default initializations
        prodml21__WellVerticalDepthCoord() : uom(), soap() { }
        virtual ~prodml21__WellVerticalDepthCoord() { }
        /// Friend allocator used by soap_new_prodml21__WellVerticalDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellVerticalDepthCoord * SOAP_FMAC2 soap_instantiate_prodml21__WellVerticalDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:374 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume (-122)
/* complex XML schema type 'prodml21:CommonPropertiesProductVolume': */
class SOAP_CMAC prodml21__CommonPropertiesProductVolume {
      public:
        /// Optional element 'prodml21:Gor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Gor;
        /// Optional element 'prodml21:GorMTD' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GorMTD;
        /// Optional element 'prodml21:GasLiquidRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GasLiquidRatio;
        /// Optional element 'prodml21:WaterConcMass' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WaterConcMass;
        /// Optional element 'prodml21:WaterConcVol' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *WaterConcVol;
        /// Optional element 'prodml21:Atmosphere' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Atmosphere;
        /// Optional element 'prodml21:Temp' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *Temp;
        /// Optional element 'prodml21:Pres' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pres;
        /// Optional element 'prodml21:AbsoluteMinPres' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *AbsoluteMinPres;
        /// Optional element 'prodml21:Mass' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *Mass;
        /// Optional element 'prodml21:Work' of XML schema type 'eml22:EnergyMeasure'
        eml22__EnergyMeasure *Work;
        /// Optional element 'prodml21:Efficiency' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Efficiency;
        /// Optional element 'prodml21:Rvp' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Rvp;
        /// Optional element 'prodml21:Tvp' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Tvp;
        /// Optional element 'prodml21:Bsw' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Bsw;
        /// Optional element 'prodml21:BswPrevious' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *BswPrevious;
        /// Optional element 'prodml21:DensityFlowRate' of XML schema type 'eml22:MassPerTimeMeasure'
        eml22__MassPerTimeMeasure *DensityFlowRate;
        /// Optional element 'prodml21:Concentration' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Concentration;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml21:WeightPercent' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WeightPercent;
        /// Optional element 'prodml21:MolePercent' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MolePercent;
        /// Optional element 'prodml21:MoleAmt' of XML schema type 'eml22:AmountOfSubstanceMeasure'
        eml22__AmountOfSubstanceMeasure *MoleAmt;
        /// Optional element 'prodml21:Sg' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Sg;
        /// Optional element 'prodml21:HcDewpoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *HcDewpoint;
        /// Optional element 'prodml21:WaterDewpoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *WaterDewpoint;
        /// Optional element 'prodml21:WobbeIndex' of XML schema type 'eml22:IsothermalCompressibilityMeasure'
        eml22__IsothermalCompressibilityMeasure *WobbeIndex;
        /// Optional element 'prodml21:GrossCalorificValueStd' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *GrossCalorificValueStd;
        /// Optional element 'prodml21:RvpStabilizedCrude' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *RvpStabilizedCrude;
        /// Optional element 'prodml21:BswStabilizedCrude' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *BswStabilizedCrude;
        /// Optional element 'prodml21:DensityStabilizedCrude' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *DensityStabilizedCrude;
        /// Optional element 'prodml21:VolumeValue' of XML schema type 'eml22:VolumeValue'
        std::vector<eml22__VolumeValue *> VolumeValue;
        /// Optional element 'prodml21:PortDiff' of XML schema type 'prodml21:ProductVolumePortDifference'
        std::vector<prodml21__ProductVolumePortDifference *> PortDiff;
        /// Optional element 'prodml21:DensityValue' of XML schema type 'eml22:DensityValue'
        std::vector<eml22__DensityValue *> DensityValue;
        /// Optional element 'prodml21:FlowRateValue' of XML schema type 'eml22:FlowRateValue'
        std::vector<eml22__FlowRateValue *> FlowRateValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CommonPropertiesProductVolume, default initialized and not managed by a soap context
        virtual prodml21__CommonPropertiesProductVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CommonPropertiesProductVolume); }
      public:
        /// Constructor with default initializations
        prodml21__CommonPropertiesProductVolume() : Gor(), GorMTD(), GasLiquidRatio(), WaterConcMass(), WaterConcVol(), Atmosphere(), Temp(), Pres(), AbsoluteMinPres(), Mass(), Work(), Efficiency(), Rvp(), Tvp(), Bsw(), BswPrevious(), DensityFlowRate(), Concentration(), MolecularWeight(), WeightPercent(), MolePercent(), MoleAmt(), Sg(), HcDewpoint(), WaterDewpoint(), WobbeIndex(), GrossCalorificValueStd(), RvpStabilizedCrude(), BswStabilizedCrude(), DensityStabilizedCrude(), VolumeValue(), PortDiff(), DensityValue(), FlowRateValue(), soap() { }
        virtual ~prodml21__CommonPropertiesProductVolume() { }
        /// Friend allocator used by soap_new_prodml21__CommonPropertiesProductVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CommonPropertiesProductVolume * SOAP_FMAC2 soap_instantiate_prodml21__CommonPropertiesProductVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:376 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData (-123)
/* complex XML schema type 'prodml21:AbstractMeasureData': */
class SOAP_CMAC prodml21__AbstractMeasureData {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractMeasureData, default initialized and not managed by a soap context
        virtual prodml21__AbstractMeasureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractMeasureData); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractMeasureData() : soap() { }
        virtual ~prodml21__AbstractMeasureData() { }
        /// Friend allocator used by soap_new_prodml21__AbstractMeasureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractMeasureData * SOAP_FMAC2 soap_instantiate_prodml21__AbstractMeasureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:22813 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__union_AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_2__prodml21__union_AbstractRefProductFlow (-1576)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml21__union_AbstractRefProductFlow
{
};
#endif

/* eml2_2ForGsoap.h:378 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow (-124)
/* Choice: */
class SOAP_CMAC prodml21__AbstractRefProductFlow {
      public:
        /// Union with union _prodml21__union_AbstractRefProductFlow variant selector __union_AbstractRefProductFlow set to one of:
        int __union_AbstractRefProductFlow;
        union _prodml21__union_AbstractRefProductFlow union_AbstractRefProductFlow;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractRefProductFlow, default initialized and not managed by a soap context
        virtual prodml21__AbstractRefProductFlow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractRefProductFlow); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractRefProductFlow() : __union_AbstractRefProductFlow(), soap() { }
        virtual ~prodml21__AbstractRefProductFlow() { }
        /// Friend allocator used by soap_new_prodml21__AbstractRefProductFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractRefProductFlow * SOAP_FMAC2 soap_instantiate_prodml21__AbstractRefProductFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:380 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject (-125)
/* complex XML schema type 'prodml21:AbstractRelatedFacilityObject': */
class SOAP_CMAC prodml21__AbstractRelatedFacilityObject {
      public:
        /// Required element 'prodml21:FacilityParent' of XML schema type 'prodml21:FacilityParent'
        prodml21__FacilityParent *FacilityParent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractRelatedFacilityObject, default initialized and not managed by a soap context
        virtual prodml21__AbstractRelatedFacilityObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractRelatedFacilityObject); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractRelatedFacilityObject() : FacilityParent(), soap() { }
        virtual ~prodml21__AbstractRelatedFacilityObject() { }
        /// Friend allocator used by soap_new_prodml21__AbstractRelatedFacilityObject(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractRelatedFacilityObject * SOAP_FMAC2 soap_instantiate_prodml21__AbstractRelatedFacilityObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:384 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition (-127)
/* complex XML schema type 'prodml21:CurveDefinition': */
class SOAP_CMAC prodml21__CurveDefinition {
      public:
        /// Required element 'prodml21:Order' of XML schema type 'eml22:NonNegativeLong'
        LONG64 Order;
        /// Required element 'prodml21:Parameter' of XML schema type 'eml22:String64'
        std::string Parameter;
        /// Optional element 'prodml21:IsIndex' of XML schema type 'xsd:boolean'
        bool *IsIndex;
        /// Required element 'prodml21:MeasureClass' of XML schema type 'eml22:MeasureClass'
        eml22__MeasureClass MeasureClass;
        /// Required element 'prodml21:Unit' of XML schema type 'eml22:UomEnum'
        std::string Unit;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CurveDefinition, default initialized and not managed by a soap context
        virtual prodml21__CurveDefinition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CurveDefinition); }
      public:
        /// Constructor with default initializations
        prodml21__CurveDefinition() : Order(), Parameter(), IsIndex(), MeasureClass(), Unit(), uid(), soap() { }
        virtual ~prodml21__CurveDefinition() { }
        /// Friend allocator used by soap_new_prodml21__CurveDefinition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CurveDefinition * SOAP_FMAC2 soap_instantiate_prodml21__CurveDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:22931 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__union_OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_2__prodml21__union_OwnershipBusinessAcct (-1580)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml21__union_OwnershipBusinessAcct
{
};
#endif

/* eml2_2ForGsoap.h:392 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct (-131)
/* Choice: */
class SOAP_CMAC prodml21__OwnershipBusinessAcct {
      public:
        /// Union with union _prodml21__union_OwnershipBusinessAcct variant selector __union_OwnershipBusinessAcct set to one of:
        int __union_OwnershipBusinessAcct;
        union _prodml21__union_OwnershipBusinessAcct union_OwnershipBusinessAcct;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OwnershipBusinessAcct, default initialized and not managed by a soap context
        virtual prodml21__OwnershipBusinessAcct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OwnershipBusinessAcct); }
      public:
        /// Constructor with default initializations
        prodml21__OwnershipBusinessAcct() : __union_OwnershipBusinessAcct(), soap() { }
        virtual ~prodml21__OwnershipBusinessAcct() { }
        /// Friend allocator used by soap_new_prodml21__OwnershipBusinessAcct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OwnershipBusinessAcct * SOAP_FMAC2 soap_instantiate_prodml21__OwnershipBusinessAcct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:398 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert (-134)
/* complex XML schema type 'prodml21:ProductVolumeAlert': */
class SOAP_CMAC prodml21__ProductVolumeAlert {
      public:
        /// Optional element 'prodml21:Target' of XML schema type 'eml22:String2000'
        std::string *Target;
        /// Optional element 'prodml21:Level' of XML schema type 'eml22:String64'
        std::string *Level;
        /// Optional element 'prodml21:Type' of XML schema type 'eml22:String64'
        std::string *Type;
        /// Optional element 'prodml21:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeAlert, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeAlert *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeAlert); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeAlert() : Target(), Level(), Type(), Description(), soap() { }
        virtual ~prodml21__ProductVolumeAlert() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeAlert(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeAlert * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeAlert(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:400 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail (-135)
/* complex XML schema type 'prodml21:ProductVolumeBalanceDetail': */
class SOAP_CMAC prodml21__ProductVolumeBalanceDetail {
      public:
        /// Required element 'prodml21:Owner' of XML schema type 'eml22:String64'
        std::string Owner;
        /// Optional element 'prodml21:SourceUnit' of XML schema type 'eml22:String64'
        std::string *SourceUnit;
        /// Optional element 'prodml21:Share' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Share;
        /// Optional element 'prodml21:AccountNumber' of XML schema type 'eml22:String64'
        std::string *AccountNumber;
        /// Optional element 'prodml21:SampleAnalysisResult' of XML schema type 'eml22:String64'
        std::vector<std::string> SampleAnalysisResult;
        /// Optional element 'prodml21:Event' of XML schema type 'prodml21:ProductVolumeBalanceEvent'
        std::vector<prodml21__ProductVolumeBalanceEvent *> Event;
        /// Optional element 'prodml21:ComponentContent' of XML schema type 'prodml21:ProductVolumeComponentContent'
        std::vector<prodml21__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml21:VolumeValue' of XML schema type 'eml22:VolumeValue'
        std::vector<eml22__VolumeValue *> VolumeValue;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeBalanceDetail, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeBalanceDetail *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeBalanceDetail); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeBalanceDetail() : Owner(), SourceUnit(), Share(), AccountNumber(), SampleAnalysisResult(), Event(), ComponentContent(), VolumeValue(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeBalanceDetail() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeBalanceDetail(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeBalanceDetail * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeBalanceDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:402 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent (-136)
/* complex XML schema type 'prodml21:ProductVolumeBalanceEvent': */
class SOAP_CMAC prodml21__ProductVolumeBalanceEvent {
      public:
        /// Required element 'prodml21:Date' of XML schema type 'xsd:date'
        std::string Date;
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:BalanceEventKind'
        prodml21__BalanceEventKind Kind;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeBalanceEvent, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeBalanceEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeBalanceEvent); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeBalanceEvent() : Date(), Kind(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeBalanceEvent() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeBalanceEvent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeBalanceEvent * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeBalanceEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:404 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet (-137)
/* complex XML schema type 'prodml21:ProductVolumeBalanceSet': */
class SOAP_CMAC prodml21__ProductVolumeBalanceSet {
      public:
        /// Optional element 'prodml21:Kind' of XML schema type 'prodml21:BalanceFlowPart'
        prodml21__BalanceFlowPart *Kind;
        /// Optional element 'prodml21:CargoNumber' of XML schema type 'eml22:String64'
        std::string *CargoNumber;
        /// Optional element 'prodml21:CargoBatchNumber' of XML schema type 'xsd:nonNegativeInteger'
        ULONG64 *CargoBatchNumber;
        /// Optional element 'prodml21:Shipper' of XML schema type 'eml22:String64'
        std::string *Shipper;
        /// Optional element 'prodml21:Destination' of XML schema type 'prodml21:ProductVolumeDestination'
        prodml21__ProductVolumeDestination *Destination;
        /// Optional element 'prodml21:BalanceDetail' of XML schema type 'prodml21:ProductVolumeBalanceDetail'
        std::vector<prodml21__ProductVolumeBalanceDetail *> BalanceDetail;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeBalanceSet, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeBalanceSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeBalanceSet); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeBalanceSet() : Kind(), CargoNumber(), CargoBatchNumber(), Shipper(), Destination(), BalanceDetail(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeBalanceSet() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeBalanceSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeBalanceSet * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeBalanceSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:406 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit (-138)
/* complex XML schema type 'prodml21:ProductVolumeBusinessSubUnit': */
class SOAP_CMAC prodml21__ProductVolumeBusinessSubUnit {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'eml22:String64'
        std::string Kind;
        /// Required element 'prodml21:OwnershipBusinessAcct' of XML schema type 'prodml21:OwnershipBusinessAcct'
        prodml21__OwnershipBusinessAcct *OwnershipBusinessAcct;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeBusinessSubUnit, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeBusinessSubUnit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeBusinessSubUnit); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeBusinessSubUnit() : Kind(), OwnershipBusinessAcct(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeBusinessSubUnit() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeBusinessSubUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeBusinessSubUnit * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeBusinessSubUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:408 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit (-139)
/* complex XML schema type 'prodml21:ProductVolumeBusinessUnit': */
class SOAP_CMAC prodml21__ProductVolumeBusinessUnit {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:BusinessUnitKind'
        prodml21__BusinessUnitKind Kind;
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Optional element 'prodml21:SubUnit' of XML schema type 'prodml21:ProductVolumeBusinessSubUnit'
        std::vector<prodml21__ProductVolumeBusinessSubUnit *> SubUnit;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeBusinessUnit, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeBusinessUnit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeBusinessUnit); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeBusinessUnit() : Kind(), Name(), Description(), SubUnit(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeBusinessUnit() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeBusinessUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeBusinessUnit * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeBusinessUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:410 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent (-140)
/* complex XML schema type 'prodml21:ProductVolumeComponentContent': */
class SOAP_CMAC prodml21__ProductVolumeComponentContent {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:ReportingProduct'
        prodml21__ReportingProduct Kind;
        /// Optional element 'prodml21:ReferenceKind' of XML schema type 'prodml21:ReportingProduct'
        prodml21__ReportingProduct *ReferenceKind;
        /// Optional element 'prodml21:Properties' of XML schema type 'prodml21:CommonPropertiesProductVolume'
        prodml21__CommonPropertiesProductVolume *Properties;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeComponentContent, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeComponentContent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeComponentContent); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeComponentContent() : Kind(), ReferenceKind(), Properties(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeComponentContent() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeComponentContent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeComponentContent * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeComponentContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:412 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination (-141)
/* complex XML schema type 'prodml21:ProductVolumeDestination': */
class SOAP_CMAC prodml21__ProductVolumeDestination {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:Type' of XML schema type 'prodml21:BalanceDestinationType'
        prodml21__BalanceDestinationType *Type;
        /// Optional element 'prodml21:Country' of XML schema type 'eml22:String64'
        std::string *Country;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeDestination, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeDestination *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeDestination); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeDestination() : Name(), Type(), Country(), soap() { }
        virtual ~prodml21__ProductVolumeDestination() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeDestination(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeDestination * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeDestination(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:414 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility (-142)
/* complex XML schema type 'prodml21:ProductVolumeFacility': */
class SOAP_CMAC prodml21__ProductVolumeFacility {
      public:
        /// Optional element 'prodml21:FacilityParent' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent;
        /// Optional element 'prodml21:FacilityParent2' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent2;
        /// Optional element 'prodml21:FacilityAlias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> FacilityAlias;
        /// Optional element 'prodml21:Unit' of XML schema type 'eml22:String64'
        std::string *Unit;
        /// Optional element 'prodml21:NetWork' of XML schema type 'eml22:String64'
        std::string *NetWork;
        /// Required element 'prodml21:Name' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Name;
        /// Optional element 'prodml21:StatusWell' of XML schema type 'eml22:WellStatus'
        eml22__WellStatus *StatusWell;
        /// Optional element 'prodml21:FluidWell' of XML schema type 'prodml21:WellFluid'
        prodml21__WellFluid *FluidWell;
        /// Optional element 'prodml21:OperatingMethod' of XML schema type 'prodml21:WellOperationMethod'
        prodml21__WellOperationMethod *OperatingMethod;
        /// Optional element 'prodml21:WellProducing' of XML schema type 'xsd:boolean'
        bool *WellProducing;
        /// Optional element 'prodml21:WellInjecting' of XML schema type 'xsd:boolean'
        bool *WellInjecting;
        /// Optional element 'prodml21:Capacity' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Capacity;
        /// Optional element 'prodml21:OperationTime' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *OperationTime;
        /// Optional element 'prodml21:Flow' of XML schema type 'prodml21:ProductVolumeFlow'
        std::vector<prodml21__ProductVolumeFlow *> Flow;
        /// Optional element 'prodml21:ParameterSet' of XML schema type 'prodml21:ProductVolumeParameterSet'
        std::vector<prodml21__ProductVolumeParameterSet *> ParameterSet;
        /// Optional element 'prodml21:DowntimeReason' of XML schema type 'prodml21:DatedComment'
        std::vector<prodml21__DatedComment *> DowntimeReason;
        /// Optional element 'prodml21:Comment' of XML schema type 'prodml21:DatedComment'
        std::vector<prodml21__DatedComment *> Comment;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeFacility, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeFacility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeFacility); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeFacility() : FacilityParent(), FacilityParent2(), FacilityAlias(), Unit(), NetWork(), Name(), StatusWell(), FluidWell(), OperatingMethod(), WellProducing(), WellInjecting(), Capacity(), OperationTime(), Flow(), ParameterSet(), DowntimeReason(), Comment(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeFacility() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeFacility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeFacility * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeFacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:416 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow (-143)
/* complex XML schema type 'prodml21:ProductVolumeFlow': */
class SOAP_CMAC prodml21__ProductVolumeFlow {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:ReportingFlow'
        prodml21__ReportingFlow Kind;
        /// Optional element 'prodml21:Port' of XML schema type 'eml22:String64'
        std::string *Port;
        /// Optional element 'prodml21:Direction' of XML schema type 'prodml21:ProductFlowPortType'
        prodml21__ProductFlowPortType *Direction;
        /// Optional element 'prodml21:Facility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml21:FacilityAlias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> FacilityAlias;
        /// Optional element 'prodml21:Qualifier' of XML schema type 'prodml21:FlowQualifier'
        prodml21__FlowQualifier *Qualifier;
        /// Optional element 'prodml21:SubQualifier' of XML schema type 'prodml21:FlowSubQualifier'
        prodml21__FlowSubQualifier *SubQualifier;
        /// Optional element 'prodml21:Version' of XML schema type 'eml22:TimeStamp'
        struct tm *Version;
        /// Optional element 'prodml21:VersionSource' of XML schema type 'eml22:String64'
        std::string *VersionSource;
        /// Optional element 'prodml21:SourceFlow' of XML schema type 'eml22:String64'
        std::string *SourceFlow;
        /// Optional element 'prodml21:Properties' of XML schema type 'prodml21:CommonPropertiesProductVolume'
        prodml21__CommonPropertiesProductVolume *Properties;
        /// Optional element 'prodml21:Product' of XML schema type 'prodml21:ProductVolumeProduct'
        std::vector<prodml21__ProductVolumeProduct *> Product;
        /// Optional element 'prodml21:RelatedFacility' of XML schema type 'prodml21:ProductVolumeRelatedFacility'
        prodml21__ProductVolumeRelatedFacility *RelatedFacility;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeFlow, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeFlow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeFlow); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeFlow() : Name(), Kind(), Port(), Direction(), Facility(), FacilityAlias(), Qualifier(), SubQualifier(), Version(), VersionSource(), SourceFlow(), Properties(), Product(), RelatedFacility(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeFlow() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeFlow * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:418 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet (-144)
/* complex XML schema type 'prodml21:ProductVolumeParameterSet': */
class SOAP_CMAC prodml21__ProductVolumeParameterSet {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'prodml21:FacilityParameter'
        prodml21__FacilityParameter Name;
        /// Optional element 'prodml21:ChildFacilityIdentifier' of XML schema type 'prodml21:ProdmlRelativeIdentifier'
        std::string *ChildFacilityIdentifier;
        /// Optional element 'prodml21:Port' of XML schema type 'eml22:String64'
        std::string *Port;
        /// Optional element 'prodml21:MeasureClass' of XML schema type 'eml22:MeasureClass'
        eml22__MeasureClass *MeasureClass;
        /// Optional element 'prodml21:CoordinateReferenceSystem' of XML schema type 'eml22:String64'
        std::string *CoordinateReferenceSystem;
        /// Optional element 'prodml21:Qualifier' of XML schema type 'prodml21:FlowQualifier'
        prodml21__FlowQualifier *Qualifier;
        /// Optional element 'prodml21:SubQualifier' of XML schema type 'prodml21:FlowSubQualifier'
        prodml21__FlowSubQualifier *SubQualifier;
        /// Optional element 'prodml21:Version' of XML schema type 'eml22:TimeStamp'
        struct tm *Version;
        /// Optional element 'prodml21:VersionSource' of XML schema type 'eml22:String64'
        std::string *VersionSource;
        /// Optional element 'prodml21:Product' of XML schema type 'prodml21:ReportingProduct'
        prodml21__ReportingProduct *Product;
        /// Optional element 'prodml21:PeriodKind' of XML schema type 'prodml21:ReportingDurationKind'
        prodml21__ReportingDurationKind *PeriodKind;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required element 'prodml21:Parameter' of XML schema type 'prodml21:ProductVolumeParameterValue'
        std::vector<prodml21__ProductVolumeParameterValue *> Parameter;
        /// Optional element 'prodml21:CurveDefinition' of XML schema type 'prodml21:CurveDefinition'
        std::vector<prodml21__CurveDefinition *> CurveDefinition;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeParameterSet, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeParameterSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeParameterSet); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeParameterSet() : Name(), ChildFacilityIdentifier(), Port(), MeasureClass(), CoordinateReferenceSystem(), Qualifier(), SubQualifier(), Version(), VersionSource(), Product(), PeriodKind(), Comment(), Parameter(), CurveDefinition(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeParameterSet() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeParameterSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeParameterSet * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeParameterSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:420 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue (-145)
/* complex XML schema type 'prodml21:ProductVolumeParameterValue': */
class SOAP_CMAC prodml21__ProductVolumeParameterValue {
      public:
        /// Optional element 'prodml21:DTim' of XML schema type 'eml22:TimeStamp'
        struct tm *DTim;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:Port' of XML schema type 'eml22:String64'
        std::string *Port;
        /// Optional element 'prodml21:Unit' of XML schema type 'eml22:String64'
        std::string *Unit;
        /// Required element 'prodml21:MeasureDataType' of XML schema type 'prodml21:AbstractMeasureData'
        std::vector<prodml21__AbstractMeasureData *> MeasureDataType;
        /// Optional element 'prodml21:Alert' of XML schema type 'prodml21:ProductVolumeAlert'
        prodml21__ProductVolumeAlert *Alert;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeParameterValue, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeParameterValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeParameterValue); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeParameterValue() : DTim(), DTimEnd(), Port(), Unit(), MeasureDataType(), Alert(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeParameterValue() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeParameterValue(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeParameterValue * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeParameterValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:422 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod (-146)
/* complex XML schema type 'prodml21:ProductVolumePeriod': */
class SOAP_CMAC prodml21__ProductVolumePeriod {
      public:
        /// Optional element 'prodml21:Kind' of XML schema type 'prodml21:ReportingDurationKind'
        prodml21__ReportingDurationKind *Kind;
        /// Optional element 'prodml21:Comment' of XML schema type 'prodml21:DatedComment'
        std::vector<prodml21__DatedComment *> Comment;
        /// Optional element 'prodml21:Properties' of XML schema type 'prodml21:CommonPropertiesProductVolume'
        prodml21__CommonPropertiesProductVolume *Properties;
        /// Optional element 'prodml21:BalanceSet' of XML schema type 'prodml21:ProductVolumeBalanceSet'
        std::vector<prodml21__ProductVolumeBalanceSet *> BalanceSet;
        /// Optional element 'prodml21:ComponentContent' of XML schema type 'prodml21:ProductVolumeComponentContent'
        std::vector<prodml21__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml21:DateTime' of XML schema type 'prodml21:AbstractDateTimeClass'
        prodml21__AbstractDateTimeClass *DateTime;
        /// Optional element 'prodml21:Alert' of XML schema type 'prodml21:ProductVolumeAlert'
        prodml21__ProductVolumeAlert *Alert;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumePeriod, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumePeriod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumePeriod); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumePeriod() : Kind(), Comment(), Properties(), BalanceSet(), ComponentContent(), DateTime(), Alert(), uid(), soap() { }
        virtual ~prodml21__ProductVolumePeriod() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumePeriod(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumePeriod * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:424 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference (-147)
/* complex XML schema type 'prodml21:ProductVolumePortDifference': */
class SOAP_CMAC prodml21__ProductVolumePortDifference {
      public:
        /// Optional element 'prodml21:PortReference' of XML schema type 'eml22:String64'
        std::string *PortReference;
        /// Optional element 'prodml21:PresDiff' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *PresDiff;
        /// Optional element 'prodml21:TempDiff' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TempDiff;
        /// Optional element 'prodml21:ChokeSize' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *ChokeSize;
        /// Optional element 'prodml21:ChokeRelative' of XML schema type 'eml22:LengthPerLengthMeasure'
        eml22__LengthPerLengthMeasure *ChokeRelative;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumePortDifference, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumePortDifference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumePortDifference); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumePortDifference() : PortReference(), PresDiff(), TempDiff(), ChokeSize(), ChokeRelative(), uid(), soap() { }
        virtual ~prodml21__ProductVolumePortDifference() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumePortDifference(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumePortDifference * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumePortDifference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:426 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct (-148)
/* complex XML schema type 'prodml21:ProductVolumeProduct': */
class SOAP_CMAC prodml21__ProductVolumeProduct {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:ReportingProduct'
        prodml21__ReportingProduct Kind;
        /// Optional element 'prodml21:Name' of XML schema type 'prodml21:NameStruct'
        prodml21__NameStruct *Name;
        /// Optional element 'prodml21:SplitFactor' of XML schema type 'prodml21:NonNegativeFraction'
        float *SplitFactor;
        /// Optional element 'prodml21:MassFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml21:MoleFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Required element 'prodml21:Period' of XML schema type 'prodml21:ProductVolumePeriod'
        std::vector<prodml21__ProductVolumePeriod *> Period;
        /// Optional element 'prodml21:ComponentContent' of XML schema type 'prodml21:ProductVolumeComponentContent'
        std::vector<prodml21__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml21:SourceFlow' of XML schema type 'prodml21:AbstractRefProductFlow'
        prodml21__AbstractRefProductFlow *SourceFlow;
        /// Optional element 'prodml21:Properties' of XML schema type 'prodml21:CommonPropertiesProductVolume'
        prodml21__CommonPropertiesProductVolume *Properties;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeProduct, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeProduct); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeProduct() : Kind(), Name(), SplitFactor(), MassFraction(), MoleFraction(), Period(), ComponentContent(), SourceFlow(), Properties(), uid(), soap() { }
        virtual ~prodml21__ProductVolumeProduct() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeProduct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeProduct * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:428 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility (-149)
/* complex XML schema type 'prodml21:ProductVolumeRelatedFacility': */
class SOAP_CMAC prodml21__ProductVolumeRelatedFacility {
      public:
        /// Optional element 'prodml21:Kind' of XML schema type 'prodml21:ReportingFacility'
        prodml21__ReportingFacility *Kind;
        /// Optional element 'prodml21:RelatedFacilityObject' of XML schema type 'prodml21:AbstractRelatedFacilityObject'
        prodml21__AbstractRelatedFacilityObject *RelatedFacilityObject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolumeRelatedFacility, default initialized and not managed by a soap context
        virtual prodml21__ProductVolumeRelatedFacility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolumeRelatedFacility); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolumeRelatedFacility() : Kind(), RelatedFacilityObject(), soap() { }
        virtual ~prodml21__ProductVolumeRelatedFacility() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolumeRelatedFacility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolumeRelatedFacility * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolumeRelatedFacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:434 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode (-152)
/* complex XML schema type 'prodml21:ConnectedNode': */
class SOAP_CMAC prodml21__ConnectedNode {
      public:
        /// Required element 'prodml21:Node' of XML schema type 'eml22:String64'
        std::string Node;
        /// Optional element 'prodml21:PlanName' of XML schema type 'eml22:String64'
        std::string *PlanName;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConnectedNode, default initialized and not managed by a soap context
        virtual prodml21__ConnectedNode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConnectedNode); }
      public:
        /// Constructor with default initializations
        prodml21__ConnectedNode() : Node(), PlanName(), DTimStart(), DTimEnd(), Comment(), uid(), soap() { }
        virtual ~prodml21__ConnectedNode() { }
        /// Friend allocator used by soap_new_prodml21__ConnectedNode(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConnectedNode * SOAP_FMAC2 soap_instantiate_prodml21__ConnectedNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:436 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier (-153)
/* complex XML schema type 'prodml21:ExpectedFlowQualifier': */
class SOAP_CMAC prodml21__ExpectedFlowQualifier {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ExpectedFlowQualifier, default initialized and not managed by a soap context
        virtual prodml21__ExpectedFlowQualifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ExpectedFlowQualifier); }
      public:
        /// Constructor with default initializations
        prodml21__ExpectedFlowQualifier() : soap() { }
        virtual ~prodml21__ExpectedFlowQualifier() { }
        /// Friend allocator used by soap_new_prodml21__ExpectedFlowQualifier(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ExpectedFlowQualifier * SOAP_FMAC2 soap_instantiate_prodml21__ExpectedFlowQualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:438 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog (-154)
/* complex XML schema type 'prodml21:ProductFlowChangeLog': */
class SOAP_CMAC prodml21__ProductFlowChangeLog {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm DTim;
        /// Optional element 'prodml21:Reason' of XML schema type 'eml22:String2000'
        std::string *Reason;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowChangeLog, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowChangeLog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowChangeLog); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowChangeLog() : Name(), DTim(), Reason(), uid(), soap() { }
        virtual ~prodml21__ProductFlowChangeLog() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowChangeLog(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowChangeLog * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowChangeLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:440 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty (-155)
/* complex XML schema type 'prodml21:ProductFlowExpectedUnitProperty': */
class SOAP_CMAC prodml21__ProductFlowExpectedUnitProperty {
      public:
        /// Required element 'prodml21:Property' of XML schema type 'prodml21:FacilityParameter'
        prodml21__FacilityParameter Property;
        /// Optional element 'prodml21:ChildFacilityIdentifier' of XML schema type 'prodml21:ProdmlRelativeIdentifier'
        std::string *ChildFacilityIdentifier;
        /// Optional element 'prodml21:TagAlias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> TagAlias;
        /// Optional element 'prodml21:Deadband' of XML schema type 'prodml21:GeneralMeasureType'
        prodml21__GeneralMeasureType *Deadband;
        /// Optional element 'prodml21:MaximumFrequency' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *MaximumFrequency;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:ExpectedFlowQualifier' of XML schema type 'prodml21:ExpectedFlowQualifier'
        prodml21__ExpectedFlowQualifier *ExpectedFlowQualifier;
        /// Optional element 'prodml21:ExpectedFlowProduct' of XML schema type 'prodml21:ProductFlowQualifierExpected'
        std::vector<prodml21__ProductFlowQualifierExpected *> ExpectedFlowProduct;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowExpectedUnitProperty, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowExpectedUnitProperty *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowExpectedUnitProperty); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowExpectedUnitProperty() : Property(), ChildFacilityIdentifier(), TagAlias(), Deadband(), MaximumFrequency(), Comment(), ExpectedFlowQualifier(), ExpectedFlowProduct(), uid(), soap() { }
        virtual ~prodml21__ProductFlowExpectedUnitProperty() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowExpectedUnitProperty(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowExpectedUnitProperty * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowExpectedUnitProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:442 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort (-156)
/* complex XML schema type 'prodml21:ProductFlowExternalPort': */
class SOAP_CMAC prodml21__ProductFlowExternalPort {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Required element 'prodml21:Direction' of XML schema type 'prodml21:ProductFlowPortType'
        prodml21__ProductFlowPortType Direction;
        /// Optional element 'prodml21:Exposed' of XML schema type 'xsd:boolean'
        bool *Exposed;
        /// Required element 'prodml21:ConnectedNode' of XML schema type 'eml22:String64'
        std::string ConnectedNode;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowExternalPort, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowExternalPort *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowExternalPort); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowExternalPort() : Name(), Direction(), Exposed(), ConnectedNode(), Comment(), uid(), soap() { }
        virtual ~prodml21__ProductFlowExternalPort() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowExternalPort(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowExternalPort * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowExternalPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:446 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan (-158)
/* complex XML schema type 'prodml21:ProductFlowNetworkPlan': */
class SOAP_CMAC prodml21__ProductFlowNetworkPlan {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm DTimStart;
        /// Optional element 'prodml21:Purpose' of XML schema type 'eml22:String2000'
        std::string *Purpose;
        /// Optional element 'prodml21:ChangeLog' of XML schema type 'prodml21:ProductFlowChangeLog'
        std::vector<prodml21__ProductFlowChangeLog *> ChangeLog;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowNetworkPlan, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowNetworkPlan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowNetworkPlan); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowNetworkPlan() : Name(), DTimStart(), Purpose(), ChangeLog(), uid(), soap() { }
        virtual ~prodml21__ProductFlowNetworkPlan() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowNetworkPlan(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowNetworkPlan * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowNetworkPlan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:448 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort (-159)
/* complex XML schema type 'prodml21:ProductFlowPort': */
class SOAP_CMAC prodml21__ProductFlowPort {
      public:
        /// Required element 'prodml21:Direction' of XML schema type 'prodml21:ProductFlowPortType'
        prodml21__ProductFlowPortType Direction;
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Optional element 'prodml21:PlanName' of XML schema type 'eml22:String64'
        std::string *PlanName;
        /// Optional element 'prodml21:Facility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml21:FacilityAlias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> FacilityAlias;
        /// Optional element 'prodml21:Exposed' of XML schema type 'xsd:boolean'
        bool *Exposed;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required element 'prodml21:ConnectedNode' of XML schema type 'prodml21:ConnectedNode'
        std::vector<prodml21__ConnectedNode *> ConnectedNode;
        /// Optional element 'prodml21:ExpectedFlowProduct' of XML schema type 'prodml21:ProductFlowQualifierExpected'
        std::vector<prodml21__ProductFlowQualifierExpected *> ExpectedFlowProduct;
        /// Optional element 'prodml21:ExpectedFlowProperty' of XML schema type 'prodml21:ProductFlowExpectedUnitProperty'
        std::vector<prodml21__ProductFlowExpectedUnitProperty *> ExpectedFlowProperty;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowPort, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowPort *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowPort); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowPort() : Direction(), Name(), PlanName(), Facility(), FacilityAlias(), Exposed(), Comment(), ConnectedNode(), ExpectedFlowProduct(), ExpectedFlowProperty(), uid(), soap() { }
        virtual ~prodml21__ProductFlowPort() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowPort(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowPort * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:452 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit (-161)
/* complex XML schema type 'prodml21:ProductFlowUnit': */
class SOAP_CMAC prodml21__ProductFlowUnit {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:PlanName' of XML schema type 'eml22:String64'
        std::string *PlanName;
        /// Optional element 'prodml21:InternalNetworkReference' of XML schema type 'eml22:String64'
        std::string *InternalNetworkReference;
        /// Optional element 'prodml21:Facility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml21:FacilityParent1' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent1;
        /// Optional element 'prodml21:FacilityParent2' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent2;
        /// Optional element 'prodml21:ContextFacility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        std::vector<prodml21__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:ExpectedProperty' of XML schema type 'prodml21:ProductFlowExpectedUnitProperty'
        std::vector<prodml21__ProductFlowExpectedUnitProperty *> ExpectedProperty;
        /// Optional element 'prodml21:RelativeCoordinate' of XML schema type 'prodml21:RelativeCoordinate'
        prodml21__RelativeCoordinate *RelativeCoordinate;
        /// Optional element 'prodml21:Port' of XML schema type 'prodml21:ProductFlowPort'
        std::vector<prodml21__ProductFlowPort *> Port;
        /// Optional element 'prodml21:FacilityAlias' of XML schema type 'prodml21:NameStruct'
        std::vector<prodml21__NameStruct *> FacilityAlias;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowUnit, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowUnit *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowUnit); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowUnit() : Name(), PlanName(), InternalNetworkReference(), Facility(), FacilityParent1(), FacilityParent2(), ContextFacility(), Comment(), ExpectedProperty(), RelativeCoordinate(), Port(), FacilityAlias(), uid(), soap() { }
        virtual ~prodml21__ProductFlowUnit() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowUnit * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:456 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate (-163)
/* complex XML schema type 'prodml21:RelativeCoordinate': */
class SOAP_CMAC prodml21__RelativeCoordinate {
      public:
        /// Optional element 'prodml21:X' of XML schema type 'eml22:LengthPerLengthMeasure'
        eml22__LengthPerLengthMeasure *X;
        /// Optional element 'prodml21:Y' of XML schema type 'eml22:LengthPerLengthMeasure'
        eml22__LengthPerLengthMeasure *Y;
        /// Optional element 'prodml21:Z' of XML schema type 'eml22:LengthPerLengthMeasure'
        eml22__LengthPerLengthMeasure *Z;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RelativeCoordinate, default initialized and not managed by a soap context
        virtual prodml21__RelativeCoordinate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RelativeCoordinate); }
      public:
        /// Constructor with default initializations
        prodml21__RelativeCoordinate() : X(), Y(), Z(), soap() { }
        virtual ~prodml21__RelativeCoordinate() { }
        /// Friend allocator used by soap_new_prodml21__RelativeCoordinate(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RelativeCoordinate * SOAP_FMAC2 soap_instantiate_prodml21__RelativeCoordinate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:24563 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__union_AbstractGasProducedRatioVolume
#define SOAP_TYPE_gsoap_eml2_2__prodml21__union_AbstractGasProducedRatioVolume (-1643)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml21__union_AbstractGasProducedRatioVolume
{
};
#endif

/* eml2_2ForGsoap.h:460 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume (-165)
/* Choice: */
class SOAP_CMAC prodml21__AbstractGasProducedRatioVolume {
      public:
        /// Union with union _prodml21__union_AbstractGasProducedRatioVolume variant selector __union_AbstractGasProducedRatioVolume set to one of:
        int __union_AbstractGasProducedRatioVolume;
        union _prodml21__union_AbstractGasProducedRatioVolume union_AbstractGasProducedRatioVolume;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractGasProducedRatioVolume, default initialized and not managed by a soap context
        virtual prodml21__AbstractGasProducedRatioVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractGasProducedRatioVolume); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractGasProducedRatioVolume() : __union_AbstractGasProducedRatioVolume(), soap() { }
        virtual ~prodml21__AbstractGasProducedRatioVolume() { }
        /// Friend allocator used by soap_new_prodml21__AbstractGasProducedRatioVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractGasProducedRatioVolume * SOAP_FMAC2 soap_instantiate_prodml21__AbstractGasProducedRatioVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:462 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume (-166)
/* complex XML schema type 'prodml21:AbstractLiquidDropoutPercVolume': */
class SOAP_CMAC prodml21__AbstractLiquidDropoutPercVolume {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractLiquidDropoutPercVolume, default initialized and not managed by a soap context
        virtual prodml21__AbstractLiquidDropoutPercVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractLiquidDropoutPercVolume); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractLiquidDropoutPercVolume() : soap() { }
        virtual ~prodml21__AbstractLiquidDropoutPercVolume() { }
        /// Friend allocator used by soap_new_prodml21__AbstractLiquidDropoutPercVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractLiquidDropoutPercVolume * SOAP_FMAC2 soap_instantiate_prodml21__AbstractLiquidDropoutPercVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:464 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage (-167)
/* complex XML schema type 'prodml21:AbstractOilVolShrinkage': */
class SOAP_CMAC prodml21__AbstractOilVolShrinkage {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractOilVolShrinkage, default initialized and not managed by a soap context
        virtual prodml21__AbstractOilVolShrinkage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractOilVolShrinkage); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractOilVolShrinkage() : soap() { }
        virtual ~prodml21__AbstractOilVolShrinkage() { }
        /// Friend allocator used by soap_new_prodml21__AbstractOilVolShrinkage(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractOilVolShrinkage * SOAP_FMAC2 soap_instantiate_prodml21__AbstractOilVolShrinkage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:466 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis (-168)
/* complex XML schema type 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis': */
class SOAP_CMAC prodml21__AtmosphericFlashTestAndCompositionalAnalysis {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Optional element 'prodml21:Date' of XML schema type 'xsd:date'
        std::string *Date;
        /// Optional element 'prodml21:FlashToPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *FlashToPressure;
        /// Optional element 'prodml21:FlashToTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *FlashToTemperature;
        /// Optional element 'prodml21:AtmosphericPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *AtmosphericPressure;
        /// Optional element 'prodml21:AtmosphericTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *AtmosphericTemperature;
        /// Optional element 'prodml21:FlashGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *FlashGOR;
        /// Optional element 'prodml21:OilFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilFormationVolumeFactor;
        /// Optional element 'prodml21:DensityAtSamplePressureandTemperature' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *DensityAtSamplePressureandTemperature;
        /// Optional element 'prodml21:AvgMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *AvgMolecularWeight;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:FlashedGas' of XML schema type 'prodml21:FlashedGas'
        prodml21__FlashedGas *FlashedGas;
        /// Optional element 'prodml21:FlashedLiquid' of XML schema type 'prodml21:FlashedLiquid'
        prodml21__FlashedLiquid *FlashedLiquid;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AtmosphericFlashTestAndCompositionalAnalysis, default initialized and not managed by a soap context
        virtual prodml21__AtmosphericFlashTestAndCompositionalAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AtmosphericFlashTestAndCompositionalAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__AtmosphericFlashTestAndCompositionalAnalysis() : TestNumber(), Date(), FlashToPressure(), FlashToTemperature(), AtmosphericPressure(), AtmosphericTemperature(), FlashGOR(), OilFormationVolumeFactor(), DensityAtSamplePressureandTemperature(), AvgMolecularWeight(), Remark(), OverallComposition(), FlashedGas(), FlashedLiquid(), uid(), soap() { }
        virtual ~prodml21__AtmosphericFlashTestAndCompositionalAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__AtmosphericFlashTestAndCompositionalAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AtmosphericFlashTestAndCompositionalAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__AtmosphericFlashTestAndCompositionalAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:468 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest (-169)
/* complex XML schema type 'prodml21:ConstantCompositionExpansionTest': */
class SOAP_CMAC prodml21__ConstantCompositionExpansionTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:LiquidFractionReference' of XML schema type 'prodml21:FluidVolumeReference'
        std::vector<prodml21__FluidVolumeReference *> LiquidFractionReference;
        /// Optional element 'prodml21:RelativeVolumeReference' of XML schema type 'prodml21:FluidVolumeReference'
        std::vector<prodml21__FluidVolumeReference *> RelativeVolumeReference;
        /// Optional element 'prodml21:ConstantCompositionExpansionTestStep' of XML schema type 'prodml21:ConstantCompositionExpansionTestStep'
        std::vector<prodml21__ConstantCompositionExpansionTestStep *> ConstantCompositionExpansionTestStep;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConstantCompositionExpansionTest, default initialized and not managed by a soap context
        virtual prodml21__ConstantCompositionExpansionTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConstantCompositionExpansionTest); }
      public:
        /// Constructor with default initializations
        prodml21__ConstantCompositionExpansionTest() : TestNumber(), TestTemperature(), SaturationPressure(), LiquidFractionReference(), RelativeVolumeReference(), ConstantCompositionExpansionTestStep(), Remark(), uid(), soap() { }
        virtual ~prodml21__ConstantCompositionExpansionTest() { }
        /// Friend allocator used by soap_new_prodml21__ConstantCompositionExpansionTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConstantCompositionExpansionTest * SOAP_FMAC2 soap_instantiate_prodml21__ConstantCompositionExpansionTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:470 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep (-170)
/* complex XML schema type 'prodml21:ConstantCompositionExpansionTestStep': */
class SOAP_CMAC prodml21__ConstantCompositionExpansionTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Required element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:LiquidFraction' of XML schema type 'prodml21:RelativeVolumeRatio'
        prodml21__RelativeVolumeRatio *LiquidFraction;
        /// Optional element 'prodml21:OilDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *OilDensity;
        /// Optional element 'prodml21:OilCompressibility' of XML schema type 'prodml21:OilCompressibility'
        prodml21__OilCompressibility *OilCompressibility;
        /// Optional element 'prodml21:OilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *OilViscosity;
        /// Optional element 'prodml21:TotalVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *TotalVolume;
        /// Optional element 'prodml21:RelativeVolumeRatio' of XML schema type 'prodml21:RelativeVolumeRatio'
        prodml21__RelativeVolumeRatio *RelativeVolumeRatio;
        /// Optional element 'prodml21:GasDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasDensity;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:GasCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasure'
        eml22__ReciprocalPressureMeasure *GasCompressibility;
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:YFunction' of XML schema type 'xsd:double'
        double *YFunction;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConstantCompositionExpansionTestStep, default initialized and not managed by a soap context
        virtual prodml21__ConstantCompositionExpansionTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConstantCompositionExpansionTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__ConstantCompositionExpansionTestStep() : StepNumber(), StepPressure(), LiquidFraction(), OilDensity(), OilCompressibility(), OilViscosity(), TotalVolume(), RelativeVolumeRatio(), GasDensity(), GasZFactor(), GasCompressibility(), GasViscosity(), YFunction(), FluidCondition(), PhasesPresent(), VaporComposition(), LiquidComposition(), OverallComposition(), Remark(), uid(), soap() { }
        virtual ~prodml21__ConstantCompositionExpansionTestStep() { }
        /// Friend allocator used by soap_new_prodml21__ConstantCompositionExpansionTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConstantCompositionExpansionTestStep * SOAP_FMAC2 soap_instantiate_prodml21__ConstantCompositionExpansionTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:472 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest (-171)
/* complex XML schema type 'prodml21:ConstantVolumeDepletionTest': */
class SOAP_CMAC prodml21__ConstantVolumeDepletionTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Optional element 'prodml21:CumulativeGasProducedReferenceStd' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *CumulativeGasProducedReferenceStd;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:CvdTestStep' of XML schema type 'prodml21:FluidCvdTestStep'
        std::vector<prodml21__FluidCvdTestStep *> CvdTestStep;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:LiquidDropoutReference' of XML schema type 'prodml21:FluidVolumeReference'
        std::vector<prodml21__FluidVolumeReference *> LiquidDropoutReference;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConstantVolumeDepletionTest, default initialized and not managed by a soap context
        virtual prodml21__ConstantVolumeDepletionTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConstantVolumeDepletionTest); }
      public:
        /// Constructor with default initializations
        prodml21__ConstantVolumeDepletionTest() : TestNumber(), TestTemperature(), CumulativeGasProducedReferenceStd(), Remark(), CvdTestStep(), SaturationPressure(), LiquidDropoutReference(), uid(), soap() { }
        virtual ~prodml21__ConstantVolumeDepletionTest() { }
        /// Friend allocator used by soap_new_prodml21__ConstantVolumeDepletionTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConstantVolumeDepletionTest * SOAP_FMAC2 soap_instantiate_prodml21__ConstantVolumeDepletionTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:478 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest (-174)
/* complex XML schema type 'prodml21:DifferentialLiberationTest': */
class SOAP_CMAC prodml21__DifferentialLiberationTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Required element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:SeparatorConditions' of XML schema type 'prodml21:SeparatorConditions'
        prodml21__SeparatorConditions *SeparatorConditions;
        /// Optional element 'prodml21:CorrectionMethod' of XML schema type 'eml22:String64'
        std::string *CorrectionMethod;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:DlTestStep' of XML schema type 'prodml21:FluidDifferentialLiberationTestStep'
        std::vector<prodml21__FluidDifferentialLiberationTestStep *> DlTestStep;
        /// Optional element 'prodml21:ShrinkageReference' of XML schema type 'prodml21:FluidVolumeReference'
        prodml21__FluidVolumeReference *ShrinkageReference;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DifferentialLiberationTest, default initialized and not managed by a soap context
        virtual prodml21__DifferentialLiberationTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DifferentialLiberationTest); }
      public:
        /// Constructor with default initializations
        prodml21__DifferentialLiberationTest() : TestNumber(), TestTemperature(), SaturationPressure(), SeparatorConditions(), CorrectionMethod(), Remark(), DlTestStep(), ShrinkageReference(), uid(), soap() { }
        virtual ~prodml21__DifferentialLiberationTest() { }
        /// Friend allocator used by soap_new_prodml21__DifferentialLiberationTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DifferentialLiberationTest * SOAP_FMAC2 soap_instantiate_prodml21__DifferentialLiberationTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:480 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas (-175)
/* complex XML schema type 'prodml21:FlashedGas': */
class SOAP_CMAC prodml21__FlashedGas {
      public:
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:GasMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolecularWeight;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:GasHeatingValue' of XML schema type 'eml22:EnergyMeasure'
        eml22__EnergyMeasure *GasHeatingValue;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FlashedGas, default initialized and not managed by a soap context
        virtual prodml21__FlashedGas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FlashedGas); }
      public:
        /// Constructor with default initializations
        prodml21__FlashedGas() : GasGravity(), GasMolecularWeight(), GasZFactor(), GasHeatingValue(), VaporComposition(), soap() { }
        virtual ~prodml21__FlashedGas() { }
        /// Friend allocator used by soap_new_prodml21__FlashedGas(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FlashedGas * SOAP_FMAC2 soap_instantiate_prodml21__FlashedGas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:482 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid (-176)
/* complex XML schema type 'prodml21:FlashedLiquid': */
class SOAP_CMAC prodml21__FlashedLiquid {
      public:
        /// Optional element 'prodml21:OilAPIGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilAPIGravity;
        /// Optional element 'prodml21:OilMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *OilMolecularWeight;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FlashedLiquid, default initialized and not managed by a soap context
        virtual prodml21__FlashedLiquid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FlashedLiquid); }
      public:
        /// Constructor with default initializations
        prodml21__FlashedLiquid() : OilAPIGravity(), OilMolecularWeight(), LiquidComposition(), soap() { }
        virtual ~prodml21__FlashedLiquid() { }
        /// Friend allocator used by soap_new_prodml21__FlashedLiquid(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FlashedLiquid * SOAP_FMAC2 soap_instantiate_prodml21__FlashedLiquid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:486 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport (-178)
/* complex XML schema type 'prodml21:FluidAnalysisReport': */
class SOAP_CMAC prodml21__FluidAnalysisReport {
      public:
        /// Optional element 'prodml21:ReportIdentifier' of XML schema type 'eml22:String64'
        std::string *ReportIdentifier;
        /// Optional element 'prodml21:ReportDate' of XML schema type 'xsd:date'
        std::string *ReportDate;
        /// Optional element 'prodml21:Author' of XML schema type 'eml22:String64'
        std::string *Author;
        /// Optional element 'prodml21:AnalysisLaboratory' of XML schema type 'eml22:String64'
        std::string *AnalysisLaboratory;
        /// Optional element 'prodml21:ReportDocument' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportDocument;
        /// Optional element 'prodml21:ReportLocation' of XML schema type 'prodml21:ReportLocation'
        std::vector<prodml21__ReportLocation *> ReportLocation;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidAnalysisReport, default initialized and not managed by a soap context
        virtual prodml21__FluidAnalysisReport *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidAnalysisReport); }
      public:
        /// Constructor with default initializations
        prodml21__FluidAnalysisReport() : ReportIdentifier(), ReportDate(), Author(), AnalysisLaboratory(), ReportDocument(), ReportLocation(), uid(), soap() { }
        virtual ~prodml21__FluidAnalysisReport() { }
        /// Friend allocator used by soap_new_prodml21__FluidAnalysisReport(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidAnalysisReport * SOAP_FMAC2 soap_instantiate_prodml21__FluidAnalysisReport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:488 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep (-179)
/* complex XML schema type 'prodml21:FluidCvdTestStep': */
class SOAP_CMAC prodml21__FluidCvdTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Required element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:OilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *OilViscosity;
        /// Optional element 'prodml21:OilDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *OilDensity;
        /// Optional element 'prodml21:GasMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolecularWeight;
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:GasFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GasFormationVolumeFactor;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:Phase2ZFactor' of XML schema type 'xsd:double'
        double *Phase2ZFactor;
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:CumulativeFluidProducedFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *CumulativeFluidProducedFraction;
        /// Optional element 'prodml21:LiquidFraction' of XML schema type 'prodml21:RelativeVolumeRatio'
        prodml21__RelativeVolumeRatio *LiquidFraction;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCvdTestStep, default initialized and not managed by a soap context
        virtual prodml21__FluidCvdTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCvdTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCvdTestStep() : StepNumber(), StepPressure(), OilViscosity(), OilDensity(), GasMolecularWeight(), GasGravity(), GasFormationVolumeFactor(), GasZFactor(), Phase2ZFactor(), GasViscosity(), CumulativeFluidProducedFraction(), LiquidFraction(), FluidCondition(), PhasesPresent(), LiquidComposition(), VaporComposition(), OverallComposition(), Remark(), uid(), soap() { }
        virtual ~prodml21__FluidCvdTestStep() { }
        /// Friend allocator used by soap_new_prodml21__FluidCvdTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCvdTestStep * SOAP_FMAC2 soap_instantiate_prodml21__FluidCvdTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:490 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep (-180)
/* complex XML schema type 'prodml21:FluidDifferentialLiberationTestStep': */
class SOAP_CMAC prodml21__FluidDifferentialLiberationTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Required element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:StepTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StepTemperature;
        /// Optional element 'prodml21:OilDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *OilDensity;
        /// Optional element 'prodml21:OilFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilFormationVolumeFactor;
        /// Optional element 'prodml21:OilCompressibility' of XML schema type 'prodml21:OilCompressibility'
        prodml21__OilCompressibility *OilCompressibility;
        /// Optional element 'prodml21:OilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *OilViscosity;
        /// Optional element 'prodml21:GasMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolecularWeight;
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:GasDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasDensity;
        /// Optional element 'prodml21:GasFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GasFormationVolumeFactor;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:TotalFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *TotalFormationVolumeFactor;
        /// Optional element 'prodml21:SolutionGORMeasured' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGORMeasured;
        /// Optional element 'prodml21:SolutionGORCorrect' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGORCorrect;
        /// Optional element 'prodml21:CumulativeStockTankGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *CumulativeStockTankGOR;
        /// Optional element 'prodml21:OilFormationVolumeFactorCorrected' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilFormationVolumeFactorCorrected;
        /// Optional element 'prodml21:ResidualAPIGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *ResidualAPIGravity;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidDifferentialLiberationTestStep, default initialized and not managed by a soap context
        virtual prodml21__FluidDifferentialLiberationTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidDifferentialLiberationTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__FluidDifferentialLiberationTestStep() : StepNumber(), StepPressure(), StepTemperature(), OilDensity(), OilFormationVolumeFactor(), OilCompressibility(), OilViscosity(), GasMolecularWeight(), GasGravity(), GasDensity(), GasFormationVolumeFactor(), GasZFactor(), GasViscosity(), TotalFormationVolumeFactor(), SolutionGORMeasured(), SolutionGORCorrect(), CumulativeStockTankGOR(), OilFormationVolumeFactorCorrected(), ResidualAPIGravity(), FluidCondition(), PhasesPresent(), LiquidComposition(), VaporComposition(), OverallComposition(), Remark(), uid(), soap() { }
        virtual ~prodml21__FluidDifferentialLiberationTestStep() { }
        /// Friend allocator used by soap_new_prodml21__FluidDifferentialLiberationTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidDifferentialLiberationTestStep * SOAP_FMAC2 soap_instantiate_prodml21__FluidDifferentialLiberationTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:492 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest (-181)
/* complex XML schema type 'prodml21:FluidSeparatorTest': */
class SOAP_CMAC prodml21__FluidSeparatorTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:SaturatedOilFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SaturatedOilFormationVolumeFactor;
        /// Optional element 'prodml21:SaturatedOilDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *SaturatedOilDensity;
        /// Optional element 'prodml21:SeparatorTestGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SeparatorTestGOR;
        /// Optional element 'prodml21:OverallGasGravity' of XML schema type 'xsd:double'
        double *OverallGasGravity;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SeparatorTestStep' of XML schema type 'prodml21:FluidSeparatorTestStep'
        std::vector<prodml21__FluidSeparatorTestStep *> SeparatorTestStep;
        /// Optional element 'prodml21:ShrinkageReference' of XML schema type 'prodml21:FluidVolumeReference'
        prodml21__FluidVolumeReference *ShrinkageReference;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSeparatorTest, default initialized and not managed by a soap context
        virtual prodml21__FluidSeparatorTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSeparatorTest); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSeparatorTest() : TestNumber(), ReservoirTemperature(), SaturationPressure(), SaturatedOilFormationVolumeFactor(), SaturatedOilDensity(), SeparatorTestGOR(), OverallGasGravity(), Remark(), SeparatorTestStep(), ShrinkageReference(), uid(), soap() { }
        virtual ~prodml21__FluidSeparatorTest() { }
        /// Friend allocator used by soap_new_prodml21__FluidSeparatorTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSeparatorTest * SOAP_FMAC2 soap_instantiate_prodml21__FluidSeparatorTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:494 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep (-182)
/* complex XML schema type 'prodml21:FluidSeparatorTestStep': */
class SOAP_CMAC prodml21__FluidSeparatorTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Required element 'prodml21:StepTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StepTemperature;
        /// Required element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:BubblePointPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *BubblePointPressure;
        /// Optional element 'prodml21:ResidualAPIGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *ResidualAPIGravity;
        /// Optional element 'prodml21:OilSpecificGravity' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *OilSpecificGravity;
        /// Optional element 'prodml21:OilDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *OilDensity;
        /// Optional element 'prodml21:OilFormationVolumeFactorStd' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilFormationVolumeFactorStd;
        /// Optional element 'prodml21:OilFormationVolumeFactorCorrected' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilFormationVolumeFactorCorrected;
        /// Optional element 'prodml21:OilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *OilViscosity;
        /// Optional element 'prodml21:StageSeparatorGORStd' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *StageSeparatorGORStd;
        /// Optional element 'prodml21:StageSeparatorGORCorrected' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *StageSeparatorGORCorrected;
        /// Optional element 'prodml21:GasMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolecularWeight;
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:GasDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasDensity;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:GasVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *GasVolume;
        /// Optional element 'prodml21:OilShrinkageFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilShrinkageFactor;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSeparatorTestStep, default initialized and not managed by a soap context
        virtual prodml21__FluidSeparatorTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSeparatorTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSeparatorTestStep() : StepNumber(), StepTemperature(), StepPressure(), BubblePointPressure(), ResidualAPIGravity(), OilSpecificGravity(), OilDensity(), OilFormationVolumeFactorStd(), OilFormationVolumeFactorCorrected(), OilViscosity(), StageSeparatorGORStd(), StageSeparatorGORCorrected(), GasMolecularWeight(), GasGravity(), GasDensity(), GasZFactor(), GasViscosity(), GasVolume(), OilShrinkageFactor(), SaturationPressure(), FluidCondition(), PhasesPresent(), LiquidComposition(), VaporComposition(), OverallComposition(), Remark(), uid(), soap() { }
        virtual ~prodml21__FluidSeparatorTestStep() { }
        /// Friend allocator used by soap_new_prodml21__FluidSeparatorTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSeparatorTestStep * SOAP_FMAC2 soap_instantiate_prodml21__FluidSeparatorTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:496 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference (-183)
/* complex XML schema type 'prodml21:FluidVolumeReference': */
class SOAP_CMAC prodml21__FluidVolumeReference {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:VolumeReferenceKind'
        prodml21__VolumeReferenceKind Kind;
        /// Optional element 'prodml21:ReferenceVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *ReferenceVolume;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidVolumeReference, default initialized and not managed by a soap context
        virtual prodml21__FluidVolumeReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidVolumeReference); }
      public:
        /// Constructor with default initializations
        prodml21__FluidVolumeReference() : Kind(), ReferenceVolume(), Remark(), uid(), soap() { }
        virtual ~prodml21__FluidVolumeReference() { }
        /// Friend allocator used by soap_new_prodml21__FluidVolumeReference(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidVolumeReference * SOAP_FMAC2 soap_instantiate_prodml21__FluidVolumeReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:500 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas (-185)
/* complex XML schema type 'prodml21:InjectedGas': */
class SOAP_CMAC prodml21__InjectedGas {
      public:
        /// Required element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        std::vector<prodml21__VaporComposition *> VaporComposition;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InjectedGas, default initialized and not managed by a soap context
        virtual prodml21__InjectedGas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InjectedGas); }
      public:
        /// Constructor with default initializations
        prodml21__InjectedGas() : VaporComposition(), uid(), soap() { }
        virtual ~prodml21__InjectedGas() { }
        /// Friend allocator used by soap_new_prodml21__InjectedGas(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InjectedGas * SOAP_FMAC2 soap_instantiate_prodml21__InjectedGas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:502 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest (-186)
/* complex XML schema type 'prodml21:InterfacialTensionTest': */
class SOAP_CMAC prodml21__InterfacialTensionTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:WettingPhase' of XML schema type 'prodml21:ThermodynamicPhase'
        prodml21__ThermodynamicPhase WettingPhase;
        /// Required element 'prodml21:nonWettingPhase' of XML schema type 'prodml21:ThermodynamicPhase'
        prodml21__ThermodynamicPhase nonWettingPhase;
        /// Optional element 'prodml21:Surfactant' of XML schema type 'prodml21:AbstractFluidComponent'
        prodml21__AbstractFluidComponent *Surfactant;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:InterfacialTensionTestStep' of XML schema type 'prodml21:InterfacialTensionTestStep'
        std::vector<prodml21__InterfacialTensionTestStep *> InterfacialTensionTestStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InterfacialTensionTest, default initialized and not managed by a soap context
        virtual prodml21__InterfacialTensionTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InterfacialTensionTest); }
      public:
        /// Constructor with default initializations
        prodml21__InterfacialTensionTest() : TestNumber(), WettingPhase(), nonWettingPhase(), Surfactant(), Remark(), InterfacialTensionTestStep(), uid(), soap() { }
        virtual ~prodml21__InterfacialTensionTest() { }
        /// Friend allocator used by soap_new_prodml21__InterfacialTensionTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InterfacialTensionTest * SOAP_FMAC2 soap_instantiate_prodml21__InterfacialTensionTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:504 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep (-187)
/* complex XML schema type 'prodml21:InterfacialTensionTestStep': */
class SOAP_CMAC prodml21__InterfacialTensionTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Optional element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:StepTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StepTemperature;
        /// Optional element 'prodml21:WettingPhaseSaturation' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *WettingPhaseSaturation;
        /// Optional element 'prodml21:SurfactantConcentration' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *SurfactantConcentration;
        /// Optional element 'prodml21:InterfacialTension' of XML schema type 'eml22:ForcePerLengthMeasure'
        eml22__ForcePerLengthMeasure *InterfacialTension;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InterfacialTensionTestStep, default initialized and not managed by a soap context
        virtual prodml21__InterfacialTensionTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InterfacialTensionTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__InterfacialTensionTestStep() : StepNumber(), StepPressure(), StepTemperature(), WettingPhaseSaturation(), SurfactantConcentration(), InterfacialTension(), Remark(), uid(), soap() { }
        virtual ~prodml21__InterfacialTensionTestStep() { }
        /// Friend allocator used by soap_new_prodml21__InterfacialTensionTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InterfacialTensionTestStep * SOAP_FMAC2 soap_instantiate_prodml21__InterfacialTensionTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:510 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance (-190)
/* complex XML schema type 'prodml21:MassBalance': */
class SOAP_CMAC prodml21__MassBalance {
      public:
        /// Optional element 'prodml21:MassBalanceFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassBalanceFraction;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:MassOut' of XML schema type 'prodml21:MassOut'
        prodml21__MassOut *MassOut;
        /// Optional element 'prodml21:MassIn' of XML schema type 'prodml21:MassIn'
        prodml21__MassIn *MassIn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MassBalance, default initialized and not managed by a soap context
        virtual prodml21__MassBalance *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MassBalance); }
      public:
        /// Constructor with default initializations
        prodml21__MassBalance() : MassBalanceFraction(), Remark(), MassOut(), MassIn(), soap() { }
        virtual ~prodml21__MassBalance() { }
        /// Friend allocator used by soap_new_prodml21__MassBalance(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MassBalance * SOAP_FMAC2 soap_instantiate_prodml21__MassBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:512 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn (-191)
/* complex XML schema type 'prodml21:MassIn': */
class SOAP_CMAC prodml21__MassIn {
      public:
        /// Optional element 'prodml21:MassFluidSlimtube' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassFluidSlimtube;
        /// Optional element 'prodml21:MassFluidConnectingLines' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassFluidConnectingLines;
        /// Optional element 'prodml21:MassInjectedGasSolvent' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassInjectedGasSolvent;
        /// Optional element 'prodml21:TotalMassIn' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *TotalMassIn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MassIn, default initialized and not managed by a soap context
        virtual prodml21__MassIn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MassIn); }
      public:
        /// Constructor with default initializations
        prodml21__MassIn() : MassFluidSlimtube(), MassFluidConnectingLines(), MassInjectedGasSolvent(), TotalMassIn(), soap() { }
        virtual ~prodml21__MassIn() { }
        /// Friend allocator used by soap_new_prodml21__MassIn(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MassIn * SOAP_FMAC2 soap_instantiate_prodml21__MassIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:514 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut (-192)
/* complex XML schema type 'prodml21:MassOut': */
class SOAP_CMAC prodml21__MassOut {
      public:
        /// Optional element 'prodml21:MassEffluentStockTankOil' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassEffluentStockTankOil;
        /// Optional element 'prodml21:MassProducedEffluentGas' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassProducedEffluentGas;
        /// Optional element 'prodml21:MassResidualOil' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassResidualOil;
        /// Optional element 'prodml21:MassProducedEffluentGasFlowDown' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *MassProducedEffluentGasFlowDown;
        /// Optional element 'prodml21:TotalMassOut' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *TotalMassOut;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MassOut, default initialized and not managed by a soap context
        virtual prodml21__MassOut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MassOut); }
      public:
        /// Constructor with default initializations
        prodml21__MassOut() : MassEffluentStockTankOil(), MassProducedEffluentGas(), MassResidualOil(), MassProducedEffluentGasFlowDown(), TotalMassOut(), soap() { }
        virtual ~prodml21__MassOut() { }
        /// Friend allocator used by soap_new_prodml21__MassOut(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MassOut * SOAP_FMAC2 soap_instantiate_prodml21__MassOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:516 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest (-193)
/* complex XML schema type 'prodml21:MultipleContactMiscibilityTest': */
class SOAP_CMAC prodml21__MultipleContactMiscibilityTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Optional element 'prodml21:GasSolventCompositionReference' of XML schema type 'eml22:String64'
        std::string *GasSolventCompositionReference;
        /// Optional element 'prodml21:MixRatio' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *MixRatio;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MultipleContactMiscibilityTest, default initialized and not managed by a soap context
        virtual prodml21__MultipleContactMiscibilityTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MultipleContactMiscibilityTest); }
      public:
        /// Constructor with default initializations
        prodml21__MultipleContactMiscibilityTest() : TestNumber(), GasSolventCompositionReference(), MixRatio(), uid(), soap() { }
        virtual ~prodml21__MultipleContactMiscibilityTest() { }
        /// Friend allocator used by soap_new_prodml21__MultipleContactMiscibilityTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MultipleContactMiscibilityTest * SOAP_FMAC2 soap_instantiate_prodml21__MultipleContactMiscibilityTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:524 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest (-197)
/* complex XML schema type 'prodml21:OtherMeasurementTest': */
class SOAP_CMAC prodml21__OtherMeasurementTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidCharacterizationTable' of XML schema type 'prodml21:FluidCharacterizationTable'
        prodml21__FluidCharacterizationTable *FluidCharacterizationTable;
        /// Optional element 'prodml21:FluidCharacterizationTableFormatSet' of XML schema type 'prodml21:FluidCharacterizationTableFormatSet'
        prodml21__FluidCharacterizationTableFormatSet *FluidCharacterizationTableFormatSet;
        /// Optional element 'prodml21:OtherMeasurementTestStep' of XML schema type 'prodml21:OtherMeasurementTestStep'
        std::vector<prodml21__OtherMeasurementTestStep *> OtherMeasurementTestStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OtherMeasurementTest, default initialized and not managed by a soap context
        virtual prodml21__OtherMeasurementTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OtherMeasurementTest); }
      public:
        /// Constructor with default initializations
        prodml21__OtherMeasurementTest() : TestNumber(), Remark(), FluidCharacterizationTable(), FluidCharacterizationTableFormatSet(), OtherMeasurementTestStep(), uid(), soap() { }
        virtual ~prodml21__OtherMeasurementTest() { }
        /// Friend allocator used by soap_new_prodml21__OtherMeasurementTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OtherMeasurementTest * SOAP_FMAC2 soap_instantiate_prodml21__OtherMeasurementTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:526 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep (-198)
/* complex XML schema type 'prodml21:OtherMeasurementTestStep': */
class SOAP_CMAC prodml21__OtherMeasurementTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Optional element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Optional element 'prodml21:StepTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StepTemperature;
        /// Optional element 'prodml21:OilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *OilViscosity;
        /// Optional element 'prodml21:OilMassDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *OilMassDensity;
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:GasMassDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasMassDensity;
        /// Optional element 'prodml21:GasZFactor' of XML schema type 'xsd:double'
        double *GasZFactor;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:WaterContent' of XML schema type 'eml22:String64'
        std::string *WaterContent;
        /// Optional element 'prodml21:WaterViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *WaterViscosity;
        /// Optional element 'prodml21:Salinity' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Salinity;
        /// Optional element 'prodml21:Rsw' of XML schema type 'xsd:double'
        double *Rsw;
        /// Optional element 'prodml21:Shear' of XML schema type 'xsd:double'
        double *Shear;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OtherMeasurementTestStep, default initialized and not managed by a soap context
        virtual prodml21__OtherMeasurementTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OtherMeasurementTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__OtherMeasurementTestStep() : StepNumber(), StepPressure(), StepTemperature(), OilViscosity(), OilMassDensity(), GasViscosity(), GasGravity(), GasMassDensity(), GasZFactor(), FluidCondition(), WaterContent(), WaterViscosity(), Salinity(), Rsw(), Shear(), Remark(), uid(), soap() { }
        virtual ~prodml21__OtherMeasurementTestStep() { }
        /// Friend allocator used by soap_new_prodml21__OtherMeasurementTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OtherMeasurementTestStep * SOAP_FMAC2 soap_instantiate_prodml21__OtherMeasurementTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:528 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity (-199)
/* complex XML schema type 'prodml21:PhaseDensity': */
class SOAP_CMAC prodml21__PhaseDensity {
      public:
        /// Optional element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
        /// Optional element 'prodml21:Density' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *Density;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PhaseDensity, default initialized and not managed by a soap context
        virtual prodml21__PhaseDensity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PhaseDensity); }
      public:
        /// Constructor with default initializations
        prodml21__PhaseDensity() : Pressure(), Density(), uid(), soap() { }
        virtual ~prodml21__PhaseDensity() { }
        /// Friend allocator used by soap_new_prodml21__PhaseDensity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PhaseDensity * SOAP_FMAC2 soap_instantiate_prodml21__PhaseDensity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:530 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity (-200)
/* complex XML schema type 'prodml21:PhaseViscosity': */
class SOAP_CMAC prodml21__PhaseViscosity {
      public:
        /// Optional element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
        /// Optional element 'prodml21:Viscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *Viscosity;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PhaseViscosity, default initialized and not managed by a soap context
        virtual prodml21__PhaseViscosity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PhaseViscosity); }
      public:
        /// Constructor with default initializations
        prodml21__PhaseViscosity() : Pressure(), Viscosity(), uid(), soap() { }
        virtual ~prodml21__PhaseViscosity() { }
        /// Friend allocator used by soap_new_prodml21__PhaseViscosity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PhaseViscosity * SOAP_FMAC2 soap_instantiate_prodml21__PhaseViscosity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:532 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties (-201)
/* complex XML schema type 'prodml21:ProducedGasProperties': */
class SOAP_CMAC prodml21__ProducedGasProperties {
      public:
        /// Optional element 'prodml21:ProducedGasGravity' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *ProducedGasGravity;
        /// Required element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        std::vector<prodml21__VaporComposition *> VaporComposition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProducedGasProperties, default initialized and not managed by a soap context
        virtual prodml21__ProducedGasProperties *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProducedGasProperties); }
      public:
        /// Constructor with default initializations
        prodml21__ProducedGasProperties() : ProducedGasGravity(), VaporComposition(), soap() { }
        virtual ~prodml21__ProducedGasProperties() { }
        /// Friend allocator used by soap_new_prodml21__ProducedGasProperties(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProducedGasProperties * SOAP_FMAC2 soap_instantiate_prodml21__ProducedGasProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:534 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties (-202)
/* complex XML schema type 'prodml21:ProducedOilProperties': */
class SOAP_CMAC prodml21__ProducedOilProperties {
      public:
        /// Optional element 'prodml21:STODensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *STODensity;
        /// Optional element 'prodml21:STOApiGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *STOApiGravity;
        /// Optional element 'prodml21:STOMW' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *STOMW;
        /// Optional element 'prodml21:STOWaterContent' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *STOWaterContent;
        /// Optional element 'prodml21:AsphalteneContent' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *AsphalteneContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProducedOilProperties, default initialized and not managed by a soap context
        virtual prodml21__ProducedOilProperties *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProducedOilProperties); }
      public:
        /// Constructor with default initializations
        prodml21__ProducedOilProperties() : STODensity(), STOApiGravity(), STOMW(), STOWaterContent(), AsphalteneContent(), soap() { }
        virtual ~prodml21__ProducedOilProperties() { }
        /// Friend allocator used by soap_new_prodml21__ProducedOilProperties(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProducedOilProperties * SOAP_FMAC2 soap_instantiate_prodml21__ProducedOilProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:540 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation (-205)
/* complex XML schema type 'prodml21:ReportLocation': */
class SOAP_CMAC prodml21__ReportLocation {
      public:
        /// Optional element 'prodml21:LocationDate' of XML schema type 'xsd:date'
        std::string *LocationDate;
        /// Optional element 'prodml21:LocationType' of XML schema type 'eml22:String64'
        std::string *LocationType;
        /// Optional element 'prodml21:Location' of XML schema type 'eml22:String64'
        std::string *Location;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReportLocation, default initialized and not managed by a soap context
        virtual prodml21__ReportLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReportLocation); }
      public:
        /// Constructor with default initializations
        prodml21__ReportLocation() : LocationDate(), LocationType(), Location(), Remark(), uid(), soap() { }
        virtual ~prodml21__ReportLocation() { }
        /// Friend allocator used by soap_new_prodml21__ReportLocation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReportLocation * SOAP_FMAC2 soap_instantiate_prodml21__ReportLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:542 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant (-206)
/* complex XML schema type 'prodml21:SampleContaminant': */
class SOAP_CMAC prodml21__SampleContaminant {
      public:
        /// Required element 'prodml21:ContaminantKind' of XML schema type 'prodml21:FluidContaminant'
        prodml21__FluidContaminant ContaminantKind;
        /// Optional element 'prodml21:WeightFractionStockTank' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WeightFractionStockTank;
        /// Optional element 'prodml21:VolumeFractionStockTank' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *VolumeFractionStockTank;
        /// Optional element 'prodml21:WeightFractionLiveSample' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WeightFractionLiveSample;
        /// Optional element 'prodml21:VolumeFractionLiveSample' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *VolumeFractionLiveSample;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml21:Density' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *Density;
        /// Optional element 'prodml21:ContaminantComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *ContaminantComposition;
        /// Optional element 'prodml21:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SampleOfContaminant' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *SampleOfContaminant;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SampleContaminant, default initialized and not managed by a soap context
        virtual prodml21__SampleContaminant *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SampleContaminant); }
      public:
        /// Constructor with default initializations
        prodml21__SampleContaminant() : ContaminantKind(), WeightFractionStockTank(), VolumeFractionStockTank(), WeightFractionLiveSample(), VolumeFractionLiveSample(), MolecularWeight(), Density(), ContaminantComposition(), Description(), Remark(), SampleOfContaminant(), uid(), soap() { }
        virtual ~prodml21__SampleContaminant() { }
        /// Friend allocator used by soap_new_prodml21__SampleContaminant(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SampleContaminant * SOAP_FMAC2 soap_instantiate_prodml21__SampleContaminant(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:544 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation (-207)
/* complex XML schema type 'prodml21:SampleIntegrityAndPreparation': */
class SOAP_CMAC prodml21__SampleIntegrityAndPreparation {
      public:
        /// Required element 'prodml21:OpeningDate' of XML schema type 'xsd:date'
        std::string OpeningDate;
        /// Optional element 'prodml21:InitialVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *InitialVolume;
        /// Optional element 'prodml21:OpeningPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *OpeningPressure;
        /// Optional element 'prodml21:OpeningTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *OpeningTemperature;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:SaturationTemperature' of XML schema type 'prodml21:SaturationTemperature'
        prodml21__SaturationTemperature *SaturationTemperature;
        /// Optional element 'prodml21:BasicSedimentAndWater' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *BasicSedimentAndWater;
        /// Optional element 'prodml21:FreeWaterVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *FreeWaterVolume;
        /// Optional element 'prodml21:WaterContentInHydrocarbon' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WaterContentInHydrocarbon;
        /// Optional element 'prodml21:OpeningRemark' of XML schema type 'eml22:String2000'
        std::string *OpeningRemark;
        /// Optional element 'prodml21:SampleRestoration' of XML schema type 'prodml21:SampleRestoration'
        std::vector<prodml21__SampleRestoration *> SampleRestoration;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SampleIntegrityAndPreparation, default initialized and not managed by a soap context
        virtual prodml21__SampleIntegrityAndPreparation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SampleIntegrityAndPreparation); }
      public:
        /// Constructor with default initializations
        prodml21__SampleIntegrityAndPreparation() : OpeningDate(), InitialVolume(), OpeningPressure(), OpeningTemperature(), SaturationPressure(), SaturationTemperature(), BasicSedimentAndWater(), FreeWaterVolume(), WaterContentInHydrocarbon(), OpeningRemark(), SampleRestoration(), uid(), soap() { }
        virtual ~prodml21__SampleIntegrityAndPreparation() { }
        /// Friend allocator used by soap_new_prodml21__SampleIntegrityAndPreparation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SampleIntegrityAndPreparation * SOAP_FMAC2 soap_instantiate_prodml21__SampleIntegrityAndPreparation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:546 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration (-208)
/* complex XML schema type 'prodml21:SampleRestoration': */
class SOAP_CMAC prodml21__SampleRestoration {
      public:
        /// Optional element 'prodml21:Date' of XML schema type 'xsd:date'
        std::string *Date;
        /// Optional element 'prodml21:RestorationDuration' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *RestorationDuration;
        /// Optional element 'prodml21:RestorationPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *RestorationPressure;
        /// Optional element 'prodml21:RestorationTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *RestorationTemperature;
        /// Optional element 'prodml21:MixingMechanism' of XML schema type 'eml22:String64'
        std::string *MixingMechanism;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SampleRestoration, default initialized and not managed by a soap context
        virtual prodml21__SampleRestoration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SampleRestoration); }
      public:
        /// Constructor with default initializations
        prodml21__SampleRestoration() : Date(), RestorationDuration(), RestorationPressure(), RestorationTemperature(), MixingMechanism(), Remark(), soap() { }
        virtual ~prodml21__SampleRestoration() { }
        /// Friend allocator used by soap_new_prodml21__SampleRestoration(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SampleRestoration * SOAP_FMAC2 soap_instantiate_prodml21__SampleRestoration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:548 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Sara
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Sara (-209)
/* complex XML schema type 'prodml21:Sara': */
class SOAP_CMAC prodml21__Sara {
      public:
        /// Optional element 'prodml21:AromaticsWeightFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *AromaticsWeightFraction;
        /// Optional element 'prodml21:AsphaltenesWeightFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *AsphaltenesWeightFraction;
        /// Optional element 'prodml21:NapthenesWeightFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *NapthenesWeightFraction;
        /// Optional element 'prodml21:ParaffinsWeightFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *ParaffinsWeightFraction;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Sara
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Sara; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Sara, default initialized and not managed by a soap context
        virtual prodml21__Sara *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Sara); }
      public:
        /// Constructor with default initializations
        prodml21__Sara() : AromaticsWeightFraction(), AsphaltenesWeightFraction(), NapthenesWeightFraction(), ParaffinsWeightFraction(), Remark(), uid(), soap() { }
        virtual ~prodml21__Sara() { }
        /// Friend allocator used by soap_new_prodml21__Sara(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Sara * SOAP_FMAC2 soap_instantiate_prodml21__Sara(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:554 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest (-212)
/* complex XML schema type 'prodml21:SaturationTest': */
class SOAP_CMAC prodml21__SaturationTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Required element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SaturationTest, default initialized and not managed by a soap context
        virtual prodml21__SaturationTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SaturationTest); }
      public:
        /// Constructor with default initializations
        prodml21__SaturationTest() : TestNumber(), TestTemperature(), SaturationPressure(), Remark(), uid(), soap() { }
        virtual ~prodml21__SaturationTest() { }
        /// Friend allocator used by soap_new_prodml21__SaturationTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SaturationTest * SOAP_FMAC2 soap_instantiate_prodml21__SaturationTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:556 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions (-213)
/* complex XML schema type 'prodml21:SeparatorConditions': */
class SOAP_CMAC prodml21__SeparatorConditions {
      public:
        /// Optional attribute 'separatorTestReference' of XML schema type 'eml22:String64'
        std::string *separatorTestReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SeparatorConditions, default initialized and not managed by a soap context
        virtual prodml21__SeparatorConditions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SeparatorConditions); }
      public:
        /// Constructor with default initializations
        prodml21__SeparatorConditions() : separatorTestReference(), soap() { }
        virtual ~prodml21__SeparatorConditions() { }
        /// Friend allocator used by soap_new_prodml21__SeparatorConditions(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SeparatorConditions * SOAP_FMAC2 soap_instantiate_prodml21__SeparatorConditions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:558 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification (-214)
/* complex XML schema type 'prodml21:SlimTubeSpecification': */
class SOAP_CMAC prodml21__SlimTubeSpecification {
      public:
        /// Optional element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
        /// Optional element 'prodml21:OuterDiameter' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *OuterDiameter;
        /// Optional element 'prodml21:InnerDiameter' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *InnerDiameter;
        /// Optional element 'prodml21:CrossSectionArea' of XML schema type 'eml22:AreaMeasure'
        eml22__AreaMeasure *CrossSectionArea;
        /// Optional element 'prodml21:PackingMaterial' of XML schema type 'eml22:String64'
        std::string *PackingMaterial;
        /// Optional element 'prodml21:PoreVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *PoreVolume;
        /// Optional element 'prodml21:Porosity' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Porosity;
        /// Optional element 'prodml21:Permeability' of XML schema type 'eml22:PermeabilityRockMeasure'
        eml22__PermeabilityRockMeasure *Permeability;
        /// Optional element 'prodml21:InjectedGas' of XML schema type 'prodml21:InjectedGas'
        std::vector<prodml21__InjectedGas *> InjectedGas;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlimTubeSpecification, default initialized and not managed by a soap context
        virtual prodml21__SlimTubeSpecification *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlimTubeSpecification); }
      public:
        /// Constructor with default initializations
        prodml21__SlimTubeSpecification() : Length(), OuterDiameter(), InnerDiameter(), CrossSectionArea(), PackingMaterial(), PoreVolume(), Porosity(), Permeability(), InjectedGas(), Remark(), uid(), soap() { }
        virtual ~prodml21__SlimTubeSpecification() { }
        /// Friend allocator used by soap_new_prodml21__SlimTubeSpecification(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlimTubeSpecification * SOAP_FMAC2 soap_instantiate_prodml21__SlimTubeSpecification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:560 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest (-215)
/* complex XML schema type 'prodml21:SlimTubeTest': */
class SOAP_CMAC prodml21__SlimTubeTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Optional element 'prodml21:PumpTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *PumpTemperature;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SlimTubeSpecification' of XML schema type 'prodml21:SlimTubeSpecification'
        std::vector<prodml21__SlimTubeSpecification *> SlimTubeSpecification;
        /// Optional element 'prodml21:SlimTubeTestPressureStep' of XML schema type 'prodml21:SlimTubeTestStep'
        std::vector<prodml21__SlimTubeTestStep *> SlimTubeTestPressureStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlimTubeTest, default initialized and not managed by a soap context
        virtual prodml21__SlimTubeTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlimTubeTest); }
      public:
        /// Constructor with default initializations
        prodml21__SlimTubeTest() : TestNumber(), TestTemperature(), PumpTemperature(), Remark(), SlimTubeSpecification(), SlimTubeTestPressureStep(), uid(), soap() { }
        virtual ~prodml21__SlimTubeTest() { }
        /// Friend allocator used by soap_new_prodml21__SlimTubeTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlimTubeTest * SOAP_FMAC2 soap_instantiate_prodml21__SlimTubeTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:562 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep (-216)
/* complex XML schema type 'prodml21:SlimTubeTestStep': */
class SOAP_CMAC prodml21__SlimTubeTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Optional element 'prodml21:StepAveragePressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepAveragePressure;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SlimTubeTestVolumeStep' of XML schema type 'prodml21:SlimTubeTestVolumeStep'
        std::vector<prodml21__SlimTubeTestVolumeStep *> SlimTubeTestVolumeStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlimTubeTestStep, default initialized and not managed by a soap context
        virtual prodml21__SlimTubeTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlimTubeTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__SlimTubeTestStep() : StepNumber(), StepAveragePressure(), Remark(), SlimTubeTestVolumeStep(), uid(), soap() { }
        virtual ~prodml21__SlimTubeTestStep() { }
        /// Friend allocator used by soap_new_prodml21__SlimTubeTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlimTubeTestStep * SOAP_FMAC2 soap_instantiate_prodml21__SlimTubeTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:564 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep (-217)
/* complex XML schema type 'prodml21:SlimTubeTestVolumeStep': */
class SOAP_CMAC prodml21__SlimTubeTestVolumeStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Optional element 'prodml21:DifferentialPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *DifferentialPressure;
        /// Optional element 'prodml21:RunTime' of XML schema type 'eml22:String64'
        std::string *RunTime;
        /// Optional element 'prodml21:InjectionVolumeAtPumpTemperature' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *InjectionVolumeAtPumpTemperature;
        /// Optional element 'prodml21:InjectionVolumeAtTestTemperature' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *InjectionVolumeAtTestTemperature;
        /// Optional element 'prodml21:InjectedPoreVolumeFraction' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *InjectedPoreVolumeFraction;
        /// Optional element 'prodml21:DarcyVelocity' of XML schema type 'eml22:LengthPerTimeMeasure'
        eml22__LengthPerTimeMeasure *DarcyVelocity;
        /// Optional element 'prodml21:CumulativeOilProductionPercOOIP' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *CumulativeOilProductionPercOOIP;
        /// Optional element 'prodml21:CumulativeOilProductionSTO' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *CumulativeOilProductionSTO;
        /// Optional element 'prodml21:IncrementalProducedGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *IncrementalProducedGOR;
        /// Optional element 'prodml21:CumulativeProducedGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *CumulativeProducedGOR;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:ProducedGasProperties' of XML schema type 'prodml21:ProducedGasProperties'
        prodml21__ProducedGasProperties *ProducedGasProperties;
        /// Optional element 'prodml21:ProducedOilProperties' of XML schema type 'prodml21:ProducedOilProperties'
        prodml21__ProducedOilProperties *ProducedOilProperties;
        /// Optional element 'prodml21:MassBalance' of XML schema type 'prodml21:MassBalance'
        prodml21__MassBalance *MassBalance;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlimTubeTestVolumeStep, default initialized and not managed by a soap context
        virtual prodml21__SlimTubeTestVolumeStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlimTubeTestVolumeStep); }
      public:
        /// Constructor with default initializations
        prodml21__SlimTubeTestVolumeStep() : StepNumber(), DifferentialPressure(), RunTime(), InjectionVolumeAtPumpTemperature(), InjectionVolumeAtTestTemperature(), InjectedPoreVolumeFraction(), DarcyVelocity(), CumulativeOilProductionPercOOIP(), CumulativeOilProductionSTO(), IncrementalProducedGOR(), CumulativeProducedGOR(), Remark(), ProducedGasProperties(), ProducedOilProperties(), MassBalance(), uid(), soap() { }
        virtual ~prodml21__SlimTubeTestVolumeStep() { }
        /// Friend allocator used by soap_new_prodml21__SlimTubeTestVolumeStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlimTubeTestVolumeStep * SOAP_FMAC2 soap_instantiate_prodml21__SlimTubeTestVolumeStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:566 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis (-218)
/* complex XML schema type 'prodml21:STOAnalysis': */
class SOAP_CMAC prodml21__STOAnalysis {
      public:
        /// Required element 'prodml21:Date' of XML schema type 'xsd:date'
        std::string Date;
        /// Optional element 'prodml21:FlashFromPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *FlashFromPressure;
        /// Optional element 'prodml21:FlashFromTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *FlashFromTemperature;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml21:FluidCondition' of XML schema type 'prodml21:FluidAnalysisStepCondition'
        prodml21__FluidAnalysisStepCondition *FluidCondition;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:STOFlashedLiquid' of XML schema type 'prodml21:STOFlashedLiquid'
        prodml21__STOFlashedLiquid *STOFlashedLiquid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__STOAnalysis, default initialized and not managed by a soap context
        virtual prodml21__STOAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__STOAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__STOAnalysis() : Date(), FlashFromPressure(), FlashFromTemperature(), MolecularWeight(), FluidCondition(), PhasesPresent(), LiquidComposition(), VaporComposition(), OverallComposition(), Remark(), STOFlashedLiquid(), soap() { }
        virtual ~prodml21__STOAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__STOAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__STOAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__STOAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:568 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid (-219)
/* complex XML schema type 'prodml21:STOFlashedLiquid': */
class SOAP_CMAC prodml21__STOFlashedLiquid {
      public:
        /// Optional element 'prodml21:OilAPIGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilAPIGravity;
        /// Optional element 'prodml21:WaterContent' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *WaterContent;
        /// Optional element 'prodml21:WatsonKFactor' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *WatsonKFactor;
        /// Optional element 'prodml21:AsphalteneContent' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *AsphalteneContent;
        /// Optional element 'prodml21:ParaffinContent' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *ParaffinContent;
        /// Optional element 'prodml21:CloudPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *CloudPoint;
        /// Optional element 'prodml21:WaxAppearanceTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *WaxAppearanceTemperature;
        /// Optional element 'prodml21:PourPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *PourPoint;
        /// Optional element 'prodml21:ASTMFlashPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ASTMFlashPoint;
        /// Optional element 'prodml21:TotalAcidNumber' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *TotalAcidNumber;
        /// Optional element 'prodml21:TotalSulfur' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *TotalSulfur;
        /// Required element 'prodml21:Nitrogen' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Nitrogen;
        /// Optional element 'prodml21:ElementalSulfur' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *ElementalSulfur;
        /// Optional element 'prodml21:Lead' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Lead;
        /// Optional element 'prodml21:Nickel' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Nickel;
        /// Optional element 'prodml21:Vanadium' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Vanadium;
        /// Optional element 'prodml21:Iron' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Iron;
        /// Optional element 'prodml21:ViscosityAtTemperature' of XML schema type 'prodml21:ViscosityAtTemperature'
        std::vector<prodml21__ViscosityAtTemperature *> ViscosityAtTemperature;
        /// Optional element 'prodml21:ReidVaporPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *ReidVaporPressure;
        /// Optional element 'prodml21:Sara' of XML schema type 'prodml21:Sara'
        std::vector<prodml21__Sara *> Sara;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__STOFlashedLiquid, default initialized and not managed by a soap context
        virtual prodml21__STOFlashedLiquid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__STOFlashedLiquid); }
      public:
        /// Constructor with default initializations
        prodml21__STOFlashedLiquid() : OilAPIGravity(), WaterContent(), WatsonKFactor(), AsphalteneContent(), ParaffinContent(), CloudPoint(), WaxAppearanceTemperature(), PourPoint(), ASTMFlashPoint(), TotalAcidNumber(), TotalSulfur(), Nitrogen(), ElementalSulfur(), Lead(), Nickel(), Vanadium(), Iron(), ViscosityAtTemperature(), ReidVaporPressure(), Sara(), soap() { }
        virtual ~prodml21__STOFlashedLiquid() { }
        /// Friend allocator used by soap_new_prodml21__STOFlashedLiquid(struct soap*, int)
        friend SOAP_FMAC1 prodml21__STOFlashedLiquid * SOAP_FMAC2 soap_instantiate_prodml21__STOFlashedLiquid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:570 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest (-220)
/* complex XML schema type 'prodml21:SwellingTest': */
class SOAP_CMAC prodml21__SwellingTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Optional element 'prodml21:InjectedGas' of XML schema type 'prodml21:InjectedGas'
        std::vector<prodml21__InjectedGas *> InjectedGas;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SwellingTestStep' of XML schema type 'prodml21:SwellingTestStep'
        std::vector<prodml21__SwellingTestStep *> SwellingTestStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SwellingTest, default initialized and not managed by a soap context
        virtual prodml21__SwellingTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SwellingTest); }
      public:
        /// Constructor with default initializations
        prodml21__SwellingTest() : TestNumber(), TestTemperature(), InjectedGas(), Remark(), SwellingTestStep(), uid(), soap() { }
        virtual ~prodml21__SwellingTest() { }
        /// Friend allocator used by soap_new_prodml21__SwellingTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SwellingTest * SOAP_FMAC2 soap_instantiate_prodml21__SwellingTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:572 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep (-221)
/* complex XML schema type 'prodml21:SwellingTestStep': */
class SOAP_CMAC prodml21__SwellingTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Optional element 'prodml21:IncrementalGasAdded' of XML schema type 'prodml21:RefInjectedGasAdded'
        std::vector<prodml21__RefInjectedGasAdded *> IncrementalGasAdded;
        /// Optional element 'prodml21:CumulativeGasAdded' of XML schema type 'prodml21:RefInjectedGasAdded'
        std::vector<prodml21__RefInjectedGasAdded *> CumulativeGasAdded;
        /// Optional element 'prodml21:Gor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *Gor;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Optional element 'prodml21:SwollenVolume' of XML schema type 'prodml21:RelativeVolumeRatio'
        prodml21__RelativeVolumeRatio *SwollenVolume;
        /// Optional element 'prodml21:SwellingFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SwellingFactor;
        /// Optional element 'prodml21:DensityAtSaturationPoint' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *DensityAtSaturationPoint;
        /// Optional element 'prodml21:ConstantCompositionExpansionTest' of XML schema type 'eml22:String64'
        std::string *ConstantCompositionExpansionTest;
        /// Optional element 'prodml21:TransportPropertyTestReference' of XML schema type 'eml22:String64'
        std::string *TransportPropertyTestReference;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SwellingTestStep, default initialized and not managed by a soap context
        virtual prodml21__SwellingTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SwellingTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__SwellingTestStep() : StepNumber(), IncrementalGasAdded(), CumulativeGasAdded(), Gor(), SaturationPressure(), SwollenVolume(), SwellingFactor(), DensityAtSaturationPoint(), ConstantCompositionExpansionTest(), TransportPropertyTestReference(), Remark(), uid(), soap() { }
        virtual ~prodml21__SwellingTestStep() { }
        /// Friend allocator used by soap_new_prodml21__SwellingTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SwellingTestStep * SOAP_FMAC2 soap_instantiate_prodml21__SwellingTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:574 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest (-222)
/* complex XML schema type 'prodml21:VaporLiquidEquilibriumTest': */
class SOAP_CMAC prodml21__VaporLiquidEquilibriumTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Required element 'prodml21:TestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TestTemperature;
        /// Optional element 'prodml21:TestPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *TestPressure;
        /// Optional element 'prodml21:GasSolventAdded' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GasSolventAdded;
        /// Optional element 'prodml21:MixtureVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *MixtureVolume;
        /// Optional element 'prodml21:MixtureGasSolventMoleFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MixtureGasSolventMoleFraction;
        /// Optional element 'prodml21:MixtureGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *MixtureGOR;
        /// Optional element 'prodml21:MixturePsatTestTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *MixturePsatTestTemperature;
        /// Optional element 'prodml21:MixtureRelativeVolumeRelativeToPsat' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *MixtureRelativeVolumeRelativeToPsat;
        /// Optional element 'prodml21:AtmosphericFlashTestReference' of XML schema type 'eml22:String64'
        std::string *AtmosphericFlashTestReference;
        /// Optional element 'prodml21:InjectedGasAdded' of XML schema type 'prodml21:InjectedGas'
        prodml21__InjectedGas *InjectedGasAdded;
        /// Optional element 'prodml21:CumulativeGasAdded' of XML schema type 'prodml21:RefInjectedGasAdded'
        prodml21__RefInjectedGasAdded *CumulativeGasAdded;
        /// Optional element 'prodml21:VaporPhaseVolume' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *VaporPhaseVolume;
        /// Required element 'prodml21:VaporPhaseViscosity' of XML schema type 'prodml21:PhaseViscosity'
        prodml21__PhaseViscosity *VaporPhaseViscosity;
        /// Required element 'prodml21:VaporPhaseDensity' of XML schema type 'prodml21:PhaseDensity'
        std::vector<prodml21__PhaseDensity *> VaporPhaseDensity;
        /// Optional element 'prodml21:LiquidPhaseVolume' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *LiquidPhaseVolume;
        /// Required element 'prodml21:LiquidPhaseDensity' of XML schema type 'prodml21:PhaseDensity'
        prodml21__PhaseDensity *LiquidPhaseDensity;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:FluidComponent'
        std::vector<prodml21__FluidComponent *> VaporComposition;
        /// Optional element 'prodml21:VaporTransportTestReference' of XML schema type 'eml22:String64'
        std::string *VaporTransportTestReference;
        /// Optional element 'prodml21:LiquidTransportTestReference' of XML schema type 'eml22:String64'
        std::string *LiquidTransportTestReference;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        std::vector<prodml21__LiquidComposition *> LiquidComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__VaporLiquidEquilibriumTest, default initialized and not managed by a soap context
        virtual prodml21__VaporLiquidEquilibriumTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__VaporLiquidEquilibriumTest); }
      public:
        /// Constructor with default initializations
        prodml21__VaporLiquidEquilibriumTest() : TestNumber(), TestTemperature(), TestPressure(), GasSolventAdded(), MixtureVolume(), MixtureGasSolventMoleFraction(), MixtureGOR(), MixturePsatTestTemperature(), MixtureRelativeVolumeRelativeToPsat(), AtmosphericFlashTestReference(), InjectedGasAdded(), CumulativeGasAdded(), VaporPhaseVolume(), VaporPhaseViscosity(), VaporPhaseDensity(), LiquidPhaseVolume(), LiquidPhaseDensity(), VaporComposition(), VaporTransportTestReference(), LiquidTransportTestReference(), LiquidComposition(), Remark(), uid(), soap() { }
        virtual ~prodml21__VaporLiquidEquilibriumTest() { }
        /// Friend allocator used by soap_new_prodml21__VaporLiquidEquilibriumTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__VaporLiquidEquilibriumTest * SOAP_FMAC2 soap_instantiate_prodml21__VaporLiquidEquilibriumTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:576 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature (-223)
/* complex XML schema type 'prodml21:ViscosityAtTemperature': */
class SOAP_CMAC prodml21__ViscosityAtTemperature {
      public:
        /// Required element 'prodml21:Viscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *Viscosity;
        /// Required element 'prodml21:ViscosityTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ViscosityTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ViscosityAtTemperature, default initialized and not managed by a soap context
        virtual prodml21__ViscosityAtTemperature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ViscosityAtTemperature); }
      public:
        /// Constructor with default initializations
        prodml21__ViscosityAtTemperature() : Viscosity(), ViscosityTemperature(), soap() { }
        virtual ~prodml21__ViscosityAtTemperature() { }
        /// Friend allocator used by soap_new_prodml21__ViscosityAtTemperature(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ViscosityAtTemperature * SOAP_FMAC2 soap_instantiate_prodml21__ViscosityAtTemperature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:580 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest (-225)
/* complex XML schema type 'prodml21:WaterAnalysisTest': */
class SOAP_CMAC prodml21__WaterAnalysisTest {
      public:
        /// Required element 'prodml21:TestNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 TestNumber;
        /// Optional element 'prodml21:LiquidGravity' of XML schema type 'xsd:double'
        double *LiquidGravity;
        /// Optional element 'prodml21:Salinity' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Salinity;
        /// Optional element 'prodml21:TotalDissolvedSolids' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *TotalDissolvedSolids;
        /// Optional element 'prodml21:TotalSuspendedSolids' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *TotalSuspendedSolids;
        /// Optional element 'prodml21:TotalHardness' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *TotalHardness;
        /// Optional element 'prodml21:PH' of XML schema type 'xsd:double'
        double *PH;
        /// Optional element 'prodml21:Resistivity' of XML schema type 'eml22:ElectricalResistivityMeasure'
        eml22__ElectricalResistivityMeasure *Resistivity;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:WaterAnalysisTestStep' of XML schema type 'prodml21:WaterAnalysisTestStep'
        std::vector<prodml21__WaterAnalysisTestStep *> WaterAnalysisTestStep;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WaterAnalysisTest, default initialized and not managed by a soap context
        virtual prodml21__WaterAnalysisTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WaterAnalysisTest); }
      public:
        /// Constructor with default initializations
        prodml21__WaterAnalysisTest() : TestNumber(), LiquidGravity(), Salinity(), TotalDissolvedSolids(), TotalSuspendedSolids(), TotalHardness(), PH(), Resistivity(), Remark(), WaterAnalysisTestStep(), uid(), soap() { }
        virtual ~prodml21__WaterAnalysisTest() { }
        /// Friend allocator used by soap_new_prodml21__WaterAnalysisTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WaterAnalysisTest * SOAP_FMAC2 soap_instantiate_prodml21__WaterAnalysisTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:582 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep (-226)
/* complex XML schema type 'prodml21:WaterAnalysisTestStep': */
class SOAP_CMAC prodml21__WaterAnalysisTestStep {
      public:
        /// Required element 'prodml21:StepNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StepNumber;
        /// Required element 'prodml21:StepPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *StepPressure;
        /// Required element 'prodml21:StepTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StepTemperature;
        /// Optional element 'prodml21:SolutionGasWaterRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGasWaterRatio;
        /// Optional element 'prodml21:WaterFormationVolumeFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *WaterFormationVolumeFactor;
        /// Optional element 'prodml21:WaterIsothermalCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasure'
        eml22__ReciprocalPressureMeasure *WaterIsothermalCompressibility;
        /// Optional element 'prodml21:WaterDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *WaterDensity;
        /// Optional element 'prodml21:WaterSpecificVolume' of XML schema type 'eml22:VolumePerMassMeasure'
        eml22__VolumePerMassMeasure *WaterSpecificVolume;
        /// Optional element 'prodml21:WaterDensityChangeWithPressure' of XML schema type 'eml22:MassPerVolumePerPressureMeasureExt'
        eml22__MassPerVolumePerPressureMeasureExt *WaterDensityChangeWithPressure;
        /// Optional element 'prodml21:WaterDensityChangeWithTemperature' of XML schema type 'eml22:MassPerVolumePerTemperatureMeasureExt'
        eml22__MassPerVolumePerTemperatureMeasureExt *WaterDensityChangeWithTemperature;
        /// Optional element 'prodml21:WaterViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *WaterViscosity;
        /// Optional element 'prodml21:WaterViscousCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasure'
        eml22__ReciprocalPressureMeasure *WaterViscousCompressibility;
        /// Optional element 'prodml21:WaterSpecificHeat' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *WaterSpecificHeat;
        /// Optional element 'prodml21:WaterHeatCapacity' of XML schema type 'eml22:EnergyMeasure'
        eml22__EnergyMeasure *WaterHeatCapacity;
        /// Optional element 'prodml21:WaterThermalConductivity' of XML schema type 'eml22:ElectricConductivityMeasure'
        eml22__ElectricConductivityMeasure *WaterThermalConductivity;
        /// Optional element 'prodml21:WaterThermalExpansion' of XML schema type 'eml22:VolumetricThermalExpansionMeasure'
        eml22__VolumetricThermalExpansionMeasure *WaterThermalExpansion;
        /// Optional element 'prodml21:WaterEnthalpy' of XML schema type 'eml22:MolarEnergyMeasure'
        eml22__MolarEnergyMeasure *WaterEnthalpy;
        /// Optional element 'prodml21:WaterEntropy' of XML schema type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasure'
        eml22__EnergyLengthPerTimeAreaTemperatureMeasure *WaterEntropy;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WaterAnalysisTestStep, default initialized and not managed by a soap context
        virtual prodml21__WaterAnalysisTestStep *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WaterAnalysisTestStep); }
      public:
        /// Constructor with default initializations
        prodml21__WaterAnalysisTestStep() : StepNumber(), StepPressure(), StepTemperature(), SolutionGasWaterRatio(), WaterFormationVolumeFactor(), WaterIsothermalCompressibility(), WaterDensity(), WaterSpecificVolume(), WaterDensityChangeWithPressure(), WaterDensityChangeWithTemperature(), WaterViscosity(), WaterViscousCompressibility(), WaterSpecificHeat(), WaterHeatCapacity(), WaterThermalConductivity(), WaterThermalExpansion(), WaterEnthalpy(), WaterEntropy(), Remark(), uid(), soap() { }
        virtual ~prodml21__WaterAnalysisTestStep() { }
        /// Friend allocator used by soap_new_prodml21__WaterAnalysisTestStep(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WaterAnalysisTestStep * SOAP_FMAC2 soap_instantiate_prodml21__WaterAnalysisTestStep(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:584 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent (-227)
/* complex XML schema type 'prodml21:WaterSampleComponent': */
class SOAP_CMAC prodml21__WaterSampleComponent {
      public:
        /// Required element 'prodml21:Ion' of XML schema type 'eml22:String64'
        std::string Ion;
        /// Optional element 'prodml21:MassConcentration' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassConcentration;
        /// Optional element 'prodml21:EquivalentConcentration' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *EquivalentConcentration;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WaterSampleComponent, default initialized and not managed by a soap context
        virtual prodml21__WaterSampleComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WaterSampleComponent); }
      public:
        /// Constructor with default initializations
        prodml21__WaterSampleComponent() : Ion(), MassConcentration(), EquivalentConcentration(), uid(), soap() { }
        virtual ~prodml21__WaterSampleComponent() { }
        /// Friend allocator used by soap_new_prodml21__WaterSampleComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WaterSampleComponent * SOAP_FMAC2 soap_instantiate_prodml21__WaterSampleComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:588 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource (-229)
/* complex XML schema type 'prodml21:FluidSampleAcquisitionJobSource': */
class SOAP_CMAC prodml21__FluidSampleAcquisitionJobSource {
      public:
        /// Required element 'prodml21:FluidSampleAcquisitionReference' of XML schema type 'eml22:String64'
        std::string FluidSampleAcquisitionReference;
        /// Required element 'prodml21:FluidSampleAcquisitionJobReference' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSampleAcquisitionJobReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleAcquisitionJobSource, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleAcquisitionJobSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleAcquisitionJobSource); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleAcquisitionJobSource() : FluidSampleAcquisitionReference(), FluidSampleAcquisitionJobReference(), soap() { }
        virtual ~prodml21__FluidSampleAcquisitionJobSource() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleAcquisitionJobSource(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleAcquisitionJobSource * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleAcquisitionJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:590 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent (-230)
/* complex XML schema type 'prodml21:FluidSampleChainofCustodyEvent': */
class SOAP_CMAC prodml21__FluidSampleChainofCustodyEvent {
      public:
        /// Optional element 'prodml21:TransferVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *TransferVolume;
        /// Optional element 'prodml21:TransferPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *TransferPressure;
        /// Optional element 'prodml21:TransferTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TransferTemperature;
        /// Required element 'prodml21:SampleIntegrity' of XML schema type 'prodml21:SampleQuality'
        prodml21__SampleQuality SampleIntegrity;
        /// Optional element 'prodml21:RemainingVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *RemainingVolume;
        /// Optional element 'prodml21:LostVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *LostVolume;
        /// Optional element 'prodml21:CustodyDate' of XML schema type 'xsd:date'
        std::string *CustodyDate;
        /// Optional element 'prodml21:CustodyAction' of XML schema type 'prodml21:SampleAction'
        prodml21__SampleAction *CustodyAction;
        /// Optional element 'prodml21:Custodian' of XML schema type 'eml22:String64'
        std::string *Custodian;
        /// Optional element 'prodml21:ContainerLocation' of XML schema type 'eml22:String64'
        std::string *ContainerLocation;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:PrevContainer' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *PrevContainer;
        /// Required element 'prodml21:CurrentContainer' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *CurrentContainer;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleChainofCustodyEvent, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleChainofCustodyEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleChainofCustodyEvent); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleChainofCustodyEvent() : TransferVolume(), TransferPressure(), TransferTemperature(), SampleIntegrity(), RemainingVolume(), LostVolume(), CustodyDate(), CustodyAction(), Custodian(), ContainerLocation(), Remark(), PrevContainer(), CurrentContainer(), uid(), soap() { }
        virtual ~prodml21__FluidSampleChainofCustodyEvent() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleChainofCustodyEvent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleChainofCustodyEvent * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleChainofCustodyEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:592 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition (-231)
/* complex XML schema type 'prodml21:FluidSampleComposition': */
class SOAP_CMAC prodml21__FluidSampleComposition {
      public:
        /// Optional element 'prodml21:VolumeFraction' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *VolumeFraction;
        /// Optional element 'prodml21:MassFraction' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml21:MoleFraction' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidSample' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSample;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleComposition, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleComposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleComposition); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleComposition() : VolumeFraction(), MassFraction(), MoleFraction(), Remark(), FluidSample(), uid(), soap() { }
        virtual ~prodml21__FluidSampleComposition() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleComposition * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:594 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement (-232)
/* complex XML schema type 'prodml21:SampleRecombinationRequirement': */
class SOAP_CMAC prodml21__SampleRecombinationRequirement {
      public:
        /// Optional element 'prodml21:LiquidSample' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *LiquidSample;
        /// Optional element 'prodml21:VaporSample' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *VaporSample;
        /// Optional element 'prodml21:RecombinationPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *RecombinationPressure;
        /// Optional element 'prodml21:RecombinationTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *RecombinationTemperature;
        /// Optional element 'prodml21:RecombinationGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *RecombinationGOR;
        /// Optional element 'prodml21:RecombinationSaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *RecombinationSaturationPressure;
        /// Optional element 'prodml21:LiquidComposition' of XML schema type 'prodml21:LiquidComposition'
        prodml21__LiquidComposition *LiquidComposition;
        /// Optional element 'prodml21:VaporComposition' of XML schema type 'prodml21:VaporComposition'
        prodml21__VaporComposition *VaporComposition;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SampleRecombinationRequirement, default initialized and not managed by a soap context
        virtual prodml21__SampleRecombinationRequirement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SampleRecombinationRequirement); }
      public:
        /// Constructor with default initializations
        prodml21__SampleRecombinationRequirement() : LiquidSample(), VaporSample(), RecombinationPressure(), RecombinationTemperature(), RecombinationGOR(), RecombinationSaturationPressure(), LiquidComposition(), VaporComposition(), OverallComposition(), Remark(), soap() { }
        virtual ~prodml21__SampleRecombinationRequirement() { }
        /// Friend allocator used by soap_new_prodml21__SampleRecombinationRequirement(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SampleRecombinationRequirement * SOAP_FMAC2 soap_instantiate_prodml21__SampleRecombinationRequirement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:602 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition (-236)
/* complex XML schema type 'prodml21:FluidSampleAcquisition': */
class SOAP_CMAC prodml21__FluidSampleAcquisition {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm Date;
        /// Optional element 'prodml21:AcquisitionPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *AcquisitionPressure;
        /// Optional element 'prodml21:AcquisitionTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *AcquisitionTemperature;
        /// Optional element 'prodml21:AcquisitionVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *AcquisitionVolume;
        /// Optional element 'prodml21:AcquisitionGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *AcquisitionGOR;
        /// Optional element 'prodml21:FormationPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *FormationPressure;
        /// Optional element 'prodml21:FormationTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *FormationTemperature;
        /// Optional element 'prodml21:ServiceCompany' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *ServiceCompany;
        /// Required element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string Remark;
        /// Required element 'prodml21:FluidSample' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSample;
        /// Required element 'prodml21:FluidSampleContainer' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSampleContainer;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleAcquisition() : Date(), AcquisitionPressure(), AcquisitionTemperature(), AcquisitionVolume(), AcquisitionGOR(), FormationPressure(), FormationTemperature(), ServiceCompany(), Remark(), FluidSample(), FluidSampleContainer(), uid(), soap() { }
        virtual ~prodml21__FluidSampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:612 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection (-241)
/* complex XML schema type 'prodml21:WftCurveSection': */
class SOAP_CMAC prodml21__WftCurveSection {
      public:
        /// Required element 'prodml21:Channel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Channel;
        /// Required element 'prodml21:Mnemonic' of XML schema type 'eml22:String64'
        std::string Mnemonic;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftCurveSection, default initialized and not managed by a soap context
        virtual prodml21__WftCurveSection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftCurveSection); }
      public:
        /// Constructor with default initializations
        prodml21__WftCurveSection() : Channel(), Mnemonic(), DTimStart(), DTimEnd(), uid(), soap() { }
        virtual ~prodml21__WftCurveSection() { }
        /// Friend allocator used by soap_new_prodml21__WftCurveSection(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftCurveSection * SOAP_FMAC2 soap_instantiate_prodml21__WftCurveSection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:614 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent (-242)
/* complex XML schema type 'prodml21:WftEvent': */
class SOAP_CMAC prodml21__WftEvent {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:WftEventKind'
        prodml21__WftEventKind Kind;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm DTim;
        /// Required element 'prodml21:Duration' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *Duration;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftEvent, default initialized and not managed by a soap context
        virtual prodml21__WftEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftEvent); }
      public:
        /// Constructor with default initializations
        prodml21__WftEvent() : Kind(), DTim(), Duration(), Remark(), uid(), soap() { }
        virtual ~prodml21__WftEvent() { }
        /// Friend allocator used by soap_new_prodml21__WftEvent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftEvent * SOAP_FMAC2 soap_instantiate_prodml21__WftEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:616 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter (-243)
/* complex XML schema type 'prodml21:WftInOutParameter': */
class SOAP_CMAC prodml21__WftInOutParameter {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Required element 'prodml21:Value' of XML schema type 'prodml21:MeasureOrQuantity'
        prodml21__MeasureOrQuantity *Value;
        /// Optional element 'prodml21:MeasureClass' of XML schema type 'eml22:MeasureClass'
        eml22__MeasureClass *MeasureClass;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftInOutParameter, default initialized and not managed by a soap context
        virtual prodml21__WftInOutParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftInOutParameter); }
      public:
        /// Constructor with default initializations
        prodml21__WftInOutParameter() : Name(), Value(), MeasureClass(), uid(), soap() { }
        virtual ~prodml21__WftInOutParameter() { }
        /// Friend allocator used by soap_new_prodml21__WftInOutParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftInOutParameter * SOAP_FMAC2 soap_instantiate_prodml21__WftInOutParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:618 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference (-244)
/* complex XML schema type 'prodml21:WftResultReference': */
class SOAP_CMAC prodml21__WftResultReference {
      public:
        /// Optional element 'prodml21:StationReference' of XML schema type 'eml22:String64'
        std::string *StationReference;
        /// Optional element 'prodml21:Test' of XML schema type 'eml22:String64'
        std::string *Test;
        /// Required element 'prodml21:ResultReference' of XML schema type 'eml22:String64'
        std::string ResultReference;
        /// Required element 'prodml21:OutputParameterReference' of XML schema type 'eml22:String64'
        std::string OutputParameterReference;
        /// Optional element 'prodml21:SampleAcquisition' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *SampleAcquisition;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftResultReference, default initialized and not managed by a soap context
        virtual prodml21__WftResultReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftResultReference); }
      public:
        /// Constructor with default initializations
        prodml21__WftResultReference() : StationReference(), Test(), ResultReference(), OutputParameterReference(), SampleAcquisition(), uid(), soap() { }
        virtual ~prodml21__WftResultReference() { }
        /// Friend allocator used by soap_new_prodml21__WftResultReference(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftResultReference * SOAP_FMAC2 soap_instantiate_prodml21__WftResultReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:622 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition (-246)
/* complex XML schema type 'prodml21:WftSampleAcquisition': */
class SOAP_CMAC prodml21__WftSampleAcquisition {
      public:
        /// Optional element 'prodml21:SampleContainer' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *SampleContainer;
        /// Optional element 'prodml21:SampleName' of XML schema type 'eml22:String64'
        std::string *SampleName;
        /// Optional element 'prodml21:Kind' of XML schema type 'eml22:String64'
        std::string *Kind;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:FieldComment' of XML schema type 'eml22:String2000'
        std::string *FieldComment;
        /// Optional element 'prodml21:InterpretationComment' of XML schema type 'eml22:String2000'
        std::string *InterpretationComment;
        /// Optional element 'prodml21:SampleCarrierSlotName' of XML schema type 'eml22:String64'
        std::string *SampleCarrierSlotName;
        /// Optional element 'prodml21:ToolSectionName' of XML schema type 'eml22:String64'
        std::string *ToolSectionName;
        /// Optional element 'prodml21:SampleContainerName' of XML schema type 'eml22:String64'
        std::string *SampleContainerName;
        /// Optional element 'prodml21:SampleContainerConfiguration' of XML schema type 'eml22:String64'
        std::string *SampleContainerConfiguration;
        /// Optional element 'prodml21:CushionPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *CushionPressure;
        /// Optional element 'prodml21:GrossFluidKind' of XML schema type 'eml22:String64'
        std::string *GrossFluidKind;
        /// Optional element 'prodml21:Test' of XML schema type 'eml22:String64'
        std::vector<std::string> Test;
        /// Optional element 'prodml21:Result' of XML schema type 'prodml21:WftTestResult'
        std::vector<prodml21__WftTestResult *> Result;
        /// Optional element 'prodml21:SampleReference' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *SampleReference;
        /// Optional element 'prodml21:TestData' of XML schema type 'prodml21:WftTestData'
        std::vector<prodml21__WftTestData *> TestData;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftSampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__WftSampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftSampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__WftSampleAcquisition() : SampleContainer(), SampleName(), Kind(), DTimStart(), DTimEnd(), FieldComment(), InterpretationComment(), SampleCarrierSlotName(), ToolSectionName(), SampleContainerName(), SampleContainerConfiguration(), CushionPressure(), GrossFluidKind(), Test(), Result(), SampleReference(), TestData(), uid(), soap() { }
        virtual ~prodml21__WftSampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__WftSampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftSampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__WftSampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:624 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation (-247)
/* complex XML schema type 'prodml21:WftStation': */
class SOAP_CMAC prodml21__WftStation {
      public:
        /// Required element 'prodml21:StationKind' of XML schema type 'prodml21:WftStationKind'
        prodml21__WftStationKind StationKind;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Required element 'prodml21:FlowingIntervalKind' of XML schema type 'prodml21:WftFlowingIntervalKind'
        prodml21__WftFlowingIntervalKind FlowingIntervalKind;
        /// Required element 'prodml21:MdTop' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdTop;
        /// Required element 'prodml21:MdBottom' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdBottom;
        /// Optional element 'prodml21:DiaProbe' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *DiaProbe;
        /// Optional element 'prodml21:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Optional element 'prodml21:Log' of XML schema type 'eml22:DataObjectReference'
        std::vector<eml22__DataObjectReference *> Log;
        /// Optional element 'prodml21:Station' of XML schema type 'eml22:String64'
        std::string *Station;
        /// Optional element 'prodml21:Event' of XML schema type 'prodml21:WftEvent'
        std::vector<prodml21__WftEvent *> Event;
        /// Optional element 'prodml21:Result' of XML schema type 'prodml21:WftTestResult'
        std::vector<prodml21__WftTestResult *> Result;
        /// Optional element 'prodml21:SampleAcquisition' of XML schema type 'prodml21:WftSampleAcquisition'
        std::vector<prodml21__WftSampleAcquisition *> SampleAcquisition;
        /// Optional element 'prodml21:Test' of XML schema type 'prodml21:WftTest'
        std::vector<prodml21__WftTest *> Test;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftStation, default initialized and not managed by a soap context
        virtual prodml21__WftStation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftStation); }
      public:
        /// Constructor with default initializations
        prodml21__WftStation() : StationKind(), DTimStart(), DTimEnd(), FlowingIntervalKind(), MdTop(), MdBottom(), DiaProbe(), Description(), Log(), Station(), Event(), Result(), SampleAcquisition(), Test(), uid(), soap() { }
        virtual ~prodml21__WftStation() { }
        /// Friend allocator used by soap_new_prodml21__WftStation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftStation * SOAP_FMAC2 soap_instantiate_prodml21__WftStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:626 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest (-248)
/* complex XML schema type 'prodml21:WftTest': */
class SOAP_CMAC prodml21__WftTest {
      public:
        /// Required element 'prodml21:TestKind' of XML schema type 'prodml21:WftTestKind'
        prodml21__WftTestKind TestKind;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:Result' of XML schema type 'prodml21:WftTestResult'
        std::vector<prodml21__WftTestResult *> Result;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftTest, default initialized and not managed by a soap context
        virtual prodml21__WftTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftTest); }
      public:
        /// Constructor with default initializations
        prodml21__WftTest() : TestKind(), DTimStart(), DTimEnd(), Result(), uid(), soap() { }
        virtual ~prodml21__WftTest() { }
        /// Friend allocator used by soap_new_prodml21__WftTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftTest * SOAP_FMAC2 soap_instantiate_prodml21__WftTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:628 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData (-249)
/* complex XML schema type 'prodml21:WftTestData': */
class SOAP_CMAC prodml21__WftTestData {
      public:
        /// Required element 'prodml21:Role' of XML schema type 'prodml21:WftTestDataRole'
        prodml21__WftTestDataRole Role;
        /// Optional element 'prodml21:Parameter' of XML schema type 'prodml21:WftInOutParameter'
        std::vector<prodml21__WftInOutParameter *> Parameter;
        /// Optional element 'prodml21:CurveSection' of XML schema type 'prodml21:WftCurveSection'
        std::vector<prodml21__WftCurveSection *> CurveSection;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftTestData, default initialized and not managed by a soap context
        virtual prodml21__WftTestData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftTestData); }
      public:
        /// Constructor with default initializations
        prodml21__WftTestData() : Role(), Parameter(), CurveSection(), uid(), soap() { }
        virtual ~prodml21__WftTestData() { }
        /// Friend allocator used by soap_new_prodml21__WftTestData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftTestData * SOAP_FMAC2 soap_instantiate_prodml21__WftTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:630 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult (-250)
/* complex XML schema type 'prodml21:WftTestResult': */
class SOAP_CMAC prodml21__WftTestResult {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:WftTestResultKind'
        prodml21__WftTestResultKind Kind;
        /// Required element 'prodml21:Method' of XML schema type 'eml22:String64'
        std::string Method;
        /// Required element 'prodml21:MdTop' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdTop;
        /// Required element 'prodml21:MdBottom' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdBottom;
        /// Optional element 'prodml21:InputParameter' of XML schema type 'prodml21:WftInOutParameter'
        std::vector<prodml21__WftInOutParameter *> InputParameter;
        /// Optional element 'prodml21:TestData' of XML schema type 'prodml21:WftTestData'
        std::vector<prodml21__WftTestData *> TestData;
        /// Optional element 'prodml21:OutputParameter' of XML schema type 'prodml21:WftInOutParameter'
        std::vector<prodml21__WftInOutParameter *> OutputParameter;
        /// Optional element 'prodml21:InputResultReference' of XML schema type 'prodml21:WftResultReference'
        std::vector<prodml21__WftResultReference *> InputResultReference;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftTestResult, default initialized and not managed by a soap context
        virtual prodml21__WftTestResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftTestResult); }
      public:
        /// Constructor with default initializations
        prodml21__WftTestResult() : Kind(), Method(), MdTop(), MdBottom(), InputParameter(), TestData(), OutputParameter(), InputResultReference(), uid(), soap() { }
        virtual ~prodml21__WftTestResult() { }
        /// Friend allocator used by soap_new_prodml21__WftTestResult(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftTestResult * SOAP_FMAC2 soap_instantiate_prodml21__WftTestResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:632 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition (-251)
/* complex XML schema type 'prodml21:AbstractDisposition': */
class SOAP_CMAC prodml21__AbstractDisposition {
      public:
        /// Required element 'prodml21:QuantityMethod' of XML schema type 'prodml21:QuantityMethodExt'
        std::string QuantityMethod;
        /// Optional element 'prodml21:ProductDispositionCode' of XML schema type 'eml22:AuthorityQualifiedName'
        eml22__AuthorityQualifiedName *ProductDispositionCode;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:DispositionQuantity' of XML schema type 'prodml21:AbstractProductQuantity'
        std::vector<prodml21__AbstractProductQuantity *> DispositionQuantity;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractDisposition, default initialized and not managed by a soap context
        virtual prodml21__AbstractDisposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractDisposition); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractDisposition() : QuantityMethod(), ProductDispositionCode(), Remark(), DispositionQuantity(), uid(), soap() { }
        virtual ~prodml21__AbstractDisposition() { }
        /// Friend allocator used by soap_new_prodml21__AbstractDisposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractDisposition * SOAP_FMAC2 soap_instantiate_prodml21__AbstractDisposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:634 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity (-252)
/* complex XML schema type 'prodml21:AbstractProductQuantity': */
class SOAP_CMAC prodml21__AbstractProductQuantity {
      public:
        /// Optional element 'prodml21:Volume' of XML schema type 'eml22:VolumeValue'
        eml22__VolumeValue *Volume;
        /// Optional element 'prodml21:Mass' of XML schema type 'eml22:MassMeasure'
        eml22__MassMeasure *Mass;
        /// Optional element 'prodml21:Moles' of XML schema type 'eml22:AmountOfSubstanceMeasure'
        eml22__AmountOfSubstanceMeasure *Moles;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractProductQuantity, default initialized and not managed by a soap context
        virtual prodml21__AbstractProductQuantity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractProductQuantity); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractProductQuantity() : Volume(), Mass(), Moles(), uid(), soap() { }
        virtual ~prodml21__AbstractProductQuantity() { }
        /// Friend allocator used by soap_new_prodml21__AbstractProductQuantity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractProductQuantity * SOAP_FMAC2 soap_instantiate_prodml21__AbstractProductQuantity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:640 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent (-255)
/* complex XML schema type 'prodml21:DeferredProductionEvent': */
class SOAP_CMAC prodml21__DeferredProductionEvent {
      public:
        /// Optional element 'prodml21:StartDate' of XML schema type 'eml22:TimeStamp'
        struct tm *StartDate;
        /// Optional element 'prodml21:EndDate' of XML schema type 'eml22:TimeStamp'
        struct tm *EndDate;
        /// Required element 'prodml21:Duration' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *Duration;
        /// Optional element 'prodml21:DowntimeReasonCode' of XML schema type 'prodml21:DowntimeReasonCode'
        prodml21__DowntimeReasonCode *DowntimeReasonCode;
        /// Optional element 'prodml21:DeferredKind' of XML schema type 'prodml21:DeferredKind'
        prodml21__DeferredKind *DeferredKind;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:DeferredProductionVolume' of XML schema type 'prodml21:DeferredProductionVolume'
        std::vector<prodml21__DeferredProductionVolume *> DeferredProductionVolume;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeferredProductionEvent, default initialized and not managed by a soap context
        virtual prodml21__DeferredProductionEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeferredProductionEvent); }
      public:
        /// Constructor with default initializations
        prodml21__DeferredProductionEvent() : StartDate(), EndDate(), Duration(), DowntimeReasonCode(), DeferredKind(), Remark(), DeferredProductionVolume(), uid(), soap() { }
        virtual ~prodml21__DeferredProductionEvent() { }
        /// Friend allocator used by soap_new_prodml21__DeferredProductionEvent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeferredProductionEvent * SOAP_FMAC2 soap_instantiate_prodml21__DeferredProductionEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:642 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume (-256)
/* complex XML schema type 'prodml21:DeferredProductionVolume': */
class SOAP_CMAC prodml21__DeferredProductionVolume {
      public:
        /// Required element 'prodml21:EstimationMethod' of XML schema type 'prodml21:EstimationMethodExt'
        std::string EstimationMethod;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required element 'prodml21:DeferredProductQuantity' of XML schema type 'prodml21:AbstractProductQuantity'
        prodml21__AbstractProductQuantity *DeferredProductQuantity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeferredProductionVolume, default initialized and not managed by a soap context
        virtual prodml21__DeferredProductionVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeferredProductionVolume); }
      public:
        /// Constructor with default initializations
        prodml21__DeferredProductionVolume() : EstimationMethod(), Remark(), DeferredProductQuantity(), soap() { }
        virtual ~prodml21__DeferredProductionVolume() { }
        /// Friend allocator used by soap_new_prodml21__DeferredProductionVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeferredProductionVolume * SOAP_FMAC2 soap_instantiate_prodml21__DeferredProductionVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:644 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode (-257)
/* Type prodml21__DowntimeReasonCode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'prodml21:DowntimeReasonCode': */
class SOAP_CMAC prodml21__DowntimeReasonCode {
      public:
        /// Optional element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string *Name;
        /// Optional element 'prodml21:Parent' of XML schema type 'prodml21:DowntimeReasonCode'
        prodml21__DowntimeReasonCode *Parent;
        /// Required attribute 'authority' of XML schema type 'eml22:String64'
        std::string authority;
        /// Optional attribute 'code' of XML schema type 'eml22:String64'
        std::string *code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DowntimeReasonCode, default initialized and not managed by a soap context
        virtual prodml21__DowntimeReasonCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DowntimeReasonCode); }
      public:
        /// Constructor with default initializations
        prodml21__DowntimeReasonCode() : Name(), Parent(), authority(), code(), soap() { }
        virtual ~prodml21__DowntimeReasonCode() { }
        /// Friend allocator used by soap_new_prodml21__DowntimeReasonCode(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DowntimeReasonCode * SOAP_FMAC2 soap_instantiate_prodml21__DowntimeReasonCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:646 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Injection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Injection (-258)
/* complex XML schema type 'prodml21:Injection': */
class SOAP_CMAC prodml21__Injection {
      public:
        /// Required element 'prodml21:QuantityMethod' of XML schema type 'prodml21:QuantityMethodExt'
        std::string QuantityMethod;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:InjectionQuantity' of XML schema type 'prodml21:AbstractProductQuantity'
        std::vector<prodml21__AbstractProductQuantity *> InjectionQuantity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Injection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Injection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Injection, default initialized and not managed by a soap context
        virtual prodml21__Injection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Injection); }
      public:
        /// Constructor with default initializations
        prodml21__Injection() : QuantityMethod(), Remark(), InjectionQuantity(), soap() { }
        virtual ~prodml21__Injection() { }
        /// Friend allocator used by soap_new_prodml21__Injection(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Injection * SOAP_FMAC2 soap_instantiate_prodml21__Injection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:652 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Production
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Production (-261)
/* complex XML schema type 'prodml21:Production': */
class SOAP_CMAC prodml21__Production {
      public:
        /// Required element 'prodml21:QuantityMethod' of XML schema type 'prodml21:QuantityMethodExt'
        std::string QuantityMethod;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:ProductionQuantity' of XML schema type 'prodml21:AbstractProductQuantity'
        std::vector<prodml21__AbstractProductQuantity *> ProductionQuantity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Production
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Production; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Production, default initialized and not managed by a soap context
        virtual prodml21__Production *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Production); }
      public:
        /// Constructor with default initializations
        prodml21__Production() : QuantityMethod(), Remark(), ProductionQuantity(), soap() { }
        virtual ~prodml21__Production() { }
        /// Friend allocator used by soap_new_prodml21__Production(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Production * SOAP_FMAC2 soap_instantiate_prodml21__Production(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:654 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod (-262)
/* complex XML schema type 'prodml21:ProductionWellPeriod': */
class SOAP_CMAC prodml21__ProductionWellPeriod {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm StartTime;
        /// Required element 'prodml21:Duration' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *Duration;
        /// Optional element 'prodml21:WellStatus' of XML schema type 'eml22:WellStatus'
        eml22__WellStatus *WellStatus;
        /// Optional element 'prodml21:WellFlowingCondition' of XML schema type 'prodml21:WellFlowingCondition'
        prodml21__WellFlowingCondition *WellFlowingCondition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required element 'prodml21:ProductRate' of XML schema type 'prodml21:ProductRate'
        std::vector<prodml21__ProductRate *> ProductRate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductionWellPeriod, default initialized and not managed by a soap context
        virtual prodml21__ProductionWellPeriod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductionWellPeriod); }
      public:
        /// Constructor with default initializations
        prodml21__ProductionWellPeriod() : StartTime(), Duration(), WellStatus(), WellFlowingCondition(), Remark(), ProductRate(), soap() { }
        virtual ~prodml21__ProductionWellPeriod() { }
        /// Friend allocator used by soap_new_prodml21__ProductionWellPeriod(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductionWellPeriod * SOAP_FMAC2 soap_instantiate_prodml21__ProductionWellPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:656 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest (-263)
/* complex XML schema type 'prodml21:ProductionWellTest': */
class SOAP_CMAC prodml21__ProductionWellTest {
      public:
        /// Optional element 'prodml21:Validate' of XML schema type 'xsd:boolean'
        bool *Validate;
        /// Optional element 'prodml21:WellTestMethod' of XML schema type 'eml22:String64'
        std::string *WellTestMethod;
        /// Optional element 'prodml21:EffectiveDate' of XML schema type 'eml22:TimeStamp'
        struct tm *EffectiveDate;
        /// Optional element 'prodml21:FlowTestPeriod' of XML schema type 'prodml21:TestPeriod'
        std::vector<prodml21__TestPeriod *> FlowTestPeriod;
        /// Required element 'prodml21:ReportingEntity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportingEntity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductionWellTest, default initialized and not managed by a soap context
        virtual prodml21__ProductionWellTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductionWellTest); }
      public:
        /// Constructor with default initializations
        prodml21__ProductionWellTest() : Validate(), WellTestMethod(), EffectiveDate(), FlowTestPeriod(), ReportingEntity(), soap() { }
        virtual ~prodml21__ProductionWellTest() { }
        /// Friend allocator used by soap_new_prodml21__ProductionWellTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductionWellTest * SOAP_FMAC2 soap_instantiate_prodml21__ProductionWellTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:660 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate (-265)
/* complex XML schema type 'prodml21:ProductRate': */
class SOAP_CMAC prodml21__ProductRate {
      public:
        /// Required element 'prodml21:ProductFluidKind' of XML schema type 'prodml21:ProductFluidKindExt'
        std::string ProductFluidKind;
        /// Optional element 'prodml21:MassFlowRate' of XML schema type 'eml22:MassPerTimeMeasure'
        eml22__MassPerTimeMeasure *MassFlowRate;
        /// Optional element 'prodml21:VolumeFlowRate' of XML schema type 'eml22:FlowRateValue'
        eml22__FlowRateValue *VolumeFlowRate;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Optional attribute 'ProductFluidReference' of XML schema type 'eml22:String64'
        std::string *ProductFluidReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductRate, default initialized and not managed by a soap context
        virtual prodml21__ProductRate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductRate); }
      public:
        /// Constructor with default initializations
        prodml21__ProductRate() : ProductFluidKind(), MassFlowRate(), VolumeFlowRate(), Remark(), uid(), ProductFluidReference(), soap() { }
        virtual ~prodml21__ProductRate() { }
        /// Friend allocator used by soap_new_prodml21__ProductRate(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductRate * SOAP_FMAC2 soap_instantiate_prodml21__ProductRate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:662 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes (-266)
/* complex XML schema type 'prodml21:ReportingEntityVolumes': */
class SOAP_CMAC prodml21__ReportingEntityVolumes {
      public:
        /// Optional element 'prodml21:StartDate' of XML schema type 'eml22:TimeStamp'
        struct tm *StartDate;
        /// Optional element 'prodml21:Duration' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *Duration;
        /// Optional element 'prodml21:Production' of XML schema type 'prodml21:Production'
        std::vector<prodml21__Production *> Production;
        /// Optional element 'prodml21:ClosingInventory' of XML schema type 'prodml21:AbstractProductQuantity'
        std::vector<prodml21__AbstractProductQuantity *> ClosingInventory;
        /// Optional element 'prodml21:OpeningInventory' of XML schema type 'prodml21:AbstractProductQuantity'
        std::vector<prodml21__AbstractProductQuantity *> OpeningInventory;
        /// Required element 'prodml21:ReportingEntity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportingEntity;
        /// Optional element 'prodml21:Injection' of XML schema type 'prodml21:Injection'
        std::vector<prodml21__Injection *> Injection;
        /// Optional element 'prodml21:Disposition' of XML schema type 'prodml21:AbstractDisposition'
        std::vector<prodml21__AbstractDisposition *> Disposition;
        /// Optional element 'prodml21:DeferredProductionEvent' of XML schema type 'prodml21:DeferredProductionEvent'
        std::vector<prodml21__DeferredProductionEvent *> DeferredProductionEvent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReportingEntityVolumes, default initialized and not managed by a soap context
        virtual prodml21__ReportingEntityVolumes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReportingEntityVolumes); }
      public:
        /// Constructor with default initializations
        prodml21__ReportingEntityVolumes() : StartDate(), Duration(), Production(), ClosingInventory(), OpeningInventory(), ReportingEntity(), Injection(), Disposition(), DeferredProductionEvent(), soap() { }
        virtual ~prodml21__ReportingEntityVolumes() { }
        /// Friend allocator used by soap_new_prodml21__ReportingEntityVolumes(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReportingEntityVolumes * SOAP_FMAC2 soap_instantiate_prodml21__ReportingEntityVolumes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:670 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod (-270)
/* complex XML schema type 'prodml21:TestPeriod': */
class SOAP_CMAC prodml21__TestPeriod {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm StartTime;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm EndTime;
        /// Optional element 'prodml21:TestPeriodKind' of XML schema type 'prodml21:TestPeriodKind'
        prodml21__TestPeriodKind *TestPeriodKind;
        /// Optional element 'prodml21:WellFlowingCondition' of XML schema type 'prodml21:WellFlowingCondition'
        prodml21__WellFlowingCondition *WellFlowingCondition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:ProductRate' of XML schema type 'prodml21:ProductRate'
        std::vector<prodml21__ProductRate *> ProductRate;
        /// Optional attribute 'uid' of XML schema type 'eml22:String64'
        std::string *uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TestPeriod, default initialized and not managed by a soap context
        virtual prodml21__TestPeriod *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TestPeriod); }
      public:
        /// Constructor with default initializations
        prodml21__TestPeriod() : StartTime(), EndTime(), TestPeriodKind(), WellFlowingCondition(), Remark(), ProductRate(), uid(), soap() { }
        virtual ~prodml21__TestPeriod() { }
        /// Friend allocator used by soap_new_prodml21__TestPeriod(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TestPeriod * SOAP_FMAC2 soap_instantiate_prodml21__TestPeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:676 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition (-273)
/* complex XML schema type 'prodml21:WellFlowingCondition': */
class SOAP_CMAC prodml21__WellFlowingCondition {
      public:
        /// Optional element 'prodml21:ChokeOrificeSize' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *ChokeOrificeSize;
        /// Optional element 'prodml21:BottomHolePressureDatumMd' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *BottomHolePressureDatumMd;
        /// Optional element 'prodml21:BottomHoleStabilizedPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *BottomHoleStabilizedPressure;
        /// Optional element 'prodml21:BottomHoleStabilizedTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *BottomHoleStabilizedTemperature;
        /// Optional element 'prodml21:CasingHeadStabilizedPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *CasingHeadStabilizedPressure;
        /// Optional element 'prodml21:CasingHeadStabilizedTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *CasingHeadStabilizedTemperature;
        /// Optional element 'prodml21:TubingHeadStabilizedPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *TubingHeadStabilizedPressure;
        /// Optional element 'prodml21:TubingHeadStabilizedTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TubingHeadStabilizedTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellFlowingCondition, default initialized and not managed by a soap context
        virtual prodml21__WellFlowingCondition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellFlowingCondition); }
      public:
        /// Constructor with default initializations
        prodml21__WellFlowingCondition() : ChokeOrificeSize(), BottomHolePressureDatumMd(), BottomHoleStabilizedPressure(), BottomHoleStabilizedTemperature(), CasingHeadStabilizedPressure(), CasingHeadStabilizedTemperature(), TubingHeadStabilizedPressure(), TubingHeadStabilizedTemperature(), soap() { }
        virtual ~prodml21__WellFlowingCondition() { }
        /// Friend allocator used by soap_new_prodml21__WellFlowingCondition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellFlowingCondition * SOAP_FMAC2 soap_instantiate_prodml21__WellFlowingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:680 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData (-275)
/* complex XML schema type 'prodml21:AbstractFlowTestData': */
class SOAP_CMAC prodml21__AbstractFlowTestData {
      public:
        /// Required element 'prodml21:ChannelSet' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ChannelSet;
        /// Required element 'prodml21:TimeChannel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TimeChannel;
        /// Optional element 'prodml21:TimeSeriesPointRepresentation' of XML schema type 'prodml21:TimeSeriesPointRepresentation'
        prodml21__TimeSeriesPointRepresentation *TimeSeriesPointRepresentation;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional attribute 'uid' of XML schema type 'eml22:String64'
        std::string *uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractFlowTestData, default initialized and not managed by a soap context
        virtual prodml21__AbstractFlowTestData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractFlowTestData); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractFlowTestData() : ChannelSet(), TimeChannel(), TimeSeriesPointRepresentation(), Remark(), uid(), soap() { }
        virtual ~prodml21__AbstractFlowTestData() { }
        /// Friend allocator used by soap_new_prodml21__AbstractFlowTestData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractFlowTestData * SOAP_FMAC2 soap_instantiate_prodml21__AbstractFlowTestData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:692 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation (-281)
/* complex XML schema type 'prodml21:FlowTestLocation': */
class SOAP_CMAC prodml21__FlowTestLocation {
      public:
        /// Optional element 'prodml21:Wellbore' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Wellbore;
        /// Optional element 'prodml21:MdInterval' of XML schema type 'eml22:MdInterval'
        eml22__MdInterval *MdInterval;
        /// Optional element 'prodml21:WellboreCompletion' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WellboreCompletion;
        /// Optional element 'prodml21:Well' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Well;
        /// Optional element 'prodml21:WellCompletion' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WellCompletion;
        /// Optional element 'prodml21:ReportingEntity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportingEntity;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:ProbeDepth' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *ProbeDepth;
        /// Optional element 'prodml21:ProbeDiameter' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *ProbeDiameter;
        /// Optional element 'prodml21:Datum' of XML schema type 'eml22:WellboreDatumReference'
        eml22__WellboreDatumReference *Datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FlowTestLocation, default initialized and not managed by a soap context
        virtual prodml21__FlowTestLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FlowTestLocation); }
      public:
        /// Constructor with default initializations
        prodml21__FlowTestLocation() : Wellbore(), MdInterval(), WellboreCompletion(), Well(), WellCompletion(), ReportingEntity(), Remark(), ProbeDepth(), ProbeDiameter(), Datum(), soap() { }
        virtual ~prodml21__FlowTestLocation() { }
        /// Friend allocator used by soap_new_prodml21__FlowTestLocation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FlowTestLocation * SOAP_FMAC2 soap_instantiate_prodml21__FlowTestLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:694 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet (-282)
/* complex XML schema type 'prodml21:FlowTestMeasurementSet': */
class SOAP_CMAC prodml21__FlowTestMeasurementSet {
      public:
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidComponentCatalog' of XML schema type 'prodml21:FluidComponentCatalog'
        prodml21__FluidComponentCatalog *FluidComponentCatalog;
        /// Required element 'prodml21:Location' of XML schema type 'prodml21:FlowTestLocation'
        prodml21__FlowTestLocation *Location;
        /// Optional element 'prodml21:TestPeriod' of XML schema type 'prodml21:TestPeriod'
        prodml21__TestPeriod *TestPeriod;
        /// Optional element 'prodml21:AbstractFlowTestData' of XML schema type 'prodml21:AbstractFlowTestData'
        std::vector<prodml21__AbstractFlowTestData *> AbstractFlowTestData;
        /// Optional element 'prodml21:OtherData' of XML schema type 'prodml21:OtherData'
        std::vector<prodml21__OtherData *> OtherData;
        /// Optional element 'prodml21:MeasuredFlowRate' of XML schema type 'prodml21:AbstractPtaFlowData'
        std::vector<prodml21__AbstractPtaFlowData *> MeasuredFlowRate;
        /// Optional element 'prodml21:MeasuredPressure' of XML schema type 'prodml21:MeasuredPressureData'
        std::vector<prodml21__MeasuredPressureData *> MeasuredPressure;
        /// Optional attribute 'uid' of XML schema type 'eml22:String64'
        std::string *uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FlowTestMeasurementSet, default initialized and not managed by a soap context
        virtual prodml21__FlowTestMeasurementSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FlowTestMeasurementSet); }
      public:
        /// Constructor with default initializations
        prodml21__FlowTestMeasurementSet() : Remark(), FluidComponentCatalog(), Location(), TestPeriod(), AbstractFlowTestData(), OtherData(), MeasuredFlowRate(), MeasuredPressure(), uid(), soap() { }
        virtual ~prodml21__FlowTestMeasurementSet() { }
        /// Friend allocator used by soap_new_prodml21__FlowTestMeasurementSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FlowTestMeasurementSet * SOAP_FMAC2 soap_instantiate_prodml21__FlowTestMeasurementSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:708 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis (-289)
/* complex XML schema type 'prodml21:AbstractAnalysis': */
class SOAP_CMAC prodml21__AbstractAnalysis {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractAnalysis, default initialized and not managed by a soap context
        virtual prodml21__AbstractAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractAnalysis() : soap() { }
        virtual ~prodml21__AbstractAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__AbstractAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__AbstractAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:710 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput (-290)
/* complex XML schema type 'prodml21:AbstractDeconvolutionOutput': */
class SOAP_CMAC prodml21__AbstractDeconvolutionOutput {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractDeconvolutionOutput, default initialized and not managed by a soap context
        virtual prodml21__AbstractDeconvolutionOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractDeconvolutionOutput); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractDeconvolutionOutput() : soap() { }
        virtual ~prodml21__AbstractDeconvolutionOutput() { }
        /// Friend allocator used by soap_new_prodml21__AbstractDeconvolutionOutput(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractDeconvolutionOutput * SOAP_FMAC2 soap_instantiate_prodml21__AbstractDeconvolutionOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:714 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory (-292)
/* complex XML schema type 'prodml21:AbstractRateHistory': */
class SOAP_CMAC prodml21__AbstractRateHistory {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractRateHistory, default initialized and not managed by a soap context
        virtual prodml21__AbstractRateHistory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractRateHistory); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractRateHistory() : soap() { }
        virtual ~prodml21__AbstractRateHistory() { }
        /// Friend allocator used by soap_new_prodml21__AbstractRateHistory(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractRateHistory * SOAP_FMAC2 soap_instantiate_prodml21__AbstractRateHistory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:716 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine (-293)
/* complex XML schema type 'prodml21:AnalysisLine': */
class SOAP_CMAC prodml21__AnalysisLine {
      public:
        /// Required element 'prodml21:LineName' of XML schema type 'eml22:String64'
        std::string LineName;
        /// Required element 'prodml21:Slope' of XML schema type 'xsd:double'
        double Slope;
        /// Required element 'prodml21:Intercept' of XML schema type 'xsd:double'
        double Intercept;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AnalysisLine, default initialized and not managed by a soap context
        virtual prodml21__AnalysisLine *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AnalysisLine); }
      public:
        /// Constructor with default initializations
        prodml21__AnalysisLine() : LineName(), Slope(), Intercept(), Remark(), soap() { }
        virtual ~prodml21__AnalysisLine() { }
        /// Friend allocator used by soap_new_prodml21__AnalysisLine(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AnalysisLine * SOAP_FMAC2 soap_instantiate_prodml21__AnalysisLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:720 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters (-295)
/* complex XML schema type 'prodml21:CompressibilityParameters': */
class SOAP_CMAC prodml21__CompressibilityParameters {
      public:
        /// Optional element 'prodml21:FormationCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasureExt'
        eml22__ReciprocalPressureMeasureExt *FormationCompressibility;
        /// Optional element 'prodml21:OilPhaseSaturation' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilPhaseSaturation;
        /// Optional element 'prodml21:GasPhaseSaturation' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *GasPhaseSaturation;
        /// Optional element 'prodml21:WaterPhaseSaturation' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *WaterPhaseSaturation;
        /// Optional element 'prodml21:TotalCompressibility' of XML schema type 'eml22:ReciprocalPressureMeasureExt'
        eml22__ReciprocalPressureMeasureExt *TotalCompressibility;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CompressibilityParameters, default initialized and not managed by a soap context
        virtual prodml21__CompressibilityParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CompressibilityParameters); }
      public:
        /// Constructor with default initializations
        prodml21__CompressibilityParameters() : FormationCompressibility(), OilPhaseSaturation(), GasPhaseSaturation(), WaterPhaseSaturation(), TotalCompressibility(), soap() { }
        virtual ~prodml21__CompressibilityParameters() { }
        /// Friend allocator used by soap_new_prodml21__CompressibilityParameters(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CompressibilityParameters * SOAP_FMAC2 soap_instantiate_prodml21__CompressibilityParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:724 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput (-297)
/* complex XML schema type 'prodml21:DeconvolutionOutput': */
class SOAP_CMAC prodml21__DeconvolutionOutput {
      public:
        /// Optional element 'prodml21:DeconvolvedPressure' of XML schema type 'prodml21:DeconvolvedPressureData'
        prodml21__DeconvolvedPressureData *DeconvolvedPressure;
        /// Required element 'prodml21:DeconvolutionReferenceFlowrateValue' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *DeconvolutionReferenceFlowrateValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeconvolutionOutput, default initialized and not managed by a soap context
        virtual prodml21__DeconvolutionOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeconvolutionOutput); }
      public:
        /// Constructor with default initializations
        prodml21__DeconvolutionOutput() : DeconvolvedPressure(), DeconvolutionReferenceFlowrateValue(), soap() { }
        virtual ~prodml21__DeconvolutionOutput() { }
        /// Friend allocator used by soap_new_prodml21__DeconvolutionOutput(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeconvolutionOutput * SOAP_FMAC2 soap_instantiate_prodml21__DeconvolutionOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:732 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel (-301)
/* complex XML schema type 'prodml21:DistributedParametersSubModel': */
class SOAP_CMAC prodml21__DistributedParametersSubModel {
      public:
        /// Required element 'prodml21:IsPermeabilityGridded' of XML schema type 'xsd:boolean'
        bool IsPermeabilityGridded;
        /// Optional element 'prodml21:PermeabilityArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *PermeabilityArrayRefID;
        /// Required element 'prodml21:IsThicknessGridded' of XML schema type 'xsd:boolean'
        bool IsThicknessGridded;
        /// Optional element 'prodml21:ThicknessArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *ThicknessArrayRefID;
        /// Required element 'prodml21:IsPorosityGridded' of XML schema type 'xsd:boolean'
        bool IsPorosityGridded;
        /// Optional element 'prodml21:PorosityArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *PorosityArrayRefID;
        /// Required element 'prodml21:IsDepthGridded' of XML schema type 'xsd:boolean'
        bool IsDepthGridded;
        /// Optional element 'prodml21:DepthArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *DepthArrayRefID;
        /// Required element 'prodml21:IsKvToKrGridded' of XML schema type 'xsd:boolean'
        bool IsKvToKrGridded;
        /// Optional element 'prodml21:KvToKrArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *KvToKrArrayRefID;
        /// Required element 'prodml21:IsKxToKyGridded' of XML schema type 'xsd:boolean'
        bool IsKxToKyGridded;
        /// Optional element 'prodml21:KxToKyArrayRefID' of XML schema type 'prodml21:ResqmlModelRef'
        prodml21__ResqmlModelRef *KxToKyArrayRefID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistributedParametersSubModel, default initialized and not managed by a soap context
        virtual prodml21__DistributedParametersSubModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistributedParametersSubModel); }
      public:
        /// Constructor with default initializations
        prodml21__DistributedParametersSubModel() : IsPermeabilityGridded(), PermeabilityArrayRefID(), IsThicknessGridded(), ThicknessArrayRefID(), IsPorosityGridded(), PorosityArrayRefID(), IsDepthGridded(), DepthArrayRefID(), IsKvToKrGridded(), KvToKrArrayRefID(), IsKxToKyGridded(), KxToKyArrayRefID(), soap() { }
        virtual ~prodml21__DistributedParametersSubModel() { }
        /// Friend allocator used by soap_new_prodml21__DistributedParametersSubModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistributedParametersSubModel * SOAP_FMAC2 soap_instantiate_prodml21__DistributedParametersSubModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:734 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval (-302)
/* complex XML schema type 'prodml21:InterferingFlowTestInterval': */
class SOAP_CMAC prodml21__InterferingFlowTestInterval {
      public:
        /// Required element 'prodml21:FlowTestMeasurementSetRef' of XML schema type 'eml22:String64'
        std::string FlowTestMeasurementSetRef;
        /// Required element 'prodml21:InterferingFlowrateRef' of XML schema type 'eml22:String64'
        std::string InterferingFlowrateRef;
        /// Optional element 'prodml21:TestPeriodRef' of XML schema type 'eml22:String64'
        std::vector<std::string> TestPeriodRef;
        /// Required element 'prodml21:SimulatedInterferencePressure' of XML schema type 'prodml21:OutputPressureData'
        prodml21__OutputPressureData *SimulatedInterferencePressure;
        /// Required element 'prodml21:SimulatedInterferencePressureRemoved' of XML schema type 'xsd:boolean'
        bool SimulatedInterferencePressureRemoved;
        /// Optional attribute 'uid' of XML schema type 'eml22:String64'
        std::string *uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InterferingFlowTestInterval, default initialized and not managed by a soap context
        virtual prodml21__InterferingFlowTestInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InterferingFlowTestInterval); }
      public:
        /// Constructor with default initializations
        prodml21__InterferingFlowTestInterval() : FlowTestMeasurementSetRef(), InterferingFlowrateRef(), TestPeriodRef(), SimulatedInterferencePressure(), SimulatedInterferencePressureRemoved(), uid(), soap() { }
        virtual ~prodml21__InterferingFlowTestInterval() { }
        /// Friend allocator used by soap_new_prodml21__InterferingFlowTestInterval(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InterferingFlowTestInterval * SOAP_FMAC2 soap_instantiate_prodml21__InterferingFlowTestInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:30472 */
#ifndef SOAP_TYPE_gsoap_eml2_2___prodml21__InternalFaultSubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2___prodml21__InternalFaultSubModel_sequence (-1775)
/* Wrapper: */
struct SOAP_CMAC __prodml21__InternalFaultSubModel_sequence {
      public:
        /** Required element 'prodml21:IsLeaky' of XML schema type 'xsd:boolean' */
        bool IsLeaky;
        /** Optional element 'prodml21:TransmissibilityReductionRatioOfLinearFront' of XML schema type 'prodml21:TransmissibilityReductionFactorOfLinearFront' */
        prodml21__TransmissibilityReductionFactorOfLinearFront *TransmissibilityReductionRatioOfLinearFront;
        /** Required element 'prodml21:IsConductive' of XML schema type 'xsd:boolean' */
        bool IsConductive;
        /** Required element 'prodml21:IsFiniteConductive' of XML schema type 'xsd:boolean' */
        bool IsFiniteConductive;
        /** Optional element 'prodml21:Conductivity' of XML schema type 'prodml21:FractureConductivity' */
        prodml21__FractureConductivity *Conductivity;
        /** Required element 'prodml21:FaultRefID' of XML schema type 'prodml21:ResqmlModelRef' */
        prodml21__ResqmlModelRef *FaultRefID;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2___prodml21__InternalFaultSubModel_sequence */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2___prodml21__InternalFaultSubModel_sequence; }
        /** Constructor with member initializations */
        __prodml21__InternalFaultSubModel_sequence() : IsLeaky(), TransmissibilityReductionRatioOfLinearFront(), IsConductive(), IsFiniteConductive(), Conductivity(), FaultRefID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __prodml21__InternalFaultSubModel_sequence * SOAP_FMAC2 soap_instantiate___prodml21__InternalFaultSubModel_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:736 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel (-303)
/* complex XML schema type 'prodml21:InternalFaultSubModel': */
class SOAP_CMAC prodml21__InternalFaultSubModel {
      public:
        std::vector<struct __prodml21__InternalFaultSubModel_sequence> __InternalFaultSubModel_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InternalFaultSubModel, default initialized and not managed by a soap context
        virtual prodml21__InternalFaultSubModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InternalFaultSubModel); }
      public:
        /// Constructor with default initializations
        prodml21__InternalFaultSubModel() : __InternalFaultSubModel_sequence(), soap() { }
        virtual ~prodml21__InternalFaultSubModel() { }
        /// Friend allocator used by soap_new_prodml21__InternalFaultSubModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InternalFaultSubModel * SOAP_FMAC2 soap_instantiate_prodml21__InternalFaultSubModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:738 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel (-304)
/* complex XML schema type 'prodml21:LayerModel': */
class SOAP_CMAC prodml21__LayerModel {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Required element 'prodml21:AggregateLayersModel' of XML schema type 'xsd:boolean'
        bool AggregateLayersModel;
        /// Optional element 'prodml21:GeologicFeature' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *GeologicFeature;
        /// Optional element 'prodml21:MdTopLayer' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdTopLayer;
        /// Optional element 'prodml21:MdBottomLayer' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MdBottomLayer;
        /// Optional element 'prodml21:LayerProductivityIndex' of XML schema type 'eml22:VolumePerTimePerPressureMeasure'
        eml22__VolumePerTimePerPressureMeasure *LayerProductivityIndex;
        /// Optional element 'prodml21:LayerTurbulentFlowCoefficient' of XML schema type 'prodml21:PressurePerFlowrateSquaredMeasure'
        prodml21__PressurePerFlowrateSquaredMeasure *LayerTurbulentFlowCoefficient;
        /// Optional element 'prodml21:LayerLaminarFlowCoefficient' of XML schema type 'prodml21:PressurePerFlowrateMeasure'
        prodml21__PressurePerFlowrateMeasure *LayerLaminarFlowCoefficient;
        /// Optional element 'prodml21:NearWellboreModel' of XML schema type 'prodml21:NearWellboreBaseModel'
        prodml21__NearWellboreBaseModel *NearWellboreModel;
        /// Optional element 'prodml21:ReservoirModel' of XML schema type 'prodml21:ReservoirBaseModel'
        prodml21__ReservoirBaseModel *ReservoirModel;
        /// Optional element 'prodml21:BoundaryModel' of XML schema type 'prodml21:BoundaryBaseModel'
        prodml21__BoundaryBaseModel *BoundaryModel;
        /// Optional element 'prodml21:LayerToLayerConnection' of XML schema type 'prodml21:LayerToLayerConnection'
        std::vector<prodml21__LayerToLayerConnection *> LayerToLayerConnection;
        /// Optional attribute 'uid' of XML schema type 'eml22:String64'
        std::string *uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LayerModel, default initialized and not managed by a soap context
        virtual prodml21__LayerModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LayerModel); }
      public:
        /// Constructor with default initializations
        prodml21__LayerModel() : Name(), AggregateLayersModel(), GeologicFeature(), MdTopLayer(), MdBottomLayer(), LayerProductivityIndex(), LayerTurbulentFlowCoefficient(), LayerLaminarFlowCoefficient(), NearWellboreModel(), ReservoirModel(), BoundaryModel(), LayerToLayerConnection(), uid(), soap() { }
        virtual ~prodml21__LayerModel() { }
        /// Friend allocator used by soap_new_prodml21__LayerModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LayerModel * SOAP_FMAC2 soap_instantiate_prodml21__LayerModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:740 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection (-305)
/* complex XML schema type 'prodml21:LayerToLayerConnection': */
class SOAP_CMAC prodml21__LayerToLayerConnection {
      public:
        /// Required element 'prodml21:ConnectedLayerRefID' of XML schema type 'eml22:String64'
        std::string ConnectedLayerRefID;
        /// Required element 'prodml21:InterLayerConnectivity' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterLayerConnectivity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LayerToLayerConnection, default initialized and not managed by a soap context
        virtual prodml21__LayerToLayerConnection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LayerToLayerConnection); }
      public:
        /// Constructor with default initializations
        prodml21__LayerToLayerConnection() : ConnectedLayerRefID(), InterLayerConnectivity(), soap() { }
        virtual ~prodml21__LayerToLayerConnection() { }
        /// Friend allocator used by soap_new_prodml21__LayerToLayerConnection(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LayerToLayerConnection * SOAP_FMAC2 soap_instantiate_prodml21__LayerToLayerConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:742 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D (-306)
/* complex XML schema type 'prodml21:LocationIn2D': */
class SOAP_CMAC prodml21__LocationIn2D {
      public:
        /// Required element 'prodml21:CoordinateX' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *CoordinateX;
        /// Required element 'prodml21:CoordinateY' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *CoordinateY;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LocationIn2D, default initialized and not managed by a soap context
        virtual prodml21__LocationIn2D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LocationIn2D); }
      public:
        /// Constructor with default initializations
        prodml21__LocationIn2D() : CoordinateX(), CoordinateY(), soap() { }
        virtual ~prodml21__LocationIn2D() { }
        /// Friend allocator used by soap_new_prodml21__LocationIn2D(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LocationIn2D * SOAP_FMAC2 soap_instantiate_prodml21__LocationIn2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:30704 */
#ifndef SOAP_TYPE_gsoap_eml2_2___prodml21__LogLogAnalysis_sequence
#define SOAP_TYPE_gsoap_eml2_2___prodml21__LogLogAnalysis_sequence (-1788)
/* Wrapper: */
struct SOAP_CMAC __prodml21__LogLogAnalysis_sequence {
      public:
        /** Required element 'prodml21:AnalysisPressure' of XML schema type 'prodml21:AbstractPtaPressureData' */
        prodml21__AbstractPtaPressureData *AnalysisPressure;
        /** Required element 'prodml21:LogLogTimeDataTransform' of XML schema type 'prodml21:LogLogTimeTransform' */
        prodml21__LogLogTimeTransform LogLogTimeDataTransform;
        /** Required element 'prodml21:LogLogPressureTransform' of XML schema type 'prodml21:LogLogPressureTransform' */
        prodml21__LogLogPressureTransform LogLogPressureTransform;
        /** Optional element 'prodml21:DerivativeSmoothingFactorL' of XML schema type 'eml22:DimensionlessMeasure' */
        eml22__DimensionlessMeasure *DerivativeSmoothingFactorL;
        /** Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000' */
        std::string *Remark;
        /** Optional element 'prodml21:AnalysisLine' of XML schema type 'prodml21:AnalysisLine' */
        std::vector<prodml21__AnalysisLine *> AnalysisLine;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2___prodml21__LogLogAnalysis_sequence */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2___prodml21__LogLogAnalysis_sequence; }
        /** Constructor with member initializations */
        __prodml21__LogLogAnalysis_sequence() : AnalysisPressure(), LogLogTimeDataTransform(), LogLogPressureTransform(), DerivativeSmoothingFactorL(), Remark(), AnalysisLine() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __prodml21__LogLogAnalysis_sequence * SOAP_FMAC2 soap_instantiate___prodml21__LogLogAnalysis_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:744 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis (-307)
/* complex XML schema type 'prodml21:LogLogAnalysis': */
class SOAP_CMAC prodml21__LogLogAnalysis {
      public:
        std::vector<struct __prodml21__LogLogAnalysis_sequence> __LogLogAnalysis_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LogLogAnalysis, default initialized and not managed by a soap context
        virtual prodml21__LogLogAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LogLogAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__LogLogAnalysis() : __LogLogAnalysis_sequence(), soap() { }
        virtual ~prodml21__LogLogAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__LogLogAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LogLogAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__LogLogAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:766 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel (-318)
/* complex XML schema type 'prodml21:ReservoirZoneSubModel': */
class SOAP_CMAC prodml21__ReservoirZoneSubModel {
      public:
        /// Required element 'prodml21:BoundingPolygonPoint' of XML schema type 'prodml21:LocationIn2D'
        std::vector<prodml21__LocationIn2D *> BoundingPolygonPoint;
        /// Optional element 'prodml21:Permeability' of XML schema type 'prodml21:HorizontalRadialPermeability'
        prodml21__HorizontalRadialPermeability *Permeability;
        /// Optional element 'prodml21:Porosity' of XML schema type 'prodml21:Porosity'
        prodml21__Porosity *Porosity;
        /// Optional element 'prodml21:Thickness' of XML schema type 'prodml21:TotalThickness'
        prodml21__TotalThickness *Thickness;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReservoirZoneSubModel, default initialized and not managed by a soap context
        virtual prodml21__ReservoirZoneSubModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReservoirZoneSubModel); }
      public:
        /// Constructor with default initializations
        prodml21__ReservoirZoneSubModel() : BoundingPolygonPoint(), Permeability(), Porosity(), Thickness(), soap() { }
        virtual ~prodml21__ReservoirZoneSubModel() { }
        /// Friend allocator used by soap_new_prodml21__ReservoirZoneSubModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReservoirZoneSubModel * SOAP_FMAC2 soap_instantiate_prodml21__ReservoirZoneSubModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:768 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef (-319)
/* complex XML schema type 'prodml21:ResqmlModelRef': */
class SOAP_CMAC prodml21__ResqmlModelRef {
      public:
        /// Required element 'prodml21:ResqmlModelRef' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ResqmlModelRef;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ResqmlModelRef, default initialized and not managed by a soap context
        virtual prodml21__ResqmlModelRef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ResqmlModelRef); }
      public:
        /// Constructor with default initializations
        prodml21__ResqmlModelRef() : ResqmlModelRef(), soap() { }
        virtual ~prodml21__ResqmlModelRef() { }
        /// Friend allocator used by soap_new_prodml21__ResqmlModelRef(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ResqmlModelRef * SOAP_FMAC2 soap_instantiate_prodml21__ResqmlModelRef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:30841 */
#ifndef SOAP_TYPE_gsoap_eml2_2___prodml21__SingleBoundarySubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2___prodml21__SingleBoundarySubModel_sequence (-1798)
/* Wrapper: */
struct SOAP_CMAC __prodml21__SingleBoundarySubModel_sequence {
      public:
        /** Required element 'prodml21:TypeOfBoundary' of XML schema type 'prodml21:Boundary1Type' */
        prodml21__Boundary1Type TypeOfBoundary;
        /** Required element 'prodml21:FaultRefID' of XML schema type 'prodml21:ResqmlModelRef' */
        prodml21__ResqmlModelRef *FaultRefID;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2___prodml21__SingleBoundarySubModel_sequence */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2___prodml21__SingleBoundarySubModel_sequence; }
        /** Constructor with member initializations */
        __prodml21__SingleBoundarySubModel_sequence() : TypeOfBoundary(), FaultRefID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __prodml21__SingleBoundarySubModel_sequence * SOAP_FMAC2 soap_instantiate___prodml21__SingleBoundarySubModel_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:772 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel (-321)
/* complex XML schema type 'prodml21:SingleBoundarySubModel': */
class SOAP_CMAC prodml21__SingleBoundarySubModel {
      public:
        std::vector<struct __prodml21__SingleBoundarySubModel_sequence> __SingleBoundarySubModel_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SingleBoundarySubModel, default initialized and not managed by a soap context
        virtual prodml21__SingleBoundarySubModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SingleBoundarySubModel); }
      public:
        /// Constructor with default initializations
        prodml21__SingleBoundarySubModel() : __SingleBoundarySubModel_sequence(), soap() { }
        virtual ~prodml21__SingleBoundarySubModel() { }
        /// Friend allocator used by soap_new_prodml21__SingleBoundarySubModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SingleBoundarySubModel * SOAP_FMAC2 soap_instantiate_prodml21__SingleBoundarySubModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:30882 */
#ifndef SOAP_TYPE_gsoap_eml2_2___prodml21__SingleFractureSubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2___prodml21__SingleFractureSubModel_sequence (-1800)
/* Wrapper: */
struct SOAP_CMAC __prodml21__SingleFractureSubModel_sequence {
      public:
        /** Required element 'prodml21:FractureTip1Location' of XML schema type 'prodml21:LocationIn2D' */
        prodml21__LocationIn2D *FractureTip1Location;
        /** Required element 'prodml21:FractureTip2Location' of XML schema type 'prodml21:LocationIn2D' */
        prodml21__LocationIn2D *FractureTip2Location;
        /** Required element 'prodml21:FractureHeight' of XML schema type 'prodml21:FractureHeight' */
        prodml21__FractureHeight *FractureHeight;
        /** Optional element 'prodml21:DistanceMidFractureHeightToBottomBoundary' of XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary' */
        prodml21__DistanceMidFractureHeightToBottomBoundary *DistanceMidFractureHeightToBottomBoundary;
        /** Optional element 'prodml21:FractureFaceSkin' of XML schema type 'prodml21:FractureFaceSkin' */
        prodml21__FractureFaceSkin *FractureFaceSkin;
        /** Optional element 'prodml21:FractureConductivity' of XML schema type 'prodml21:FractureConductivity' */
        prodml21__FractureConductivity *FractureConductivity;
        /** Optional element 'prodml21:FractureStorativityRatio' of XML schema type 'prodml21:FractureStorativityRatio' */
        prodml21__FractureStorativityRatio *FractureStorativityRatio;
        /** Required element 'prodml21:FractureModelType' of XML schema type 'prodml21:FractureModelType' */
        prodml21__FractureModelType FractureModelType;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2___prodml21__SingleFractureSubModel_sequence */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2___prodml21__SingleFractureSubModel_sequence; }
        /** Constructor with member initializations */
        __prodml21__SingleFractureSubModel_sequence() : FractureTip1Location(), FractureTip2Location(), FractureHeight(), DistanceMidFractureHeightToBottomBoundary(), FractureFaceSkin(), FractureConductivity(), FractureStorativityRatio(), FractureModelType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __prodml21__SingleFractureSubModel_sequence * SOAP_FMAC2 soap_instantiate___prodml21__SingleFractureSubModel_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:776 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel (-323)
/* complex XML schema type 'prodml21:SingleFractureSubModel': */
class SOAP_CMAC prodml21__SingleFractureSubModel {
      public:
        std::vector<struct __prodml21__SingleFractureSubModel_sequence> __SingleFractureSubModel_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SingleFractureSubModel, default initialized and not managed by a soap context
        virtual prodml21__SingleFractureSubModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SingleFractureSubModel); }
      public:
        /// Constructor with default initializations
        prodml21__SingleFractureSubModel() : __SingleFractureSubModel_sequence(), soap() { }
        virtual ~prodml21__SingleFractureSubModel() { }
        /// Friend allocator used by soap_new_prodml21__SingleFractureSubModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SingleFractureSubModel * SOAP_FMAC2 soap_instantiate_prodml21__SingleFractureSubModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:778 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis (-324)
/* complex XML schema type 'prodml21:SpecializedAnalysis': */
class SOAP_CMAC prodml21__SpecializedAnalysis {
      public:
        /// Required element 'prodml21:SpecializedAnalysisType' of XML schema type 'eml22:String2000'
        std::string SpecializedAnalysisType;
        /// Optional element 'prodml21:AnyParameter' of XML schema type 'prodml21:AbstractParameter'
        std::vector<prodml21__AbstractParameter *> AnyParameter;
        /// Optional element 'prodml21:CustomParameter' of XML schema type 'prodml21:CustomParameter'
        std::vector<prodml21__CustomParameter *> CustomParameter;
        /// Required element 'prodml21:SpecializedXAxisDescription' of XML schema type 'eml22:String2000'
        std::string SpecializedXAxisDescription;
        /// Required element 'prodml21:SpecializedYAxisDescription' of XML schema type 'eml22:String2000'
        std::string SpecializedYAxisDescription;
        /// Required element 'prodml21:AnalysisPressureFunction' of XML schema type 'prodml21:AbstractPtaPressureData'
        prodml21__AbstractPtaPressureData *AnalysisPressureFunction;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:AnalysisLine' of XML schema type 'prodml21:AnalysisLine'
        std::vector<prodml21__AnalysisLine *> AnalysisLine;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SpecializedAnalysis, default initialized and not managed by a soap context
        virtual prodml21__SpecializedAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SpecializedAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__SpecializedAnalysis() : SpecializedAnalysisType(), AnyParameter(), CustomParameter(), SpecializedXAxisDescription(), SpecializedYAxisDescription(), AnalysisPressureFunction(), Remark(), AnalysisLine(), soap() { }
        virtual ~prodml21__SpecializedAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__SpecializedAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SpecializedAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__SpecializedAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:782 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection (-326)
/* complex XML schema type 'prodml21:AbstractModelSection': */
class SOAP_CMAC prodml21__AbstractModelSection {
      public:
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:Method' of XML schema type 'eml22:String64'
        std::string *Method;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractModelSection, default initialized and not managed by a soap context
        virtual prodml21__AbstractModelSection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractModelSection); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractModelSection() : Comment(), Method(), soap() { }
        virtual ~prodml21__AbstractModelSection() { }
        /// Friend allocator used by soap_new_prodml21__AbstractModelSection(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractModelSection * SOAP_FMAC2 soap_instantiate_prodml21__AbstractModelSection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:880 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter (-375)
/* complex XML schema type 'prodml21:AbstractParameter': */
class SOAP_CMAC prodml21__AbstractParameter {
      public:
        /// Optional element 'prodml21:SourceResultRefID' of XML schema type 'eml22:String64'
        std::string *SourceResultRefID;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required attribute 'Uid' of XML schema type 'eml22:String64'
        std::string Uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractParameter, default initialized and not managed by a soap context
        virtual prodml21__AbstractParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractParameter); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractParameter() : SourceResultRefID(), Remark(), Uid(), soap() { }
        virtual ~prodml21__AbstractParameter() { }
        /// Friend allocator used by soap_new_prodml21__AbstractParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractParameter * SOAP_FMAC2 soap_instantiate_prodml21__AbstractParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1022 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode (-446)
/* Type prodml21__ReportingHierarchyNode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'prodml21:ReportingHierarchyNode': */
class SOAP_CMAC prodml21__ReportingHierarchyNode {
      public:
        /// Optional element 'prodml21:ChildNode' of XML schema type 'prodml21:ReportingHierarchyNode'
        std::vector<prodml21__ReportingHierarchyNode *> ChildNode;
        /// Optional element 'prodml21:ReportingEntity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportingEntity;
        /// Required attribute 'id' of XML schema type 'eml22:String64'
        std::string id;
        /// Required attribute 'name' of XML schema type 'eml22:String64'
        std::string name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReportingHierarchyNode, default initialized and not managed by a soap context
        virtual prodml21__ReportingHierarchyNode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReportingHierarchyNode); }
      public:
        /// Constructor with default initializations
        prodml21__ReportingHierarchyNode() : ChildNode(), ReportingEntity(), id(), name(), soap() { }
        virtual ~prodml21__ReportingHierarchyNode() { }
        /// Friend allocator used by soap_new_prodml21__ReportingHierarchyNode(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReportingHierarchyNode * SOAP_FMAC2 soap_instantiate_prodml21__ReportingHierarchyNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1024 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue (-447)
/* complex XML schema type 'prodml21:AbstractValue': */
class SOAP_CMAC prodml21__AbstractValue {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractValue, default initialized and not managed by a soap context
        virtual prodml21__AbstractValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractValue); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractValue() : soap() { }
        virtual ~prodml21__AbstractValue() { }
        /// Friend allocator used by soap_new_prodml21__AbstractValue(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractValue * SOAP_FMAC2 soap_instantiate_prodml21__AbstractValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1038 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart (-454)
/* complex XML schema type 'eml22:AbstractGrowingObjectPart': */
class SOAP_CMAC eml22__AbstractGrowingObjectPart {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm Creation;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm LastUpdate;
        /// Optional element 'eml22:ExtensionNameValue' of XML schema type 'eml22:ExtensionNameValue'
        eml22__ExtensionNameValue *ExtensionNameValue;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
        /// Optional attribute 'objectVersion' of XML schema type 'eml22:String64'
        std::string *objectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractGrowingObjectPart, default initialized and not managed by a soap context
        virtual eml22__AbstractGrowingObjectPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractGrowingObjectPart); }
      public:
        /// Constructor with default initializations
        eml22__AbstractGrowingObjectPart() : Creation(), LastUpdate(), ExtensionNameValue(), uid(), objectVersion(), soap() { }
        virtual ~eml22__AbstractGrowingObjectPart() { }
        /// Friend allocator used by soap_new_eml22__AbstractGrowingObjectPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractGrowingObjectPart * SOAP_FMAC2 soap_instantiate_eml22__AbstractGrowingObjectPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1044 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject (-457)
/* complex XML schema type 'eml22:AbstractObject': */
class SOAP_CMAC eml22__AbstractObject {
      public:
        /// Optional element 'eml22:Aliases' of XML schema type 'eml22:ObjectAlias'
        std::vector<eml22__ObjectAlias *> Aliases;
        /// Required element 'eml22:Citation' of XML schema type 'eml22:Citation'
        eml22__Citation *Citation;
        /// Optional element 'eml22:CustomData' of XML schema type 'eml22:CustomData'
        eml22__CustomData *CustomData;
        /// Optional element 'eml22:ExtensionNameValue' of XML schema type 'eml22:ExtensionNameValue'
        std::vector<eml22__ExtensionNameValue *> ExtensionNameValue;
        /// Optional attribute 'objectVersion' of XML schema type 'eml22:String64'
        std::string *objectVersion;
        /// Required attribute 'schemaVersion' of XML schema type 'eml22:String64'
        std::string schemaVersion;
        /// Required attribute 'uuid' of XML schema type 'eml22:UuidString'
        std::string uuid;
        /// Optional attribute 'existenceKind' of XML schema type 'eml22:ExistenceKind'
        eml22__ExistenceKind *existenceKind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractObject, default initialized and not managed by a soap context
        virtual eml22__AbstractObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractObject); }
      public:
        /// Constructor with default initializations
        eml22__AbstractObject() : Aliases(), Citation(), CustomData(), ExtensionNameValue(), objectVersion(), schemaVersion(), uuid(), existenceKind(), soap() { }
        virtual ~eml22__AbstractObject() { }
        /// Friend allocator used by soap_new_eml22__AbstractObject(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractObject * SOAP_FMAC2 soap_instantiate_eml22__AbstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1050 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Citation
#define SOAP_TYPE_gsoap_eml2_2_eml22__Citation (-460)
/* complex XML schema type 'eml22:Citation': */
class SOAP_CMAC eml22__Citation {
      public:
        /// Required element 'eml22:Title' of XML schema type 'eml22:String256'
        std::string Title;
        /// Required element 'eml22:Originator' of XML schema type 'eml22:String64'
        std::string Originator;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm Creation;
        /// Required element 'eml22:Format' of XML schema type 'eml22:String2000'
        std::string Format;
        /// Optional element 'eml22:Editor' of XML schema type 'eml22:String64'
        std::string *Editor;
        /// Optional element 'eml22:LastUpdate' of XML schema type 'eml22:TimeStamp'
        struct tm *LastUpdate;
        /// Optional element 'eml22:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Optional element 'eml22:DescriptiveKeywords' of XML schema type 'eml22:String2000'
        std::string *DescriptiveKeywords;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__Citation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__Citation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__Citation, default initialized and not managed by a soap context
        virtual eml22__Citation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__Citation); }
      public:
        /// Constructor with default initializations
        eml22__Citation() : Title(), Originator(), Creation(), Format(), Editor(), LastUpdate(), Description(), DescriptiveKeywords(), soap() { }
        virtual ~eml22__Citation() { }
        /// Friend allocator used by soap_new_eml22__Citation(struct soap*, int)
        friend SOAP_FMAC1 eml22__Citation * SOAP_FMAC2 soap_instantiate_eml22__Citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1052 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CustomData
#define SOAP_TYPE_gsoap_eml2_2_eml22__CustomData (-461)
/* complex XML schema type 'eml22:CustomData': */
class SOAP_CMAC eml22__CustomData {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__CustomData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__CustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__CustomData, default initialized and not managed by a soap context
        virtual eml22__CustomData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__CustomData); }
      public:
        /// Constructor with default initializations
        eml22__CustomData() : __any(), soap() { }
        virtual ~eml22__CustomData() { }
        /// Friend allocator used by soap_new_eml22__CustomData(struct soap*, int)
        friend SOAP_FMAC1 eml22__CustomData * SOAP_FMAC2 soap_instantiate_eml22__CustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1054 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue (-462)
/* complex XML schema type 'eml22:ExtensionNameValue': */
class SOAP_CMAC eml22__ExtensionNameValue {
      public:
        /// Required element 'eml22:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Required element 'eml22:Value' of XML schema type 'eml22:StringMeasure'
        eml22__StringMeasure *Value;
        /// Optional element 'eml22:MeasureClass' of XML schema type 'eml22:MeasureClass'
        eml22__MeasureClass *MeasureClass;
        /// Optional element 'eml22:DTim' of XML schema type 'eml22:TimeStamp'
        struct tm *DTim;
        /// Optional element 'eml22:Index' of XML schema type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'eml22:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ExtensionNameValue, default initialized and not managed by a soap context
        virtual eml22__ExtensionNameValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ExtensionNameValue); }
      public:
        /// Constructor with default initializations
        eml22__ExtensionNameValue() : Name(), Value(), MeasureClass(), DTim(), Index(), Description(), soap() { }
        virtual ~eml22__ExtensionNameValue() { }
        /// Friend allocator used by soap_new_eml22__ExtensionNameValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__ExtensionNameValue * SOAP_FMAC2 soap_instantiate_eml22__ExtensionNameValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1056 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias (-463)
/* complex XML schema type 'eml22:ObjectAlias': */
class SOAP_CMAC eml22__ObjectAlias {
      public:
        /// Required element 'eml22:Identifier' of XML schema type 'eml22:String64'
        std::string Identifier;
        /// Optional element 'eml22:Description' of XML schema type 'eml22:String2000'
        std::string *Description;
        /// Required attribute 'authority' of XML schema type 'eml22:String64'
        std::string authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ObjectAlias, default initialized and not managed by a soap context
        virtual eml22__ObjectAlias *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ObjectAlias); }
      public:
        /// Constructor with default initializations
        eml22__ObjectAlias() : Identifier(), Description(), authority(), soap() { }
        virtual ~eml22__ObjectAlias() { }
        /// Friend allocator used by soap_new_eml22__ObjectAlias(struct soap*, int)
        friend SOAP_FMAC1 eml22__ObjectAlias * SOAP_FMAC2 soap_instantiate_eml22__ObjectAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1058 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval (-464)
/* complex XML schema type 'eml22:DateTimeInterval': */
class SOAP_CMAC eml22__DateTimeInterval {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm StartTime;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm EndTime;
        /// Optional element 'eml22:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DateTimeInterval, default initialized and not managed by a soap context
        virtual eml22__DateTimeInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DateTimeInterval); }
      public:
        /// Constructor with default initializations
        eml22__DateTimeInterval() : StartTime(), EndTime(), Comment(), soap() { }
        virtual ~eml22__DateTimeInterval() { }
        /// Friend allocator used by soap_new_eml22__DateTimeInterval(struct soap*, int)
        friend SOAP_FMAC1 eml22__DateTimeInterval * SOAP_FMAC2 soap_instantiate_eml22__DateTimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1060 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime (-465)
/* complex XML schema type 'eml22:GeologicTime': */
class SOAP_CMAC eml22__GeologicTime {
      public:
        /// Optional element 'eml22:AgeOffsetAttribute' of XML schema type 'xsd:long'
        LONG64 *AgeOffsetAttribute;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm DateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeologicTime, default initialized and not managed by a soap context
        virtual eml22__GeologicTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeologicTime); }
      public:
        /// Constructor with default initializations
        eml22__GeologicTime() : AgeOffsetAttribute(), DateTime(), soap() { }
        virtual ~eml22__GeologicTime() { }
        /// Friend allocator used by soap_new_eml22__GeologicTime(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeologicTime * SOAP_FMAC2 soap_instantiate_eml22__GeologicTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1066 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet (-468)
/* complex XML schema type 'eml22:PropertyKindFacet': */
class SOAP_CMAC eml22__PropertyKindFacet {
      public:
        /// Required element 'eml22:Facet' of XML schema type 'eml22:FacetExt'
        std::string Facet;
        /// Required element 'eml22:Kind' of XML schema type 'eml22:FacetKind'
        eml22__FacetKind Kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PropertyKindFacet, default initialized and not managed by a soap context
        virtual eml22__PropertyKindFacet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PropertyKindFacet); }
      public:
        /// Constructor with default initializations
        eml22__PropertyKindFacet() : Facet(), Kind(), soap() { }
        virtual ~eml22__PropertyKindFacet() { }
        /// Friend allocator used by soap_new_eml22__PropertyKindFacet(struct soap*, int)
        friend SOAP_FMAC1 eml22__PropertyKindFacet * SOAP_FMAC2 soap_instantiate_eml22__PropertyKindFacet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1068 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex (-469)
/* complex XML schema type 'eml22:TimeIndex': */
class SOAP_CMAC eml22__TimeIndex {
      public:
        /// Required element 'eml22:Index' of XML schema type 'eml22:NonNegativeLong'
        LONG64 Index;
        /// Required element 'eml22:TimeSeries' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeIndex, default initialized and not managed by a soap context
        virtual eml22__TimeIndex *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeIndex); }
      public:
        /// Constructor with default initializations
        eml22__TimeIndex() : Index(), TimeSeries(), soap() { }
        virtual ~eml22__TimeIndex() { }
        /// Friend allocator used by soap_new_eml22__TimeIndex(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeIndex * SOAP_FMAC2 soap_instantiate_eml22__TimeIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1070 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices (-470)
/* complex XML schema type 'eml22:TimeIndices': */
class SOAP_CMAC eml22__TimeIndices {
      public:
        /// Required element 'eml22:TimeIndexCount' of XML schema type 'eml22:PositiveLong'
        LONG64 TimeIndexCount;
        /// Optional element 'eml22:TimeIndexStart' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *TimeIndexStart;
        /// Optional element 'eml22:SimulatorTimeStep' of XML schema type 'eml22:AbstractIntegerArray'
        eml22__AbstractIntegerArray *SimulatorTimeStep;
        /// Required element 'eml22:UseInterval' of XML schema type 'xsd:boolean'
        bool UseInterval;
        /// Required element 'eml22:TimeSeries' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeIndices, default initialized and not managed by a soap context
        virtual eml22__TimeIndices *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeIndices); }
      public:
        /// Constructor with default initializations
        eml22__TimeIndices() : TimeIndexCount(), TimeIndexStart(), SimulatorTimeStep(), UseInterval(), TimeSeries(), soap() { }
        virtual ~eml22__TimeIndices() { }
        /// Friend allocator used by soap_new_eml22__TimeIndices(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeIndices * SOAP_FMAC2 soap_instantiate_eml22__TimeIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1074 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage (-472)
/* complex XML schema type 'eml22:TimeSeriesParentage': */
class SOAP_CMAC eml22__TimeSeriesParentage {
      public:
        /// Required element 'eml22:HasOverlap' of XML schema type 'xsd:boolean'
        bool HasOverlap;
        /// Required element 'eml22:ParentTimeIndex' of XML schema type 'eml22:TimeIndex'
        eml22__TimeIndex *ParentTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeSeriesParentage, default initialized and not managed by a soap context
        virtual eml22__TimeSeriesParentage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeSeriesParentage); }
      public:
        /// Constructor with default initializations
        eml22__TimeSeriesParentage() : HasOverlap(), ParentTimeIndex(), soap() { }
        virtual ~eml22__TimeSeriesParentage() { }
        /// Friend allocator used by soap_new_eml22__TimeSeriesParentage(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeSeriesParentage * SOAP_FMAC2 soap_instantiate_eml22__TimeSeriesParentage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1086 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray (-478)
/* complex XML schema type 'eml22:AbstractValueArray': */
class SOAP_CMAC eml22__AbstractValueArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractValueArray, default initialized and not managed by a soap context
        virtual eml22__AbstractValueArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractValueArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractValueArray() : soap() { }
        virtual ~eml22__AbstractValueArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractValueArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractValueArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1096 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Cost
#define SOAP_TYPE_gsoap_eml2_2_eml22__Cost (-483)
/* complex XML schema type 'eml22:Cost': */
class SOAP_CMAC eml22__Cost {
      public:
        /// Required attribute 'currency' of XML schema type 'eml22:String64'
        std::string currency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__Cost
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__Cost; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__Cost, default initialized and not managed by a soap context
        virtual eml22__Cost *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__Cost); }
      public:
        /// Constructor with default initializations
        eml22__Cost() : currency(), soap() { }
        virtual ~eml22__Cost() { }
        /// Friend allocator used by soap_new_eml22__Cost(struct soap*, int)
        friend SOAP_FMAC1 eml22__Cost * SOAP_FMAC2 soap_instantiate_eml22__Cost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1100 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DummyType
#define SOAP_TYPE_gsoap_eml2_2_eml22__DummyType (-485)
/* complex XML schema type 'eml22:DummyType': */
class SOAP_CMAC eml22__DummyType {
      public:
        /// Required element 'eml22:DummyElement' of XML schema type 'eml22:CustomData'
        eml22__CustomData *DummyElement;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DummyType
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DummyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DummyType, default initialized and not managed by a soap context
        virtual eml22__DummyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DummyType); }
      public:
        /// Constructor with default initializations
        eml22__DummyType() : DummyElement(), soap() { }
        virtual ~eml22__DummyType() { }
        /// Friend allocator used by soap_new_eml22__DummyType(struct soap*, int)
        friend SOAP_FMAC1 eml22__DummyType * SOAP_FMAC2 soap_instantiate_eml22__DummyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1122 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray (-496)
/* complex XML schema type 'eml22:JaggedArray': */
class SOAP_CMAC eml22__JaggedArray {
      public:
        /// Required element 'eml22:Elements' of XML schema type 'eml22:AbstractValueArray'
        eml22__AbstractValueArray *Elements;
        /// Required element 'eml22:CumulativeLength' of XML schema type 'eml22:AbstractIntegerArray'
        eml22__AbstractIntegerArray *CumulativeLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__JaggedArray, default initialized and not managed by a soap context
        virtual eml22__JaggedArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__JaggedArray); }
      public:
        /// Constructor with default initializations
        eml22__JaggedArray() : Elements(), CumulativeLength(), soap() { }
        virtual ~eml22__JaggedArray() { }
        /// Friend allocator used by soap_new_eml22__JaggedArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__JaggedArray * SOAP_FMAC2 soap_instantiate_eml22__JaggedArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1124 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval (-497)
/* complex XML schema type 'eml22:MdInterval': */
class SOAP_CMAC eml22__MdInterval {
      public:
        /// Required element 'eml22:MdTop' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *MdTop;
        /// Required element 'eml22:MdBase' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *MdBase;
        /// Optional element 'eml22:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required attribute 'datum' of XML schema type 'eml22:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MdInterval, default initialized and not managed by a soap context
        virtual eml22__MdInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MdInterval); }
      public:
        /// Constructor with default initializations
        eml22__MdInterval() : MdTop(), MdBase(), Comment(), datum(), soap() { }
        virtual ~eml22__MdInterval() { }
        /// Friend allocator used by soap_new_eml22__MdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml22__MdInterval * SOAP_FMAC2 soap_instantiate_eml22__MdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1134 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval (-502)
/* complex XML schema type 'eml22:TvdInterval': */
class SOAP_CMAC eml22__TvdInterval {
      public:
        /// Required element 'eml22:TvdTop' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *TvdTop;
        /// Required element 'eml22:TvdBase' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *TvdBase;
        /// Optional element 'eml22:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required attribute 'datum' of XML schema type 'eml22:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TvdInterval, default initialized and not managed by a soap context
        virtual eml22__TvdInterval *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TvdInterval); }
      public:
        /// Constructor with default initializations
        eml22__TvdInterval() : TvdTop(), TvdBase(), Comment(), datum(), soap() { }
        virtual ~eml22__TvdInterval() { }
        /// Friend allocator used by soap_new_eml22__TvdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml22__TvdInterval * SOAP_FMAC2 soap_instantiate_eml22__TvdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1874 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference (-872)
/* complex XML schema type 'eml22:DataObjectReference': */
class SOAP_CMAC eml22__DataObjectReference {
      public:
        /// Required element 'eml22:ContentType' of XML schema type 'eml22:String2000'
        std::string ContentType;
        /// Required element 'eml22:Title' of XML schema type 'eml22:String2000'
        std::string Title;
        /// Required element 'eml22:Uuid' of XML schema type 'eml22:UuidString'
        std::string Uuid;
        /// Optional element 'eml22:UuidAuthority' of XML schema type 'eml22:String64'
        std::string *UuidAuthority;
        /// Optional element 'eml22:Uri' of XML schema type 'xsd:anyURI'
        std::string *Uri;
        /// Optional element 'eml22:ObjectVersion' of XML schema type 'eml22:String64'
        std::string *ObjectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DataObjectReference, default initialized and not managed by a soap context
        virtual eml22__DataObjectReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DataObjectReference); }
      public:
        /// Constructor with default initializations
        eml22__DataObjectReference() : ContentType(), Title(), Uuid(), UuidAuthority(), Uri(), ObjectVersion(), soap() { }
        virtual ~eml22__DataObjectReference() { }
        /// Friend allocator used by soap_new_eml22__DataObjectReference(struct soap*, int)
        friend SOAP_FMAC1 eml22__DataObjectReference * SOAP_FMAC2 soap_instantiate_eml22__DataObjectReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1878 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset (-874)
/* complex XML schema type 'eml22:ExternalDataset': */
class SOAP_CMAC eml22__ExternalDataset {
      public:
        /// Required element 'eml22:ExternalFileProxy' of XML schema type 'eml22:ExternalDatasetPart'
        std::vector<eml22__ExternalDatasetPart *> ExternalFileProxy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ExternalDataset, default initialized and not managed by a soap context
        virtual eml22__ExternalDataset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ExternalDataset); }
      public:
        /// Constructor with default initializations
        eml22__ExternalDataset() : ExternalFileProxy(), soap() { }
        virtual ~eml22__ExternalDataset() { }
        /// Friend allocator used by soap_new_eml22__ExternalDataset(struct soap*, int)
        friend SOAP_FMAC1 eml22__ExternalDataset * SOAP_FMAC2 soap_instantiate_eml22__ExternalDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1880 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart (-875)
/* complex XML schema type 'eml22:ExternalDatasetPart': */
class SOAP_CMAC eml22__ExternalDatasetPart {
      public:
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
        /// Required element 'eml22:PathInExternalFile' of XML schema type 'eml22:String2000'
        std::string PathInExternalFile;
        /// Required element 'eml22:StartIndex' of XML schema type 'eml22:NonNegativeLong'
        LONG64 StartIndex;
        /// Required element 'eml22:EpcExternalPartReference' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *EpcExternalPartReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ExternalDatasetPart, default initialized and not managed by a soap context
        virtual eml22__ExternalDatasetPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ExternalDatasetPart); }
      public:
        /// Constructor with default initializations
        eml22__ExternalDatasetPart() : Count(), PathInExternalFile(), StartIndex(), EpcExternalPartReference(), soap() { }
        virtual ~eml22__ExternalDatasetPart() { }
        /// Friend allocator used by soap_new_eml22__ExternalDatasetPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__ExternalDatasetPart * SOAP_FMAC2 soap_instantiate_eml22__ExternalDatasetPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1882 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter (-876)
/* complex XML schema type 'eml22:AbstractActivityParameter': */
class SOAP_CMAC eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:Title' of XML schema type 'eml22:String2000'
        std::string Title;
        /// Optional element 'eml22:Index' of XML schema type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'eml22:Selection' of XML schema type 'eml22:String2000'
        std::string *Selection;
        /// Optional element 'eml22:Key' of XML schema type 'eml22:AbstractParameterKey'
        std::vector<eml22__AbstractParameterKey *> Key;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractActivityParameter, default initialized and not managed by a soap context
        virtual eml22__AbstractActivityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractActivityParameter); }
      public:
        /// Constructor with default initializations
        eml22__AbstractActivityParameter() : Title(), Index(), Selection(), Key(), soap() { }
        virtual ~eml22__AbstractActivityParameter() { }
        /// Friend allocator used by soap_new_eml22__AbstractActivityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractActivityParameter * SOAP_FMAC2 soap_instantiate_eml22__AbstractActivityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1884 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey (-877)
/* complex XML schema type 'eml22:AbstractParameterKey': */
class SOAP_CMAC eml22__AbstractParameterKey {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractParameterKey, default initialized and not managed by a soap context
        virtual eml22__AbstractParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractParameterKey); }
      public:
        /// Constructor with default initializations
        eml22__AbstractParameterKey() : soap() { }
        virtual ~eml22__AbstractParameterKey() { }
        /// Friend allocator used by soap_new_eml22__AbstractParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractParameterKey * SOAP_FMAC2 soap_instantiate_eml22__AbstractParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1898 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate (-884)
/* complex XML schema type 'eml22:ParameterTemplate': */
class SOAP_CMAC eml22__ParameterTemplate {
      public:
        /// Optional element 'eml22:AllowedKind' of XML schema type 'eml22:ActivityParameterKind'
        std::vector<eml22__ActivityParameterKind> AllowedKind;
        /// Required element 'eml22:IsInput' of XML schema type 'xsd:boolean'
        bool IsInput;
        /// Optional element 'eml22:KeyConstraint' of XML schema type 'eml22:String2000'
        std::vector<std::string> KeyConstraint;
        /// Required element 'eml22:IsOutput' of XML schema type 'xsd:boolean'
        bool IsOutput;
        /// Required element 'eml22:Title' of XML schema type 'eml22:String2000'
        std::string Title;
        /// Optional element 'eml22:DataObjectContentType' of XML schema type 'eml22:String2000'
        std::string *DataObjectContentType;
        /// Required element 'eml22:MaxOccurs' of XML schema type 'xsd:long'
        LONG64 MaxOccurs;
        /// Required element 'eml22:MinOccurs' of XML schema type 'xsd:long'
        LONG64 MinOccurs;
        /// Optional element 'eml22:Constraint' of XML schema type 'eml22:String2000'
        std::string *Constraint;
        /// Optional element 'eml22:DefaultValue' of XML schema type 'eml22:AbstractActivityParameter'
        std::vector<eml22__AbstractActivityParameter *> DefaultValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ParameterTemplate, default initialized and not managed by a soap context
        virtual eml22__ParameterTemplate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ParameterTemplate); }
      public:
        /// Constructor with default initializations
        eml22__ParameterTemplate() : AllowedKind(), IsInput(), KeyConstraint(), IsOutput(), Title(), DataObjectContentType(), MaxOccurs(), MinOccurs(), Constraint(), DefaultValue(), soap() { }
        virtual ~eml22__ParameterTemplate() { }
        /// Friend allocator used by soap_new_eml22__ParameterTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml22__ParameterTemplate * SOAP_FMAC2 soap_instantiate_eml22__ParameterTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1908 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue (-889)
/* complex XML schema type 'eml22:AbstractPressureValue': */
class SOAP_CMAC eml22__AbstractPressureValue {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractPressureValue, default initialized and not managed by a soap context
        virtual eml22__AbstractPressureValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractPressureValue); }
      public:
        /// Constructor with default initializations
        eml22__AbstractPressureValue() : soap() { }
        virtual ~eml22__AbstractPressureValue() { }
        /// Friend allocator used by soap_new_eml22__AbstractPressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractPressureValue * SOAP_FMAC2 soap_instantiate_eml22__AbstractPressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:32303 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__union_AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2__eml22__union_AbstractTemperaturePressure (-1831)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml22__union_AbstractTemperaturePressure
{
};
#endif

/* eml2_2ForGsoap.h:1910 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure (-890)
/* Choice: */
class SOAP_CMAC eml22__AbstractTemperaturePressure {
      public:
        /// Union with union _eml22__union_AbstractTemperaturePressure variant selector __union_AbstractTemperaturePressure set to one of:
        int __union_AbstractTemperaturePressure;
        union _eml22__union_AbstractTemperaturePressure union_AbstractTemperaturePressure;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractTemperaturePressure, default initialized and not managed by a soap context
        virtual eml22__AbstractTemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractTemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml22__AbstractTemperaturePressure() : __union_AbstractTemperaturePressure(), soap() { }
        virtual ~eml22__AbstractTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml22__AbstractTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml22__AbstractTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1912 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue (-891)
/* complex XML schema type 'eml22:DensityValue': */
class SOAP_CMAC eml22__DensityValue {
      public:
        /// Required element 'eml22:Density' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *Density;
        /// Optional element 'eml22:MeasurementPressureTemperature' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DensityValue, default initialized and not managed by a soap context
        virtual eml22__DensityValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DensityValue); }
      public:
        /// Constructor with default initializations
        eml22__DensityValue() : Density(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml22__DensityValue() { }
        /// Friend allocator used by soap_new_eml22__DensityValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__DensityValue * SOAP_FMAC2 soap_instantiate_eml22__DensityValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1914 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue (-892)
/* complex XML schema type 'eml22:FlowRateValue': */
class SOAP_CMAC eml22__FlowRateValue {
      public:
        /// Required element 'eml22:FlowRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *FlowRate;
        /// Optional element 'eml22:MeasurementPressureTemperature' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FlowRateValue, default initialized and not managed by a soap context
        virtual eml22__FlowRateValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FlowRateValue); }
      public:
        /// Constructor with default initializations
        eml22__FlowRateValue() : FlowRate(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml22__FlowRateValue() { }
        /// Friend allocator used by soap_new_eml22__FlowRateValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__FlowRateValue * SOAP_FMAC2 soap_instantiate_eml22__FlowRateValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1918 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue (-894)
/* complex XML schema type 'eml22:PressureValue': */
class SOAP_CMAC eml22__PressureValue {
      public:
        /// Required element 'eml22:AbstractPressureValue' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *AbstractPressureValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureValue, default initialized and not managed by a soap context
        virtual eml22__PressureValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureValue); }
      public:
        /// Constructor with default initializations
        eml22__PressureValue() : AbstractPressureValue(), soap() { }
        virtual ~eml22__PressureValue() { }
        /// Friend allocator used by soap_new_eml22__PressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureValue * SOAP_FMAC2 soap_instantiate_eml22__PressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1928 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue (-899)
/* complex XML schema type 'eml22:VolumeValue': */
class SOAP_CMAC eml22__VolumeValue {
      public:
        /// Required element 'eml22:Volume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Volume;
        /// Optional element 'eml22:MeasurementPressureTemperature' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumeValue, default initialized and not managed by a soap context
        virtual eml22__VolumeValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumeValue); }
      public:
        /// Constructor with default initializations
        eml22__VolumeValue() : Volume(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml22__VolumeValue() { }
        /// Friend allocator used by soap_new_eml22__VolumeValue(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumeValue * SOAP_FMAC2 soap_instantiate_eml22__VolumeValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1930 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs (-900)
/* complex XML schema type 'eml22:AbstractGeodeticCrs': */
class SOAP_CMAC eml22__AbstractGeodeticCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractGeodeticCrs, default initialized and not managed by a soap context
        virtual eml22__AbstractGeodeticCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractGeodeticCrs); }
      public:
        /// Constructor with default initializations
        eml22__AbstractGeodeticCrs() : soap() { }
        virtual ~eml22__AbstractGeodeticCrs() { }
        /// Friend allocator used by soap_new_eml22__AbstractGeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractGeodeticCrs * SOAP_FMAC2 soap_instantiate_eml22__AbstractGeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1932 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs (-901)
/* complex XML schema type 'eml22:AbstractProjectedCrs': */
class SOAP_CMAC eml22__AbstractProjectedCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractProjectedCrs, default initialized and not managed by a soap context
        virtual eml22__AbstractProjectedCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractProjectedCrs); }
      public:
        /// Constructor with default initializations
        eml22__AbstractProjectedCrs() : soap() { }
        virtual ~eml22__AbstractProjectedCrs() { }
        /// Friend allocator used by soap_new_eml22__AbstractProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractProjectedCrs * SOAP_FMAC2 soap_instantiate_eml22__AbstractProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1934 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs (-902)
/* complex XML schema type 'eml22:AbstractVerticalCrs': */
class SOAP_CMAC eml22__AbstractVerticalCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractVerticalCrs, default initialized and not managed by a soap context
        virtual eml22__AbstractVerticalCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractVerticalCrs); }
      public:
        /// Constructor with default initializations
        eml22__AbstractVerticalCrs() : soap() { }
        virtual ~eml22__AbstractVerticalCrs() { }
        /// Friend allocator used by soap_new_eml22__AbstractVerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractVerticalCrs * SOAP_FMAC2 soap_instantiate_eml22__AbstractVerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1950 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes (-910)
/* complex XML schema type 'eml22:HorizontalAxes': */
class SOAP_CMAC eml22__HorizontalAxes {
      public:
        /// Required element 'eml22:Direction1' of XML schema type 'eml22:AxisDirectionKind'
        eml22__AxisDirectionKind Direction1;
        /// Required element 'eml22:Direction2' of XML schema type 'eml22:AxisDirectionKind'
        eml22__AxisDirectionKind Direction2;
        /// Required element 'eml22:Uom' of XML schema type 'eml22:LengthMeasureExt'
        eml22__LengthMeasureExt *Uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HorizontalAxes, default initialized and not managed by a soap context
        virtual eml22__HorizontalAxes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HorizontalAxes); }
      public:
        /// Constructor with default initializations
        eml22__HorizontalAxes() : Direction1(), Direction2(), Uom(), soap() { }
        virtual ~eml22__HorizontalAxes() { }
        /// Friend allocator used by soap_new_eml22__HorizontalAxes(struct soap*, int)
        friend SOAP_FMAC1 eml22__HorizontalAxes * SOAP_FMAC2 soap_instantiate_eml22__HorizontalAxes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1964 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem (-917)
/* complex XML schema type 'eml22:PublicLandSurveySystem': */
class SOAP_CMAC eml22__PublicLandSurveySystem {
      public:
        /// Optional element 'eml22:PrincipalMeridian' of XML schema type 'eml22:PrincipalMeridian'
        eml22__PrincipalMeridian *PrincipalMeridian;
        /// Optional element 'eml22:Range' of XML schema type 'xsd:int'
        int *Range;
        /// Optional element 'eml22:RangeDir' of XML schema type 'eml22:EastOrWest'
        eml22__EastOrWest *RangeDir;
        /// Optional element 'eml22:Township' of XML schema type 'xsd:int'
        int *Township;
        /// Optional element 'eml22:TownshipDir' of XML schema type 'eml22:NorthOrSouth'
        eml22__NorthOrSouth *TownshipDir;
        /// Optional element 'eml22:Section' of XML schema type 'eml22:SectionNumber'
        std::string *Section;
        /// Optional element 'eml22:QuarterSection' of XML schema type 'eml22:PublicLandSurveySystemQuarterSection'
        std::string *QuarterSection;
        /// Optional element 'eml22:QuarterTownship' of XML schema type 'eml22:PublicLandSurveySystemQuarterTownship'
        std::string *QuarterTownship;
        /// Optional element 'eml22:FootageEW' of XML schema type 'eml22:DistanceEastWest'
        eml22__DistanceEastWest *FootageEW;
        /// Optional element 'eml22:FootageNS' of XML schema type 'eml22:DistanceNorthSouth'
        eml22__DistanceNorthSouth *FootageNS;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PublicLandSurveySystem, default initialized and not managed by a soap context
        virtual eml22__PublicLandSurveySystem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PublicLandSurveySystem); }
      public:
        /// Constructor with default initializations
        eml22__PublicLandSurveySystem() : PrincipalMeridian(), Range(), RangeDir(), Township(), TownshipDir(), Section(), QuarterSection(), QuarterTownship(), FootageEW(), FootageNS(), soap() { }
        virtual ~eml22__PublicLandSurveySystem() { }
        /// Friend allocator used by soap_new_eml22__PublicLandSurveySystem(struct soap*, int)
        friend SOAP_FMAC1 eml22__PublicLandSurveySystem * SOAP_FMAC2 soap_instantiate_eml22__PublicLandSurveySystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1966 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Vector
#define SOAP_TYPE_gsoap_eml2_2_eml22__Vector (-918)
/* complex XML schema type 'eml22:Vector': */
class SOAP_CMAC eml22__Vector {
      public:
        /// Required element 'eml22:Component1' of XML schema type 'xsd:double'
        double Component1;
        /// Required element 'eml22:Component2' of XML schema type 'xsd:double'
        double Component2;
        /// Required element 'eml22:Component3' of XML schema type 'xsd:double'
        double Component3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__Vector
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__Vector, default initialized and not managed by a soap context
        virtual eml22__Vector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__Vector); }
      public:
        /// Constructor with default initializations
        eml22__Vector() : Component1(), Component2(), Component3(), soap() { }
        virtual ~eml22__Vector() { }
        /// Friend allocator used by soap_new_eml22__Vector(struct soap*, int)
        friend SOAP_FMAC1 eml22__Vector * SOAP_FMAC2 soap_instantiate_eml22__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1968 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis (-919)
/* complex XML schema type 'eml22:VerticalAxis': */
class SOAP_CMAC eml22__VerticalAxis {
      public:
        /// Required element 'eml22:Direction' of XML schema type 'eml22:VerticalDirection'
        eml22__VerticalDirection Direction;
        /// Required element 'eml22:Uom' of XML schema type 'eml22:LengthAndTimeUomExt'
        std::string Uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalAxis, default initialized and not managed by a soap context
        virtual eml22__VerticalAxis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalAxis); }
      public:
        /// Constructor with default initializations
        eml22__VerticalAxis() : Direction(), Uom(), soap() { }
        virtual ~eml22__VerticalAxis() { }
        /// Friend allocator used by soap_new_eml22__VerticalAxis(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalAxis * SOAP_FMAC2 soap_instantiate_eml22__VerticalAxis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1982 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule
#define SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule (-926)
/* complex XML schema type 'eml22:FailingRule': */
class SOAP_CMAC eml22__FailingRule {
      public:
        /// Required element 'eml22:RuleId' of XML schema type 'eml22:String64'
        std::string RuleId;
        /// Optional element 'eml22:RuleName' of XML schema type 'eml22:String2000'
        std::string *RuleName;
        /// Optional element 'eml22:Severity' of XML schema type 'eml22:String64'
        std::string *Severity;
        /// Optional element 'eml22:FailingRuleExtensions' of XML schema type 'eml22:ExtensionNameValue'
        std::vector<eml22__ExtensionNameValue *> FailingRuleExtensions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FailingRule, default initialized and not managed by a soap context
        virtual eml22__FailingRule *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FailingRule); }
      public:
        /// Constructor with default initializations
        eml22__FailingRule() : RuleId(), RuleName(), Severity(), FailingRuleExtensions(), soap() { }
        virtual ~eml22__FailingRule() { }
        /// Friend allocator used by soap_new_eml22__FailingRule(struct soap*, int)
        friend SOAP_FMAC1 eml22__FailingRule * SOAP_FMAC2 soap_instantiate_eml22__FailingRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1984 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange
#define SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange (-927)
/* complex XML schema type 'eml22:IndexRange': */
class SOAP_CMAC eml22__IndexRange {
      public:
        /// Required element 'eml22:IndexMinimum' of XML schema type 'eml22:String64'
        std::string IndexMinimum;
        /// Required element 'eml22:IndexMaximum' of XML schema type 'eml22:String64'
        std::string IndexMaximum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IndexRange, default initialized and not managed by a soap context
        virtual eml22__IndexRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IndexRange); }
      public:
        /// Constructor with default initializations
        eml22__IndexRange() : IndexMinimum(), IndexMaximum(), soap() { }
        virtual ~eml22__IndexRange() { }
        /// Friend allocator used by soap_new_eml22__IndexRange(struct soap*, int)
        friend SOAP_FMAC1 eml22__IndexRange * SOAP_FMAC2 soap_instantiate_eml22__IndexRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1986 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation (-928)
/* complex XML schema type 'eml22:AbstractGraphicalInformation': */
class SOAP_CMAC eml22__AbstractGraphicalInformation {
      public:
        /// Required element 'eml22:TargetObject' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TargetObject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractGraphicalInformation, default initialized and not managed by a soap context
        virtual eml22__AbstractGraphicalInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractGraphicalInformation); }
      public:
        /// Constructor with default initializations
        eml22__AbstractGraphicalInformation() : TargetObject(), soap() { }
        virtual ~eml22__AbstractGraphicalInformation() { }
        /// Friend allocator used by soap_new_eml22__AbstractGraphicalInformation(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractGraphicalInformation * SOAP_FMAC2 soap_instantiate_eml22__AbstractGraphicalInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:164 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel (-17)
/* complex XML schema type 'prodml21:AbstractCompositionalModel': */
class SOAP_CMAC prodml21__AbstractCompositionalModel : public prodml21__AbstractPvtModel {
      public:
        /// Optional element 'prodml21:MixingRule' of XML schema type 'prodml21:MixingRule'
        prodml21__MixingRule *MixingRule;
        /// Optional element 'prodml21:BinaryInteractionCoefficientSet' of XML schema type 'prodml21:BinaryInteractionCoefficientSet'
        prodml21__BinaryInteractionCoefficientSet *BinaryInteractionCoefficientSet;
        /// Optional element 'prodml21:ComponentPropertySet' of XML schema type 'prodml21:ComponentPropertySet'
        prodml21__ComponentPropertySet *ComponentPropertySet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCompositionalModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCompositionalModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCompositionalModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCompositionalModel() : MixingRule(), BinaryInteractionCoefficientSet(), ComponentPropertySet() { }
        virtual ~prodml21__AbstractCompositionalModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCompositionalModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCompositionalModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCompositionalModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:166 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel (-18)
/* complex XML schema type 'prodml21:AbstractCorrelationModel': */
class SOAP_CMAC prodml21__AbstractCorrelationModel : public prodml21__AbstractPvtModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationModel() { }
        virtual ~prodml21__AbstractCorrelationModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:226 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization (-48)
/* complex XML schema type 'prodml21:FluidCharacterization': */
class SOAP_CMAC prodml21__FluidCharacterization : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:ApplicationSource' of XML schema type 'prodml21:ApplicationInfo'
        prodml21__ApplicationInfo *ApplicationSource;
        /// Optional element 'prodml21:ApplicationTarget' of XML schema type 'prodml21:ApplicationInfo'
        std::vector<prodml21__ApplicationInfo *> ApplicationTarget;
        /// Optional element 'prodml21:FluidCharacterizationType' of XML schema type 'eml22:String64'
        std::string *FluidCharacterizationType;
        /// Optional element 'prodml21:IntendedUsage' of XML schema type 'eml22:String64'
        std::string *IntendedUsage;
        /// Optional element 'prodml21:RockFluidUnitFeature' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *RockFluidUnitFeature;
        /// Optional element 'prodml21:StandardConditions' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *StandardConditions;
        /// Optional element 'prodml21:FluidCharacterizationSource' of XML schema type 'prodml21:FluidCharacterizationSource'
        std::vector<prodml21__FluidCharacterizationSource *> FluidCharacterizationSource;
        /// Optional element 'prodml21:FluidComponentCatalog' of XML schema type 'prodml21:FluidComponentCatalog'
        prodml21__FluidComponentCatalog *FluidComponentCatalog;
        /// Optional element 'prodml21:FluidCharacterizationModel' of XML schema type 'prodml21:FluidCharacterizationModel'
        std::vector<prodml21__FluidCharacterizationModel *> FluidCharacterizationModel;
        /// Optional element 'prodml21:FluidCharacterizationTableFormat' of XML schema type 'prodml21:FluidCharacterizationTableFormat'
        std::vector<prodml21__FluidCharacterizationTableFormat *> FluidCharacterizationTableFormat;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidSystem' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSystem;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterization, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterization *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterization); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterization() : ApplicationSource(), ApplicationTarget(), FluidCharacterizationType(), IntendedUsage(), RockFluidUnitFeature(), StandardConditions(), FluidCharacterizationSource(), FluidComponentCatalog(), FluidCharacterizationModel(), FluidCharacterizationTableFormat(), Remark(), FluidSystem() { }
        virtual ~prodml21__FluidCharacterization() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterization(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterization * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:308 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater (-89)
/* complex XML schema type 'prodml21:FormationWater': */
class SOAP_CMAC prodml21__FormationWater : public prodml21__AbstractFluidComponent {
      public:
        /// Optional element 'prodml21:SpecificGravity' of XML schema type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml21:Salinity' of XML schema type 'eml22:MassPerMassMeasure'
        eml22__MassPerMassMeasure *Salinity;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FormationWater, default initialized and not managed by a soap context
        virtual prodml21__FormationWater *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FormationWater); }
      public:
        /// Constructor with default initializations
        prodml21__FormationWater() : SpecificGravity(), Salinity(), Remark() { }
        virtual ~prodml21__FormationWater() { }
        /// Friend allocator used by soap_new_prodml21__FormationWater(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FormationWater * SOAP_FMAC2 soap_instantiate_prodml21__FormationWater(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:314 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure (-92)
/* complex XML schema type 'prodml21:GeneralQualifiedMeasure': */
class SOAP_CMAC prodml21__GeneralQualifiedMeasure : public prodml21__AbstractMeasureData {
      public:
        /// Optional attribute 'status' of XML schema type 'prodml21:ValueStatus'
        prodml21__ValueStatus *status;
        /// Optional attribute 'componentReference' of XML schema type 'eml22:String64'
        std::string *componentReference;
        /// Required attribute 'uom' of XML schema type 'eml22:UomEnum'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__GeneralQualifiedMeasure, default initialized and not managed by a soap context
        virtual prodml21__GeneralQualifiedMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__GeneralQualifiedMeasure); }
      public:
        /// Constructor with default initializations
        prodml21__GeneralQualifiedMeasure() : status(), componentReference(), uom() { }
        virtual ~prodml21__GeneralQualifiedMeasure() { }
        /// Friend allocator used by soap_new_prodml21__GeneralQualifiedMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__GeneralQualifiedMeasure * SOAP_FMAC2 soap_instantiate_prodml21__GeneralQualifiedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:320 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount (-95)
/* complex XML schema type 'prodml21:IntegerQualifiedCount': */
class SOAP_CMAC prodml21__IntegerQualifiedCount : public prodml21__AbstractMeasureData {
      public:
        /// Optional attribute 'status' of XML schema type 'prodml21:ValueStatus'
        prodml21__ValueStatus *status;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__IntegerQualifiedCount, default initialized and not managed by a soap context
        virtual prodml21__IntegerQualifiedCount *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__IntegerQualifiedCount); }
      public:
        /// Constructor with default initializations
        prodml21__IntegerQualifiedCount() : status() { }
        virtual ~prodml21__IntegerQualifiedCount() { }
        /// Friend allocator used by soap_new_prodml21__IntegerQualifiedCount(struct soap*, int)
        friend SOAP_FMAC1 prodml21__IntegerQualifiedCount * SOAP_FMAC2 soap_instantiate_prodml21__IntegerQualifiedCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:324 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString (-97)
/* complex XML schema type 'prodml21:KindQualifiedString': */
class SOAP_CMAC prodml21__KindQualifiedString : public prodml21__AbstractMeasureData {
      public:
        /// Optional attribute 'status' of XML schema type 'prodml21:ValueStatus'
        prodml21__ValueStatus *status;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__KindQualifiedString, default initialized and not managed by a soap context
        virtual prodml21__KindQualifiedString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__KindQualifiedString); }
      public:
        /// Constructor with default initializations
        prodml21__KindQualifiedString() : status() { }
        virtual ~prodml21__KindQualifiedString() { }
        /// Friend allocator used by soap_new_prodml21__KindQualifiedString(struct soap*, int)
        friend SOAP_FMAC1 prodml21__KindQualifiedString * SOAP_FMAC2 soap_instantiate_prodml21__KindQualifiedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:334 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas (-102)
/* complex XML schema type 'prodml21:NaturalGas': */
class SOAP_CMAC prodml21__NaturalGas : public prodml21__AbstractFluidComponent {
      public:
        /// Optional element 'prodml21:GasGravity' of XML schema type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml21:GrossEnergyContentPerUnitMass' of XML schema type 'eml22:EnergyPerMassMeasure'
        eml22__EnergyPerMassMeasure *GrossEnergyContentPerUnitMass;
        /// Optional element 'prodml21:NetEnergyContentPerUnitMass' of XML schema type 'eml22:EnergyPerMassMeasure'
        eml22__EnergyPerMassMeasure *NetEnergyContentPerUnitMass;
        /// Optional element 'prodml21:GrossEnergyContentPerUnitVolume' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *GrossEnergyContentPerUnitVolume;
        /// Optional element 'prodml21:NetEnergyContentPerUnitVolume' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *NetEnergyContentPerUnitVolume;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NaturalGas, default initialized and not managed by a soap context
        virtual prodml21__NaturalGas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NaturalGas); }
      public:
        /// Constructor with default initializations
        prodml21__NaturalGas() : GasGravity(), MolecularWeight(), GrossEnergyContentPerUnitMass(), NetEnergyContentPerUnitMass(), GrossEnergyContentPerUnitVolume(), NetEnergyContentPerUnitVolume(), Remark() { }
        virtual ~prodml21__NaturalGas() { }
        /// Friend allocator used by soap_new_prodml21__NaturalGas(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NaturalGas * SOAP_FMAC2 soap_instantiate_prodml21__NaturalGas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:346 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent (-108)
/* complex XML schema type 'prodml21:PlusFluidComponent': */
class SOAP_CMAC prodml21__PlusFluidComponent : public prodml21__AbstractFluidComponent {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:PlusComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml21:SpecificGravity' of XML schema type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml21:StartingCarbonNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *StartingCarbonNumber;
        /// Optional element 'prodml21:StartingBoilingPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StartingBoilingPoint;
        /// Optional element 'prodml21:AvgDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *AvgDensity;
        /// Optional element 'prodml21:AvgMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *AvgMolecularWeight;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PlusFluidComponent, default initialized and not managed by a soap context
        virtual prodml21__PlusFluidComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PlusFluidComponent); }
      public:
        /// Constructor with default initializations
        prodml21__PlusFluidComponent() : Kind(), SpecificGravity(), StartingCarbonNumber(), StartingBoilingPoint(), AvgDensity(), AvgMolecularWeight(), Remark() { }
        virtual ~prodml21__PlusFluidComponent() { }
        /// Friend allocator used by soap_new_prodml21__PlusFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PlusFluidComponent * SOAP_FMAC2 soap_instantiate_prodml21__PlusFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:356 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent (-113)
/* complex XML schema type 'prodml21:PseudoFluidComponent': */
class SOAP_CMAC prodml21__PseudoFluidComponent : public prodml21__AbstractFluidComponent {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:PseudoComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml21:SpecificGravity' of XML schema type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml21:StartingCarbonNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *StartingCarbonNumber;
        /// Optional element 'prodml21:EndingCarbonNumber' of XML schema type 'eml22:NonNegativeLong'
        LONG64 *EndingCarbonNumber;
        /// Optional element 'prodml21:AvgMolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *AvgMolecularWeight;
        /// Optional element 'prodml21:AvgDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *AvgDensity;
        /// Optional element 'prodml21:StartingBoilingPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *StartingBoilingPoint;
        /// Optional element 'prodml21:EndingBoilingPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *EndingBoilingPoint;
        /// Optional element 'prodml21:AvgBoilingPoint' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *AvgBoilingPoint;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PseudoFluidComponent, default initialized and not managed by a soap context
        virtual prodml21__PseudoFluidComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PseudoFluidComponent); }
      public:
        /// Constructor with default initializations
        prodml21__PseudoFluidComponent() : Kind(), SpecificGravity(), StartingCarbonNumber(), EndingCarbonNumber(), AvgMolecularWeight(), AvgDensity(), StartingBoilingPoint(), EndingBoilingPoint(), AvgBoilingPoint(), Remark() { }
        virtual ~prodml21__PseudoFluidComponent() { }
        /// Friend allocator used by soap_new_prodml21__PseudoFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PseudoFluidComponent * SOAP_FMAC2 soap_instantiate_prodml21__PseudoFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:358 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent (-114)
/* complex XML schema type 'prodml21:PureFluidComponent': */
class SOAP_CMAC prodml21__PureFluidComponent : public prodml21__AbstractFluidComponent {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:PureComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Required element 'prodml21:HydrocarbonFlag' of XML schema type 'xsd:boolean'
        bool HydrocarbonFlag;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PureFluidComponent, default initialized and not managed by a soap context
        virtual prodml21__PureFluidComponent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PureFluidComponent); }
      public:
        /// Constructor with default initializations
        prodml21__PureFluidComponent() : Kind(), MolecularWeight(), HydrocarbonFlag(), Remark() { }
        virtual ~prodml21__PureFluidComponent() { }
        /// Friend allocator used by soap_new_prodml21__PureFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PureFluidComponent * SOAP_FMAC2 soap_instantiate_prodml21__PureFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:360 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate (-115)
/* complex XML schema type 'prodml21:StartEndDate': */
class SOAP_CMAC prodml21__StartEndDate : public prodml21__AbstractDateTimeClass {
      public:
        /// Optional element 'prodml21:DateStart' of XML schema type 'xsd:date'
        std::string *DateStart;
        /// Optional element 'prodml21:DateEnd' of XML schema type 'xsd:date'
        std::string *DateEnd;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StartEndDate, default initialized and not managed by a soap context
        virtual prodml21__StartEndDate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StartEndDate); }
      public:
        /// Constructor with default initializations
        prodml21__StartEndDate() : DateStart(), DateEnd() { }
        virtual ~prodml21__StartEndDate() { }
        /// Friend allocator used by soap_new_prodml21__StartEndDate(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StartEndDate * SOAP_FMAC2 soap_instantiate_prodml21__StartEndDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:362 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime (-116)
/* complex XML schema type 'prodml21:StartEndTime': */
class SOAP_CMAC prodml21__StartEndTime : public prodml21__AbstractDateTimeClass {
      public:
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StartEndTime, default initialized and not managed by a soap context
        virtual prodml21__StartEndTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StartEndTime); }
      public:
        /// Constructor with default initializations
        prodml21__StartEndTime() : DTimStart(), DTimEnd() { }
        virtual ~prodml21__StartEndTime() { }
        /// Friend allocator used by soap_new_prodml21__StartEndTime(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StartEndTime * SOAP_FMAC2 soap_instantiate_prodml21__StartEndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:364 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil (-117)
/* complex XML schema type 'prodml21:StockTankOil': */
class SOAP_CMAC prodml21__StockTankOil : public prodml21__AbstractFluidComponent {
      public:
        /// Optional element 'prodml21:APIGravity' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *APIGravity;
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml21:GrossEnergyContentPerUnitMass' of XML schema type 'eml22:EnergyPerMassMeasure'
        eml22__EnergyPerMassMeasure *GrossEnergyContentPerUnitMass;
        /// Optional element 'prodml21:NetEnergyContentPerUnitMass' of XML schema type 'eml22:EnergyPerMassMeasure'
        eml22__EnergyPerMassMeasure *NetEnergyContentPerUnitMass;
        /// Optional element 'prodml21:GrossEnergyContentPerUnitVolume' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *GrossEnergyContentPerUnitVolume;
        /// Optional element 'prodml21:NetEnergyContentPerUnitVolume' of XML schema type 'eml22:EnergyPerVolumeMeasure'
        eml22__EnergyPerVolumeMeasure *NetEnergyContentPerUnitVolume;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StockTankOil, default initialized and not managed by a soap context
        virtual prodml21__StockTankOil *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StockTankOil); }
      public:
        /// Constructor with default initializations
        prodml21__StockTankOil() : APIGravity(), MolecularWeight(), GrossEnergyContentPerUnitMass(), NetEnergyContentPerUnitMass(), GrossEnergyContentPerUnitVolume(), NetEnergyContentPerUnitVolume(), Remark() { }
        virtual ~prodml21__StockTankOil() { }
        /// Friend allocator used by soap_new_prodml21__StockTankOil(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StockTankOil * SOAP_FMAC2 soap_instantiate_prodml21__StockTankOil(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData (-126)
/* complex XML schema type 'prodml21:CurveData': */
class SOAP_CMAC prodml21__CurveData : public prodml21__AbstractMeasureData {
      public:
        /// Required element 'prodml21:Index' of XML schema type 'eml22:PositiveLong'
        std::vector<LONG64> Index;
        /// Required element 'prodml21:Value' of XML schema type 'xsd:double'
        std::vector<double> Value;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CurveData, default initialized and not managed by a soap context
        virtual prodml21__CurveData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CurveData); }
      public:
        /// Constructor with default initializations
        prodml21__CurveData() : Index(), Value(), uid() { }
        virtual ~prodml21__CurveData() { }
        /// Friend allocator used by soap_new_prodml21__CurveData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CurveData * SOAP_FMAC2 soap_instantiate_prodml21__CurveData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:386 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent (-128)
/* Type prodml21__FacilityParent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'prodml21:FacilityParent': */
class SOAP_CMAC prodml21__FacilityParent : public prodml21__AbstractRelatedFacilityObject {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Name;
        /// Optional element 'prodml21:FacilityParent1' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent1;
        /// Optional element 'prodml21:FacilityParent2' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *FacilityParent2;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FacilityParent, default initialized and not managed by a soap context
        virtual prodml21__FacilityParent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FacilityParent); }
      public:
        /// Constructor with default initializations
        prodml21__FacilityParent() : Name(), FacilityParent1(), FacilityParent2() { }
        virtual ~prodml21__FacilityParent() { }
        /// Friend allocator used by soap_new_prodml21__FacilityParent(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FacilityParent * SOAP_FMAC2 soap_instantiate_prodml21__FacilityParent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:388 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort (-129)
/* complex XML schema type 'prodml21:FacilityUnitPort': */
class SOAP_CMAC prodml21__FacilityUnitPort : public prodml21__AbstractRelatedFacilityObject {
      public:
        /// Required element 'prodml21:PortReference' of XML schema type 'eml22:String64'
        std::string PortReference;
        /// Required element 'prodml21:UnitReference' of XML schema type 'eml22:String64'
        std::string UnitReference;
        /// Optional element 'prodml21:NetworkReference' of XML schema type 'eml22:String64'
        std::string *NetworkReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FacilityUnitPort, default initialized and not managed by a soap context
        virtual prodml21__FacilityUnitPort *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FacilityUnitPort); }
      public:
        /// Constructor with default initializations
        prodml21__FacilityUnitPort() : PortReference(), UnitReference(), NetworkReference() { }
        virtual ~prodml21__FacilityUnitPort() { }
        /// Friend allocator used by soap_new_prodml21__FacilityUnitPort(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FacilityUnitPort * SOAP_FMAC2 soap_instantiate_prodml21__FacilityUnitPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:390 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData (-130)
/* complex XML schema type 'prodml21:IntegerData': */
class SOAP_CMAC prodml21__IntegerData : public prodml21__AbstractMeasureData {
      public:
        /// Required element 'prodml21:IntegerValue' of XML schema type 'prodml21:IntegerQualifiedCount'
        prodml21__IntegerQualifiedCount *IntegerValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__IntegerData, default initialized and not managed by a soap context
        virtual prodml21__IntegerData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__IntegerData); }
      public:
        /// Constructor with default initializations
        prodml21__IntegerData() : IntegerValue() { }
        virtual ~prodml21__IntegerData() { }
        /// Friend allocator used by soap_new_prodml21__IntegerData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__IntegerData * SOAP_FMAC2 soap_instantiate_prodml21__IntegerData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:394 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility (-132)
/* complex XML schema type 'prodml21:Parentfacility': */
class SOAP_CMAC prodml21__Parentfacility : public prodml21__AbstractRefProductFlow {
      public:
        /// Required element 'prodml21:ParentfacilityReference' of XML schema type 'eml22:String64'
        std::string ParentfacilityReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Parentfacility, default initialized and not managed by a soap context
        virtual prodml21__Parentfacility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Parentfacility); }
      public:
        /// Constructor with default initializations
        prodml21__Parentfacility() : ParentfacilityReference() { }
        virtual ~prodml21__Parentfacility() { }
        /// Friend allocator used by soap_new_prodml21__Parentfacility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Parentfacility * SOAP_FMAC2 soap_instantiate_prodml21__Parentfacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:396 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume (-133)
/* complex XML schema type 'prodml21:ProductVolume': */
class SOAP_CMAC prodml21__ProductVolume : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:Installation' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml21:ContextFacility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        std::vector<prodml21__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml21:Kind' of XML schema type 'eml22:String64'
        std::string *Kind;
        /// Optional element 'prodml21:PeriodKind' of XML schema type 'prodml21:ReportingDurationKind'
        prodml21__ReportingDurationKind *PeriodKind;
        /// Optional element 'prodml21:DTimMin' of XML schema type 'prodml21:EndpointQualifiedDateTime'
        prodml21__EndpointQualifiedDateTime *DTimMin;
        /// Optional element 'prodml21:DTimMax' of XML schema type 'prodml21:EndpointQualifiedDateTime'
        prodml21__EndpointQualifiedDateTime *DTimMax;
        /// Optional element 'prodml21:DTimCurrent' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimCurrent;
        /// Optional element 'prodml21:CalculationMethod' of XML schema type 'prodml21:CalculationMethod'
        prodml21__CalculationMethod *CalculationMethod;
        /// Optional element 'prodml21:Operator' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *Operator;
        /// Optional element 'prodml21:Title' of XML schema type 'prodml21:NameStruct'
        prodml21__NameStruct *Title;
        /// Optional element 'prodml21:GeographicContext' of XML schema type 'prodml21:GeographicContext'
        prodml21__GeographicContext *GeographicContext;
        /// Optional element 'prodml21:IssueDate' of XML schema type 'xsd:date'
        std::string *IssueDate;
        /// Optional element 'prodml21:IssuedBy' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *IssuedBy;
        /// Optional element 'prodml21:ApprovalDate' of XML schema type 'xsd:date'
        std::string *ApprovalDate;
        /// Optional element 'prodml21:Approver' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *Approver;
        /// Optional element 'prodml21:StandardTempPres' of XML schema type 'eml22:ReferenceCondition'
        eml22__ReferenceCondition *StandardTempPres;
        /// Required element 'prodml21:Facility' of XML schema type 'prodml21:ProductVolumeFacility'
        std::vector<prodml21__ProductVolumeFacility *> Facility;
        /// Optional element 'prodml21:BusinessUnit' of XML schema type 'prodml21:ProductVolumeBusinessUnit'
        std::vector<prodml21__ProductVolumeBusinessUnit *> BusinessUnit;
        /// Optional element 'prodml21:ProductFlowModel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ProductFlowModel;
        /// Optional element 'prodml21:DateTime' of XML schema type 'prodml21:AbstractDateTimeClass'
        prodml21__AbstractDateTimeClass *DateTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductVolume, default initialized and not managed by a soap context
        virtual prodml21__ProductVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductVolume); }
      public:
        /// Constructor with default initializations
        prodml21__ProductVolume() : Installation(), ContextFacility(), Kind(), PeriodKind(), DTimMin(), DTimMax(), DTimCurrent(), CalculationMethod(), Operator(), Title(), GeographicContext(), IssueDate(), IssuedBy(), ApprovalDate(), Approver(), StandardTempPres(), Facility(), BusinessUnit(), ProductFlowModel(), DateTime() { }
        virtual ~prodml21__ProductVolume() { }
        /// Friend allocator used by soap_new_prodml21__ProductVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductVolume * SOAP_FMAC2 soap_instantiate_prodml21__ProductVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:430 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow (-150)
/* complex XML schema type 'prodml21:ReferenceFlow': */
class SOAP_CMAC prodml21__ReferenceFlow : public prodml21__AbstractRefProductFlow {
      public:
        /// Required element 'prodml21:FlowReference' of XML schema type 'eml22:String64'
        std::string FlowReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReferenceFlow, default initialized and not managed by a soap context
        virtual prodml21__ReferenceFlow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReferenceFlow); }
      public:
        /// Constructor with default initializations
        prodml21__ReferenceFlow() : FlowReference() { }
        virtual ~prodml21__ReferenceFlow() { }
        /// Friend allocator used by soap_new_prodml21__ReferenceFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReferenceFlow * SOAP_FMAC2 soap_instantiate_prodml21__ReferenceFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:432 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StringData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StringData (-151)
/* complex XML schema type 'prodml21:StringData': */
class SOAP_CMAC prodml21__StringData : public prodml21__AbstractMeasureData {
      public:
        /// Required element 'prodml21:StringValue' of XML schema type 'prodml21:KindQualifiedString'
        prodml21__KindQualifiedString *StringValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StringData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StringData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StringData, default initialized and not managed by a soap context
        virtual prodml21__StringData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StringData); }
      public:
        /// Constructor with default initializations
        prodml21__StringData() : StringValue() { }
        virtual ~prodml21__StringData() { }
        /// Friend allocator used by soap_new_prodml21__StringData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StringData * SOAP_FMAC2 soap_instantiate_prodml21__StringData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:444 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel (-157)
/* complex XML schema type 'prodml21:ProductFlowModel': */
class SOAP_CMAC prodml21__ProductFlowModel : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:Installation' of XML schema type 'prodml21:FacilityIdentifierStruct'
        prodml21__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml21:ContextFacility' of XML schema type 'prodml21:FacilityIdentifierStruct'
        std::vector<prodml21__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:ExistenceTime' of XML schema type 'prodml21:EndpointQualifiedDateTime'
        prodml21__EndpointQualifiedDateTime *ExistenceTime;
        /// Optional element 'prodml21:DTimMin' of XML schema type 'prodml21:EndpointQualifiedDateTime'
        prodml21__EndpointQualifiedDateTime *DTimMin;
        /// Optional element 'prodml21:DTimMax' of XML schema type 'prodml21:EndpointQualifiedDateTime'
        prodml21__EndpointQualifiedDateTime *DTimMax;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Required element 'prodml21:Network' of XML schema type 'prodml21:ProductFlowNetwork'
        std::vector<prodml21__ProductFlowNetwork *> Network;
        /// Optional element 'prodml21:ExternalConnect' of XML schema type 'prodml21:ProductFlowExternalReference'
        std::vector<prodml21__ProductFlowExternalReference *> ExternalConnect;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowModel, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowModel); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowModel() : Installation(), ContextFacility(), DTimStart(), DTimEnd(), ExistenceTime(), DTimMin(), DTimMax(), Comment(), Network(), ExternalConnect() { }
        virtual ~prodml21__ProductFlowModel() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowModel * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:450 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected (-160)
/* complex XML schema type 'prodml21:ProductFlowQualifierExpected': */
class SOAP_CMAC prodml21__ProductFlowQualifierExpected : public prodml21__ExpectedFlowQualifier {
      public:
        /// Required element 'prodml21:Flow' of XML schema type 'prodml21:ReportingFlow'
        prodml21__ReportingFlow Flow;
        /// Optional element 'prodml21:Product' of XML schema type 'prodml21:ReportingProduct'
        prodml21__ReportingProduct *Product;
        /// Optional element 'prodml21:Qualifier' of XML schema type 'prodml21:FlowQualifier'
        std::vector<prodml21__FlowQualifier> Qualifier;
        /// Required attribute 'uid' of XML schema type 'eml22:String64'
        std::string uid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFlowQualifierExpected, default initialized and not managed by a soap context
        virtual prodml21__ProductFlowQualifierExpected *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFlowQualifierExpected); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFlowQualifierExpected() : Flow(), Product(), Qualifier(), uid() { }
        virtual ~prodml21__ProductFlowQualifierExpected() { }
        /// Friend allocator used by soap_new_prodml21__ProductFlowQualifierExpected(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFlowQualifierExpected * SOAP_FMAC2 soap_instantiate_prodml21__ProductFlowQualifierExpected(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:454 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier (-162)
/* complex XML schema type 'prodml21:Qualifier': */
class SOAP_CMAC prodml21__Qualifier : public prodml21__ExpectedFlowQualifier {
      public:
        /// Optional element 'prodml21:Qualifier' of XML schema type 'prodml21:FlowQualifier'
        std::vector<prodml21__FlowQualifier> Qualifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Qualifier, default initialized and not managed by a soap context
        virtual prodml21__Qualifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Qualifier); }
      public:
        /// Constructor with default initializations
        prodml21__Qualifier() : Qualifier() { }
        virtual ~prodml21__Qualifier() { }
        /// Friend allocator used by soap_new_prodml21__Qualifier(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Qualifier * SOAP_FMAC2 soap_instantiate_prodml21__Qualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:458 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem (-164)
/* complex XML schema type 'prodml21:FluidSystem': */
class SOAP_CMAC prodml21__FluidSystem : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:StandardConditions' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *StandardConditions;
        /// Required element 'prodml21:ReservoirFluidKind' of XML schema type 'prodml21:ReservoirFluidKind'
        prodml21__ReservoirFluidKind ReservoirFluidKind;
        /// Optional element 'prodml21:PhasesPresent' of XML schema type 'prodml21:PhasePresent'
        prodml21__PhasePresent *PhasesPresent;
        /// Optional element 'prodml21:ReservoirLifeCycleState' of XML schema type 'prodml21:ReservoirLifeCycleState'
        prodml21__ReservoirLifeCycleState *ReservoirLifeCycleState;
        /// Optional element 'prodml21:RockFluidUnitFeature' of XML schema type 'eml22:DataObjectReference'
        std::vector<eml22__DataObjectReference *> RockFluidUnitFeature;
        /// Optional element 'prodml21:SaturationPressure' of XML schema type 'prodml21:SaturationPressure'
        prodml21__SaturationPressure *SaturationPressure;
        /// Required element 'prodml21:SolutionGOR' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGOR;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:StockTankOil' of XML schema type 'prodml21:StockTankOil'
        prodml21__StockTankOil *StockTankOil;
        /// Optional element 'prodml21:NaturalGas' of XML schema type 'prodml21:NaturalGas'
        prodml21__NaturalGas *NaturalGas;
        /// Optional element 'prodml21:FormationWater' of XML schema type 'prodml21:FormationWater'
        prodml21__FormationWater *FormationWater;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSystem, default initialized and not managed by a soap context
        virtual prodml21__FluidSystem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSystem); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSystem() : StandardConditions(), ReservoirFluidKind(), PhasesPresent(), ReservoirLifeCycleState(), RockFluidUnitFeature(), SaturationPressure(), SolutionGOR(), Remark(), StockTankOil(), NaturalGas(), FormationWater() { }
        virtual ~prodml21__FluidSystem() { }
        /// Friend allocator used by soap_new_prodml21__FluidSystem(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSystem * SOAP_FMAC2 soap_instantiate_prodml21__FluidSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:474 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd (-172)
/* complex XML schema type 'prodml21:CumulativeGasProducedRatioStd': */
class SOAP_CMAC prodml21__CumulativeGasProducedRatioStd : public prodml21__AbstractGasProducedRatioVolume {
      public:
        /// Required element 'prodml21:CumulativeGasProducedRatioStd' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *CumulativeGasProducedRatioStd;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CumulativeGasProducedRatioStd, default initialized and not managed by a soap context
        virtual prodml21__CumulativeGasProducedRatioStd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CumulativeGasProducedRatioStd); }
      public:
        /// Constructor with default initializations
        prodml21__CumulativeGasProducedRatioStd() : CumulativeGasProducedRatioStd() { }
        virtual ~prodml21__CumulativeGasProducedRatioStd() { }
        /// Friend allocator used by soap_new_prodml21__CumulativeGasProducedRatioStd(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CumulativeGasProducedRatioStd * SOAP_FMAC2 soap_instantiate_prodml21__CumulativeGasProducedRatioStd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:476 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol (-173)
/* complex XML schema type 'prodml21:CumulativeGasProducedVol': */
class SOAP_CMAC prodml21__CumulativeGasProducedVol : public prodml21__AbstractGasProducedRatioVolume {
      public:
        /// Required element 'prodml21:CumulativeGasProducedVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *CumulativeGasProducedVolume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CumulativeGasProducedVol, default initialized and not managed by a soap context
        virtual prodml21__CumulativeGasProducedVol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CumulativeGasProducedVol); }
      public:
        /// Constructor with default initializations
        prodml21__CumulativeGasProducedVol() : CumulativeGasProducedVolume() { }
        virtual ~prodml21__CumulativeGasProducedVol() { }
        /// Friend allocator used by soap_new_prodml21__CumulativeGasProducedVol(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CumulativeGasProducedVol * SOAP_FMAC2 soap_instantiate_prodml21__CumulativeGasProducedVol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:484 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis (-177)
/* complex XML schema type 'prodml21:FluidAnalysis': */
class SOAP_CMAC prodml21__FluidAnalysis : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:RequestDate' of XML schema type 'xsd:date'
        std::string *RequestDate;
        /// Optional element 'prodml21:AnalysisDescription' of XML schema type 'eml22:String2000'
        std::string *AnalysisDescription;
        /// Optional element 'prodml21:AnalysisPurpose' of XML schema type 'eml22:String2000'
        std::string *AnalysisPurpose;
        /// Optional element 'prodml21:AnalysisSite' of XML schema type 'eml22:String2000'
        std::string *AnalysisSite;
        /// Optional element 'prodml21:LabContact' of XML schema type 'eml22:String64'
        std::string *LabContact;
        /// Optional element 'prodml21:StandardConditions' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *StandardConditions;
        /// Required element 'prodml21:AnalysisQuality' of XML schema type 'prodml21:SampleQuality'
        prodml21__SampleQuality AnalysisQuality;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:SampleContaminant' of XML schema type 'prodml21:SampleContaminant'
        std::vector<prodml21__SampleContaminant *> SampleContaminant;
        /// Required element 'prodml21:FluidSample' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSample;
        /// Optional element 'prodml21:FluidAnalysisReport' of XML schema type 'prodml21:FluidAnalysisReport'
        std::vector<prodml21__FluidAnalysisReport *> FluidAnalysisReport;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidAnalysis, default initialized and not managed by a soap context
        virtual prodml21__FluidAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__FluidAnalysis() : RequestDate(), AnalysisDescription(), AnalysisPurpose(), AnalysisSite(), LabContact(), StandardConditions(), AnalysisQuality(), Remark(), SampleContaminant(), FluidSample(), FluidAnalysisReport() { }
        virtual ~prodml21__FluidAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__FluidAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__FluidAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:506 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction (-188)
/* complex XML schema type 'prodml21:LiquidDropoutFraction': */
class SOAP_CMAC prodml21__LiquidDropoutFraction : public prodml21__AbstractLiquidDropoutPercVolume {
      public:
        /// Required element 'prodml21:LiquidDropoutPercent' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *LiquidDropoutPercent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LiquidDropoutFraction, default initialized and not managed by a soap context
        virtual prodml21__LiquidDropoutFraction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LiquidDropoutFraction); }
      public:
        /// Constructor with default initializations
        prodml21__LiquidDropoutFraction() : LiquidDropoutPercent() { }
        virtual ~prodml21__LiquidDropoutFraction() { }
        /// Friend allocator used by soap_new_prodml21__LiquidDropoutFraction(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LiquidDropoutFraction * SOAP_FMAC2 soap_instantiate_prodml21__LiquidDropoutFraction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:508 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume (-189)
/* complex XML schema type 'prodml21:LiquidVolume': */
class SOAP_CMAC prodml21__LiquidVolume : public prodml21__AbstractLiquidDropoutPercVolume {
      public:
        /// Required element 'prodml21:LiquidVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *LiquidVolume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LiquidVolume, default initialized and not managed by a soap context
        virtual prodml21__LiquidVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LiquidVolume); }
      public:
        /// Constructor with default initializations
        prodml21__LiquidVolume() : LiquidVolume() { }
        virtual ~prodml21__LiquidVolume() { }
        /// Friend allocator used by soap_new_prodml21__LiquidVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LiquidVolume * SOAP_FMAC2 soap_instantiate_prodml21__LiquidVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:520 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor (-195)
/* complex XML schema type 'prodml21:OilShrinkageFactor': */
class SOAP_CMAC prodml21__OilShrinkageFactor : public prodml21__AbstractOilVolShrinkage {
      public:
        /// Required element 'prodml21:OilShrinkageFactor' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *OilShrinkageFactor;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OilShrinkageFactor, default initialized and not managed by a soap context
        virtual prodml21__OilShrinkageFactor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OilShrinkageFactor); }
      public:
        /// Constructor with default initializations
        prodml21__OilShrinkageFactor() : OilShrinkageFactor() { }
        virtual ~prodml21__OilShrinkageFactor() { }
        /// Friend allocator used by soap_new_prodml21__OilShrinkageFactor(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OilShrinkageFactor * SOAP_FMAC2 soap_instantiate_prodml21__OilShrinkageFactor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:522 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume (-196)
/* complex XML schema type 'prodml21:OilVolume': */
class SOAP_CMAC prodml21__OilVolume : public prodml21__AbstractOilVolShrinkage {
      public:
        /// Required element 'prodml21:OilVolume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *OilVolume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OilVolume, default initialized and not managed by a soap context
        virtual prodml21__OilVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OilVolume); }
      public:
        /// Constructor with default initializations
        prodml21__OilVolume() : OilVolume() { }
        virtual ~prodml21__OilVolume() { }
        /// Friend allocator used by soap_new_prodml21__OilVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OilVolume * SOAP_FMAC2 soap_instantiate_prodml21__OilVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:586 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample (-228)
/* complex XML schema type 'prodml21:FluidSample': */
class SOAP_CMAC prodml21__FluidSample : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:SampleKind' of XML schema type 'prodml21:FluidSampleKind'
        prodml21__FluidSampleKind *SampleKind;
        /// Optional element 'prodml21:RockFluidUnitFeature' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *RockFluidUnitFeature;
        /// Optional element 'prodml21:Representative' of XML schema type 'xsd:boolean'
        bool *Representative;
        /// Optional element 'prodml21:SampleDisposition' of XML schema type 'eml22:String64'
        std::string *SampleDisposition;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:FluidSampleAcquisitionJobSource' of XML schema type 'prodml21:FluidSampleAcquisitionJobSource'
        prodml21__FluidSampleAcquisitionJobSource *FluidSampleAcquisitionJobSource;
        /// Optional element 'prodml21:FluidSampleChainofCustodyEvent' of XML schema type 'prodml21:FluidSampleChainofCustodyEvent'
        std::vector<prodml21__FluidSampleChainofCustodyEvent *> FluidSampleChainofCustodyEvent;
        /// Optional element 'prodml21:FluidSystem' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSystem;
        /// Optional element 'prodml21:FluidSampleComposition' of XML schema type 'prodml21:FluidSampleComposition'
        std::vector<prodml21__FluidSampleComposition *> FluidSampleComposition;
        /// Optional element 'prodml21:OriginalSampleContainer' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *OriginalSampleContainer;
        /// Optional element 'prodml21:SampleRecombinationRequirement' of XML schema type 'prodml21:SampleRecombinationRequirement'
        prodml21__SampleRecombinationRequirement *SampleRecombinationRequirement;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSample, default initialized and not managed by a soap context
        virtual prodml21__FluidSample *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSample); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSample() : SampleKind(), RockFluidUnitFeature(), Representative(), SampleDisposition(), Remark(), FluidSampleAcquisitionJobSource(), FluidSampleChainofCustodyEvent(), FluidSystem(), FluidSampleComposition(), OriginalSampleContainer(), SampleRecombinationRequirement() { }
        virtual ~prodml21__FluidSample() { }
        /// Friend allocator used by soap_new_prodml21__FluidSample(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSample * SOAP_FMAC2 soap_instantiate_prodml21__FluidSample(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:596 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer (-233)
/* complex XML schema type 'prodml21:FluidSampleContainer': */
class SOAP_CMAC prodml21__FluidSampleContainer : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:Make' of XML schema type 'eml22:String64'
        std::string *Make;
        /// Optional element 'prodml21:Model' of XML schema type 'eml22:String64'
        std::string *Model;
        /// Optional element 'prodml21:SerialNumber' of XML schema type 'eml22:String64'
        std::string *SerialNumber;
        /// Optional element 'prodml21:BottleID' of XML schema type 'eml22:String64'
        std::string *BottleID;
        /// Optional element 'prodml21:Capacity' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Capacity;
        /// Optional element 'prodml21:Owner' of XML schema type 'eml22:String64'
        std::string *Owner;
        /// Optional element 'prodml21:Kind' of XML schema type 'eml22:String64'
        std::string *Kind;
        /// Optional element 'prodml21:Metallurgy' of XML schema type 'eml22:String64'
        std::string *Metallurgy;
        /// Optional element 'prodml21:PressureRating' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *PressureRating;
        /// Optional element 'prodml21:TemperatureRating' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *TemperatureRating;
        /// Optional element 'prodml21:LastInspectionDate' of XML schema type 'xsd:date'
        std::string *LastInspectionDate;
        /// Optional element 'prodml21:TransportCertificateReference' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TransportCertificateReference;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleContainer, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleContainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleContainer); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleContainer() : Make(), Model(), SerialNumber(), BottleID(), Capacity(), Owner(), Kind(), Metallurgy(), PressureRating(), TemperatureRating(), LastInspectionDate(), TransportCertificateReference(), Remark() { }
        virtual ~prodml21__FluidSampleContainer() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleContainer(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleContainer * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleContainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:598 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition (-234)
/* complex XML schema type 'prodml21:DownholeSampleAcquisition': */
class SOAP_CMAC prodml21__DownholeSampleAcquisition : public prodml21__FluidSampleAcquisition {
      public:
        /// Required element 'prodml21:TopMD' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *TopMD;
        /// Optional element 'prodml21:BaseMD' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *BaseMD;
        /// Optional element 'prodml21:ToolKind' of XML schema type 'eml22:String64'
        std::string *ToolKind;
        /// Required element 'prodml21:SamplingRun' of XML schema type 'eml22:NonNegativeLong'
        LONG64 SamplingRun;
        /// Required element 'prodml21:Wellbore' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Wellbore;
        /// Optional element 'prodml21:WellboreCompletion' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WellboreCompletion;
        /// Optional element 'prodml21:ProductionWellTest' of XML schema type 'prodml21:ProductionWellTest'
        prodml21__ProductionWellTest *ProductionWellTest;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DownholeSampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__DownholeSampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DownholeSampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__DownholeSampleAcquisition() : TopMD(), BaseMD(), ToolKind(), SamplingRun(), Wellbore(), WellboreCompletion(), ProductionWellTest() { }
        virtual ~prodml21__DownholeSampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__DownholeSampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DownholeSampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__DownholeSampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:600 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition (-235)
/* complex XML schema type 'prodml21:FacilitySampleAcquisition': */
class SOAP_CMAC prodml21__FacilitySampleAcquisition : public prodml21__FluidSampleAcquisition {
      public:
        /// Optional element 'prodml21:SamplingPoint' of XML schema type 'eml22:String64'
        std::string *SamplingPoint;
        /// Required element 'prodml21:FacilityPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *FacilityPressure;
        /// Required element 'prodml21:FacilityTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *FacilityTemperature;
        /// Optional element 'prodml21:Facility' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Facility;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FacilitySampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__FacilitySampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FacilitySampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__FacilitySampleAcquisition() : SamplingPoint(), FacilityPressure(), FacilityTemperature(), Facility() { }
        virtual ~prodml21__FacilitySampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__FacilitySampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FacilitySampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__FacilitySampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:604 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob (-237)
/* complex XML schema type 'prodml21:FluidSampleAcquisitionJob': */
class SOAP_CMAC prodml21__FluidSampleAcquisitionJob : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:EstimatedStartDate' of XML schema type 'xsd:date'
        std::string *EstimatedStartDate;
        /// Optional element 'prodml21:Operation' of XML schema type 'eml22:String64'
        std::string *Operation;
        /// Optional element 'prodml21:FieldNoteReference' of XML schema type 'eml22:DataObjectReference'
        std::vector<eml22__DataObjectReference *> FieldNoteReference;
        /// Required element 'prodml21:FluidSystem' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidSystem;
        /// Optional element 'prodml21:FluidSampleAcquisition' of XML schema type 'prodml21:FluidSampleAcquisition'
        std::vector<prodml21__FluidSampleAcquisition *> FluidSampleAcquisition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidSampleAcquisitionJob, default initialized and not managed by a soap context
        virtual prodml21__FluidSampleAcquisitionJob *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidSampleAcquisitionJob); }
      public:
        /// Constructor with default initializations
        prodml21__FluidSampleAcquisitionJob() : EstimatedStartDate(), Operation(), FieldNoteReference(), FluidSystem(), FluidSampleAcquisition() { }
        virtual ~prodml21__FluidSampleAcquisitionJob() { }
        /// Friend allocator used by soap_new_prodml21__FluidSampleAcquisitionJob(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidSampleAcquisitionJob * SOAP_FMAC2 soap_instantiate_prodml21__FluidSampleAcquisitionJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:606 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition (-238)
/* complex XML schema type 'prodml21:SeparatorSampleAcquisition': */
class SOAP_CMAC prodml21__SeparatorSampleAcquisition : public prodml21__FluidSampleAcquisition {
      public:
        /// Required element 'prodml21:Separator' of XML schema type 'eml22:String64'
        std::string Separator;
        /// Optional element 'prodml21:WellCompletion' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WellCompletion;
        /// Required element 'prodml21:SeparatorPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *SeparatorPressure;
        /// Required element 'prodml21:SeparatorTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *SeparatorTemperature;
        /// Optional element 'prodml21:SamplingPoint' of XML schema type 'eml22:String64'
        std::string *SamplingPoint;
        /// Optional element 'prodml21:CorrectedOilRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *CorrectedOilRate;
        /// Optional element 'prodml21:CorrectedGasRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *CorrectedGasRate;
        /// Optional element 'prodml21:CorrectedWaterRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *CorrectedWaterRate;
        /// Optional element 'prodml21:MeasuredOilRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *MeasuredOilRate;
        /// Optional element 'prodml21:MeasuredGasRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *MeasuredGasRate;
        /// Optional element 'prodml21:MeasuredWaterRate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *MeasuredWaterRate;
        /// Optional element 'prodml21:ProductionWellTest' of XML schema type 'prodml21:ProductionWellTest'
        prodml21__ProductionWellTest *ProductionWellTest;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SeparatorSampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__SeparatorSampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SeparatorSampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__SeparatorSampleAcquisition() : Separator(), WellCompletion(), SeparatorPressure(), SeparatorTemperature(), SamplingPoint(), CorrectedOilRate(), CorrectedGasRate(), CorrectedWaterRate(), MeasuredOilRate(), MeasuredGasRate(), MeasuredWaterRate(), ProductionWellTest() { }
        virtual ~prodml21__SeparatorSampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__SeparatorSampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SeparatorSampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__SeparatorSampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:608 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition (-239)
/* complex XML schema type 'prodml21:WellheadSampleAcquisition': */
class SOAP_CMAC prodml21__WellheadSampleAcquisition : public prodml21__FluidSampleAcquisition {
      public:
        /// Optional element 'prodml21:Well' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Well;
        /// Optional element 'prodml21:WellCompletion' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WellCompletion;
        /// Required element 'prodml21:WellheadPressure' of XML schema type 'eml22:AbstractPressureValue'
        eml22__AbstractPressureValue *WellheadPressure;
        /// Required element 'prodml21:WellheadTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *WellheadTemperature;
        /// Optional element 'prodml21:SamplingPoint' of XML schema type 'eml22:String64'
        std::string *SamplingPoint;
        /// Optional element 'prodml21:ProductionWellTest' of XML schema type 'prodml21:ProductionWellTest'
        prodml21__ProductionWellTest *ProductionWellTest;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellheadSampleAcquisition, default initialized and not managed by a soap context
        virtual prodml21__WellheadSampleAcquisition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellheadSampleAcquisition); }
      public:
        /// Constructor with default initializations
        prodml21__WellheadSampleAcquisition() : Well(), WellCompletion(), WellheadPressure(), WellheadTemperature(), SamplingPoint(), ProductionWellTest() { }
        virtual ~prodml21__WellheadSampleAcquisition() { }
        /// Friend allocator used by soap_new_prodml21__WellheadSampleAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellheadSampleAcquisition * SOAP_FMAC2 soap_instantiate_prodml21__WellheadSampleAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:610 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob (-240)
/* complex XML schema type 'prodml21:WftSampleAcquisitionJob': */
class SOAP_CMAC prodml21__WftSampleAcquisitionJob : public prodml21__FluidSampleAcquisition {
      public:
        /// Required element 'prodml21:WftStation' of XML schema type 'eml22:String64'
        std::string WftStation;
        /// Required element 'prodml21:WftSampleAcquisition' of XML schema type 'eml22:String64'
        std::string WftSampleAcquisition;
        /// Required element 'prodml21:WftRun' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *WftRun;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftSampleAcquisitionJob, default initialized and not managed by a soap context
        virtual prodml21__WftSampleAcquisitionJob *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftSampleAcquisitionJob); }
      public:
        /// Constructor with default initializations
        prodml21__WftSampleAcquisitionJob() : WftStation(), WftSampleAcquisition(), WftRun() { }
        virtual ~prodml21__WftSampleAcquisitionJob() { }
        /// Friend allocator used by soap_new_prodml21__WftSampleAcquisitionJob(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftSampleAcquisitionJob * SOAP_FMAC2 soap_instantiate_prodml21__WftSampleAcquisitionJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:620 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun (-245)
/* complex XML schema type 'prodml21:WftRun': */
class SOAP_CMAC prodml21__WftRun : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:ObjectGrowing' of XML schema type 'xsd:boolean'
        bool *ObjectGrowing;
        /// Optional element 'prodml21:TieInLog' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *TieInLog;
        /// Optional element 'prodml21:ServiceCompany' of XML schema type 'eml22:String64'
        std::string *ServiceCompany;
        /// Optional element 'prodml21:DTimStart' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimStart;
        /// Optional element 'prodml21:DTimEnd' of XML schema type 'eml22:TimeStamp'
        struct tm *DTimEnd;
        /// Optional element 'prodml21:MinIndex' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MinIndex;
        /// Optional element 'prodml21:MaxIndex' of XML schema type 'prodml21:MeasuredDepthCoord'
        prodml21__MeasuredDepthCoord *MaxIndex;
        /// Optional element 'prodml21:Station' of XML schema type 'prodml21:WftStation'
        std::vector<prodml21__WftStation *> Station;
        /// Optional element 'prodml21:Result' of XML schema type 'prodml21:WftTestResult'
        std::vector<prodml21__WftTestResult *> Result;
        /// Optional element 'prodml21:Wellbore' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Wellbore;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WftRun, default initialized and not managed by a soap context
        virtual prodml21__WftRun *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WftRun); }
      public:
        /// Constructor with default initializations
        prodml21__WftRun() : ObjectGrowing(), TieInLog(), ServiceCompany(), DTimStart(), DTimEnd(), MinIndex(), MaxIndex(), Station(), Result(), Wellbore() { }
        virtual ~prodml21__WftRun() { }
        /// Friend allocator used by soap_new_prodml21__WftRun(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WftRun * SOAP_FMAC2 soap_instantiate_prodml21__WftRun(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:636 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume (-253)
/* complex XML schema type 'prodml21:AbstractSimpleProductVolume': */
class SOAP_CMAC prodml21__AbstractSimpleProductVolume : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:StandardConditions' of XML schema type 'eml22:AbstractTemperaturePressure'
        eml22__AbstractTemperaturePressure *StandardConditions;
        /// Optional element 'prodml21:ApprovalDate' of XML schema type 'xsd:date'
        std::string *ApprovalDate;
        /// Optional element 'prodml21:GeographicContext' of XML schema type 'prodml21:GeographicContext'
        prodml21__GeographicContext *GeographicContext;
        /// Optional element 'prodml21:FluidComponentCatalog' of XML schema type 'prodml21:FluidComponentCatalog'
        prodml21__FluidComponentCatalog *FluidComponentCatalog;
        /// Optional element 'prodml21:Operator' of XML schema type 'prodml21:BusinessAssociate'
        prodml21__BusinessAssociate *Operator;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractSimpleProductVolume, default initialized and not managed by a soap context
        virtual prodml21__AbstractSimpleProductVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractSimpleProductVolume); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractSimpleProductVolume() : StandardConditions(), ApprovalDate(), GeographicContext(), FluidComponentCatalog(), Operator() { }
        virtual ~prodml21__AbstractSimpleProductVolume() { }
        /// Friend allocator used by soap_new_prodml21__AbstractSimpleProductVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractSimpleProductVolume * SOAP_FMAC2 soap_instantiate_prodml21__AbstractSimpleProductVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:648 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition (-259)
/* complex XML schema type 'prodml21:ProductDisposition': */
class SOAP_CMAC prodml21__ProductDisposition : public prodml21__AbstractDisposition {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:DispositionKindExt'
        std::string Kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductDisposition, default initialized and not managed by a soap context
        virtual prodml21__ProductDisposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductDisposition); }
      public:
        /// Constructor with default initializations
        prodml21__ProductDisposition() : Kind() { }
        virtual ~prodml21__ProductDisposition() { }
        /// Friend allocator used by soap_new_prodml21__ProductDisposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductDisposition * SOAP_FMAC2 soap_instantiate_prodml21__ProductDisposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:650 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid (-260)
/* complex XML schema type 'prodml21:ProductFluid': */
class SOAP_CMAC prodml21__ProductFluid : public prodml21__AbstractProductQuantity {
      public:
        /// Required element 'prodml21:ProductFluidKind' of XML schema type 'prodml21:ProductFluidKindExt'
        std::string ProductFluidKind;
        /// Optional element 'prodml21:GrossEnergyContent' of XML schema type 'eml22:EnergyMeasure'
        eml22__EnergyMeasure *GrossEnergyContent;
        /// Optional element 'prodml21:NetEnergyContent' of XML schema type 'eml22:EnergyMeasure'
        eml22__EnergyMeasure *NetEnergyContent;
        /// Optional element 'prodml21:OverallComposition' of XML schema type 'prodml21:OverallComposition'
        prodml21__OverallComposition *OverallComposition;
        /// Optional attribute 'productFluidReference' of XML schema type 'eml22:String64'
        std::string *productFluidReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductFluid, default initialized and not managed by a soap context
        virtual prodml21__ProductFluid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductFluid); }
      public:
        /// Constructor with default initializations
        prodml21__ProductFluid() : ProductFluidKind(), GrossEnergyContent(), NetEnergyContent(), OverallComposition(), productFluidReference() { }
        virtual ~prodml21__ProductFluid() { }
        /// Friend allocator used by soap_new_prodml21__ProductFluid(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductFluid * SOAP_FMAC2 soap_instantiate_prodml21__ProductFluid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:664 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid (-267)
/* complex XML schema type 'prodml21:ServiceFluid': */
class SOAP_CMAC prodml21__ServiceFluid : public prodml21__AbstractProductQuantity {
      public:
        /// Required element 'prodml21:ServiceFluidKind' of XML schema type 'prodml21:ServiceFluidKindExt'
        std::string ServiceFluidKind;
        /// Optional attribute 'serviceFluidReference' of XML schema type 'eml22:String64'
        std::string *serviceFluidReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ServiceFluid, default initialized and not managed by a soap context
        virtual prodml21__ServiceFluid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ServiceFluid); }
      public:
        /// Constructor with default initializations
        prodml21__ServiceFluid() : ServiceFluidKind(), serviceFluidReference() { }
        virtual ~prodml21__ServiceFluid() { }
        /// Friend allocator used by soap_new_prodml21__ServiceFluid(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ServiceFluid * SOAP_FMAC2 soap_instantiate_prodml21__ServiceFluid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:668 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition (-269)
/* complex XML schema type 'prodml21:TerminalLiftingDisposition': */
class SOAP_CMAC prodml21__TerminalLiftingDisposition : public prodml21__AbstractDisposition {
      public:
        /// Optional element 'prodml21:TerminalLifting' of XML schema type 'prodml21:TerminalLifting'
        prodml21__TerminalLifting *TerminalLifting;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TerminalLiftingDisposition, default initialized and not managed by a soap context
        virtual prodml21__TerminalLiftingDisposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TerminalLiftingDisposition); }
      public:
        /// Constructor with default initializations
        prodml21__TerminalLiftingDisposition() : TerminalLifting() { }
        virtual ~prodml21__TerminalLiftingDisposition() { }
        /// Friend allocator used by soap_new_prodml21__TerminalLiftingDisposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TerminalLiftingDisposition * SOAP_FMAC2 soap_instantiate_prodml21__TerminalLiftingDisposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:674 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition (-272)
/* complex XML schema type 'prodml21:TransferDisposition': */
class SOAP_CMAC prodml21__TransferDisposition : public prodml21__AbstractDisposition {
      public:
        /// Optional element 'prodml21:Transfer' of XML schema type 'prodml21:Transfer'
        prodml21__Transfer *Transfer;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TransferDisposition, default initialized and not managed by a soap context
        virtual prodml21__TransferDisposition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TransferDisposition); }
      public:
        /// Constructor with default initializations
        prodml21__TransferDisposition() : Transfer() { }
        virtual ~prodml21__TransferDisposition() { }
        /// Friend allocator used by soap_new_prodml21__TransferDisposition(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TransferDisposition * SOAP_FMAC2 soap_instantiate_prodml21__TransferDisposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:682 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData (-276)
/* complex XML schema type 'prodml21:AbstractPtaFlowData': */
class SOAP_CMAC prodml21__AbstractPtaFlowData : public prodml21__AbstractFlowTestData {
      public:
        /// Optional element 'prodml21:FluidPhaseMeasuredKind' of XML schema type 'prodml21:FluidPhaseKind'
        prodml21__FluidPhaseKind *FluidPhaseMeasuredKind;
        /// Required element 'prodml21:FlowChannel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowChannel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractPtaFlowData, default initialized and not managed by a soap context
        virtual prodml21__AbstractPtaFlowData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractPtaFlowData); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractPtaFlowData() : FluidPhaseMeasuredKind(), FlowChannel() { }
        virtual ~prodml21__AbstractPtaFlowData() { }
        /// Friend allocator used by soap_new_prodml21__AbstractPtaFlowData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractPtaFlowData * SOAP_FMAC2 soap_instantiate_prodml21__AbstractPtaFlowData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:684 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Channel (-277)
/* complex XML schema type 'prodml21:Channel': */
class SOAP_CMAC prodml21__Channel : public eml22__AbstractObject {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Channel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Channel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Channel, default initialized and not managed by a soap context
        virtual prodml21__Channel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Channel); }
      public:
        /// Constructor with default initializations
        prodml21__Channel() { }
        virtual ~prodml21__Channel() { }
        /// Friend allocator used by soap_new_prodml21__Channel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Channel * SOAP_FMAC2 soap_instantiate_prodml21__Channel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:686 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet (-278)
/* complex XML schema type 'prodml21:ChannelSet': */
class SOAP_CMAC prodml21__ChannelSet : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:Data' of XML schema type 'xsd:string'
        std::vector<std::string> Data;
        /// Optional element 'prodml21:Channel' of XML schema type 'prodml21:Channel'
        std::vector<prodml21__Channel *> Channel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChannelSet, default initialized and not managed by a soap context
        virtual prodml21__ChannelSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChannelSet); }
      public:
        /// Constructor with default initializations
        prodml21__ChannelSet() : Data(), Channel() { }
        virtual ~prodml21__ChannelSet() { }
        /// Friend allocator used by soap_new_prodml21__ChannelSet(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChannelSet * SOAP_FMAC2 soap_instantiate_prodml21__ChannelSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:690 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity (-280)
/* complex XML schema type 'prodml21:FlowTestActivity': */
class SOAP_CMAC prodml21__FlowTestActivity : public eml22__AbstractObject {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FlowTestActivity, default initialized and not managed by a soap context
        virtual prodml21__FlowTestActivity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FlowTestActivity); }
      public:
        /// Constructor with default initializations
        prodml21__FlowTestActivity() { }
        virtual ~prodml21__FlowTestActivity() { }
        /// Friend allocator used by soap_new_prodml21__FlowTestActivity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FlowTestActivity * SOAP_FMAC2 soap_instantiate_prodml21__FlowTestActivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:700 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData (-285)
/* complex XML schema type 'prodml21:OtherData': */
class SOAP_CMAC prodml21__OtherData : public prodml21__AbstractFlowTestData {
      public:
        /// Required element 'prodml21:DataChannel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *DataChannel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OtherData, default initialized and not managed by a soap context
        virtual prodml21__OtherData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OtherData); }
      public:
        /// Constructor with default initializations
        prodml21__OtherData() : DataChannel() { }
        virtual ~prodml21__OtherData() { }
        /// Friend allocator used by soap_new_prodml21__OtherData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OtherData * SOAP_FMAC2 soap_instantiate_prodml21__OtherData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:712 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData (-291)
/* complex XML schema type 'prodml21:AbstractPtaPressureData': */
class SOAP_CMAC prodml21__AbstractPtaPressureData : public prodml21__AbstractFlowTestData {
      public:
        /// Required element 'prodml21:PressureChannel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *PressureChannel;
        /// Optional element 'prodml21:PressureDerivativeChannel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *PressureDerivativeChannel;
        /// Optional element 'prodml21:PressureReferenceDepth' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *PressureReferenceDepth;
        /// Optional element 'prodml21:Datum' of XML schema type 'eml22:WellboreDatumReference'
        eml22__WellboreDatumReference *Datum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractPtaPressureData, default initialized and not managed by a soap context
        virtual prodml21__AbstractPtaPressureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractPtaPressureData); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractPtaPressureData() : PressureChannel(), PressureDerivativeChannel(), PressureReferenceDepth(), Datum() { }
        virtual ~prodml21__AbstractPtaPressureData() { }
        /// Friend allocator used by soap_new_prodml21__AbstractPtaPressureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractPtaPressureData * SOAP_FMAC2 soap_instantiate_prodml21__AbstractPtaPressureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:718 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData (-294)
/* complex XML schema type 'prodml21:ChannelFlowrateData': */
class SOAP_CMAC prodml21__ChannelFlowrateData : public prodml21__AbstractRateHistory {
      public:
        /// Required element 'prodml21:InputFlowrate' of XML schema type 'prodml21:AbstractPtaFlowData'
        prodml21__AbstractPtaFlowData *InputFlowrate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChannelFlowrateData, default initialized and not managed by a soap context
        virtual prodml21__ChannelFlowrateData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChannelFlowrateData); }
      public:
        /// Constructor with default initializations
        prodml21__ChannelFlowrateData() : InputFlowrate() { }
        virtual ~prodml21__ChannelFlowrateData() { }
        /// Friend allocator used by soap_new_prodml21__ChannelFlowrateData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChannelFlowrateData * SOAP_FMAC2 soap_instantiate_prodml21__ChannelFlowrateData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:722 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput (-296)
/* complex XML schema type 'prodml21:DeconvolutionMultipleOutput': */
class SOAP_CMAC prodml21__DeconvolutionMultipleOutput : public prodml21__AbstractDeconvolutionOutput {
      public:
        /// Required element 'prodml21:TestPeriodOutputRefId' of XML schema type 'eml22:String64'
        std::string TestPeriodOutputRefId;
        /// Required element 'prodml21:DeconvolutionMultipleOutput' of XML schema type 'prodml21:DeconvolutionOutput'
        prodml21__DeconvolutionOutput *DeconvolutionMultipleOutput;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeconvolutionMultipleOutput, default initialized and not managed by a soap context
        virtual prodml21__DeconvolutionMultipleOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeconvolutionMultipleOutput); }
      public:
        /// Constructor with default initializations
        prodml21__DeconvolutionMultipleOutput() : TestPeriodOutputRefId(), DeconvolutionMultipleOutput() { }
        virtual ~prodml21__DeconvolutionMultipleOutput() { }
        /// Friend allocator used by soap_new_prodml21__DeconvolutionMultipleOutput(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeconvolutionMultipleOutput * SOAP_FMAC2 soap_instantiate_prodml21__DeconvolutionMultipleOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:726 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput (-298)
/* complex XML schema type 'prodml21:DeconvolutionSingleOutput': */
class SOAP_CMAC prodml21__DeconvolutionSingleOutput : public prodml21__AbstractDeconvolutionOutput {
      public:
        /// Required element 'prodml21:DeconvolutionSingleOutput' of XML schema type 'prodml21:DeconvolutionOutput'
        prodml21__DeconvolutionOutput *DeconvolutionSingleOutput;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeconvolutionSingleOutput, default initialized and not managed by a soap context
        virtual prodml21__DeconvolutionSingleOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeconvolutionSingleOutput); }
      public:
        /// Constructor with default initializations
        prodml21__DeconvolutionSingleOutput() : DeconvolutionSingleOutput() { }
        virtual ~prodml21__DeconvolutionSingleOutput() { }
        /// Friend allocator used by soap_new_prodml21__DeconvolutionSingleOutput(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeconvolutionSingleOutput * SOAP_FMAC2 soap_instantiate_prodml21__DeconvolutionSingleOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:758 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis (-314)
/* complex XML schema type 'prodml21:PressureTransientAnalysis': */
class SOAP_CMAC prodml21__PressureTransientAnalysis : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:ModelName' of XML schema type 'eml22:String2000'
        std::string ModelName;
        /// Optional element 'prodml21:TimeAppliesFrom' of XML schema type 'eml22:TimeStamp'
        struct tm *TimeAppliesFrom;
        /// Optional element 'prodml21:MethodName' of XML schema type 'eml22:String2000'
        std::string *MethodName;
        /// Optional element 'prodml21:TimeAppliesTo' of XML schema type 'eml22:TimeStamp'
        struct tm *TimeAppliesTo;
        /// Optional element 'prodml21:IsNumericalAnalysis' of XML schema type 'xsd:boolean'
        bool *IsNumericalAnalysis;
        /// Optional element 'prodml21:FluidCharacterization' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FluidCharacterization;
        /// Optional element 'prodml21:NumericalPtaModel' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *NumericalPtaModel;
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity;
        /// Optional element 'prodml21:PrincipalFlowTestMeasurementSetRef' of XML schema type 'eml22:String64'
        std::string *PrincipalFlowTestMeasurementSetRef;
        /// Required element 'prodml21:PrincipalTestPeriodRef' of XML schema type 'eml22:String64'
        std::vector<std::string> PrincipalTestPeriodRef;
        /// Optional element 'prodml21:WellboreModel' of XML schema type 'prodml21:WellboreBaseModel'
        prodml21__WellboreBaseModel *WellboreModel;
        /// Optional element 'prodml21:LayerModel' of XML schema type 'prodml21:LayerModel'
        std::vector<prodml21__LayerModel *> LayerModel;
        /// Required element 'prodml21:FluidPhaseAnalysisKind' of XML schema type 'prodml21:FluidPhaseKind'
        prodml21__FluidPhaseKind FluidPhaseAnalysisKind;
        /// Required element 'prodml21:PressureNonLinearTransformKind' of XML schema type 'prodml21:PressureNonLinearTransformKind'
        prodml21__PressureNonLinearTransformKind PressureNonLinearTransformKind;
        /// Optional element 'prodml21:PseudoPressureEffectApplied' of XML schema type 'prodml21:PseudoPressureEffectApplied'
        prodml21__PseudoPressureEffectApplied *PseudoPressureEffectApplied;
        /// Required element 'prodml21:TimeNonLinearTransformKind' of XML schema type 'prodml21:TimeNonLinearTransformKind'
        prodml21__TimeNonLinearTransformKind TimeNonLinearTransformKind;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Optional element 'prodml21:Analysis' of XML schema type 'prodml21:AbstractAnalysis'
        prodml21__AbstractAnalysis *Analysis;
        /// Optional element 'prodml21:InterferingFlowTestInterval' of XML schema type 'prodml21:InterferingFlowTestInterval'
        std::vector<prodml21__InterferingFlowTestInterval *> InterferingFlowTestInterval;
        /// Optional element 'prodml21:CompressibilityParameters' of XML schema type 'prodml21:CompressibilityParameters'
        prodml21__CompressibilityParameters *CompressibilityParameters;
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity_;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PressureTransientAnalysis, default initialized and not managed by a soap context
        virtual prodml21__PressureTransientAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PressureTransientAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__PressureTransientAnalysis() : ModelName(), TimeAppliesFrom(), MethodName(), TimeAppliesTo(), IsNumericalAnalysis(), FluidCharacterization(), NumericalPtaModel(), FlowTestActivity(), PrincipalFlowTestMeasurementSetRef(), PrincipalTestPeriodRef(), WellboreModel(), LayerModel(), FluidPhaseAnalysisKind(), PressureNonLinearTransformKind(), PseudoPressureEffectApplied(), TimeNonLinearTransformKind(), Remark(), Analysis(), InterferingFlowTestInterval(), CompressibilityParameters(), FlowTestActivity_() { }
        virtual ~prodml21__PressureTransientAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__PressureTransientAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PressureTransientAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__PressureTransientAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:760 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis (-315)
/* complex XML schema type 'prodml21:PtaAnalysis': */
class SOAP_CMAC prodml21__PtaAnalysis : public prodml21__AbstractAnalysis {
      public:
        /// Optional element 'prodml21:InitialPressureP0ForImpulseTest' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *InitialPressureP0ForImpulseTest;
        /// Required element 'prodml21:InputPressure' of XML schema type 'prodml21:AbstractPtaPressureData'
        prodml21__AbstractPtaPressureData *InputPressure;
        /// Optional element 'prodml21:SimulatedPressure' of XML schema type 'prodml21:OutputPressureData'
        prodml21__OutputPressureData *SimulatedPressure;
        /// Optional element 'prodml21:SimulatedPressureGaugeNoise' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *SimulatedPressureGaugeNoise;
        /// Optional element 'prodml21:SimulatedPressureGaugeResolution' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *SimulatedPressureGaugeResolution;
        /// Optional element 'prodml21:SimulatedPressureGaugeDrift' of XML schema type 'eml22:PressurePerTimeMeasure'
        eml22__PressurePerTimeMeasure *SimulatedPressureGaugeDrift;
        /// Optional element 'prodml21:SimulatedLogLogData' of XML schema type 'prodml21:LogLogAnalysis'
        prodml21__LogLogAnalysis *SimulatedLogLogData;
        /// Optional element 'prodml21:MeasuredLogLogData' of XML schema type 'prodml21:LogLogAnalysis'
        prodml21__LogLogAnalysis *MeasuredLogLogData;
        /// Optional element 'prodml21:SpecializedAnalysis' of XML schema type 'prodml21:SpecializedAnalysis'
        std::vector<prodml21__SpecializedAnalysis *> SpecializedAnalysis;
        /// Required element 'prodml21:RateHistory' of XML schema type 'prodml21:AbstractRateHistory'
        prodml21__AbstractRateHistory *RateHistory;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PtaAnalysis, default initialized and not managed by a soap context
        virtual prodml21__PtaAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PtaAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__PtaAnalysis() : InitialPressureP0ForImpulseTest(), InputPressure(), SimulatedPressure(), SimulatedPressureGaugeNoise(), SimulatedPressureGaugeResolution(), SimulatedPressureGaugeDrift(), SimulatedLogLogData(), MeasuredLogLogData(), SpecializedAnalysis(), RateHistory() { }
        virtual ~prodml21__PtaAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__PtaAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PtaAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__PtaAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:762 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess (-316)
/* complex XML schema type 'prodml21:PtaDataPreProcess': */
class SOAP_CMAC prodml21__PtaDataPreProcess : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity;
        /// Optional element 'prodml21:FlowTestMeasurementSetRef' of XML schema type 'eml22:String64'
        std::string *FlowTestMeasurementSetRef;
        /// Required element 'prodml21:InputData' of XML schema type 'prodml21:AbstractFlowTestData'
        std::vector<prodml21__AbstractFlowTestData *> InputData;
        /// Required element 'prodml21:PreProcessedData' of XML schema type 'prodml21:AbstractFlowTestData'
        prodml21__AbstractFlowTestData *PreProcessedData;
        /// Optional element 'prodml21:DataConditioning' of XML schema type 'prodml21:DataConditioningExt'
        std::vector<std::string> DataConditioning;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity_;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PtaDataPreProcess, default initialized and not managed by a soap context
        virtual prodml21__PtaDataPreProcess *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PtaDataPreProcess); }
      public:
        /// Constructor with default initializations
        prodml21__PtaDataPreProcess() : FlowTestActivity(), FlowTestMeasurementSetRef(), InputData(), PreProcessedData(), DataConditioning(), Remark(), FlowTestActivity_() { }
        virtual ~prodml21__PtaDataPreProcess() { }
        /// Friend allocator used by soap_new_prodml21__PtaDataPreProcess(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PtaDataPreProcess * SOAP_FMAC2 soap_instantiate_prodml21__PtaDataPreProcess(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:764 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution (-317)
/* complex XML schema type 'prodml21:PtaDeconvolution': */
class SOAP_CMAC prodml21__PtaDeconvolution : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity;
        /// Optional element 'prodml21:FlowTestMeasurementSetRef' of XML schema type 'eml22:String64'
        std::string *FlowTestMeasurementSetRef;
        /// Optional element 'prodml21:FlowTestPeriodRef' of XML schema type 'eml22:String64'
        std::vector<std::string> FlowTestPeriodRef;
        /// Required element 'prodml21:MethodName' of XML schema type 'eml22:String2000'
        std::string MethodName;
        /// Required element 'prodml21:InitialPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *InitialPressure;
        /// Required element 'prodml21:InputPressure' of XML schema type 'prodml21:AbstractPtaPressureData'
        prodml21__AbstractPtaPressureData *InputPressure;
        /// Required element 'prodml21:InputFlowrate' of XML schema type 'prodml21:AbstractPtaFlowData'
        prodml21__AbstractPtaFlowData *InputFlowrate;
        /// Optional element 'prodml21:ReconstructedPressure' of XML schema type 'prodml21:DeconvolvedPressureData'
        prodml21__DeconvolvedPressureData *ReconstructedPressure;
        /// Optional element 'prodml21:ReconstructedFlowrate' of XML schema type 'prodml21:DeconvolvedFlowData'
        prodml21__DeconvolvedFlowData *ReconstructedFlowrate;
        /// Optional element 'prodml21:Remark' of XML schema type 'eml22:String2000'
        std::string *Remark;
        /// Required element 'prodml21:FlowTestActivity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *FlowTestActivity_;
        /// Required element 'prodml21:DeconvolutionOutput' of XML schema type 'prodml21:AbstractDeconvolutionOutput'
        std::vector<prodml21__AbstractDeconvolutionOutput *> DeconvolutionOutput;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PtaDeconvolution, default initialized and not managed by a soap context
        virtual prodml21__PtaDeconvolution *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PtaDeconvolution); }
      public:
        /// Constructor with default initializations
        prodml21__PtaDeconvolution() : FlowTestActivity(), FlowTestMeasurementSetRef(), FlowTestPeriodRef(), MethodName(), InitialPressure(), InputPressure(), InputFlowrate(), ReconstructedPressure(), ReconstructedFlowrate(), Remark(), FlowTestActivity_(), DeconvolutionOutput() { }
        virtual ~prodml21__PtaDeconvolution() { }
        /// Friend allocator used by soap_new_prodml21__PtaDeconvolution(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PtaDeconvolution * SOAP_FMAC2 soap_instantiate_prodml21__PtaDeconvolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:770 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis (-320)
/* complex XML schema type 'prodml21:RtaAnalysis': */
class SOAP_CMAC prodml21__RtaAnalysis : public prodml21__AbstractAnalysis {
      public:
        /// Required element 'prodml21:InputPressure' of XML schema type 'prodml21:AbstractPtaPressureData'
        prodml21__AbstractPtaPressureData *InputPressure;
        /// Required element 'prodml21:InputFlowrateData' of XML schema type 'prodml21:AbstractPtaFlowData'
        prodml21__AbstractPtaFlowData *InputFlowrateData;
        /// Required element 'prodml21:SimulatedFlowrate' of XML schema type 'prodml21:OutputFlowData'
        prodml21__OutputFlowData *SimulatedFlowrate;
        /// Optional element 'prodml21:MeasuredLogLogData' of XML schema type 'prodml21:LogLogAnalysis'
        prodml21__LogLogAnalysis *MeasuredLogLogData;
        /// Optional element 'prodml21:SimulatedLogLogData' of XML schema type 'prodml21:LogLogAnalysis'
        prodml21__LogLogAnalysis *SimulatedLogLogData;
        /// Optional element 'prodml21:SpecializedAnalysis' of XML schema type 'prodml21:SpecializedAnalysis'
        std::vector<prodml21__SpecializedAnalysis *> SpecializedAnalysis;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RtaAnalysis, default initialized and not managed by a soap context
        virtual prodml21__RtaAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RtaAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__RtaAnalysis() : InputPressure(), InputFlowrateData(), SimulatedFlowrate(), MeasuredLogLogData(), SimulatedLogLogData(), SpecializedAnalysis() { }
        virtual ~prodml21__RtaAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__RtaAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RtaAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__RtaAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:774 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData (-322)
/* complex XML schema type 'prodml21:SingleFlowrateData': */
class SOAP_CMAC prodml21__SingleFlowrateData : public prodml21__AbstractRateHistory {
      public:
        /// Required element 'prodml21:EffectiveProducingTimeUsed' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *EffectiveProducingTimeUsed;
        /// Required element 'prodml21:SingleFlowrate' of XML schema type 'eml22:VolumePerTimeMeasure'
        eml22__VolumePerTimeMeasure *SingleFlowrate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SingleFlowrateData, default initialized and not managed by a soap context
        virtual prodml21__SingleFlowrateData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SingleFlowrateData); }
      public:
        /// Constructor with default initializations
        prodml21__SingleFlowrateData() : EffectiveProducingTimeUsed(), SingleFlowrate() { }
        virtual ~prodml21__SingleFlowrateData() { }
        /// Friend allocator used by soap_new_prodml21__SingleFlowrateData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SingleFlowrateData * SOAP_FMAC2 soap_instantiate_prodml21__SingleFlowrateData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:780 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData (-325)
/* complex XML schema type 'prodml21:TestPeriodsFlowrateData': */
class SOAP_CMAC prodml21__TestPeriodsFlowrateData : public prodml21__AbstractRateHistory {
      public:
        /// Required element 'prodml21:TestPeriodRef' of XML schema type 'eml22:String64'
        std::vector<std::string> TestPeriodRef;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TestPeriodsFlowrateData, default initialized and not managed by a soap context
        virtual prodml21__TestPeriodsFlowrateData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TestPeriodsFlowrateData); }
      public:
        /// Constructor with default initializations
        prodml21__TestPeriodsFlowrateData() : TestPeriodRef() { }
        virtual ~prodml21__TestPeriodsFlowrateData() { }
        /// Friend allocator used by soap_new_prodml21__TestPeriodsFlowrateData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TestPeriodsFlowrateData * SOAP_FMAC2 soap_instantiate_prodml21__TestPeriodsFlowrateData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:784 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel (-327)
/* complex XML schema type 'prodml21:BoundaryBaseModel': */
class SOAP_CMAC prodml21__BoundaryBaseModel : public prodml21__AbstractModelSection {
      public:
        /// Optional element 'prodml21:RadiusOfInvestigation' of XML schema type 'prodml21:RadiusOfInvestigation'
        prodml21__RadiusOfInvestigation *RadiusOfInvestigation;
        /// Optional element 'prodml21:PoreVolumeOfInvestigation' of XML schema type 'prodml21:PoreVolumeOfInvestigation'
        prodml21__PoreVolumeOfInvestigation *PoreVolumeOfInvestigation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BoundaryBaseModel, default initialized and not managed by a soap context
        virtual prodml21__BoundaryBaseModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BoundaryBaseModel); }
      public:
        /// Constructor with default initializations
        prodml21__BoundaryBaseModel() : RadiusOfInvestigation(), PoreVolumeOfInvestigation() { }
        virtual ~prodml21__BoundaryBaseModel() { }
        /// Friend allocator used by soap_new_prodml21__BoundaryBaseModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BoundaryBaseModel * SOAP_FMAC2 soap_instantiate_prodml21__BoundaryBaseModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:850 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel (-360)
/* complex XML schema type 'prodml21:NearWellboreBaseModel': */
class SOAP_CMAC prodml21__NearWellboreBaseModel : public prodml21__AbstractModelSection {
      public:
        /// Required element 'prodml21:SkinRelativeToTotalThickness' of XML schema type 'prodml21:SkinRelativeToTotalThickness'
        prodml21__SkinRelativeToTotalThickness *SkinRelativeToTotalThickness;
        /// Optional element 'prodml21:RateDependentSkinFactor' of XML schema type 'prodml21:RateDependentSkinFactor'
        prodml21__RateDependentSkinFactor *RateDependentSkinFactor;
        /// Optional element 'prodml21:DeltaPressureTotalSkin' of XML schema type 'prodml21:DeltaPressureTotalSkin'
        prodml21__DeltaPressureTotalSkin *DeltaPressureTotalSkin;
        /// Optional element 'prodml21:RatioDpSkinToTotalDrawdown' of XML schema type 'prodml21:RatioDpSkinToTotalDrawdown'
        prodml21__RatioDpSkinToTotalDrawdown *RatioDpSkinToTotalDrawdown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NearWellboreBaseModel, default initialized and not managed by a soap context
        virtual prodml21__NearWellboreBaseModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NearWellboreBaseModel); }
      public:
        /// Constructor with default initializations
        prodml21__NearWellboreBaseModel() : SkinRelativeToTotalThickness(), RateDependentSkinFactor(), DeltaPressureTotalSkin(), RatioDpSkinToTotalDrawdown() { }
        virtual ~prodml21__NearWellboreBaseModel() { }
        /// Friend allocator used by soap_new_prodml21__NearWellboreBaseModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NearWellboreBaseModel * SOAP_FMAC2 soap_instantiate_prodml21__NearWellboreBaseModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:864 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel (-367)
/* complex XML schema type 'prodml21:ReservoirBaseModel': */
class SOAP_CMAC prodml21__ReservoirBaseModel : public prodml21__AbstractModelSection {
      public:
        /// Required element 'prodml21:HorizontalRadialPermeability' of XML schema type 'prodml21:HorizontalRadialPermeability'
        prodml21__HorizontalRadialPermeability *HorizontalRadialPermeability;
        /// Required element 'prodml21:TotalThickness' of XML schema type 'prodml21:TotalThickness'
        prodml21__TotalThickness *TotalThickness;
        /// Required element 'prodml21:PermeabilityThicknessProduct' of XML schema type 'prodml21:PermeabilityThicknessProduct'
        prodml21__PermeabilityThicknessProduct *PermeabilityThicknessProduct;
        /// Required element 'prodml21:Porosity' of XML schema type 'prodml21:Porosity'
        prodml21__Porosity *Porosity;
        /// Required element 'prodml21:InitialPressure' of XML schema type 'prodml21:InitialPressure'
        prodml21__InitialPressure *InitialPressure;
        /// Optional element 'prodml21:PressureDatumTVD' of XML schema type 'prodml21:PressureDatumTVD'
        prodml21__PressureDatumTVD *PressureDatumTVD;
        /// Optional element 'prodml21:AveragePressure' of XML schema type 'prodml21:AveragePressure'
        prodml21__AveragePressure *AveragePressure;
        /// Optional element 'prodml21:VerticalAnisotropyKvToKr' of XML schema type 'prodml21:VerticalAnisotropyKvToKr'
        prodml21__VerticalAnisotropyKvToKr *VerticalAnisotropyKvToKr;
        /// Optional element 'prodml21:HorizontalAnisotropyKxToKy' of XML schema type 'prodml21:HorizontalAnisotropyKxToKy'
        prodml21__HorizontalAnisotropyKxToKy *HorizontalAnisotropyKxToKy;
        /// Optional element 'prodml21:OrientationOfAnisotropyXDirection' of XML schema type 'prodml21:OrientationOfAnisotropyXDirection'
        prodml21__OrientationOfAnisotropyXDirection *OrientationOfAnisotropyXDirection;
        /// Optional element 'prodml21:UpperBoundaryType' of XML schema type 'prodml21:UpperBoundaryType'
        prodml21__UpperBoundaryType *UpperBoundaryType;
        /// Optional element 'prodml21:LowerBoundaryType' of XML schema type 'prodml21:LowerBoundaryType'
        prodml21__LowerBoundaryType *LowerBoundaryType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReservoirBaseModel, default initialized and not managed by a soap context
        virtual prodml21__ReservoirBaseModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReservoirBaseModel); }
      public:
        /// Constructor with default initializations
        prodml21__ReservoirBaseModel() : HorizontalRadialPermeability(), TotalThickness(), PermeabilityThicknessProduct(), Porosity(), InitialPressure(), PressureDatumTVD(), AveragePressure(), VerticalAnisotropyKvToKr(), HorizontalAnisotropyKxToKy(), OrientationOfAnisotropyXDirection(), UpperBoundaryType(), LowerBoundaryType() { }
        virtual ~prodml21__ReservoirBaseModel() { }
        /// Friend allocator used by soap_new_prodml21__ReservoirBaseModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReservoirBaseModel * SOAP_FMAC2 soap_instantiate_prodml21__ReservoirBaseModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:878 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel (-374)
/* complex XML schema type 'prodml21:WellboreBaseModel': */
class SOAP_CMAC prodml21__WellboreBaseModel : public prodml21__AbstractModelSection {
      public:
        /// Required element 'prodml21:WellboreRadius' of XML schema type 'prodml21:WellboreRadius'
        prodml21__WellboreRadius *WellboreRadius;
        /// Required element 'prodml21:WellboreStorageCoefficient' of XML schema type 'prodml21:WellboreStorageCoefficient'
        prodml21__WellboreStorageCoefficient *WellboreStorageCoefficient;
        /// Optional element 'prodml21:WellboreVolume' of XML schema type 'prodml21:WellboreVolume'
        prodml21__WellboreVolume *WellboreVolume;
        /// Optional element 'prodml21:WellboreFluidCompressibility' of XML schema type 'prodml21:WellboreFluidCompressibility'
        prodml21__WellboreFluidCompressibility *WellboreFluidCompressibility;
        /// Optional element 'prodml21:TubingInteralDiameter' of XML schema type 'prodml21:TubingInteralDiameter'
        prodml21__TubingInteralDiameter *TubingInteralDiameter;
        /// Optional element 'prodml21:FluidDensity' of XML schema type 'prodml21:FluidDensity'
        prodml21__FluidDensity *FluidDensity;
        /// Optional element 'prodml21:WellboreDeviationAngle' of XML schema type 'prodml21:WellboreDeviationAngle'
        prodml21__WellboreDeviationAngle *WellboreDeviationAngle;
        /// Optional element 'prodml21:WellboreStorageMechanismType' of XML schema type 'prodml21:WellboreStorageMechanismType'
        prodml21__WellboreStorageMechanismType *WellboreStorageMechanismType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreBaseModel, default initialized and not managed by a soap context
        virtual prodml21__WellboreBaseModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreBaseModel); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreBaseModel() : WellboreRadius(), WellboreStorageCoefficient(), WellboreVolume(), WellboreFluidCompressibility(), TubingInteralDiameter(), FluidDensity(), WellboreDeviationAngle(), WellboreStorageMechanismType() { }
        virtual ~prodml21__WellboreBaseModel() { }
        /// Friend allocator used by soap_new_prodml21__WellboreBaseModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreBaseModel * SOAP_FMAC2 soap_instantiate_prodml21__WellboreBaseModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:882 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries (-376)
/* complex XML schema type 'prodml21:AngleBetweenBoundaries': */
class SOAP_CMAC prodml21__AngleBetweenBoundaries : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "AngleBetweenBoundaries"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AngleBetweenBoundaries, default initialized and not managed by a soap context
        virtual prodml21__AngleBetweenBoundaries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AngleBetweenBoundaries); }
      public:
        /// Constructor with default initializations
        prodml21__AngleBetweenBoundaries() : Abbreviation("AngleBetweenBoundaries"), Angle() { }
        virtual ~prodml21__AngleBetweenBoundaries() { }
        /// Friend allocator used by soap_new_prodml21__AngleBetweenBoundaries(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AngleBetweenBoundaries * SOAP_FMAC2 soap_instantiate_prodml21__AngleBetweenBoundaries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:884 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure (-377)
/* complex XML schema type 'prodml21:AveragePressure': */
class SOAP_CMAC prodml21__AveragePressure : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Pbar"
        /// Required element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AveragePressure, default initialized and not managed by a soap context
        virtual prodml21__AveragePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AveragePressure); }
      public:
        /// Constructor with default initializations
        prodml21__AveragePressure() : Abbreviation("Pbar"), Pressure() { }
        virtual ~prodml21__AveragePressure() { }
        /// Friend allocator used by soap_new_prodml21__AveragePressure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AveragePressure * SOAP_FMAC2 soap_instantiate_prodml21__AveragePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:886 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness (-378)
/* complex XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness': */
class SOAP_CMAC prodml21__ConvergenceSkinRelativeToTotalThickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Sconv"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConvergenceSkinRelativeToTotalThickness, default initialized and not managed by a soap context
        virtual prodml21__ConvergenceSkinRelativeToTotalThickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConvergenceSkinRelativeToTotalThickness); }
      public:
        /// Constructor with default initializations
        prodml21__ConvergenceSkinRelativeToTotalThickness() : Abbreviation("Sconv"), Value() { }
        virtual ~prodml21__ConvergenceSkinRelativeToTotalThickness() { }
        /// Friend allocator used by soap_new_prodml21__ConvergenceSkinRelativeToTotalThickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConvergenceSkinRelativeToTotalThickness * SOAP_FMAC2 soap_instantiate_prodml21__ConvergenceSkinRelativeToTotalThickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:888 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter (-379)
/* complex XML schema type 'prodml21:CustomParameter': */
class SOAP_CMAC prodml21__CustomParameter : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;
        /// Required element 'prodml21:MeasureValue' of XML schema type 'prodml21:GeneralMeasureType'
        prodml21__GeneralMeasureType *MeasureValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomParameter, default initialized and not managed by a soap context
        virtual prodml21__CustomParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomParameter); }
      public:
        /// Constructor with default initializations
        prodml21__CustomParameter() : Name(), Abbreviation(), MeasureValue() { }
        virtual ~prodml21__CustomParameter() { }
        /// Friend allocator used by soap_new_prodml21__CustomParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomParameter * SOAP_FMAC2 soap_instantiate_prodml21__CustomParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:890 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin (-380)
/* complex XML schema type 'prodml21:DeltaPressureTotalSkin': */
class SOAP_CMAC prodml21__DeltaPressureTotalSkin : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "dP Skin"
        /// Required element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeltaPressureTotalSkin, default initialized and not managed by a soap context
        virtual prodml21__DeltaPressureTotalSkin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeltaPressureTotalSkin); }
      public:
        /// Constructor with default initializations
        prodml21__DeltaPressureTotalSkin() : Abbreviation("dP Skin"), Pressure() { }
        virtual ~prodml21__DeltaPressureTotalSkin() { }
        /// Friend allocator used by soap_new_prodml21__DeltaPressureTotalSkin(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeltaPressureTotalSkin * SOAP_FMAC2 soap_instantiate_prodml21__DeltaPressureTotalSkin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:892 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges (-381)
/* complex XML schema type 'prodml21:DeltaTimeStorageChanges': */
class SOAP_CMAC prodml21__DeltaTimeStorageChanges : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "dT"
        /// Required element 'prodml21:Time' of XML schema type 'eml22:TimeMeasure'
        eml22__TimeMeasure *Time;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeltaTimeStorageChanges, default initialized and not managed by a soap context
        virtual prodml21__DeltaTimeStorageChanges *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeltaTimeStorageChanges); }
      public:
        /// Constructor with default initializations
        prodml21__DeltaTimeStorageChanges() : Abbreviation("dT"), Time() { }
        virtual ~prodml21__DeltaTimeStorageChanges() { }
        /// Friend allocator used by soap_new_prodml21__DeltaTimeStorageChanges(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeltaTimeStorageChanges * SOAP_FMAC2 soap_instantiate_prodml21__DeltaTimeStorageChanges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:894 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary (-382)
/* complex XML schema type 'prodml21:DistanceFractureToBottomBoundary': */
class SOAP_CMAC prodml21__DistanceFractureToBottomBoundary : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Zf"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceFractureToBottomBoundary, default initialized and not managed by a soap context
        virtual prodml21__DistanceFractureToBottomBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceFractureToBottomBoundary); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceFractureToBottomBoundary() : Abbreviation("Zf"), Length() { }
        virtual ~prodml21__DistanceFractureToBottomBoundary() { }
        /// Friend allocator used by soap_new_prodml21__DistanceFractureToBottomBoundary(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceFractureToBottomBoundary * SOAP_FMAC2 soap_instantiate_prodml21__DistanceFractureToBottomBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:896 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary (-383)
/* complex XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary': */
class SOAP_CMAC prodml21__DistanceMidFractureHeightToBottomBoundary : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Zf"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceMidFractureHeightToBottomBoundary, default initialized and not managed by a soap context
        virtual prodml21__DistanceMidFractureHeightToBottomBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceMidFractureHeightToBottomBoundary); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceMidFractureHeightToBottomBoundary() : Abbreviation("Zf"), Length() { }
        virtual ~prodml21__DistanceMidFractureHeightToBottomBoundary() { }
        /// Friend allocator used by soap_new_prodml21__DistanceMidFractureHeightToBottomBoundary(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceMidFractureHeightToBottomBoundary * SOAP_FMAC2 soap_instantiate_prodml21__DistanceMidFractureHeightToBottomBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:898 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary (-384)
/* complex XML schema type 'prodml21:DistanceMidPerforationsToBottomBoundary': */
class SOAP_CMAC prodml21__DistanceMidPerforationsToBottomBoundary : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Zp"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceMidPerforationsToBottomBoundary, default initialized and not managed by a soap context
        virtual prodml21__DistanceMidPerforationsToBottomBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceMidPerforationsToBottomBoundary); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceMidPerforationsToBottomBoundary() : Abbreviation("Zp"), Length() { }
        virtual ~prodml21__DistanceMidPerforationsToBottomBoundary() { }
        /// Friend allocator used by soap_new_prodml21__DistanceMidPerforationsToBottomBoundary(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceMidPerforationsToBottomBoundary * SOAP_FMAC2 soap_instantiate_prodml21__DistanceMidPerforationsToBottomBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:900 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1 (-385)
/* complex XML schema type 'prodml21:DistanceToBoundary1': */
class SOAP_CMAC prodml21__DistanceToBoundary1 : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "L1"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToBoundary1, default initialized and not managed by a soap context
        virtual prodml21__DistanceToBoundary1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToBoundary1); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToBoundary1() : Abbreviation("L1"), Length() { }
        virtual ~prodml21__DistanceToBoundary1() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToBoundary1(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToBoundary1 * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToBoundary1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:902 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2 (-386)
/* complex XML schema type 'prodml21:DistanceToBoundary2': */
class SOAP_CMAC prodml21__DistanceToBoundary2 : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "L2"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToBoundary2, default initialized and not managed by a soap context
        virtual prodml21__DistanceToBoundary2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToBoundary2); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToBoundary2() : Abbreviation("L2"), Length() { }
        virtual ~prodml21__DistanceToBoundary2() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToBoundary2(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToBoundary2 * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToBoundary2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:904 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3 (-387)
/* complex XML schema type 'prodml21:DistanceToBoundary3': */
class SOAP_CMAC prodml21__DistanceToBoundary3 : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "L3"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToBoundary3, default initialized and not managed by a soap context
        virtual prodml21__DistanceToBoundary3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToBoundary3); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToBoundary3() : Abbreviation("L3"), Length() { }
        virtual ~prodml21__DistanceToBoundary3() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToBoundary3(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToBoundary3 * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToBoundary3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:906 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4 (-388)
/* complex XML schema type 'prodml21:DistanceToBoundary4': */
class SOAP_CMAC prodml21__DistanceToBoundary4 : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "L4"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToBoundary4, default initialized and not managed by a soap context
        virtual prodml21__DistanceToBoundary4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToBoundary4); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToBoundary4() : Abbreviation("L4"), Length() { }
        virtual ~prodml21__DistanceToBoundary4() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToBoundary4(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToBoundary4 * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToBoundary4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:908 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface (-389)
/* complex XML schema type 'prodml21:DistanceToMobilityInterface': */
class SOAP_CMAC prodml21__DistanceToMobilityInterface : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Li"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToMobilityInterface, default initialized and not managed by a soap context
        virtual prodml21__DistanceToMobilityInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToMobilityInterface); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToMobilityInterface() : Abbreviation("Li"), Length() { }
        virtual ~prodml21__DistanceToMobilityInterface() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToMobilityInterface(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToMobilityInterface * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToMobilityInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:910 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut (-390)
/* complex XML schema type 'prodml21:DistanceToPinchOut': */
class SOAP_CMAC prodml21__DistanceToPinchOut : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Lpinch"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceToPinchOut, default initialized and not managed by a soap context
        virtual prodml21__DistanceToPinchOut *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceToPinchOut); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceToPinchOut() : Abbreviation("Lpinch"), Length() { }
        virtual ~prodml21__DistanceToPinchOut() { }
        /// Friend allocator used by soap_new_prodml21__DistanceToPinchOut(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceToPinchOut * SOAP_FMAC2 soap_instantiate_prodml21__DistanceToPinchOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:912 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary (-391)
/* complex XML schema type 'prodml21:DistanceWellboreToBottomBoundary': */
class SOAP_CMAC prodml21__DistanceWellboreToBottomBoundary : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Zw"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DistanceWellboreToBottomBoundary, default initialized and not managed by a soap context
        virtual prodml21__DistanceWellboreToBottomBoundary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DistanceWellboreToBottomBoundary); }
      public:
        /// Constructor with default initializations
        prodml21__DistanceWellboreToBottomBoundary() : Abbreviation("Zw"), Length() { }
        virtual ~prodml21__DistanceWellboreToBottomBoundary() { }
        /// Friend allocator used by soap_new_prodml21__DistanceWellboreToBottomBoundary(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DistanceWellboreToBottomBoundary * SOAP_FMAC2 soap_instantiate_prodml21__DistanceWellboreToBottomBoundary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:914 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured (-392)
/* complex XML schema type 'prodml21:DrainageAreaMeasured': */
class SOAP_CMAC prodml21__DrainageAreaMeasured : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "A"
        /// Required element 'prodml21:Area' of XML schema type 'eml22:AreaMeasure'
        eml22__AreaMeasure *Area;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DrainageAreaMeasured, default initialized and not managed by a soap context
        virtual prodml21__DrainageAreaMeasured *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DrainageAreaMeasured); }
      public:
        /// Constructor with default initializations
        prodml21__DrainageAreaMeasured() : Abbreviation("A"), Area() { }
        virtual ~prodml21__DrainageAreaMeasured() { }
        /// Friend allocator used by soap_new_prodml21__DrainageAreaMeasured(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DrainageAreaMeasured * SOAP_FMAC2 soap_instantiate_prodml21__DrainageAreaMeasured(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:916 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity (-393)
/* complex XML schema type 'prodml21:FaultConductivity': */
class SOAP_CMAC prodml21__FaultConductivity : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Fc"
        /// Required element 'prodml21:PermeabilityLength' of XML schema type 'eml22:PermeabilityLengthMeasureExt'
        eml22__PermeabilityLengthMeasureExt *PermeabilityLength;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FaultConductivity, default initialized and not managed by a soap context
        virtual prodml21__FaultConductivity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FaultConductivity); }
      public:
        /// Constructor with default initializations
        prodml21__FaultConductivity() : Abbreviation("Fc"), PermeabilityLength() { }
        virtual ~prodml21__FaultConductivity() { }
        /// Friend allocator used by soap_new_prodml21__FaultConductivity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FaultConductivity * SOAP_FMAC2 soap_instantiate_prodml21__FaultConductivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:918 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity (-394)
/* complex XML schema type 'prodml21:FluidDensity': */
class SOAP_CMAC prodml21__FluidDensity : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Rho"
        /// Required element 'prodml21:Density' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *Density;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidDensity, default initialized and not managed by a soap context
        virtual prodml21__FluidDensity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidDensity); }
      public:
        /// Constructor with default initializations
        prodml21__FluidDensity() : Abbreviation("Rho"), Density() { }
        virtual ~prodml21__FluidDensity() { }
        /// Friend allocator used by soap_new_prodml21__FluidDensity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidDensity * SOAP_FMAC2 soap_instantiate_prodml21__FluidDensity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:920 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore (-395)
/* complex XML schema type 'prodml21:FractureAngleToWellbore': */
class SOAP_CMAC prodml21__FractureAngleToWellbore : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "FractureAngleToWellbore"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureAngleToWellbore, default initialized and not managed by a soap context
        virtual prodml21__FractureAngleToWellbore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureAngleToWellbore); }
      public:
        /// Constructor with default initializations
        prodml21__FractureAngleToWellbore() : Abbreviation("FractureAngleToWellbore"), Angle() { }
        virtual ~prodml21__FractureAngleToWellbore() { }
        /// Friend allocator used by soap_new_prodml21__FractureAngleToWellbore(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureAngleToWellbore * SOAP_FMAC2 soap_instantiate_prodml21__FractureAngleToWellbore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:922 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity (-396)
/* complex XML schema type 'prodml21:FractureConductivity': */
class SOAP_CMAC prodml21__FractureConductivity : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Fc"
        /// Required element 'prodml21:PermeabilityLength' of XML schema type 'eml22:PermeabilityLengthMeasureExt'
        eml22__PermeabilityLengthMeasureExt *PermeabilityLength;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureConductivity, default initialized and not managed by a soap context
        virtual prodml21__FractureConductivity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureConductivity); }
      public:
        /// Constructor with default initializations
        prodml21__FractureConductivity() : Abbreviation("Fc"), PermeabilityLength() { }
        virtual ~prodml21__FractureConductivity() { }
        /// Friend allocator used by soap_new_prodml21__FractureConductivity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureConductivity * SOAP_FMAC2 soap_instantiate_prodml21__FractureConductivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:924 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin (-397)
/* complex XML schema type 'prodml21:FractureFaceSkin': */
class SOAP_CMAC prodml21__FractureFaceSkin : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Sf"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureFaceSkin, default initialized and not managed by a soap context
        virtual prodml21__FractureFaceSkin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureFaceSkin); }
      public:
        /// Constructor with default initializations
        prodml21__FractureFaceSkin() : Abbreviation("Sf"), Value() { }
        virtual ~prodml21__FractureFaceSkin() { }
        /// Friend allocator used by soap_new_prodml21__FractureFaceSkin(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureFaceSkin * SOAP_FMAC2 soap_instantiate_prodml21__FractureFaceSkin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:926 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength (-398)
/* complex XML schema type 'prodml21:FractureHalfLength': */
class SOAP_CMAC prodml21__FractureHalfLength : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Xf"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureHalfLength, default initialized and not managed by a soap context
        virtual prodml21__FractureHalfLength *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureHalfLength); }
      public:
        /// Constructor with default initializations
        prodml21__FractureHalfLength() : Abbreviation("Xf"), Length() { }
        virtual ~prodml21__FractureHalfLength() { }
        /// Friend allocator used by soap_new_prodml21__FractureHalfLength(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureHalfLength * SOAP_FMAC2 soap_instantiate_prodml21__FractureHalfLength(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:928 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight (-399)
/* complex XML schema type 'prodml21:FractureHeight': */
class SOAP_CMAC prodml21__FractureHeight : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Hf"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureHeight, default initialized and not managed by a soap context
        virtual prodml21__FractureHeight *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureHeight); }
      public:
        /// Constructor with default initializations
        prodml21__FractureHeight() : Abbreviation("Hf"), Length() { }
        virtual ~prodml21__FractureHeight() { }
        /// Friend allocator used by soap_new_prodml21__FractureHeight(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureHeight * SOAP_FMAC2 soap_instantiate_prodml21__FractureHeight(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:930 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius (-400)
/* complex XML schema type 'prodml21:FractureRadius': */
class SOAP_CMAC prodml21__FractureRadius : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:abbreviation' of XML schema type 'xsd:string'
        std::string abbreviation;	///< initialized with fixed value = "Rf"
        /// Required element 'prodml21:length' of XML schema type 'xsd:string'
        std::string length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureRadius, default initialized and not managed by a soap context
        virtual prodml21__FractureRadius *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureRadius); }
      public:
        /// Constructor with default initializations
        prodml21__FractureRadius() : abbreviation("Rf"), length() { }
        virtual ~prodml21__FractureRadius() { }
        /// Friend allocator used by soap_new_prodml21__FractureRadius(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureRadius * SOAP_FMAC2 soap_instantiate_prodml21__FractureRadius(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:932 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio (-401)
/* complex XML schema type 'prodml21:FractureStorativityRatio': */
class SOAP_CMAC prodml21__FractureStorativityRatio : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "etaD"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FractureStorativityRatio, default initialized and not managed by a soap context
        virtual prodml21__FractureStorativityRatio *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FractureStorativityRatio); }
      public:
        /// Constructor with default initializations
        prodml21__FractureStorativityRatio() : Abbreviation("etaD"), Value() { }
        virtual ~prodml21__FractureStorativityRatio() { }
        /// Friend allocator used by soap_new_prodml21__FractureStorativityRatio(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FractureStorativityRatio * SOAP_FMAC2 soap_instantiate_prodml21__FractureStorativityRatio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:934 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy (-402)
/* complex XML schema type 'prodml21:HorizontalAnisotropyKxToKy': */
class SOAP_CMAC prodml21__HorizontalAnisotropyKxToKy : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "kxToky"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalAnisotropyKxToKy, default initialized and not managed by a soap context
        virtual prodml21__HorizontalAnisotropyKxToKy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalAnisotropyKxToKy); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalAnisotropyKxToKy() : Abbreviation("kxToky"), Value() { }
        virtual ~prodml21__HorizontalAnisotropyKxToKy() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalAnisotropyKxToKy(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalAnisotropyKxToKy * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalAnisotropyKxToKy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:936 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability (-403)
/* complex XML schema type 'prodml21:HorizontalRadialPermeability': */
class SOAP_CMAC prodml21__HorizontalRadialPermeability : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "K"
        /// Required element 'prodml21:Permeability' of XML schema type 'eml22:PermeabilityRockMeasureExt'
        eml22__PermeabilityRockMeasureExt *Permeability;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalRadialPermeability, default initialized and not managed by a soap context
        virtual prodml21__HorizontalRadialPermeability *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalRadialPermeability); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalRadialPermeability() : Abbreviation("K"), Permeability() { }
        virtual ~prodml21__HorizontalRadialPermeability() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalRadialPermeability(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalRadialPermeability * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalRadialPermeability(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:938 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure (-404)
/* complex XML schema type 'prodml21:InitialPressure': */
class SOAP_CMAC prodml21__InitialPressure : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Pi"
        /// Required element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InitialPressure, default initialized and not managed by a soap context
        virtual prodml21__InitialPressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InitialPressure); }
      public:
        /// Constructor with default initializations
        prodml21__InitialPressure() : Abbreviation("Pi"), Pressure() { }
        virtual ~prodml21__InitialPressure() { }
        /// Friend allocator used by soap_new_prodml21__InitialPressure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InitialPressure * SOAP_FMAC2 soap_instantiate_prodml21__InitialPressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:940 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio (-405)
/* complex XML schema type 'prodml21:InnerToOuterZoneDiffusivityRatio': */
class SOAP_CMAC prodml21__InnerToOuterZoneDiffusivityRatio : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "D"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InnerToOuterZoneDiffusivityRatio, default initialized and not managed by a soap context
        virtual prodml21__InnerToOuterZoneDiffusivityRatio *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InnerToOuterZoneDiffusivityRatio); }
      public:
        /// Constructor with default initializations
        prodml21__InnerToOuterZoneDiffusivityRatio() : Abbreviation("D"), Value() { }
        virtual ~prodml21__InnerToOuterZoneDiffusivityRatio() { }
        /// Friend allocator used by soap_new_prodml21__InnerToOuterZoneDiffusivityRatio(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InnerToOuterZoneDiffusivityRatio * SOAP_FMAC2 soap_instantiate_prodml21__InnerToOuterZoneDiffusivityRatio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:942 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio (-406)
/* complex XML schema type 'prodml21:InnerToOuterZoneMobilityRatio': */
class SOAP_CMAC prodml21__InnerToOuterZoneMobilityRatio : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "M"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InnerToOuterZoneMobilityRatio, default initialized and not managed by a soap context
        virtual prodml21__InnerToOuterZoneMobilityRatio *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InnerToOuterZoneMobilityRatio); }
      public:
        /// Constructor with default initializations
        prodml21__InnerToOuterZoneMobilityRatio() : Abbreviation("M"), Value() { }
        virtual ~prodml21__InnerToOuterZoneMobilityRatio() { }
        /// Friend allocator used by soap_new_prodml21__InnerToOuterZoneMobilityRatio(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InnerToOuterZoneMobilityRatio * SOAP_FMAC2 soap_instantiate_prodml21__InnerToOuterZoneMobilityRatio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:944 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter (-407)
/* complex XML schema type 'prodml21:InterporosityFlowParameter': */
class SOAP_CMAC prodml21__InterporosityFlowParameter : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Lambda"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InterporosityFlowParameter, default initialized and not managed by a soap context
        virtual prodml21__InterporosityFlowParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InterporosityFlowParameter); }
      public:
        /// Constructor with default initializations
        prodml21__InterporosityFlowParameter() : Abbreviation("Lambda"), Value() { }
        virtual ~prodml21__InterporosityFlowParameter() { }
        /// Friend allocator used by soap_new_prodml21__InterporosityFlowParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InterporosityFlowParameter * SOAP_FMAC2 soap_instantiate_prodml21__InterporosityFlowParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:946 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness (-408)
/* complex XML schema type 'prodml21:Layer2Thickness': */
class SOAP_CMAC prodml21__Layer2Thickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "h layer 2"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Layer2Thickness, default initialized and not managed by a soap context
        virtual prodml21__Layer2Thickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Layer2Thickness); }
      public:
        /// Constructor with default initializations
        prodml21__Layer2Thickness() : Abbreviation("h layer 2"), Length() { }
        virtual ~prodml21__Layer2Thickness() { }
        /// Friend allocator used by soap_new_prodml21__Layer2Thickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Layer2Thickness * SOAP_FMAC2 soap_instantiate_prodml21__Layer2Thickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:948 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin (-409)
/* complex XML schema type 'prodml21:LeakSkin': */
class SOAP_CMAC prodml21__LeakSkin : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Sl"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LeakSkin, default initialized and not managed by a soap context
        virtual prodml21__LeakSkin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LeakSkin); }
      public:
        /// Constructor with default initializations
        prodml21__LeakSkin() : Abbreviation("Sl"), Value() { }
        virtual ~prodml21__LeakSkin() { }
        /// Friend allocator used by soap_new_prodml21__LeakSkin(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LeakSkin * SOAP_FMAC2 soap_instantiate_prodml21__LeakSkin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:950 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing (-410)
/* complex XML schema type 'prodml21:LengthHorizontalWellboreFlowing': */
class SOAP_CMAC prodml21__LengthHorizontalWellboreFlowing : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "hw"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LengthHorizontalWellboreFlowing, default initialized and not managed by a soap context
        virtual prodml21__LengthHorizontalWellboreFlowing *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LengthHorizontalWellboreFlowing); }
      public:
        /// Constructor with default initializations
        prodml21__LengthHorizontalWellboreFlowing() : Abbreviation("hw"), Length() { }
        virtual ~prodml21__LengthHorizontalWellboreFlowing() { }
        /// Friend allocator used by soap_new_prodml21__LengthHorizontalWellboreFlowing(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LengthHorizontalWellboreFlowing * SOAP_FMAC2 soap_instantiate_prodml21__LengthHorizontalWellboreFlowing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:952 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness (-411)
/* complex XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness': */
class SOAP_CMAC prodml21__MechanicalSkinRelativeToTotalThickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Smech"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MechanicalSkinRelativeToTotalThickness, default initialized and not managed by a soap context
        virtual prodml21__MechanicalSkinRelativeToTotalThickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MechanicalSkinRelativeToTotalThickness); }
      public:
        /// Constructor with default initializations
        prodml21__MechanicalSkinRelativeToTotalThickness() : Abbreviation("Smech"), Value() { }
        virtual ~prodml21__MechanicalSkinRelativeToTotalThickness() { }
        /// Friend allocator used by soap_new_prodml21__MechanicalSkinRelativeToTotalThickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MechanicalSkinRelativeToTotalThickness * SOAP_FMAC2 soap_instantiate_prodml21__MechanicalSkinRelativeToTotalThickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:954 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName (-412)
/* complex XML schema type 'prodml21:ModelName': */
class SOAP_CMAC prodml21__ModelName : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "ModelName"
        /// Required element 'prodml21:Name' of XML schema type 'eml22:String64'
        std::string Name;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ModelName, default initialized and not managed by a soap context
        virtual prodml21__ModelName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ModelName); }
      public:
        /// Constructor with default initializations
        prodml21__ModelName() : Abbreviation("ModelName"), Name() { }
        virtual ~prodml21__ModelName() { }
        /// Friend allocator used by soap_new_prodml21__ModelName(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ModelName * SOAP_FMAC2 soap_instantiate_prodml21__ModelName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:956 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures (-413)
/* complex XML schema type 'prodml21:NumberOfFractures': */
class SOAP_CMAC prodml21__NumberOfFractures : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Nf"
        /// Required element 'prodml21:Number' of XML schema type 'xsd:integer'
        LONG64 Number;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NumberOfFractures, default initialized and not managed by a soap context
        virtual prodml21__NumberOfFractures *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NumberOfFractures); }
      public:
        /// Constructor with default initializations
        prodml21__NumberOfFractures() : Abbreviation("Nf"), Number() { }
        virtual ~prodml21__NumberOfFractures() { }
        /// Friend allocator used by soap_new_prodml21__NumberOfFractures(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NumberOfFractures * SOAP_FMAC2 soap_instantiate_prodml21__NumberOfFractures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:958 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection (-414)
/* complex XML schema type 'prodml21:OrientationOfAnisotropyXDirection': */
class SOAP_CMAC prodml21__OrientationOfAnisotropyXDirection : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "OrientationOfAnisotropy_XDirection"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OrientationOfAnisotropyXDirection, default initialized and not managed by a soap context
        virtual prodml21__OrientationOfAnisotropyXDirection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OrientationOfAnisotropyXDirection); }
      public:
        /// Constructor with default initializations
        prodml21__OrientationOfAnisotropyXDirection() : Abbreviation("OrientationOfAnisotropy_XDirection"), Angle() { }
        virtual ~prodml21__OrientationOfAnisotropyXDirection() { }
        /// Friend allocator used by soap_new_prodml21__OrientationOfAnisotropyXDirection(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OrientationOfAnisotropyXDirection * SOAP_FMAC2 soap_instantiate_prodml21__OrientationOfAnisotropyXDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:960 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane (-415)
/* complex XML schema type 'prodml21:OrientationOfFracturePlane': */
class SOAP_CMAC prodml21__OrientationOfFracturePlane : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "OrientationOfFracturePlane"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OrientationOfFracturePlane, default initialized and not managed by a soap context
        virtual prodml21__OrientationOfFracturePlane *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OrientationOfFracturePlane); }
      public:
        /// Constructor with default initializations
        prodml21__OrientationOfFracturePlane() : Abbreviation("OrientationOfFracturePlane"), Angle() { }
        virtual ~prodml21__OrientationOfFracturePlane() { }
        /// Friend allocator used by soap_new_prodml21__OrientationOfFracturePlane(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OrientationOfFracturePlane * SOAP_FMAC2 soap_instantiate_prodml21__OrientationOfFracturePlane(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:962 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront (-416)
/* complex XML schema type 'prodml21:OrientationOfLinearFront': */
class SOAP_CMAC prodml21__OrientationOfLinearFront : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "OrientationOfLinearFront"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OrientationOfLinearFront, default initialized and not managed by a soap context
        virtual prodml21__OrientationOfLinearFront *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OrientationOfLinearFront); }
      public:
        /// Constructor with default initializations
        prodml21__OrientationOfLinearFront() : Abbreviation("OrientationOfLinearFront"), Angle() { }
        virtual ~prodml21__OrientationOfLinearFront() { }
        /// Friend allocator used by soap_new_prodml21__OrientationOfLinearFront(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OrientationOfLinearFront * SOAP_FMAC2 soap_instantiate_prodml21__OrientationOfLinearFront(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:964 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1 (-417)
/* complex XML schema type 'prodml21:OrientationOfNormalToBoundary1': */
class SOAP_CMAC prodml21__OrientationOfNormalToBoundary1 : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "OrientationOfNormalToBoundary1"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OrientationOfNormalToBoundary1, default initialized and not managed by a soap context
        virtual prodml21__OrientationOfNormalToBoundary1 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OrientationOfNormalToBoundary1); }
      public:
        /// Constructor with default initializations
        prodml21__OrientationOfNormalToBoundary1() : Abbreviation("OrientationOfNormalToBoundary1"), Angle() { }
        virtual ~prodml21__OrientationOfNormalToBoundary1() { }
        /// Friend allocator used by soap_new_prodml21__OrientationOfNormalToBoundary1(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OrientationOfNormalToBoundary1 * SOAP_FMAC2 soap_instantiate_prodml21__OrientationOfNormalToBoundary1(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:966 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory (-418)
/* complex XML schema type 'prodml21:OrientationWellTrajectory': */
class SOAP_CMAC prodml21__OrientationWellTrajectory : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "OrientationWellTrajectory"
        /// Required element 'prodml21:Angle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *Angle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OrientationWellTrajectory, default initialized and not managed by a soap context
        virtual prodml21__OrientationWellTrajectory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OrientationWellTrajectory); }
      public:
        /// Constructor with default initializations
        prodml21__OrientationWellTrajectory() : Abbreviation("OrientationWellTrajectory"), Angle() { }
        virtual ~prodml21__OrientationWellTrajectory() { }
        /// Friend allocator used by soap_new_prodml21__OrientationWellTrajectory(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OrientationWellTrajectory * SOAP_FMAC2 soap_instantiate_prodml21__OrientationWellTrajectory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:968 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength (-419)
/* complex XML schema type 'prodml21:PerforatedLength': */
class SOAP_CMAC prodml21__PerforatedLength : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "hp"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PerforatedLength, default initialized and not managed by a soap context
        virtual prodml21__PerforatedLength *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PerforatedLength); }
      public:
        /// Constructor with default initializations
        prodml21__PerforatedLength() : Abbreviation("hp"), Length() { }
        virtual ~prodml21__PerforatedLength() { }
        /// Friend allocator used by soap_new_prodml21__PerforatedLength(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PerforatedLength * SOAP_FMAC2 soap_instantiate_prodml21__PerforatedLength(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:970 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct (-420)
/* complex XML schema type 'prodml21:PermeabilityThicknessProduct': */
class SOAP_CMAC prodml21__PermeabilityThicknessProduct : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "k.h"
        /// Required element 'prodml21:PermeabilityLength' of XML schema type 'eml22:PermeabilityLengthMeasureExt'
        eml22__PermeabilityLengthMeasureExt *PermeabilityLength;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PermeabilityThicknessProduct, default initialized and not managed by a soap context
        virtual prodml21__PermeabilityThicknessProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PermeabilityThicknessProduct); }
      public:
        /// Constructor with default initializations
        prodml21__PermeabilityThicknessProduct() : Abbreviation("k.h"), PermeabilityLength() { }
        virtual ~prodml21__PermeabilityThicknessProduct() { }
        /// Friend allocator used by soap_new_prodml21__PermeabilityThicknessProduct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PermeabilityThicknessProduct * SOAP_FMAC2 soap_instantiate_prodml21__PermeabilityThicknessProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:972 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured (-421)
/* complex XML schema type 'prodml21:PoreVolumeMeasured': */
class SOAP_CMAC prodml21__PoreVolumeMeasured : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "PVmeas"
        /// Required element 'prodml21:Volume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Volume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PoreVolumeMeasured, default initialized and not managed by a soap context
        virtual prodml21__PoreVolumeMeasured *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PoreVolumeMeasured); }
      public:
        /// Constructor with default initializations
        prodml21__PoreVolumeMeasured() : Abbreviation("PVmeas"), Volume() { }
        virtual ~prodml21__PoreVolumeMeasured() { }
        /// Friend allocator used by soap_new_prodml21__PoreVolumeMeasured(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PoreVolumeMeasured * SOAP_FMAC2 soap_instantiate_prodml21__PoreVolumeMeasured(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:974 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation (-422)
/* complex XML schema type 'prodml21:PoreVolumeOfInvestigation': */
class SOAP_CMAC prodml21__PoreVolumeOfInvestigation : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "PVinv"
        /// Required element 'prodml21:Volume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Volume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PoreVolumeOfInvestigation, default initialized and not managed by a soap context
        virtual prodml21__PoreVolumeOfInvestigation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PoreVolumeOfInvestigation); }
      public:
        /// Constructor with default initializations
        prodml21__PoreVolumeOfInvestigation() : Abbreviation("PVinv"), Volume() { }
        virtual ~prodml21__PoreVolumeOfInvestigation() { }
        /// Friend allocator used by soap_new_prodml21__PoreVolumeOfInvestigation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PoreVolumeOfInvestigation * SOAP_FMAC2 soap_instantiate_prodml21__PoreVolumeOfInvestigation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:976 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity (-423)
/* complex XML schema type 'prodml21:Porosity': */
class SOAP_CMAC prodml21__Porosity : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Phi"
        /// Required element 'prodml21:VolumePerVolume' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *VolumePerVolume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Porosity, default initialized and not managed by a soap context
        virtual prodml21__Porosity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Porosity); }
      public:
        /// Constructor with default initializations
        prodml21__Porosity() : Abbreviation("Phi"), VolumePerVolume() { }
        virtual ~prodml21__Porosity() { }
        /// Friend allocator used by soap_new_prodml21__Porosity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Porosity * SOAP_FMAC2 soap_instantiate_prodml21__Porosity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:978 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD (-424)
/* complex XML schema type 'prodml21:PressureDatumTVD': */
class SOAP_CMAC prodml21__PressureDatumTVD : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "datum"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PressureDatumTVD, default initialized and not managed by a soap context
        virtual prodml21__PressureDatumTVD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PressureDatumTVD); }
      public:
        /// Constructor with default initializations
        prodml21__PressureDatumTVD() : Abbreviation("datum"), Length() { }
        virtual ~prodml21__PressureDatumTVD() { }
        /// Friend allocator used by soap_new_prodml21__PressureDatumTVD(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PressureDatumTVD * SOAP_FMAC2 soap_instantiate_prodml21__PressureDatumTVD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:980 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation (-425)
/* complex XML schema type 'prodml21:RadiusOfInvestigation': */
class SOAP_CMAC prodml21__RadiusOfInvestigation : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Ri"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RadiusOfInvestigation, default initialized and not managed by a soap context
        virtual prodml21__RadiusOfInvestigation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RadiusOfInvestigation); }
      public:
        /// Constructor with default initializations
        prodml21__RadiusOfInvestigation() : Abbreviation("Ri"), Length() { }
        virtual ~prodml21__RadiusOfInvestigation() { }
        /// Friend allocator used by soap_new_prodml21__RadiusOfInvestigation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RadiusOfInvestigation * SOAP_FMAC2 soap_instantiate_prodml21__RadiusOfInvestigation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:982 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor (-426)
/* complex XML schema type 'prodml21:RateDependentSkinFactor': */
class SOAP_CMAC prodml21__RateDependentSkinFactor : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "D"
        /// Required element 'prodml21:InverseFlowrate' of XML schema type 'eml22:TimePerVolumeMeasureExt'
        eml22__TimePerVolumeMeasureExt *InverseFlowrate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RateDependentSkinFactor, default initialized and not managed by a soap context
        virtual prodml21__RateDependentSkinFactor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RateDependentSkinFactor); }
      public:
        /// Constructor with default initializations
        prodml21__RateDependentSkinFactor() : Abbreviation("D"), InverseFlowrate() { }
        virtual ~prodml21__RateDependentSkinFactor() { }
        /// Friend allocator used by soap_new_prodml21__RateDependentSkinFactor(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RateDependentSkinFactor * SOAP_FMAC2 soap_instantiate_prodml21__RateDependentSkinFactor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:984 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown (-427)
/* complex XML schema type 'prodml21:RatioDpSkinToTotalDrawdown': */
class SOAP_CMAC prodml21__RatioDpSkinToTotalDrawdown : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Ratio dP Skin To Total"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RatioDpSkinToTotalDrawdown, default initialized and not managed by a soap context
        virtual prodml21__RatioDpSkinToTotalDrawdown *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RatioDpSkinToTotalDrawdown); }
      public:
        /// Constructor with default initializations
        prodml21__RatioDpSkinToTotalDrawdown() : Abbreviation("Ratio dP Skin To Total"), Value() { }
        virtual ~prodml21__RatioDpSkinToTotalDrawdown() { }
        /// Friend allocator used by soap_new_prodml21__RatioDpSkinToTotalDrawdown(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RatioDpSkinToTotalDrawdown * SOAP_FMAC2 soap_instantiate_prodml21__RatioDpSkinToTotalDrawdown(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:986 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage (-428)
/* complex XML schema type 'prodml21:RatioInitialToFinalWellboreStorage': */
class SOAP_CMAC prodml21__RatioInitialToFinalWellboreStorage : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Ci/Cs"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RatioInitialToFinalWellboreStorage, default initialized and not managed by a soap context
        virtual prodml21__RatioInitialToFinalWellboreStorage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RatioInitialToFinalWellboreStorage); }
      public:
        /// Constructor with default initializations
        prodml21__RatioInitialToFinalWellboreStorage() : Abbreviation("Ci/Cs"), Value() { }
        virtual ~prodml21__RatioInitialToFinalWellboreStorage() { }
        /// Friend allocator used by soap_new_prodml21__RatioInitialToFinalWellboreStorage(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RatioInitialToFinalWellboreStorage * SOAP_FMAC2 soap_instantiate_prodml21__RatioInitialToFinalWellboreStorage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:988 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct (-429)
/* complex XML schema type 'prodml21:RatioLayer1ToTotalPermeabilityThicknessProduct': */
class SOAP_CMAC prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Kappa"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct, default initialized and not managed by a soap context
        virtual prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct); }
      public:
        /// Constructor with default initializations
        prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct() : Abbreviation("Kappa"), Value() { }
        virtual ~prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct() { }
        /// Friend allocator used by soap_new_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct * SOAP_FMAC2 soap_instantiate_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:990 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness (-430)
/* complex XML schema type 'prodml21:Region2Thickness': */
class SOAP_CMAC prodml21__Region2Thickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "h region 2"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Region2Thickness, default initialized and not managed by a soap context
        virtual prodml21__Region2Thickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Region2Thickness); }
      public:
        /// Constructor with default initializations
        prodml21__Region2Thickness() : Abbreviation("h region 2"), Length() { }
        virtual ~prodml21__Region2Thickness() { }
        /// Friend allocator used by soap_new_prodml21__Region2Thickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Region2Thickness * SOAP_FMAC2 soap_instantiate_prodml21__Region2Thickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:992 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness (-431)
/* complex XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness': */
class SOAP_CMAC prodml21__SkinLayer2RelativeToTotalThickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "S2"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SkinLayer2RelativeToTotalThickness, default initialized and not managed by a soap context
        virtual prodml21__SkinLayer2RelativeToTotalThickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SkinLayer2RelativeToTotalThickness); }
      public:
        /// Constructor with default initializations
        prodml21__SkinLayer2RelativeToTotalThickness() : Abbreviation("S2"), Value() { }
        virtual ~prodml21__SkinLayer2RelativeToTotalThickness() { }
        /// Friend allocator used by soap_new_prodml21__SkinLayer2RelativeToTotalThickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SkinLayer2RelativeToTotalThickness * SOAP_FMAC2 soap_instantiate_prodml21__SkinLayer2RelativeToTotalThickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:994 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness (-432)
/* complex XML schema type 'prodml21:SkinRelativeToTotalThickness': */
class SOAP_CMAC prodml21__SkinRelativeToTotalThickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "S"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SkinRelativeToTotalThickness, default initialized and not managed by a soap context
        virtual prodml21__SkinRelativeToTotalThickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SkinRelativeToTotalThickness); }
      public:
        /// Constructor with default initializations
        prodml21__SkinRelativeToTotalThickness() : Abbreviation("S"), Value() { }
        virtual ~prodml21__SkinRelativeToTotalThickness() { }
        /// Friend allocator used by soap_new_prodml21__SkinRelativeToTotalThickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SkinRelativeToTotalThickness * SOAP_FMAC2 soap_instantiate_prodml21__SkinRelativeToTotalThickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:996 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio (-433)
/* complex XML schema type 'prodml21:StorativityRatio': */
class SOAP_CMAC prodml21__StorativityRatio : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Omega"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StorativityRatio, default initialized and not managed by a soap context
        virtual prodml21__StorativityRatio *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StorativityRatio); }
      public:
        /// Constructor with default initializations
        prodml21__StorativityRatio() : Abbreviation("Omega"), Value() { }
        virtual ~prodml21__StorativityRatio() { }
        /// Friend allocator used by soap_new_prodml21__StorativityRatio(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StorativityRatio * SOAP_FMAC2 soap_instantiate_prodml21__StorativityRatio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:998 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness (-434)
/* complex XML schema type 'prodml21:TotalThickness': */
class SOAP_CMAC prodml21__TotalThickness : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "h"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TotalThickness, default initialized and not managed by a soap context
        virtual prodml21__TotalThickness *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TotalThickness); }
      public:
        /// Constructor with default initializations
        prodml21__TotalThickness() : Abbreviation("h"), Length() { }
        virtual ~prodml21__TotalThickness() { }
        /// Friend allocator used by soap_new_prodml21__TotalThickness(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TotalThickness * SOAP_FMAC2 soap_instantiate_prodml21__TotalThickness(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1000 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront (-435)
/* complex XML schema type 'prodml21:TransmissibilityReductionFactorOfLinearFront': */
class SOAP_CMAC prodml21__TransmissibilityReductionFactorOfLinearFront : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:abbreviation' of XML schema type 'xsd:string'
        std::string abbreviation;	///< initialized with fixed value = "Leakage"
        /// Required element 'prodml21:value' of XML schema type 'xsd:string'
        std::string value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TransmissibilityReductionFactorOfLinearFront, default initialized and not managed by a soap context
        virtual prodml21__TransmissibilityReductionFactorOfLinearFront *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TransmissibilityReductionFactorOfLinearFront); }
      public:
        /// Constructor with default initializations
        prodml21__TransmissibilityReductionFactorOfLinearFront() : abbreviation("Leakage"), value() { }
        virtual ~prodml21__TransmissibilityReductionFactorOfLinearFront() { }
        /// Friend allocator used by soap_new_prodml21__TransmissibilityReductionFactorOfLinearFront(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TransmissibilityReductionFactorOfLinearFront * SOAP_FMAC2 soap_instantiate_prodml21__TransmissibilityReductionFactorOfLinearFront(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1002 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter (-436)
/* complex XML schema type 'prodml21:TubingInteralDiameter': */
class SOAP_CMAC prodml21__TubingInteralDiameter : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "ID"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TubingInteralDiameter, default initialized and not managed by a soap context
        virtual prodml21__TubingInteralDiameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TubingInteralDiameter); }
      public:
        /// Constructor with default initializations
        prodml21__TubingInteralDiameter() : Abbreviation("ID"), Length() { }
        virtual ~prodml21__TubingInteralDiameter() { }
        /// Friend allocator used by soap_new_prodml21__TubingInteralDiameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TubingInteralDiameter * SOAP_FMAC2 soap_instantiate_prodml21__TubingInteralDiameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1004 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr (-437)
/* complex XML schema type 'prodml21:VerticalAnisotropyKvToKr': */
class SOAP_CMAC prodml21__VerticalAnisotropyKvToKr : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "kvTokr"
        /// Required element 'prodml21:Value' of XML schema type 'eml22:DimensionlessMeasure'
        eml22__DimensionlessMeasure *Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__VerticalAnisotropyKvToKr, default initialized and not managed by a soap context
        virtual prodml21__VerticalAnisotropyKvToKr *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__VerticalAnisotropyKvToKr); }
      public:
        /// Constructor with default initializations
        prodml21__VerticalAnisotropyKvToKr() : Abbreviation("kvTokr"), Value() { }
        virtual ~prodml21__VerticalAnisotropyKvToKr() { }
        /// Friend allocator used by soap_new_prodml21__VerticalAnisotropyKvToKr(struct soap*, int)
        friend SOAP_FMAC1 prodml21__VerticalAnisotropyKvToKr * SOAP_FMAC2 soap_instantiate_prodml21__VerticalAnisotropyKvToKr(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1006 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle (-438)
/* complex XML schema type 'prodml21:WellboreDeviationAngle': */
class SOAP_CMAC prodml21__WellboreDeviationAngle : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Deviation"
        /// Required element 'prodml21:PlaneAngle' of XML schema type 'eml22:PlaneAngleMeasure'
        eml22__PlaneAngleMeasure *PlaneAngle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreDeviationAngle, default initialized and not managed by a soap context
        virtual prodml21__WellboreDeviationAngle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreDeviationAngle); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreDeviationAngle() : Abbreviation("Deviation"), PlaneAngle() { }
        virtual ~prodml21__WellboreDeviationAngle() { }
        /// Friend allocator used by soap_new_prodml21__WellboreDeviationAngle(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreDeviationAngle * SOAP_FMAC2 soap_instantiate_prodml21__WellboreDeviationAngle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1008 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility (-439)
/* complex XML schema type 'prodml21:WellboreFluidCompressibility': */
class SOAP_CMAC prodml21__WellboreFluidCompressibility : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Cw"
        /// Required element 'prodml21:Compressibility' of XML schema type 'eml22:ReciprocalPressureMeasureExt'
        eml22__ReciprocalPressureMeasureExt *Compressibility;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreFluidCompressibility, default initialized and not managed by a soap context
        virtual prodml21__WellboreFluidCompressibility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreFluidCompressibility); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreFluidCompressibility() : Abbreviation("Cw"), Compressibility() { }
        virtual ~prodml21__WellboreFluidCompressibility() { }
        /// Friend allocator used by soap_new_prodml21__WellboreFluidCompressibility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreFluidCompressibility * SOAP_FMAC2 soap_instantiate_prodml21__WellboreFluidCompressibility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1010 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius (-440)
/* complex XML schema type 'prodml21:WellboreRadius': */
class SOAP_CMAC prodml21__WellboreRadius : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Rw"
        /// Required element 'prodml21:Length' of XML schema type 'eml22:LengthMeasure'
        eml22__LengthMeasure *Length;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreRadius, default initialized and not managed by a soap context
        virtual prodml21__WellboreRadius *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreRadius); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreRadius() : Abbreviation("Rw"), Length() { }
        virtual ~prodml21__WellboreRadius() { }
        /// Friend allocator used by soap_new_prodml21__WellboreRadius(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreRadius * SOAP_FMAC2 soap_instantiate_prodml21__WellboreRadius(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1012 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient (-441)
/* complex XML schema type 'prodml21:WellboreStorageCoefficient': */
class SOAP_CMAC prodml21__WellboreStorageCoefficient : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Cs"
        /// Required element 'prodml21:VolumePerPressure' of XML schema type 'eml22:VolumePerPressureMeasureExt'
        eml22__VolumePerPressureMeasureExt *VolumePerPressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreStorageCoefficient, default initialized and not managed by a soap context
        virtual prodml21__WellboreStorageCoefficient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreStorageCoefficient); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreStorageCoefficient() : Abbreviation("Cs"), VolumePerPressure() { }
        virtual ~prodml21__WellboreStorageCoefficient() { }
        /// Friend allocator used by soap_new_prodml21__WellboreStorageCoefficient(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreStorageCoefficient * SOAP_FMAC2 soap_instantiate_prodml21__WellboreStorageCoefficient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1014 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume (-442)
/* complex XML schema type 'prodml21:WellboreVolume': */
class SOAP_CMAC prodml21__WellboreVolume : public prodml21__AbstractParameter {
      public:
        /// Required element 'prodml21:Abbreviation' of XML schema type 'eml22:String64'
        std::string Abbreviation;	///< initialized with fixed value = "Vw"
        /// Required element 'prodml21:Volume' of XML schema type 'eml22:VolumeMeasure'
        eml22__VolumeMeasure *Volume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellboreVolume, default initialized and not managed by a soap context
        virtual prodml21__WellboreVolume *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellboreVolume); }
      public:
        /// Constructor with default initializations
        prodml21__WellboreVolume() : Abbreviation("Vw"), Volume() { }
        virtual ~prodml21__WellboreVolume() { }
        /// Friend allocator used by soap_new_prodml21__WellboreVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellboreVolume * SOAP_FMAC2 soap_instantiate_prodml21__WellboreVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1016 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Facility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Facility (-443)
/* complex XML schema type 'prodml21:Facility': */
class SOAP_CMAC prodml21__Facility : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:ReportingFacilityExt'
        std::string Kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Facility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Facility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Facility, default initialized and not managed by a soap context
        virtual prodml21__Facility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Facility); }
      public:
        /// Constructor with default initializations
        prodml21__Facility() : Kind() { }
        virtual ~prodml21__Facility() { }
        /// Friend allocator used by soap_new_prodml21__Facility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Facility * SOAP_FMAC2 soap_instantiate_prodml21__Facility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1018 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity (-444)
/* complex XML schema type 'prodml21:ReportingEntity': */
class SOAP_CMAC prodml21__ReportingEntity : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:Kind' of XML schema type 'prodml21:ReportingEntityKind'
        prodml21__ReportingEntityKind Kind;
        /// Optional element 'prodml21:AssociatedFacility' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *AssociatedFacility;
        /// Optional element 'prodml21:AssociatedObject' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *AssociatedObject;
        /// Optional element 'prodml21:Alias' of XML schema type 'eml22:ObjectAlias'
        std::vector<eml22__ObjectAlias *> Alias;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReportingEntity, default initialized and not managed by a soap context
        virtual prodml21__ReportingEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReportingEntity); }
      public:
        /// Constructor with default initializations
        prodml21__ReportingEntity() : Kind(), AssociatedFacility(), AssociatedObject(), Alias() { }
        virtual ~prodml21__ReportingEntity() { }
        /// Friend allocator used by soap_new_prodml21__ReportingEntity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReportingEntity * SOAP_FMAC2 soap_instantiate_prodml21__ReportingEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1020 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy (-445)
/* complex XML schema type 'prodml21:ReportingHierarchy': */
class SOAP_CMAC prodml21__ReportingHierarchy : public eml22__AbstractObject {
      public:
        /// Required element 'prodml21:ReportingNode' of XML schema type 'prodml21:ReportingHierarchyNode'
        std::vector<prodml21__ReportingHierarchyNode *> ReportingNode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ReportingHierarchy, default initialized and not managed by a soap context
        virtual prodml21__ReportingHierarchy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ReportingHierarchy); }
      public:
        /// Constructor with default initializations
        prodml21__ReportingHierarchy() : ReportingNode() { }
        virtual ~prodml21__ReportingHierarchy() { }
        /// Friend allocator used by soap_new_prodml21__ReportingHierarchy(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ReportingHierarchy * SOAP_FMAC2 soap_instantiate_prodml21__ReportingHierarchy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1026 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue (-448)
/* complex XML schema type 'prodml21:DoubleValue': */
class SOAP_CMAC prodml21__DoubleValue : public prodml21__AbstractValue {
      public:
        /// Required element 'prodml21:DoubleValue' of XML schema type 'prodml21:TimeSeriesDoubleSample'
        prodml21__TimeSeriesDoubleSample *DoubleValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DoubleValue, default initialized and not managed by a soap context
        virtual prodml21__DoubleValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DoubleValue); }
      public:
        /// Constructor with default initializations
        prodml21__DoubleValue() : DoubleValue() { }
        virtual ~prodml21__DoubleValue() { }
        /// Friend allocator used by soap_new_prodml21__DoubleValue(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DoubleValue * SOAP_FMAC2 soap_instantiate_prodml21__DoubleValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1028 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue (-449)
/* complex XML schema type 'prodml21:StringValue': */
class SOAP_CMAC prodml21__StringValue : public prodml21__AbstractValue {
      public:
        /// Required element 'prodml21:StringValue' of XML schema type 'prodml21:TimeSeriesStringSample'
        prodml21__TimeSeriesStringSample *StringValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__StringValue, default initialized and not managed by a soap context
        virtual prodml21__StringValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__StringValue); }
      public:
        /// Constructor with default initializations
        prodml21__StringValue() : StringValue() { }
        virtual ~prodml21__StringValue() { }
        /// Friend allocator used by soap_new_prodml21__StringValue(struct soap*, int)
        friend SOAP_FMAC1 prodml21__StringValue * SOAP_FMAC2 soap_instantiate_prodml21__StringValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1030 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData (-450)
/* complex XML schema type 'prodml21:TimeSeriesData': */
class SOAP_CMAC prodml21__TimeSeriesData : public eml22__AbstractObject {
      public:
        /// Optional element 'prodml21:Key' of XML schema type 'prodml21:KeywordValueStruct'
        std::vector<prodml21__KeywordValueStruct *> Key;
        /// Optional element 'prodml21:Unit' of XML schema type 'eml22:UomEnum'
        std::string *Unit;
        /// Optional element 'prodml21:MeasureClass' of XML schema type 'eml22:MeasureClass'
        eml22__MeasureClass *MeasureClass;
        /// Optional element 'prodml21:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'prodml21:DataValue' of XML schema type 'prodml21:AbstractValue'
        std::vector<prodml21__AbstractValue *> DataValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TimeSeriesData, default initialized and not managed by a soap context
        virtual prodml21__TimeSeriesData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TimeSeriesData); }
      public:
        /// Constructor with default initializations
        prodml21__TimeSeriesData() : Key(), Unit(), MeasureClass(), Comment(), DataValue() { }
        virtual ~prodml21__TimeSeriesData() { }
        /// Friend allocator used by soap_new_prodml21__TimeSeriesData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TimeSeriesData * SOAP_FMAC2 soap_instantiate_prodml21__TimeSeriesData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1036 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject (-453)
/* complex XML schema type 'eml22:AbstractGrowingObject': */
class SOAP_CMAC eml22__AbstractGrowingObject : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:GrowingStatus' of XML schema type 'eml22:GrowingStatusKind'
        eml22__GrowingStatusKind GrowingStatus;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractGrowingObject, default initialized and not managed by a soap context
        virtual eml22__AbstractGrowingObject *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractGrowingObject); }
      public:
        /// Constructor with default initializations
        eml22__AbstractGrowingObject() : GrowingStatus() { }
        virtual ~eml22__AbstractGrowingObject() { }
        /// Friend allocator used by soap_new_eml22__AbstractGrowingObject(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractGrowingObject * SOAP_FMAC2 soap_instantiate_eml22__AbstractGrowingObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1040 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart (-455)
/* complex XML schema type 'eml22:AbstractMdGrowingPart': */
class SOAP_CMAC eml22__AbstractMdGrowingPart : public eml22__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml22:Md' of XML schema type 'eml22:MeasuredDepthCoord'
        eml22__MeasuredDepthCoord *Md;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractMdGrowingPart, default initialized and not managed by a soap context
        virtual eml22__AbstractMdGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractMdGrowingPart); }
      public:
        /// Constructor with default initializations
        eml22__AbstractMdGrowingPart() : Md() { }
        virtual ~eml22__AbstractMdGrowingPart() { }
        /// Friend allocator used by soap_new_eml22__AbstractMdGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractMdGrowingPart * SOAP_FMAC2 soap_instantiate_eml22__AbstractMdGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1042 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart (-456)
/* complex XML schema type 'eml22:AbstractMdIntervalGrowingPart': */
class SOAP_CMAC eml22__AbstractMdIntervalGrowingPart : public eml22__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml22:MdInterval' of XML schema type 'eml22:MdInterval'
        eml22__MdInterval *MdInterval;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractMdIntervalGrowingPart, default initialized and not managed by a soap context
        virtual eml22__AbstractMdIntervalGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractMdIntervalGrowingPart); }
      public:
        /// Constructor with default initializations
        eml22__AbstractMdIntervalGrowingPart() : MdInterval() { }
        virtual ~eml22__AbstractMdIntervalGrowingPart() { }
        /// Friend allocator used by soap_new_eml22__AbstractMdIntervalGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractMdIntervalGrowingPart * SOAP_FMAC2 soap_instantiate_eml22__AbstractMdIntervalGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1046 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart (-458)
/* complex XML schema type 'eml22:AbstractTimeGrowingPart': */
class SOAP_CMAC eml22__AbstractTimeGrowingPart : public eml22__AbstractGrowingObjectPart {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm Time;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractTimeGrowingPart, default initialized and not managed by a soap context
        virtual eml22__AbstractTimeGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractTimeGrowingPart); }
      public:
        /// Constructor with default initializations
        eml22__AbstractTimeGrowingPart() : Time() { }
        virtual ~eml22__AbstractTimeGrowingPart() { }
        /// Friend allocator used by soap_new_eml22__AbstractTimeGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractTimeGrowingPart * SOAP_FMAC2 soap_instantiate_eml22__AbstractTimeGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1048 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart (-459)
/* complex XML schema type 'eml22:AbstractTimeIntervalGrowingPart': */
class SOAP_CMAC eml22__AbstractTimeIntervalGrowingPart : public eml22__AbstractGrowingObjectPart {
      public:
        /// Required element 'eml22:TimeInterval' of XML schema type 'eml22:DateTimeInterval'
        eml22__DateTimeInterval *TimeInterval;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractTimeIntervalGrowingPart, default initialized and not managed by a soap context
        virtual eml22__AbstractTimeIntervalGrowingPart *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractTimeIntervalGrowingPart); }
      public:
        /// Constructor with default initializations
        eml22__AbstractTimeIntervalGrowingPart() : TimeInterval() { }
        virtual ~eml22__AbstractTimeIntervalGrowingPart() { }
        /// Friend allocator used by soap_new_eml22__AbstractTimeIntervalGrowingPart(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractTimeIntervalGrowingPart * SOAP_FMAC2 soap_instantiate_eml22__AbstractTimeIntervalGrowingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1062 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind (-466)
/* complex XML schema type 'eml22:PropertyKind': */
class SOAP_CMAC eml22__PropertyKind : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:IsAbstract' of XML schema type 'xsd:boolean'
        bool IsAbstract;
        /// Optional element 'eml22:DeprecationDate' of XML schema type 'eml22:TimeStamp'
        struct tm *DeprecationDate;
        /// Required element 'eml22:QuantityClass' of XML schema type 'eml22:QuantityClassKindExt'
        std::string QuantityClass;
        /// Optional element 'eml22:Parent' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Parent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PropertyKind, default initialized and not managed by a soap context
        virtual eml22__PropertyKind *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PropertyKind); }
      public:
        /// Constructor with default initializations
        eml22__PropertyKind() : IsAbstract(), DeprecationDate(), QuantityClass(), Parent() { }
        virtual ~eml22__PropertyKind() { }
        /// Friend allocator used by soap_new_eml22__PropertyKind(struct soap*, int)
        friend SOAP_FMAC1 eml22__PropertyKind * SOAP_FMAC2 soap_instantiate_eml22__PropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1064 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary (-467)
/* complex XML schema type 'eml22:PropertyKindDictionary': */
class SOAP_CMAC eml22__PropertyKindDictionary : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:PropertyKind' of XML schema type 'eml22:PropertyKind'
        std::vector<eml22__PropertyKind *> PropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PropertyKindDictionary, default initialized and not managed by a soap context
        virtual eml22__PropertyKindDictionary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PropertyKindDictionary); }
      public:
        /// Constructor with default initializations
        eml22__PropertyKindDictionary() : PropertyKind() { }
        virtual ~eml22__PropertyKindDictionary() { }
        /// Friend allocator used by soap_new_eml22__PropertyKindDictionary(struct soap*, int)
        friend SOAP_FMAC1 eml22__PropertyKindDictionary * SOAP_FMAC2 soap_instantiate_eml22__PropertyKindDictionary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1072 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries (-471)
/* complex XML schema type 'eml22:TimeSeries': */
class SOAP_CMAC eml22__TimeSeries : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:Time' of XML schema type 'eml22:GeologicTime'
        std::vector<eml22__GeologicTime *> Time;
        /// Optional element 'eml22:TimeSeriesParentage' of XML schema type 'eml22:TimeSeriesParentage'
        eml22__TimeSeriesParentage *TimeSeriesParentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeSeries, default initialized and not managed by a soap context
        virtual eml22__TimeSeries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeSeries); }
      public:
        /// Constructor with default initializations
        eml22__TimeSeries() : Time(), TimeSeriesParentage() { }
        virtual ~eml22__TimeSeries() { }
        /// Friend allocator used by soap_new_eml22__TimeSeries(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeSeries * SOAP_FMAC2 soap_instantiate_eml22__TimeSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1076 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray (-473)
/* complex XML schema type 'eml22:AbstractBooleanArray': */
class SOAP_CMAC eml22__AbstractBooleanArray : public eml22__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractBooleanArray, default initialized and not managed by a soap context
        virtual eml22__AbstractBooleanArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractBooleanArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractBooleanArray() { }
        virtual ~eml22__AbstractBooleanArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractBooleanArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractBooleanArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractBooleanArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1082 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray (-476)
/* complex XML schema type 'eml22:AbstractNumericArray': */
class SOAP_CMAC eml22__AbstractNumericArray : public eml22__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractNumericArray, default initialized and not managed by a soap context
        virtual eml22__AbstractNumericArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractNumericArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractNumericArray() { }
        virtual ~eml22__AbstractNumericArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractNumericArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractNumericArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractNumericArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1084 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray (-477)
/* complex XML schema type 'eml22:AbstractStringArray': */
class SOAP_CMAC eml22__AbstractStringArray : public eml22__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractStringArray, default initialized and not managed by a soap context
        virtual eml22__AbstractStringArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractStringArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractStringArray() { }
        virtual ~eml22__AbstractStringArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractStringArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractStringArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractStringArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1876 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference (-873)
/* complex XML schema type 'eml22:EpcExternalPartReference': */
class SOAP_CMAC eml22__EpcExternalPartReference : public eml22__AbstractObject {
      public:
        /// Optional element 'eml22:Filename' of XML schema type 'eml22:String2000'
        std::string *Filename;
        /// Optional element 'eml22:MimeType' of XML schema type 'eml22:String2000'
        std::string *MimeType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EpcExternalPartReference, default initialized and not managed by a soap context
        virtual eml22__EpcExternalPartReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EpcExternalPartReference); }
      public:
        /// Constructor with default initializations
        eml22__EpcExternalPartReference() : Filename(), MimeType() { }
        virtual ~eml22__EpcExternalPartReference() { }
        /// Friend allocator used by soap_new_eml22__EpcExternalPartReference(struct soap*, int)
        friend SOAP_FMAC1 eml22__EpcExternalPartReference * SOAP_FMAC2 soap_instantiate_eml22__EpcExternalPartReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1886 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Activity
#define SOAP_TYPE_gsoap_eml2_2_eml22__Activity (-878)
/* complex XML schema type 'eml22:Activity': */
class SOAP_CMAC eml22__Activity : public eml22__AbstractObject {
      public:
        /// Optional element 'eml22:Parent' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Parent;
        /// Required element 'eml22:ActivityDescriptor' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ActivityDescriptor;
        /// Required element 'eml22:Parameter' of XML schema type 'eml22:AbstractActivityParameter'
        std::vector<eml22__AbstractActivityParameter *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__Activity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__Activity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__Activity, default initialized and not managed by a soap context
        virtual eml22__Activity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__Activity); }
      public:
        /// Constructor with default initializations
        eml22__Activity() : Parent(), ActivityDescriptor(), Parameter() { }
        virtual ~eml22__Activity() { }
        /// Friend allocator used by soap_new_eml22__Activity(struct soap*, int)
        friend SOAP_FMAC1 eml22__Activity * SOAP_FMAC2 soap_instantiate_eml22__Activity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1888 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate (-879)
/* complex XML schema type 'eml22:ActivityTemplate': */
class SOAP_CMAC eml22__ActivityTemplate : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:Parameter' of XML schema type 'eml22:ParameterTemplate'
        std::vector<eml22__ParameterTemplate *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ActivityTemplate, default initialized and not managed by a soap context
        virtual eml22__ActivityTemplate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ActivityTemplate); }
      public:
        /// Constructor with default initializations
        eml22__ActivityTemplate() : Parameter() { }
        virtual ~eml22__ActivityTemplate() { }
        /// Friend allocator used by soap_new_eml22__ActivityTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml22__ActivityTemplate * SOAP_FMAC2 soap_instantiate_eml22__ActivityTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1890 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter (-880)
/* complex XML schema type 'eml22:DataObjectParameter': */
class SOAP_CMAC eml22__DataObjectParameter : public eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:DataObject' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DataObjectParameter, default initialized and not managed by a soap context
        virtual eml22__DataObjectParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DataObjectParameter); }
      public:
        /// Constructor with default initializations
        eml22__DataObjectParameter() : DataObject() { }
        virtual ~eml22__DataObjectParameter() { }
        /// Friend allocator used by soap_new_eml22__DataObjectParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__DataObjectParameter * SOAP_FMAC2 soap_instantiate_eml22__DataObjectParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1892 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter (-881)
/* complex XML schema type 'eml22:DoubleQuantityParameter': */
class SOAP_CMAC eml22__DoubleQuantityParameter : public eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:Value' of XML schema type 'xsd:double'
        double Value;
        /// Required element 'eml22:Uom' of XML schema type 'eml22:UnitOfMeasureExt'
        std::string Uom;
        /// Optional element 'eml22:CustomUnitDictionary' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *CustomUnitDictionary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DoubleQuantityParameter, default initialized and not managed by a soap context
        virtual eml22__DoubleQuantityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DoubleQuantityParameter); }
      public:
        /// Constructor with default initializations
        eml22__DoubleQuantityParameter() : Value(), Uom(), CustomUnitDictionary() { }
        virtual ~eml22__DoubleQuantityParameter() { }
        /// Friend allocator used by soap_new_eml22__DoubleQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__DoubleQuantityParameter * SOAP_FMAC2 soap_instantiate_eml22__DoubleQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1894 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter (-882)
/* complex XML schema type 'eml22:IntegerQuantityParameter': */
class SOAP_CMAC eml22__IntegerQuantityParameter : public eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:Value' of XML schema type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerQuantityParameter, default initialized and not managed by a soap context
        virtual eml22__IntegerQuantityParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerQuantityParameter); }
      public:
        /// Constructor with default initializations
        eml22__IntegerQuantityParameter() : Value() { }
        virtual ~eml22__IntegerQuantityParameter() { }
        /// Friend allocator used by soap_new_eml22__IntegerQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerQuantityParameter * SOAP_FMAC2 soap_instantiate_eml22__IntegerQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1896 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey (-883)
/* complex XML schema type 'eml22:ObjectParameterKey': */
class SOAP_CMAC eml22__ObjectParameterKey : public eml22__AbstractParameterKey {
      public:
        /// Required element 'eml22:DataObject' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ObjectParameterKey, default initialized and not managed by a soap context
        virtual eml22__ObjectParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ObjectParameterKey); }
      public:
        /// Constructor with default initializations
        eml22__ObjectParameterKey() : DataObject() { }
        virtual ~eml22__ObjectParameterKey() { }
        /// Friend allocator used by soap_new_eml22__ObjectParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml22__ObjectParameterKey * SOAP_FMAC2 soap_instantiate_eml22__ObjectParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1900 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter (-885)
/* complex XML schema type 'eml22:StringParameter': */
class SOAP_CMAC eml22__StringParameter : public eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:Value' of XML schema type 'eml22:String2000'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__StringParameter, default initialized and not managed by a soap context
        virtual eml22__StringParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__StringParameter); }
      public:
        /// Constructor with default initializations
        eml22__StringParameter() : Value() { }
        virtual ~eml22__StringParameter() { }
        /// Friend allocator used by soap_new_eml22__StringParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__StringParameter * SOAP_FMAC2 soap_instantiate_eml22__StringParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1902 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter (-886)
/* complex XML schema type 'eml22:TimeIndexParameter': */
class SOAP_CMAC eml22__TimeIndexParameter : public eml22__AbstractActivityParameter {
      public:
        /// Required element 'eml22:TimeIndex' of XML schema type 'eml22:TimeIndex'
        eml22__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeIndexParameter, default initialized and not managed by a soap context
        virtual eml22__TimeIndexParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeIndexParameter); }
      public:
        /// Constructor with default initializations
        eml22__TimeIndexParameter() : TimeIndex() { }
        virtual ~eml22__TimeIndexParameter() { }
        /// Friend allocator used by soap_new_eml22__TimeIndexParameter(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeIndexParameter * SOAP_FMAC2 soap_instantiate_eml22__TimeIndexParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1904 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey (-887)
/* complex XML schema type 'eml22:TimeIndexParameterKey': */
class SOAP_CMAC eml22__TimeIndexParameterKey : public eml22__AbstractParameterKey {
      public:
        /// Required element 'eml22:TimeIndex' of XML schema type 'eml22:TimeIndex'
        eml22__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeIndexParameterKey, default initialized and not managed by a soap context
        virtual eml22__TimeIndexParameterKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeIndexParameterKey); }
      public:
        /// Constructor with default initializations
        eml22__TimeIndexParameterKey() : TimeIndex() { }
        virtual ~eml22__TimeIndexParameterKey() { }
        /// Friend allocator used by soap_new_eml22__TimeIndexParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeIndexParameterKey * SOAP_FMAC2 soap_instantiate_eml22__TimeIndexParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1906 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure (-888)
/* complex XML schema type 'eml22:AbsolutePressure': */
class SOAP_CMAC eml22__AbsolutePressure : public eml22__AbstractPressureValue {
      public:
        /// Required element 'eml22:AbsolutePressure' of XML schema type 'eml22:PressureMeasureExt'
        eml22__PressureMeasureExt *AbsolutePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbsolutePressure, default initialized and not managed by a soap context
        virtual eml22__AbsolutePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbsolutePressure); }
      public:
        /// Constructor with default initializations
        eml22__AbsolutePressure() : AbsolutePressure() { }
        virtual ~eml22__AbsolutePressure() { }
        /// Friend allocator used by soap_new_eml22__AbsolutePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbsolutePressure * SOAP_FMAC2 soap_instantiate_eml22__AbsolutePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1916 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure (-893)
/* complex XML schema type 'eml22:GaugePressure': */
class SOAP_CMAC eml22__GaugePressure : public eml22__AbstractPressureValue {
      public:
        /// Required element 'eml22:GaugePressure' of XML schema type 'eml22:PressureMeasureExt'
        eml22__PressureMeasureExt *GaugePressure;
        /// Optional element 'eml22:ReferencePressure' of XML schema type 'eml22:ReferencePressure'
        eml22__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GaugePressure, default initialized and not managed by a soap context
        virtual eml22__GaugePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GaugePressure); }
      public:
        /// Constructor with default initializations
        eml22__GaugePressure() : GaugePressure(), ReferencePressure() { }
        virtual ~eml22__GaugePressure() { }
        /// Friend allocator used by soap_new_eml22__GaugePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__GaugePressure * SOAP_FMAC2 soap_instantiate_eml22__GaugePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:41486 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__union_ReferenceTemperaturePressure_
#define SOAP_TYPE_gsoap_eml2_2__eml22__union_ReferenceTemperaturePressure_ (-1955)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml22__union_ReferenceTemperaturePressure_
{
        #define SOAP_UNION_gsoap_eml2_2__eml22__union_ReferenceTemperaturePressure__ReferenceTempPres	(1)	/**< union variant selector value for member ReferenceTempPres */
        std::string *ReferenceTempPres;
};
#endif

/* eml2_2ForGsoap.h:1922 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure (-896)
/* complex XML schema type 'eml22:ReferenceTemperaturePressure': */
class SOAP_CMAC eml22__ReferenceTemperaturePressure : public eml22__AbstractTemperaturePressure {
      public:
        /// Union with union _eml22__union_ReferenceTemperaturePressure_ variant selector __union_ReferenceTemperaturePressure_ set to one of: SOAP_UNION_gsoap_eml2_2__eml22__union_ReferenceTemperaturePressure__ReferenceTempPres
        int __union_ReferenceTemperaturePressure_;
        union _eml22__union_ReferenceTemperaturePressure_ union_ReferenceTemperaturePressure_;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReferenceTemperaturePressure, default initialized and not managed by a soap context
        virtual eml22__ReferenceTemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReferenceTemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml22__ReferenceTemperaturePressure() : __union_ReferenceTemperaturePressure_() { }
        virtual ~eml22__ReferenceTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml22__ReferenceTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReferenceTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml22__ReferenceTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1924 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure (-897)
/* complex XML schema type 'eml22:RelativePressure': */
class SOAP_CMAC eml22__RelativePressure : public eml22__AbstractPressureValue {
      public:
        /// Required element 'eml22:RelativePressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *RelativePressure;
        /// Required element 'eml22:ReferencePressure' of XML schema type 'eml22:ReferencePressure'
        eml22__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__RelativePressure, default initialized and not managed by a soap context
        virtual eml22__RelativePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__RelativePressure); }
      public:
        /// Constructor with default initializations
        eml22__RelativePressure() : RelativePressure(), ReferencePressure() { }
        virtual ~eml22__RelativePressure() { }
        /// Friend allocator used by soap_new_eml22__RelativePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__RelativePressure * SOAP_FMAC2 soap_instantiate_eml22__RelativePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1926 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure (-898)
/* complex XML schema type 'eml22:TemperaturePressure': */
class SOAP_CMAC eml22__TemperaturePressure : public eml22__AbstractTemperaturePressure {
      public:
        /// Required element 'eml22:Temperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *Temperature;
        /// Required element 'eml22:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperaturePressure, default initialized and not managed by a soap context
        virtual eml22__TemperaturePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperaturePressure); }
      public:
        /// Constructor with default initializations
        eml22__TemperaturePressure() : Temperature(), Pressure() { }
        virtual ~eml22__TemperaturePressure() { }
        /// Friend allocator used by soap_new_eml22__TemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperaturePressure * SOAP_FMAC2 soap_instantiate_eml22__TemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1940 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs (-905)
/* complex XML schema type 'eml22:GeodeticCrs': */
class SOAP_CMAC eml22__GeodeticCrs : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:AbstractGeodeticCrs' of XML schema type 'eml22:AbstractGeodeticCrs'
        eml22__AbstractGeodeticCrs *AbstractGeodeticCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeodeticCrs, default initialized and not managed by a soap context
        virtual eml22__GeodeticCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeodeticCrs); }
      public:
        /// Constructor with default initializations
        eml22__GeodeticCrs() : AbstractGeodeticCrs() { }
        virtual ~eml22__GeodeticCrs() { }
        /// Friend allocator used by soap_new_eml22__GeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeodeticCrs * SOAP_FMAC2 soap_instantiate_eml22__GeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1942 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs (-906)
/* complex XML schema type 'eml22:GeodeticEpsgCrs': */
class SOAP_CMAC eml22__GeodeticEpsgCrs : public eml22__AbstractGeodeticCrs {
      public:
        /// Required element 'eml22:EpsgCode' of XML schema type 'eml22:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeodeticEpsgCrs, default initialized and not managed by a soap context
        virtual eml22__GeodeticEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeodeticEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml22__GeodeticEpsgCrs() : EpsgCode() { }
        virtual ~eml22__GeodeticEpsgCrs() { }
        /// Friend allocator used by soap_new_eml22__GeodeticEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeodeticEpsgCrs * SOAP_FMAC2 soap_instantiate_eml22__GeodeticEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1944 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs (-907)
/* complex XML schema type 'eml22:GeodeticLocalAuthorityCrs': */
class SOAP_CMAC eml22__GeodeticLocalAuthorityCrs : public eml22__AbstractGeodeticCrs {
      public:
        /// Required element 'eml22:LocalAuthorityCrsName' of XML schema type 'eml22:AuthorityQualifiedName'
        eml22__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeodeticLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml22__GeodeticLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeodeticLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml22__GeodeticLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml22__GeodeticLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml22__GeodeticLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeodeticLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml22__GeodeticLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1946 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs (-908)
/* complex XML schema type 'eml22:GeodeticUnknownCrs': */
class SOAP_CMAC eml22__GeodeticUnknownCrs : public eml22__AbstractGeodeticCrs {
      public:
        /// Required element 'eml22:Unknown' of XML schema type 'eml22:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeodeticUnknownCrs, default initialized and not managed by a soap context
        virtual eml22__GeodeticUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeodeticUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml22__GeodeticUnknownCrs() : Unknown() { }
        virtual ~eml22__GeodeticUnknownCrs() { }
        /// Friend allocator used by soap_new_eml22__GeodeticUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeodeticUnknownCrs * SOAP_FMAC2 soap_instantiate_eml22__GeodeticUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1948 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs (-909)
/* complex XML schema type 'eml22:GeodeticWktCrs': */
class SOAP_CMAC eml22__GeodeticWktCrs : public eml22__AbstractGeodeticCrs {
      public:
        /// Required element 'eml22:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GeodeticWktCrs, default initialized and not managed by a soap context
        virtual eml22__GeodeticWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GeodeticWktCrs); }
      public:
        /// Constructor with default initializations
        eml22__GeodeticWktCrs() : WellKnownText() { }
        virtual ~eml22__GeodeticWktCrs() { }
        /// Friend allocator used by soap_new_eml22__GeodeticWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__GeodeticWktCrs * SOAP_FMAC2 soap_instantiate_eml22__GeodeticWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1952 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs (-911)
/* complex XML schema type 'eml22:LocalEngineeringCompoundCrs': */
class SOAP_CMAC eml22__LocalEngineeringCompoundCrs : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:Azimuth' of XML schema type 'eml22:PlaneAngleMeasureExt'
        eml22__PlaneAngleMeasureExt *Azimuth;
        /// Required element 'eml22:AzimuthReference' of XML schema type 'eml22:NorthReferenceKind'
        eml22__NorthReferenceKind AzimuthReference;
        /// Required element 'eml22:OriginProjectedCoordinate1' of XML schema type 'xsd:double'
        double OriginProjectedCoordinate1;
        /// Required element 'eml22:OriginProjectedCoordinate2' of XML schema type 'xsd:double'
        double OriginProjectedCoordinate2;
        /// Required element 'eml22:OriginVerticalCoordinate' of XML schema type 'xsd:double'
        double OriginVerticalCoordinate;
        /// Required element 'eml22:VerticalAxis' of XML schema type 'eml22:VerticalAxis'
        eml22__VerticalAxis *VerticalAxis;
        /// Required element 'eml22:HorizontalAxes' of XML schema type 'eml22:HorizontalAxes'
        eml22__HorizontalAxes *HorizontalAxes;
        /// Required element 'eml22:VerticalCrs' of XML schema type 'eml22:VerticalCrs'
        eml22__VerticalCrs *VerticalCrs;
        /// Optional element 'eml22:OriginUncertaintyVectorAtSigmaX' of XML schema type 'eml22:Vector'
        eml22__Vector *OriginUncertaintyVectorAtSigmaX;
        /// Required element 'eml22:ProjectedCrs' of XML schema type 'eml22:ProjectedCrs'
        eml22__ProjectedCrs *ProjectedCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LocalEngineeringCompoundCrs, default initialized and not managed by a soap context
        virtual eml22__LocalEngineeringCompoundCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LocalEngineeringCompoundCrs); }
      public:
        /// Constructor with default initializations
        eml22__LocalEngineeringCompoundCrs() : Azimuth(), AzimuthReference(), OriginProjectedCoordinate1(), OriginProjectedCoordinate2(), OriginVerticalCoordinate(), VerticalAxis(), HorizontalAxes(), VerticalCrs(), OriginUncertaintyVectorAtSigmaX(), ProjectedCrs() { }
        virtual ~eml22__LocalEngineeringCompoundCrs() { }
        /// Friend allocator used by soap_new_eml22__LocalEngineeringCompoundCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__LocalEngineeringCompoundCrs * SOAP_FMAC2 soap_instantiate_eml22__LocalEngineeringCompoundCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1954 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs (-912)
/* complex XML schema type 'eml22:ProjectedCrs': */
class SOAP_CMAC eml22__ProjectedCrs : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:AxisOrder' of XML schema type 'eml22:AxisOrder2d'
        eml22__AxisOrder2d AxisOrder;
        /// Required element 'eml22:AbstractProjectedCrs' of XML schema type 'eml22:AbstractProjectedCrs'
        eml22__AbstractProjectedCrs *AbstractProjectedCrs;
        /// Optional attribute 'uom' of XML schema type 'eml22:LengthUomExt'
        std::string *uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ProjectedCrs, default initialized and not managed by a soap context
        virtual eml22__ProjectedCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ProjectedCrs); }
      public:
        /// Constructor with default initializations
        eml22__ProjectedCrs() : AxisOrder(), AbstractProjectedCrs(), uom() { }
        virtual ~eml22__ProjectedCrs() { }
        /// Friend allocator used by soap_new_eml22__ProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__ProjectedCrs * SOAP_FMAC2 soap_instantiate_eml22__ProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1956 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs (-913)
/* complex XML schema type 'eml22:ProjectedEpsgCrs': */
class SOAP_CMAC eml22__ProjectedEpsgCrs : public eml22__AbstractProjectedCrs {
      public:
        /// Required element 'eml22:EpsgCode' of XML schema type 'eml22:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ProjectedEpsgCrs, default initialized and not managed by a soap context
        virtual eml22__ProjectedEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ProjectedEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml22__ProjectedEpsgCrs() : EpsgCode() { }
        virtual ~eml22__ProjectedEpsgCrs() { }
        /// Friend allocator used by soap_new_eml22__ProjectedEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__ProjectedEpsgCrs * SOAP_FMAC2 soap_instantiate_eml22__ProjectedEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1958 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs (-914)
/* complex XML schema type 'eml22:ProjectedLocalAuthorityCrs': */
class SOAP_CMAC eml22__ProjectedLocalAuthorityCrs : public eml22__AbstractProjectedCrs {
      public:
        /// Required element 'eml22:LocalAuthorityCrsName' of XML schema type 'eml22:AuthorityQualifiedName'
        eml22__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ProjectedLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml22__ProjectedLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ProjectedLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml22__ProjectedLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml22__ProjectedLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml22__ProjectedLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__ProjectedLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml22__ProjectedLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1960 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs (-915)
/* complex XML schema type 'eml22:ProjectedUnknownCrs': */
class SOAP_CMAC eml22__ProjectedUnknownCrs : public eml22__AbstractProjectedCrs {
      public:
        /// Required element 'eml22:Unknown' of XML schema type 'eml22:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ProjectedUnknownCrs, default initialized and not managed by a soap context
        virtual eml22__ProjectedUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ProjectedUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml22__ProjectedUnknownCrs() : Unknown() { }
        virtual ~eml22__ProjectedUnknownCrs() { }
        /// Friend allocator used by soap_new_eml22__ProjectedUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__ProjectedUnknownCrs * SOAP_FMAC2 soap_instantiate_eml22__ProjectedUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1962 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs (-916)
/* complex XML schema type 'eml22:ProjectedWktCrs': */
class SOAP_CMAC eml22__ProjectedWktCrs : public eml22__AbstractProjectedCrs {
      public:
        /// Required element 'eml22:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ProjectedWktCrs, default initialized and not managed by a soap context
        virtual eml22__ProjectedWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ProjectedWktCrs); }
      public:
        /// Constructor with default initializations
        eml22__ProjectedWktCrs() : WellKnownText() { }
        virtual ~eml22__ProjectedWktCrs() { }
        /// Friend allocator used by soap_new_eml22__ProjectedWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__ProjectedWktCrs * SOAP_FMAC2 soap_instantiate_eml22__ProjectedWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1970 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs (-920)
/* complex XML schema type 'eml22:VerticalCrs': */
class SOAP_CMAC eml22__VerticalCrs : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:Direction' of XML schema type 'eml22:VerticalDirection'
        eml22__VerticalDirection Direction;
        /// Required element 'eml22:AbstractVerticalCrs' of XML schema type 'eml22:AbstractVerticalCrs'
        eml22__AbstractVerticalCrs *AbstractVerticalCrs;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUomExt'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalCrs, default initialized and not managed by a soap context
        virtual eml22__VerticalCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalCrs); }
      public:
        /// Constructor with default initializations
        eml22__VerticalCrs() : Direction(), AbstractVerticalCrs(), uom() { }
        virtual ~eml22__VerticalCrs() { }
        /// Friend allocator used by soap_new_eml22__VerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalCrs * SOAP_FMAC2 soap_instantiate_eml22__VerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1972 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs (-921)
/* complex XML schema type 'eml22:VerticalEpsgCrs': */
class SOAP_CMAC eml22__VerticalEpsgCrs : public eml22__AbstractVerticalCrs {
      public:
        /// Required element 'eml22:EpsgCode' of XML schema type 'eml22:PositiveLong'
        LONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalEpsgCrs, default initialized and not managed by a soap context
        virtual eml22__VerticalEpsgCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalEpsgCrs); }
      public:
        /// Constructor with default initializations
        eml22__VerticalEpsgCrs() : EpsgCode() { }
        virtual ~eml22__VerticalEpsgCrs() { }
        /// Friend allocator used by soap_new_eml22__VerticalEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalEpsgCrs * SOAP_FMAC2 soap_instantiate_eml22__VerticalEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1974 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs (-922)
/* complex XML schema type 'eml22:VerticalLocalAuthorityCrs': */
class SOAP_CMAC eml22__VerticalLocalAuthorityCrs : public eml22__AbstractVerticalCrs {
      public:
        /// Required element 'eml22:LocalAuthorityCrsName' of XML schema type 'eml22:AuthorityQualifiedName'
        eml22__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml22__VerticalLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalLocalAuthorityCrs); }
      public:
        /// Constructor with default initializations
        eml22__VerticalLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml22__VerticalLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml22__VerticalLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml22__VerticalLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1976 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs (-923)
/* complex XML schema type 'eml22:VerticalUnknownCrs': */
class SOAP_CMAC eml22__VerticalUnknownCrs : public eml22__AbstractVerticalCrs {
      public:
        /// Required element 'eml22:Unknown' of XML schema type 'eml22:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalUnknownCrs, default initialized and not managed by a soap context
        virtual eml22__VerticalUnknownCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalUnknownCrs); }
      public:
        /// Constructor with default initializations
        eml22__VerticalUnknownCrs() : Unknown() { }
        virtual ~eml22__VerticalUnknownCrs() { }
        /// Friend allocator used by soap_new_eml22__VerticalUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalUnknownCrs * SOAP_FMAC2 soap_instantiate_eml22__VerticalUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1978 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs (-924)
/* complex XML schema type 'eml22:VerticalWktCrs': */
class SOAP_CMAC eml22__VerticalWktCrs : public eml22__AbstractVerticalCrs {
      public:
        /// Required element 'eml22:WellKnownText' of XML schema type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalWktCrs, default initialized and not managed by a soap context
        virtual eml22__VerticalWktCrs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalWktCrs); }
      public:
        /// Constructor with default initializations
        eml22__VerticalWktCrs() : WellKnownText() { }
        virtual ~eml22__VerticalWktCrs() { }
        /// Friend allocator used by soap_new_eml22__VerticalWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalWktCrs * SOAP_FMAC2 soap_instantiate_eml22__VerticalWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1980 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord (-925)
/* complex XML schema type 'eml22:DataAssuranceRecord': */
class SOAP_CMAC eml22__DataAssuranceRecord : public eml22__AbstractObject {
      public:
        /// Required element 'eml22:PolicyId' of XML schema type 'eml22:String64'
        std::string PolicyId;
        /// Optional element 'eml22:PolicyName' of XML schema type 'eml22:String2000'
        std::string *PolicyName;
        /// Optional element 'eml22:ReferencedElementName' of XML schema type 'eml22:String64'
        std::string *ReferencedElementName;
        /// Optional element 'eml22:ReferencedElementUid' of XML schema type 'eml22:String64'
        std::string *ReferencedElementUid;
        /// Required element 'eml22:Origin' of XML schema type 'eml22:String2000'
        std::string Origin;
        /// Required element 'eml22:Conformance' of XML schema type 'xsd:boolean'
        bool Conformance;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm Date;
        /// Optional element 'eml22:Comment' of XML schema type 'eml22:String2000'
        std::string *Comment;
        /// Optional element 'eml22:IndexRange' of XML schema type 'eml22:IndexRange'
        eml22__IndexRange *IndexRange;
        /// Optional element 'eml22:FailingRules' of XML schema type 'eml22:FailingRule'
        std::vector<eml22__FailingRule *> FailingRules;
        /// Required element 'eml22:ReferencedData' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReferencedData;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DataAssuranceRecord, default initialized and not managed by a soap context
        virtual eml22__DataAssuranceRecord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DataAssuranceRecord); }
      public:
        /// Constructor with default initializations
        eml22__DataAssuranceRecord() : PolicyId(), PolicyName(), ReferencedElementName(), ReferencedElementUid(), Origin(), Conformance(), Date(), Comment(), IndexRange(), FailingRules(), ReferencedData() { }
        virtual ~eml22__DataAssuranceRecord() { }
        /// Friend allocator used by soap_new_eml22__DataAssuranceRecord(struct soap*, int)
        friend SOAP_FMAC1 eml22__DataAssuranceRecord * SOAP_FMAC2 soap_instantiate_eml22__DataAssuranceRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1988 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet (-929)
/* complex XML schema type 'eml22:GraphicalInformationSet': */
class SOAP_CMAC eml22__GraphicalInformationSet : public eml22__AbstractObject {
      public:
        /// Optional element 'eml22:GraphicalInformation' of XML schema type 'eml22:AbstractGraphicalInformation'
        std::vector<eml22__AbstractGraphicalInformation *> GraphicalInformation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GraphicalInformationSet, default initialized and not managed by a soap context
        virtual eml22__GraphicalInformationSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GraphicalInformationSet); }
      public:
        /// Constructor with default initializations
        eml22__GraphicalInformationSet() : GraphicalInformation() { }
        virtual ~eml22__GraphicalInformationSet() { }
        /// Friend allocator used by soap_new_eml22__GraphicalInformationSet(struct soap*, int)
        friend SOAP_FMAC1 eml22__GraphicalInformationSet * SOAP_FMAC2 soap_instantiate_eml22__GraphicalInformationSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:170 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow (-20)
/* simple XML schema type 'prodml21:FluidCharacterizationTableRow': */
class SOAP_CMAC prodml21__FluidCharacterizationTableRow {
      public:
        /// Simple content of XML schema type 'eml22:AbstractString' wrapped by this struct
        std::string __item;
        /// Required attribute 'row' of XML schema type 'eml22:String64'
        std::string row;
        /// Optional attribute 'kind' of XML schema type 'prodml21:saturationKind'
        prodml21__saturationKind *kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FluidCharacterizationTableRow, default initialized and not managed by a soap context
        virtual prodml21__FluidCharacterizationTableRow *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FluidCharacterizationTableRow); }
      public:
        /// Constructor with default initializations
        prodml21__FluidCharacterizationTableRow() : __item(), row(), kind(), soap() { }
        virtual ~prodml21__FluidCharacterizationTableRow() { }
        /// Friend allocator used by soap_new_prodml21__FluidCharacterizationTableRow(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FluidCharacterizationTableRow * SOAP_FMAC2 soap_instantiate_prodml21__FluidCharacterizationTableRow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:172 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel (-21)
/* complex XML schema type 'prodml21:AbstractCompositionalEoSModel': */
class SOAP_CMAC prodml21__AbstractCompositionalEoSModel : public prodml21__AbstractCompositionalModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCompositionalEoSModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCompositionalEoSModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCompositionalEoSModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCompositionalEoSModel() { }
        virtual ~prodml21__AbstractCompositionalEoSModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCompositionalEoSModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCompositionalEoSModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCompositionalEoSModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:174 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel (-22)
/* complex XML schema type 'prodml21:AbstractCompositionalViscosityModel': */
class SOAP_CMAC prodml21__AbstractCompositionalViscosityModel : public prodml21__AbstractCompositionalModel {
      public:
        /// Required attribute 'phase' of XML schema type 'prodml21:ThermodynamicPhase'
        prodml21__ThermodynamicPhase phase;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCompositionalViscosityModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCompositionalViscosityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCompositionalViscosityModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCompositionalViscosityModel() : phase() { }
        virtual ~prodml21__AbstractCompositionalViscosityModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCompositionalViscosityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCompositionalViscosityModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCompositionalViscosityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:180 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel (-25)
/* complex XML schema type 'prodml21:AbstractCorrelationViscosityModel': */
class SOAP_CMAC prodml21__AbstractCorrelationViscosityModel : public prodml21__AbstractCorrelationModel {
      public:
        /// Optional element 'prodml21:MolecularWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *MolecularWeight;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationViscosityModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationViscosityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationViscosityModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationViscosityModel() : MolecularWeight() { }
        virtual ~prodml21__AbstractCorrelationViscosityModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationViscosityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationViscosityModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationViscosityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:194 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient (-32)
/* simple XML schema type 'prodml21:BinaryInteractionCoefficient': */
class SOAP_CMAC prodml21__BinaryInteractionCoefficient {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'fluidComponent1Reference' of XML schema type 'eml22:String64'
        std::string fluidComponent1Reference;
        /// Optional attribute 'fluidComponent2Reference' of XML schema type 'eml22:String64'
        std::string *fluidComponent2Reference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BinaryInteractionCoefficient, default initialized and not managed by a soap context
        virtual prodml21__BinaryInteractionCoefficient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BinaryInteractionCoefficient); }
      public:
        /// Constructor with default initializations
        prodml21__BinaryInteractionCoefficient() : __item(), fluidComponent1Reference(), fluidComponent2Reference(), soap() { }
        virtual ~prodml21__BinaryInteractionCoefficient() { }
        /// Friend allocator used by soap_new_prodml21__BinaryInteractionCoefficient(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BinaryInteractionCoefficient * SOAP_FMAC2 soap_instantiate_prodml21__BinaryInteractionCoefficient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:202 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel (-36)
/* complex XML schema type 'prodml21:CompositionalThermalModel': */
class SOAP_CMAC prodml21__CompositionalThermalModel : public prodml21__AbstractCompositionalModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CompositionalThermalModel, default initialized and not managed by a soap context
        virtual prodml21__CompositionalThermalModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CompositionalThermalModel); }
      public:
        /// Constructor with default initializations
        prodml21__CompositionalThermalModel() { }
        virtual ~prodml21__CompositionalThermalModel() { }
        /// Friend allocator used by soap_new_prodml21__CompositionalThermalModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CompositionalThermalModel * SOAP_FMAC2 soap_instantiate_prodml21__CompositionalThermalModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:204 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel (-37)
/* complex XML schema type 'prodml21:CorrelationThermalModel': */
class SOAP_CMAC prodml21__CorrelationThermalModel : public prodml21__AbstractCorrelationModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CorrelationThermalModel, default initialized and not managed by a soap context
        virtual prodml21__CorrelationThermalModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CorrelationThermalModel); }
      public:
        /// Constructor with default initializations
        prodml21__CorrelationThermalModel() { }
        virtual ~prodml21__CorrelationThermalModel() { }
        /// Friend allocator used by soap_new_prodml21__CorrelationThermalModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CorrelationThermalModel * SOAP_FMAC2 soap_instantiate_prodml21__CorrelationThermalModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:268 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter (-69)
/* simple XML schema type 'prodml21:PvtModelParameter': */
class SOAP_CMAC prodml21__PvtModelParameter {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'kind' of XML schema type 'prodml21:PvtModelParameterKindExt'
        std::string kind;
        /// Optional attribute 'name' of XML schema type 'eml22:String64'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PvtModelParameter, default initialized and not managed by a soap context
        virtual prodml21__PvtModelParameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PvtModelParameter); }
      public:
        /// Constructor with default initializations
        prodml21__PvtModelParameter() : __item(), kind(), name(), soap() { }
        virtual ~prodml21__PvtModelParameter() { }
        /// Friend allocator used by soap_new_prodml21__PvtModelParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PvtModelParameter * SOAP_FMAC2 soap_instantiate_prodml21__PvtModelParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:322 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct (-96)
/* simple XML schema type 'prodml21:KeywordValueStruct': */
class SOAP_CMAC prodml21__KeywordValueStruct {
      public:
        /// Simple content of XML schema type 'eml22:AbstractString' wrapped by this struct
        std::string __item;
        /// Required attribute 'keyword' of XML schema type 'prodml21:TimeSeriesKeyword'
        prodml21__TimeSeriesKeyword keyword;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__KeywordValueStruct, default initialized and not managed by a soap context
        virtual prodml21__KeywordValueStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__KeywordValueStruct); }
      public:
        /// Constructor with default initializations
        prodml21__KeywordValueStruct() : __item(), keyword(), soap() { }
        virtual ~prodml21__KeywordValueStruct() { }
        /// Friend allocator used by soap_new_prodml21__KeywordValueStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__KeywordValueStruct * SOAP_FMAC2 soap_instantiate_prodml21__KeywordValueStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:328 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord (-99)
/* simple XML schema type 'prodml21:MeasuredDepthCoord': */
class SOAP_CMAC prodml21__MeasuredDepthCoord {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VerticalCoordinateUom'
        eml22__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MeasuredDepthCoord, default initialized and not managed by a soap context
        virtual prodml21__MeasuredDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MeasuredDepthCoord); }
      public:
        /// Constructor with default initializations
        prodml21__MeasuredDepthCoord() : __item(), uom(), soap() { }
        virtual ~prodml21__MeasuredDepthCoord() { }
        /// Friend allocator used by soap_new_prodml21__MeasuredDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MeasuredDepthCoord * SOAP_FMAC2 soap_instantiate_prodml21__MeasuredDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:330 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity (-100)
/* simple XML schema type 'prodml21:MeasureOrQuantity': */
class SOAP_CMAC prodml21__MeasureOrQuantity {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Optional attribute 'uom' of XML schema type 'eml22:UomEnum'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MeasureOrQuantity, default initialized and not managed by a soap context
        virtual prodml21__MeasureOrQuantity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MeasureOrQuantity); }
      public:
        /// Constructor with default initializations
        prodml21__MeasureOrQuantity() : __item(), uom(), soap() { }
        virtual ~prodml21__MeasureOrQuantity() { }
        /// Friend allocator used by soap_new_prodml21__MeasureOrQuantity(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MeasureOrQuantity * SOAP_FMAC2 soap_instantiate_prodml21__MeasureOrQuantity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:348 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure (-109)
/* simple XML schema type 'prodml21:PressurePerFlowrateMeasure': */
class SOAP_CMAC prodml21__PressurePerFlowrateMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'prodml21:PressurePerFlowrateUom'
        prodml21__PressurePerFlowrateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PressurePerFlowrateMeasure, default initialized and not managed by a soap context
        virtual prodml21__PressurePerFlowrateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PressurePerFlowrateMeasure); }
      public:
        /// Constructor with default initializations
        prodml21__PressurePerFlowrateMeasure() : __item(), uom(), soap() { }
        virtual ~prodml21__PressurePerFlowrateMeasure() { }
        /// Friend allocator used by soap_new_prodml21__PressurePerFlowrateMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PressurePerFlowrateMeasure * SOAP_FMAC2 soap_instantiate_prodml21__PressurePerFlowrateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:350 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure (-110)
/* simple XML schema type 'prodml21:PressurePerFlowrateSquaredMeasure': */
class SOAP_CMAC prodml21__PressurePerFlowrateSquaredMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'prodml21:PressurePerFlowrateSquaredUom'
        prodml21__PressurePerFlowrateSquaredUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PressurePerFlowrateSquaredMeasure, default initialized and not managed by a soap context
        virtual prodml21__PressurePerFlowrateSquaredMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PressurePerFlowrateSquaredMeasure); }
      public:
        /// Constructor with default initializations
        prodml21__PressurePerFlowrateSquaredMeasure() : __item(), uom(), soap() { }
        virtual ~prodml21__PressurePerFlowrateSquaredMeasure() { }
        /// Friend allocator used by soap_new_prodml21__PressurePerFlowrateSquaredMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PressurePerFlowrateSquaredMeasure * SOAP_FMAC2 soap_instantiate_prodml21__PressurePerFlowrateSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:498 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis (-184)
/* complex XML schema type 'prodml21:HydrocarbonAnalysis': */
class SOAP_CMAC prodml21__HydrocarbonAnalysis : public prodml21__FluidAnalysis {
      public:
        /// Optional element 'prodml21:FluidComponentCatalog' of XML schema type 'prodml21:FluidComponentCatalog'
        prodml21__FluidComponentCatalog *FluidComponentCatalog;
        /// Optional element 'prodml21:SampleIntegrityAndPreparation' of XML schema type 'prodml21:SampleIntegrityAndPreparation'
        prodml21__SampleIntegrityAndPreparation *SampleIntegrityAndPreparation;
        /// Optional element 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis' of XML schema type 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis'
        std::vector<prodml21__AtmosphericFlashTestAndCompositionalAnalysis *> AtmosphericFlashTestAndCompositionalAnalysis;
        /// Optional element 'prodml21:ConstantCompositionExpansionTest' of XML schema type 'prodml21:ConstantCompositionExpansionTest'
        std::vector<prodml21__ConstantCompositionExpansionTest *> ConstantCompositionExpansionTest;
        /// Optional element 'prodml21:SaturationTest' of XML schema type 'prodml21:SaturationTest'
        std::vector<prodml21__SaturationTest *> SaturationTest;
        /// Optional element 'prodml21:DifferentialLiberationTest' of XML schema type 'prodml21:DifferentialLiberationTest'
        std::vector<prodml21__DifferentialLiberationTest *> DifferentialLiberationTest;
        /// Optional element 'prodml21:ConstantVolumeDepletionTest' of XML schema type 'prodml21:ConstantVolumeDepletionTest'
        std::vector<prodml21__ConstantVolumeDepletionTest *> ConstantVolumeDepletionTest;
        /// Optional element 'prodml21:SeparatorTest' of XML schema type 'prodml21:FluidSeparatorTest'
        std::vector<prodml21__FluidSeparatorTest *> SeparatorTest;
        /// Optional element 'prodml21:TransportTest' of XML schema type 'prodml21:OtherMeasurementTest'
        std::vector<prodml21__OtherMeasurementTest *> TransportTest;
        /// Optional element 'prodml21:VaporLiquidEquilibriumTest' of XML schema type 'prodml21:VaporLiquidEquilibriumTest'
        std::vector<prodml21__VaporLiquidEquilibriumTest *> VaporLiquidEquilibriumTest;
        /// Optional element 'prodml21:SwellingTest' of XML schema type 'prodml21:SwellingTest'
        std::vector<prodml21__SwellingTest *> SwellingTest;
        /// Optional element 'prodml21:SlimTubeTest' of XML schema type 'prodml21:SlimTubeTest'
        std::vector<prodml21__SlimTubeTest *> SlimTubeTest;
        /// Optional element 'prodml21:MultipleContactMiscibilityTest' of XML schema type 'prodml21:MultipleContactMiscibilityTest'
        std::vector<prodml21__MultipleContactMiscibilityTest *> MultipleContactMiscibilityTest;
        /// Optional element 'prodml21:STOAnalysis' of XML schema type 'prodml21:STOAnalysis'
        std::vector<prodml21__STOAnalysis *> STOAnalysis;
        /// Optional element 'prodml21:InterfacialTensionTest' of XML schema type 'prodml21:InterfacialTensionTest'
        std::vector<prodml21__InterfacialTensionTest *> InterfacialTensionTest;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HydrocarbonAnalysis, default initialized and not managed by a soap context
        virtual prodml21__HydrocarbonAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HydrocarbonAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__HydrocarbonAnalysis() : FluidComponentCatalog(), SampleIntegrityAndPreparation(), AtmosphericFlashTestAndCompositionalAnalysis(), ConstantCompositionExpansionTest(), SaturationTest(), DifferentialLiberationTest(), ConstantVolumeDepletionTest(), SeparatorTest(), TransportTest(), VaporLiquidEquilibriumTest(), SwellingTest(), SlimTubeTest(), MultipleContactMiscibilityTest(), STOAnalysis(), InterfacialTensionTest() { }
        virtual ~prodml21__HydrocarbonAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__HydrocarbonAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HydrocarbonAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__HydrocarbonAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:578 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis (-224)
/* complex XML schema type 'prodml21:WaterAnalysis': */
class SOAP_CMAC prodml21__WaterAnalysis : public prodml21__FluidAnalysis {
      public:
        /// Optional element 'prodml21:WaterAnalysisTest' of XML schema type 'prodml21:WaterAnalysisTest'
        std::vector<prodml21__WaterAnalysisTest *> WaterAnalysisTest;
        /// Optional element 'prodml21:SampleIntegrityAndPreparation' of XML schema type 'prodml21:SampleIntegrityAndPreparation'
        prodml21__SampleIntegrityAndPreparation *SampleIntegrityAndPreparation;
        /// Optional element 'prodml21:WaterSampleComponent' of XML schema type 'prodml21:WaterSampleComponent'
        std::vector<prodml21__WaterSampleComponent *> WaterSampleComponent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WaterAnalysis, default initialized and not managed by a soap context
        virtual prodml21__WaterAnalysis *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WaterAnalysis); }
      public:
        /// Constructor with default initializations
        prodml21__WaterAnalysis() : WaterAnalysisTest(), SampleIntegrityAndPreparation(), WaterSampleComponent() { }
        virtual ~prodml21__WaterAnalysis() { }
        /// Friend allocator used by soap_new_prodml21__WaterAnalysis(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WaterAnalysis * SOAP_FMAC2 soap_instantiate_prodml21__WaterAnalysis(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:638 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes (-254)
/* complex XML schema type 'prodml21:AssetProductionVolumes': */
class SOAP_CMAC prodml21__AssetProductionVolumes : public prodml21__AbstractSimpleProductVolume {
      public:
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm StartDate;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm EndDate;
        /// Required element 'prodml21:NominalPeriod' of XML schema type 'prodml21:ReportingDurationKindExt'
        std::string NominalPeriod;
        /// Optional element 'prodml21:ReportingEntityVolumes' of XML schema type 'prodml21:ReportingEntityVolumes'
        std::vector<prodml21__ReportingEntityVolumes *> ReportingEntityVolumes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AssetProductionVolumes, default initialized and not managed by a soap context
        virtual prodml21__AssetProductionVolumes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AssetProductionVolumes); }
      public:
        /// Constructor with default initializations
        prodml21__AssetProductionVolumes() : StartDate(), EndDate(), NominalPeriod(), ReportingEntityVolumes() { }
        virtual ~prodml21__AssetProductionVolumes() { }
        /// Friend allocator used by soap_new_prodml21__AssetProductionVolumes(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AssetProductionVolumes * SOAP_FMAC2 soap_instantiate_prodml21__AssetProductionVolumes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:658 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests (-264)
/* complex XML schema type 'prodml21:ProductionWellTests': */
class SOAP_CMAC prodml21__ProductionWellTests : public prodml21__AbstractSimpleProductVolume {
      public:
        /// Required element 'prodml21:NominalPeriodKind' of XML schema type 'prodml21:ReportingDurationKindExt'
        std::string NominalPeriodKind;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm StartDate;
        /// Typedef eml22__TimeStamp with custom serializer for struct tm
        struct tm EndDate;
        /// Optional element 'prodml21:ProductionWellTest' of XML schema type 'prodml21:ProductionWellTest'
        std::vector<prodml21__ProductionWellTest *> ProductionWellTest;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductionWellTests, default initialized and not managed by a soap context
        virtual prodml21__ProductionWellTests *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductionWellTests); }
      public:
        /// Constructor with default initializations
        prodml21__ProductionWellTests() : NominalPeriodKind(), StartDate(), EndDate(), ProductionWellTest() { }
        virtual ~prodml21__ProductionWellTests() { }
        /// Friend allocator used by soap_new_prodml21__ProductionWellTests(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductionWellTests * SOAP_FMAC2 soap_instantiate_prodml21__ProductionWellTests(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:666 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting (-268)
/* complex XML schema type 'prodml21:TerminalLifting': */
class SOAP_CMAC prodml21__TerminalLifting : public prodml21__AbstractSimpleProductVolume {
      public:
        /// Required element 'prodml21:CertificateNumber' of XML schema type 'eml22:String64'
        std::string CertificateNumber;
        /// Optional element 'prodml21:StartTime' of XML schema type 'eml22:TimeStamp'
        struct tm *StartTime;
        /// Optional element 'prodml21:EndTime' of XML schema type 'eml22:TimeStamp'
        struct tm *EndTime;
        /// Required element 'prodml21:LoadingTerminal' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *LoadingTerminal;
        /// Required element 'prodml21:Tanker' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Tanker;
        /// Optional element 'prodml21:ProductQuantity' of XML schema type 'prodml21:ProductFluid'
        std::vector<prodml21__ProductFluid *> ProductQuantity;
        /// Optional element 'prodml21:DestinationTerminal' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *DestinationTerminal;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TerminalLifting, default initialized and not managed by a soap context
        virtual prodml21__TerminalLifting *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TerminalLifting); }
      public:
        /// Constructor with default initializations
        prodml21__TerminalLifting() : CertificateNumber(), StartTime(), EndTime(), LoadingTerminal(), Tanker(), ProductQuantity(), DestinationTerminal() { }
        virtual ~prodml21__TerminalLifting() { }
        /// Friend allocator used by soap_new_prodml21__TerminalLifting(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TerminalLifting * SOAP_FMAC2 soap_instantiate_prodml21__TerminalLifting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:672 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer (-271)
/* complex XML schema type 'prodml21:Transfer': */
class SOAP_CMAC prodml21__Transfer : public prodml21__AbstractSimpleProductVolume {
      public:
        /// Required element 'prodml21:TransferKind' of XML schema type 'prodml21:TransferKind'
        prodml21__TransferKind TransferKind;
        /// Optional element 'prodml21:StartTime' of XML schema type 'eml22:TimeStamp'
        struct tm *StartTime;
        /// Optional element 'prodml21:EndTime' of XML schema type 'eml22:TimeStamp'
        struct tm *EndTime;
        /// Optional element 'prodml21:ProductTransferQuantity' of XML schema type 'prodml21:ProductFluid'
        std::vector<prodml21__ProductFluid *> ProductTransferQuantity;
        /// Required element 'prodml21:DestinationFacility' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *DestinationFacility;
        /// Required element 'prodml21:SourceFacility' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *SourceFacility;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Transfer, default initialized and not managed by a soap context
        virtual prodml21__Transfer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Transfer); }
      public:
        /// Constructor with default initializations
        prodml21__Transfer() : TransferKind(), StartTime(), EndTime(), ProductTransferQuantity(), DestinationFacility(), SourceFacility() { }
        virtual ~prodml21__Transfer() { }
        /// Friend allocator used by soap_new_prodml21__Transfer(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Transfer * SOAP_FMAC2 soap_instantiate_prodml21__Transfer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:678 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters (-274)
/* complex XML schema type 'prodml21:WellProductionParameters': */
class SOAP_CMAC prodml21__WellProductionParameters : public prodml21__AbstractSimpleProductVolume {
      public:
        /// Optional element 'prodml21:StartDate' of XML schema type 'xsd:date'
        std::string *StartDate;
        /// Optional element 'prodml21:EndDate' of XML schema type 'xsd:date'
        std::string *EndDate;
        /// Optional element 'prodml21:NominalPeriod' of XML schema type 'prodml21:ReportingDurationKindExt'
        std::string *NominalPeriod;
        /// Required element 'prodml21:ProductionPeriod' of XML schema type 'prodml21:ProductionWellPeriod'
        std::vector<prodml21__ProductionWellPeriod *> ProductionPeriod;
        /// Required element 'prodml21:ReportingEntity' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *ReportingEntity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__WellProductionParameters, default initialized and not managed by a soap context
        virtual prodml21__WellProductionParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__WellProductionParameters); }
      public:
        /// Constructor with default initializations
        prodml21__WellProductionParameters() : StartDate(), EndDate(), NominalPeriod(), ProductionPeriod(), ReportingEntity() { }
        virtual ~prodml21__WellProductionParameters() { }
        /// Friend allocator used by soap_new_prodml21__WellProductionParameters(struct soap*, int)
        friend SOAP_FMAC1 prodml21__WellProductionParameters * SOAP_FMAC2 soap_instantiate_prodml21__WellProductionParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:688 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest (-279)
/* complex XML schema type 'prodml21:DrillStemTest': */
class SOAP_CMAC prodml21__DrillStemTest : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        prodml21__FlowTestMeasurementSet *IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DrillStemTest, default initialized and not managed by a soap context
        virtual prodml21__DrillStemTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DrillStemTest); }
      public:
        /// Constructor with default initializations
        prodml21__DrillStemTest() : IntervalMeasurementSet() { }
        virtual ~prodml21__DrillStemTest() { }
        /// Friend allocator used by soap_new_prodml21__DrillStemTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DrillStemTest * SOAP_FMAC2 soap_instantiate_prodml21__DrillStemTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:696 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation (-283)
/* complex XML schema type 'prodml21:FormationTesterStation': */
class SOAP_CMAC prodml21__FormationTesterStation : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        prodml21__FlowTestMeasurementSet *IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FormationTesterStation, default initialized and not managed by a soap context
        virtual prodml21__FormationTesterStation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FormationTesterStation); }
      public:
        /// Constructor with default initializations
        prodml21__FormationTesterStation() : IntervalMeasurementSet() { }
        virtual ~prodml21__FormationTesterStation() { }
        /// Friend allocator used by soap_new_prodml21__FormationTesterStation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FormationTesterStation * SOAP_FMAC2 soap_instantiate_prodml21__FormationTesterStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:698 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest (-284)
/* complex XML schema type 'prodml21:InterwellTest': */
class SOAP_CMAC prodml21__InterwellTest : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        std::vector<prodml21__FlowTestMeasurementSet *> IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InterwellTest, default initialized and not managed by a soap context
        virtual prodml21__InterwellTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InterwellTest); }
      public:
        /// Constructor with default initializations
        prodml21__InterwellTest() : IntervalMeasurementSet() { }
        virtual ~prodml21__InterwellTest() { }
        /// Friend allocator used by soap_new_prodml21__InterwellTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InterwellTest * SOAP_FMAC2 soap_instantiate_prodml21__InterwellTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:702 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest (-286)
/* complex XML schema type 'prodml21:ProductionFlowTest': */
class SOAP_CMAC prodml21__ProductionFlowTest : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        prodml21__FlowTestMeasurementSet *IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductionFlowTest, default initialized and not managed by a soap context
        virtual prodml21__ProductionFlowTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductionFlowTest); }
      public:
        /// Constructor with default initializations
        prodml21__ProductionFlowTest() : IntervalMeasurementSet() { }
        virtual ~prodml21__ProductionFlowTest() { }
        /// Friend allocator used by soap_new_prodml21__ProductionFlowTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductionFlowTest * SOAP_FMAC2 soap_instantiate_prodml21__ProductionFlowTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:704 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest (-287)
/* complex XML schema type 'prodml21:ProductionTransientTest': */
class SOAP_CMAC prodml21__ProductionTransientTest : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        prodml21__FlowTestMeasurementSet *IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ProductionTransientTest, default initialized and not managed by a soap context
        virtual prodml21__ProductionTransientTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ProductionTransientTest); }
      public:
        /// Constructor with default initializations
        prodml21__ProductionTransientTest() : IntervalMeasurementSet() { }
        virtual ~prodml21__ProductionTransientTest() { }
        /// Friend allocator used by soap_new_prodml21__ProductionTransientTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ProductionTransientTest * SOAP_FMAC2 soap_instantiate_prodml21__ProductionTransientTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:706 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest (-288)
/* complex XML schema type 'prodml21:VerticalInterferenceTest': */
class SOAP_CMAC prodml21__VerticalInterferenceTest : public prodml21__FlowTestActivity {
      public:
        /// Required element 'prodml21:IntervalMeasurementSet' of XML schema type 'prodml21:FlowTestMeasurementSet'
        std::vector<prodml21__FlowTestMeasurementSet *> IntervalMeasurementSet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__VerticalInterferenceTest, default initialized and not managed by a soap context
        virtual prodml21__VerticalInterferenceTest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__VerticalInterferenceTest); }
      public:
        /// Constructor with default initializations
        prodml21__VerticalInterferenceTest() : IntervalMeasurementSet() { }
        virtual ~prodml21__VerticalInterferenceTest() { }
        /// Friend allocator used by soap_new_prodml21__VerticalInterferenceTest(struct soap*, int)
        friend SOAP_FMAC1 prodml21__VerticalInterferenceTest * SOAP_FMAC2 soap_instantiate_prodml21__VerticalInterferenceTest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:728 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData (-299)
/* complex XML schema type 'prodml21:DeconvolvedFlowData': */
class SOAP_CMAC prodml21__DeconvolvedFlowData : public prodml21__AbstractPtaFlowData {
      public:
        /// Required element 'prodml21:Deconvolution' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Deconvolution;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeconvolvedFlowData, default initialized and not managed by a soap context
        virtual prodml21__DeconvolvedFlowData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeconvolvedFlowData); }
      public:
        /// Constructor with default initializations
        prodml21__DeconvolvedFlowData() : Deconvolution() { }
        virtual ~prodml21__DeconvolvedFlowData() { }
        /// Friend allocator used by soap_new_prodml21__DeconvolvedFlowData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeconvolvedFlowData * SOAP_FMAC2 soap_instantiate_prodml21__DeconvolvedFlowData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:730 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData (-300)
/* complex XML schema type 'prodml21:DeconvolvedPressureData': */
class SOAP_CMAC prodml21__DeconvolvedPressureData : public prodml21__AbstractPtaPressureData {
      public:
        /// Required element 'prodml21:Deconvolution' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *Deconvolution;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeconvolvedPressureData, default initialized and not managed by a soap context
        virtual prodml21__DeconvolvedPressureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeconvolvedPressureData); }
      public:
        /// Constructor with default initializations
        prodml21__DeconvolvedPressureData() : Deconvolution() { }
        virtual ~prodml21__DeconvolvedPressureData() { }
        /// Friend allocator used by soap_new_prodml21__DeconvolvedPressureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeconvolvedPressureData * SOAP_FMAC2 soap_instantiate_prodml21__DeconvolvedPressureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:746 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData (-308)
/* complex XML schema type 'prodml21:MeasuredFlowData': */
class SOAP_CMAC prodml21__MeasuredFlowData : public prodml21__AbstractPtaFlowData {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MeasuredFlowData, default initialized and not managed by a soap context
        virtual prodml21__MeasuredFlowData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MeasuredFlowData); }
      public:
        /// Constructor with default initializations
        prodml21__MeasuredFlowData() { }
        virtual ~prodml21__MeasuredFlowData() { }
        /// Friend allocator used by soap_new_prodml21__MeasuredFlowData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MeasuredFlowData * SOAP_FMAC2 soap_instantiate_prodml21__MeasuredFlowData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:748 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData (-309)
/* complex XML schema type 'prodml21:MeasuredPressureData': */
class SOAP_CMAC prodml21__MeasuredPressureData : public prodml21__AbstractPtaPressureData {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__MeasuredPressureData, default initialized and not managed by a soap context
        virtual prodml21__MeasuredPressureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__MeasuredPressureData); }
      public:
        /// Constructor with default initializations
        prodml21__MeasuredPressureData() { }
        virtual ~prodml21__MeasuredPressureData() { }
        /// Friend allocator used by soap_new_prodml21__MeasuredPressureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__MeasuredPressureData * SOAP_FMAC2 soap_instantiate_prodml21__MeasuredPressureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:750 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData (-310)
/* complex XML schema type 'prodml21:OutputFlowData': */
class SOAP_CMAC prodml21__OutputFlowData : public prodml21__AbstractPtaFlowData {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OutputFlowData, default initialized and not managed by a soap context
        virtual prodml21__OutputFlowData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OutputFlowData); }
      public:
        /// Constructor with default initializations
        prodml21__OutputFlowData() { }
        virtual ~prodml21__OutputFlowData() { }
        /// Friend allocator used by soap_new_prodml21__OutputFlowData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OutputFlowData * SOAP_FMAC2 soap_instantiate_prodml21__OutputFlowData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:752 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData (-311)
/* complex XML schema type 'prodml21:OutputPressureData': */
class SOAP_CMAC prodml21__OutputPressureData : public prodml21__AbstractPtaPressureData {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OutputPressureData, default initialized and not managed by a soap context
        virtual prodml21__OutputPressureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OutputPressureData); }
      public:
        /// Constructor with default initializations
        prodml21__OutputPressureData() { }
        virtual ~prodml21__OutputPressureData() { }
        /// Friend allocator used by soap_new_prodml21__OutputPressureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OutputPressureData * SOAP_FMAC2 soap_instantiate_prodml21__OutputPressureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:754 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData (-312)
/* complex XML schema type 'prodml21:PreProcessedFlowData': */
class SOAP_CMAC prodml21__PreProcessedFlowData : public prodml21__AbstractPtaFlowData {
      public:
        /// Required element 'prodml21:PreProcess' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *PreProcess;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PreProcessedFlowData, default initialized and not managed by a soap context
        virtual prodml21__PreProcessedFlowData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PreProcessedFlowData); }
      public:
        /// Constructor with default initializations
        prodml21__PreProcessedFlowData() : PreProcess() { }
        virtual ~prodml21__PreProcessedFlowData() { }
        /// Friend allocator used by soap_new_prodml21__PreProcessedFlowData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PreProcessedFlowData * SOAP_FMAC2 soap_instantiate_prodml21__PreProcessedFlowData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:756 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData (-313)
/* complex XML schema type 'prodml21:PreProcessedPressureData': */
class SOAP_CMAC prodml21__PreProcessedPressureData : public prodml21__AbstractPtaPressureData {
      public:
        /// Required element 'prodml21:PreProcess' of XML schema type 'eml22:DataObjectReference'
        eml22__DataObjectReference *PreProcess;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PreProcessedPressureData, default initialized and not managed by a soap context
        virtual prodml21__PreProcessedPressureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PreProcessedPressureData); }
      public:
        /// Constructor with default initializations
        prodml21__PreProcessedPressureData() : PreProcess() { }
        virtual ~prodml21__PreProcessedPressureData() { }
        /// Friend allocator used by soap_new_prodml21__PreProcessedPressureData(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PreProcessedPressureData * SOAP_FMAC2 soap_instantiate_prodml21__PreProcessedPressureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:786 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel (-328)
/* complex XML schema type 'prodml21:ChangingStorageFairModel': */
class SOAP_CMAC prodml21__ChangingStorageFairModel : public prodml21__WellboreBaseModel {
      public:
        /// Required element 'prodml21:RatioInitialToFinalWellboreStorage' of XML schema type 'prodml21:RatioInitialToFinalWellboreStorage'
        prodml21__RatioInitialToFinalWellboreStorage *RatioInitialToFinalWellboreStorage;
        /// Required element 'prodml21:DeltaTimeStorageChanges' of XML schema type 'prodml21:DeltaTimeStorageChanges'
        prodml21__DeltaTimeStorageChanges *DeltaTimeStorageChanges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChangingStorageFairModel, default initialized and not managed by a soap context
        virtual prodml21__ChangingStorageFairModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChangingStorageFairModel); }
      public:
        /// Constructor with default initializations
        prodml21__ChangingStorageFairModel() : RatioInitialToFinalWellboreStorage(), DeltaTimeStorageChanges() { }
        virtual ~prodml21__ChangingStorageFairModel() { }
        /// Friend allocator used by soap_new_prodml21__ChangingStorageFairModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChangingStorageFairModel * SOAP_FMAC2 soap_instantiate_prodml21__ChangingStorageFairModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:788 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel (-329)
/* complex XML schema type 'prodml21:ChangingStorageHegemanModel': */
class SOAP_CMAC prodml21__ChangingStorageHegemanModel : public prodml21__WellboreBaseModel {
      public:
        /// Required element 'prodml21:RatioInitialToFinalWellboreStorage' of XML schema type 'prodml21:RatioInitialToFinalWellboreStorage'
        prodml21__RatioInitialToFinalWellboreStorage *RatioInitialToFinalWellboreStorage;
        /// Required element 'prodml21:DeltaTimeStorageChanges' of XML schema type 'prodml21:DeltaTimeStorageChanges'
        prodml21__DeltaTimeStorageChanges *DeltaTimeStorageChanges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChangingStorageHegemanModel, default initialized and not managed by a soap context
        virtual prodml21__ChangingStorageHegemanModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChangingStorageHegemanModel); }
      public:
        /// Constructor with default initializations
        prodml21__ChangingStorageHegemanModel() : RatioInitialToFinalWellboreStorage(), DeltaTimeStorageChanges() { }
        virtual ~prodml21__ChangingStorageHegemanModel() { }
        /// Friend allocator used by soap_new_prodml21__ChangingStorageHegemanModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChangingStorageHegemanModel * SOAP_FMAC2 soap_instantiate_prodml21__ChangingStorageHegemanModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:790 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel (-330)
/* complex XML schema type 'prodml21:ChangingStorageSpiveyFissuresModel': */
class SOAP_CMAC prodml21__ChangingStorageSpiveyFissuresModel : public prodml21__WellboreBaseModel {
      public:
        /// Required element 'prodml21:RatioInitialToFinalWellboreStorage' of XML schema type 'prodml21:RatioInitialToFinalWellboreStorage'
        prodml21__RatioInitialToFinalWellboreStorage *RatioInitialToFinalWellboreStorage;
        /// Required element 'prodml21:LeakSkin' of XML schema type 'prodml21:LeakSkin'
        prodml21__LeakSkin *LeakSkin;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChangingStorageSpiveyFissuresModel, default initialized and not managed by a soap context
        virtual prodml21__ChangingStorageSpiveyFissuresModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChangingStorageSpiveyFissuresModel); }
      public:
        /// Constructor with default initializations
        prodml21__ChangingStorageSpiveyFissuresModel() : RatioInitialToFinalWellboreStorage(), LeakSkin() { }
        virtual ~prodml21__ChangingStorageSpiveyFissuresModel() { }
        /// Friend allocator used by soap_new_prodml21__ChangingStorageSpiveyFissuresModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChangingStorageSpiveyFissuresModel * SOAP_FMAC2 soap_instantiate_prodml21__ChangingStorageSpiveyFissuresModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:792 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel (-331)
/* complex XML schema type 'prodml21:ChangingStorageSpiveyPackerModel': */
class SOAP_CMAC prodml21__ChangingStorageSpiveyPackerModel : public prodml21__WellboreBaseModel {
      public:
        /// Required element 'prodml21:RatioInitialToFinalWellboreStorage' of XML schema type 'prodml21:RatioInitialToFinalWellboreStorage'
        prodml21__RatioInitialToFinalWellboreStorage *RatioInitialToFinalWellboreStorage;
        /// Required element 'prodml21:LeakSkin' of XML schema type 'prodml21:LeakSkin'
        prodml21__LeakSkin *LeakSkin;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ChangingStorageSpiveyPackerModel, default initialized and not managed by a soap context
        virtual prodml21__ChangingStorageSpiveyPackerModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ChangingStorageSpiveyPackerModel); }
      public:
        /// Constructor with default initializations
        prodml21__ChangingStorageSpiveyPackerModel() : RatioInitialToFinalWellboreStorage(), LeakSkin() { }
        virtual ~prodml21__ChangingStorageSpiveyPackerModel() { }
        /// Friend allocator used by soap_new_prodml21__ChangingStorageSpiveyPackerModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ChangingStorageSpiveyPackerModel * SOAP_FMAC2 soap_instantiate_prodml21__ChangingStorageSpiveyPackerModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:794 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel (-332)
/* complex XML schema type 'prodml21:ClosedCircleModel': */
class SOAP_CMAC prodml21__ClosedCircleModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ClosedCircleModel, default initialized and not managed by a soap context
        virtual prodml21__ClosedCircleModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ClosedCircleModel); }
      public:
        /// Constructor with default initializations
        prodml21__ClosedCircleModel() : Boundary1Type() { }
        virtual ~prodml21__ClosedCircleModel() { }
        /// Friend allocator used by soap_new_prodml21__ClosedCircleModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ClosedCircleModel * SOAP_FMAC2 soap_instantiate_prodml21__ClosedCircleModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:796 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel (-333)
/* complex XML schema type 'prodml21:ClosedRectangleModel': */
class SOAP_CMAC prodml21__ClosedRectangleModel : public prodml21__BoundaryBaseModel {
      public:
        /// Optional element 'prodml21:DrainageAreaMeasured' of XML schema type 'prodml21:DrainageAreaMeasured'
        prodml21__DrainageAreaMeasured *DrainageAreaMeasured;
        /// Optional element 'prodml21:PoreVolumeMeasured' of XML schema type 'prodml21:PoreVolumeMeasured'
        prodml21__PoreVolumeMeasured *PoreVolumeMeasured;
        /// Required element 'prodml21:DistanceToBoundary1' of XML schema type 'prodml21:DistanceToBoundary1'
        prodml21__DistanceToBoundary1 *DistanceToBoundary1;
        /// Required element 'prodml21:DistanceToBoundary2' of XML schema type 'prodml21:DistanceToBoundary2'
        prodml21__DistanceToBoundary2 *DistanceToBoundary2;
        /// Required element 'prodml21:DistanceToBoundary3' of XML schema type 'prodml21:DistanceToBoundary3'
        prodml21__DistanceToBoundary3 *DistanceToBoundary3;
        /// Required element 'prodml21:DistanceToBoundary4' of XML schema type 'prodml21:DistanceToBoundary4'
        prodml21__DistanceToBoundary4 *DistanceToBoundary4;
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
        /// Required element 'prodml21:Boundary2Type' of XML schema type 'prodml21:Boundary2Type'
        prodml21__Boundary2Type Boundary2Type;
        /// Required element 'prodml21:Boundary3Type' of XML schema type 'prodml21:Boundary3Type'
        prodml21__Boundary3Type Boundary3Type;
        /// Required element 'prodml21:Boundary4Type' of XML schema type 'prodml21:Boundary4Type'
        prodml21__Boundary4Type Boundary4Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ClosedRectangleModel, default initialized and not managed by a soap context
        virtual prodml21__ClosedRectangleModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ClosedRectangleModel); }
      public:
        /// Constructor with default initializations
        prodml21__ClosedRectangleModel() : DrainageAreaMeasured(), PoreVolumeMeasured(), DistanceToBoundary1(), DistanceToBoundary2(), DistanceToBoundary3(), DistanceToBoundary4(), OrientationOfNormalToBoundary1(), Boundary1Type(), Boundary2Type(), Boundary3Type(), Boundary4Type() { }
        virtual ~prodml21__ClosedRectangleModel() { }
        /// Friend allocator used by soap_new_prodml21__ClosedRectangleModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ClosedRectangleModel * SOAP_FMAC2 soap_instantiate_prodml21__ClosedRectangleModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:798 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel (-334)
/* complex XML schema type 'prodml21:ConstantStorageModel': */
class SOAP_CMAC prodml21__ConstantStorageModel : public prodml21__WellboreBaseModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__ConstantStorageModel, default initialized and not managed by a soap context
        virtual prodml21__ConstantStorageModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__ConstantStorageModel); }
      public:
        /// Constructor with default initializations
        prodml21__ConstantStorageModel() { }
        virtual ~prodml21__ConstantStorageModel() { }
        /// Friend allocator used by soap_new_prodml21__ConstantStorageModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__ConstantStorageModel * SOAP_FMAC2 soap_instantiate_prodml21__ConstantStorageModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:800 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel (-335)
/* complex XML schema type 'prodml21:CustomBoundaryModel': */
class SOAP_CMAC prodml21__CustomBoundaryModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:ModelName' of XML schema type 'prodml21:ModelName'
        prodml21__ModelName *ModelName;
        /// Optional element 'prodml21:AnyParameter' of XML schema type 'prodml21:AbstractParameter'
        std::vector<prodml21__AbstractParameter *> AnyParameter;
        /// Optional element 'prodml21:CustomParameter' of XML schema type 'prodml21:CustomParameter'
        std::vector<prodml21__CustomParameter *> CustomParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomBoundaryModel, default initialized and not managed by a soap context
        virtual prodml21__CustomBoundaryModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomBoundaryModel); }
      public:
        /// Constructor with default initializations
        prodml21__CustomBoundaryModel() : ModelName(), AnyParameter(), CustomParameter() { }
        virtual ~prodml21__CustomBoundaryModel() { }
        /// Friend allocator used by soap_new_prodml21__CustomBoundaryModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomBoundaryModel * SOAP_FMAC2 soap_instantiate_prodml21__CustomBoundaryModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:802 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel (-336)
/* complex XML schema type 'prodml21:CustomNearWellboreModel': */
class SOAP_CMAC prodml21__CustomNearWellboreModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:ModelName' of XML schema type 'prodml21:ModelName'
        prodml21__ModelName *ModelName;
        /// Optional element 'prodml21:AnyParameter' of XML schema type 'prodml21:AbstractParameter'
        std::vector<prodml21__AbstractParameter *> AnyParameter;
        /// Optional element 'prodml21:CustomParameter' of XML schema type 'prodml21:CustomParameter'
        std::vector<prodml21__CustomParameter *> CustomParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomNearWellboreModel, default initialized and not managed by a soap context
        virtual prodml21__CustomNearWellboreModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomNearWellboreModel); }
      public:
        /// Constructor with default initializations
        prodml21__CustomNearWellboreModel() : ModelName(), AnyParameter(), CustomParameter() { }
        virtual ~prodml21__CustomNearWellboreModel() { }
        /// Friend allocator used by soap_new_prodml21__CustomNearWellboreModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomNearWellboreModel * SOAP_FMAC2 soap_instantiate_prodml21__CustomNearWellboreModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:804 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel (-337)
/* complex XML schema type 'prodml21:CustomReservoirModel': */
class SOAP_CMAC prodml21__CustomReservoirModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:ModelName' of XML schema type 'prodml21:ModelName'
        prodml21__ModelName *ModelName;
        /// Optional element 'prodml21:AnyParameter' of XML schema type 'prodml21:AbstractParameter'
        std::vector<prodml21__AbstractParameter *> AnyParameter;
        /// Optional element 'prodml21:CustomParameter' of XML schema type 'prodml21:CustomParameter'
        std::vector<prodml21__CustomParameter *> CustomParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomReservoirModel, default initialized and not managed by a soap context
        virtual prodml21__CustomReservoirModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomReservoirModel); }
      public:
        /// Constructor with default initializations
        prodml21__CustomReservoirModel() : ModelName(), AnyParameter(), CustomParameter() { }
        virtual ~prodml21__CustomReservoirModel() { }
        /// Friend allocator used by soap_new_prodml21__CustomReservoirModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomReservoirModel * SOAP_FMAC2 soap_instantiate_prodml21__CustomReservoirModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:806 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel (-338)
/* complex XML schema type 'prodml21:CustomWellboreModel': */
class SOAP_CMAC prodml21__CustomWellboreModel : public prodml21__WellboreBaseModel {
      public:
        /// Required element 'prodml21:ModelName' of XML schema type 'prodml21:ModelName'
        prodml21__ModelName *ModelName;
        /// Optional element 'prodml21:AnyParameter' of XML schema type 'prodml21:AbstractParameter'
        std::vector<prodml21__AbstractParameter *> AnyParameter;
        /// Optional element 'prodml21:CustomParameter' of XML schema type 'prodml21:CustomParameter'
        std::vector<prodml21__CustomParameter *> CustomParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CustomWellboreModel, default initialized and not managed by a soap context
        virtual prodml21__CustomWellboreModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CustomWellboreModel); }
      public:
        /// Constructor with default initializations
        prodml21__CustomWellboreModel() : ModelName(), AnyParameter(), CustomParameter() { }
        virtual ~prodml21__CustomWellboreModel() { }
        /// Friend allocator used by soap_new_prodml21__CustomWellboreModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CustomWellboreModel * SOAP_FMAC2 soap_instantiate_prodml21__CustomWellboreModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:808 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel (-339)
/* complex XML schema type 'prodml21:DualPermeabilityWithCrossflowModel': */
class SOAP_CMAC prodml21__DualPermeabilityWithCrossflowModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InterporosityFlowParameter' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterporosityFlowParameter;
        /// Required element 'prodml21:StorativityRatio' of XML schema type 'prodml21:StorativityRatio'
        prodml21__StorativityRatio *StorativityRatio;
        /// Required element 'prodml21:RatioLayer1ToTotalPermeabilityThicknessProduct' of XML schema type 'prodml21:RatioLayer1ToTotalPermeabilityThicknessProduct'
        prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct *RatioLayer1ToTotalPermeabilityThicknessProduct;
        /// Optional element 'prodml21:Layer2Thickness' of XML schema type 'prodml21:Layer2Thickness'
        prodml21__Layer2Thickness *Layer2Thickness;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DualPermeabilityWithCrossflowModel, default initialized and not managed by a soap context
        virtual prodml21__DualPermeabilityWithCrossflowModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DualPermeabilityWithCrossflowModel); }
      public:
        /// Constructor with default initializations
        prodml21__DualPermeabilityWithCrossflowModel() : InterporosityFlowParameter(), StorativityRatio(), RatioLayer1ToTotalPermeabilityThicknessProduct(), Layer2Thickness() { }
        virtual ~prodml21__DualPermeabilityWithCrossflowModel() { }
        /// Friend allocator used by soap_new_prodml21__DualPermeabilityWithCrossflowModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DualPermeabilityWithCrossflowModel * SOAP_FMAC2 soap_instantiate_prodml21__DualPermeabilityWithCrossflowModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:810 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel (-340)
/* complex XML schema type 'prodml21:DualPorosityPseudoSteadyStateModel': */
class SOAP_CMAC prodml21__DualPorosityPseudoSteadyStateModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InterporosityFlowParameter' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterporosityFlowParameter;
        /// Required element 'prodml21:StorativityRatio' of XML schema type 'prodml21:StorativityRatio'
        prodml21__StorativityRatio *StorativityRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DualPorosityPseudoSteadyStateModel, default initialized and not managed by a soap context
        virtual prodml21__DualPorosityPseudoSteadyStateModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DualPorosityPseudoSteadyStateModel); }
      public:
        /// Constructor with default initializations
        prodml21__DualPorosityPseudoSteadyStateModel() : InterporosityFlowParameter(), StorativityRatio() { }
        virtual ~prodml21__DualPorosityPseudoSteadyStateModel() { }
        /// Friend allocator used by soap_new_prodml21__DualPorosityPseudoSteadyStateModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DualPorosityPseudoSteadyStateModel * SOAP_FMAC2 soap_instantiate_prodml21__DualPorosityPseudoSteadyStateModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:812 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel (-341)
/* complex XML schema type 'prodml21:DualPorosityTransientSlabsModel': */
class SOAP_CMAC prodml21__DualPorosityTransientSlabsModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InterporosityFlowParameter' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterporosityFlowParameter;
        /// Required element 'prodml21:StorativityRatio' of XML schema type 'prodml21:StorativityRatio'
        prodml21__StorativityRatio *StorativityRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DualPorosityTransientSlabsModel, default initialized and not managed by a soap context
        virtual prodml21__DualPorosityTransientSlabsModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DualPorosityTransientSlabsModel); }
      public:
        /// Constructor with default initializations
        prodml21__DualPorosityTransientSlabsModel() : InterporosityFlowParameter(), StorativityRatio() { }
        virtual ~prodml21__DualPorosityTransientSlabsModel() { }
        /// Friend allocator used by soap_new_prodml21__DualPorosityTransientSlabsModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DualPorosityTransientSlabsModel * SOAP_FMAC2 soap_instantiate_prodml21__DualPorosityTransientSlabsModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:814 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel (-342)
/* complex XML schema type 'prodml21:DualPorosityTransientSpheresModel': */
class SOAP_CMAC prodml21__DualPorosityTransientSpheresModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InterporosityFlowParameter' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterporosityFlowParameter;
        /// Required element 'prodml21:StorativityRatio' of XML schema type 'prodml21:StorativityRatio'
        prodml21__StorativityRatio *StorativityRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DualPorosityTransientSpheresModel, default initialized and not managed by a soap context
        virtual prodml21__DualPorosityTransientSpheresModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DualPorosityTransientSpheresModel); }
      public:
        /// Constructor with default initializations
        prodml21__DualPorosityTransientSpheresModel() : InterporosityFlowParameter(), StorativityRatio() { }
        virtual ~prodml21__DualPorosityTransientSpheresModel() { }
        /// Friend allocator used by soap_new_prodml21__DualPorosityTransientSpheresModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DualPorosityTransientSpheresModel * SOAP_FMAC2 soap_instantiate_prodml21__DualPorosityTransientSpheresModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:816 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel (-343)
/* complex XML schema type 'prodml21:FiniteRadiusModel': */
class SOAP_CMAC prodml21__FiniteRadiusModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FiniteRadiusModel, default initialized and not managed by a soap context
        virtual prodml21__FiniteRadiusModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FiniteRadiusModel); }
      public:
        /// Constructor with default initializations
        prodml21__FiniteRadiusModel() : SkinLayer2RelativeToTotalThickness() { }
        virtual ~prodml21__FiniteRadiusModel() { }
        /// Friend allocator used by soap_new_prodml21__FiniteRadiusModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FiniteRadiusModel * SOAP_FMAC2 soap_instantiate_prodml21__FiniteRadiusModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:818 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel (-344)
/* complex XML schema type 'prodml21:FracturedFiniteConductivityModel': */
class SOAP_CMAC prodml21__FracturedFiniteConductivityModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Required element 'prodml21:FractureHalfLength' of XML schema type 'prodml21:FractureHalfLength'
        prodml21__FractureHalfLength *FractureHalfLength;
        /// Optional element 'prodml21:FractureFaceSkin' of XML schema type 'prodml21:FractureFaceSkin'
        prodml21__FractureFaceSkin *FractureFaceSkin;
        /// Optional element 'prodml21:OrientationOfFracturePlane' of XML schema type 'prodml21:OrientationOfFracturePlane'
        prodml21__OrientationOfFracturePlane *OrientationOfFracturePlane;
        /// Required element 'prodml21:FractureConductivity' of XML schema type 'prodml21:FractureConductivity'
        prodml21__FractureConductivity *FractureConductivity;
        /// Optional element 'prodml21:DistanceMidFractureHeightToBottomBoundary' of XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary'
        prodml21__DistanceMidFractureHeightToBottomBoundary *DistanceMidFractureHeightToBottomBoundary;
        /// Optional element 'prodml21:FractureHeight' of XML schema type 'prodml21:FractureHeight'
        prodml21__FractureHeight *FractureHeight;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedFiniteConductivityModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedFiniteConductivityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedFiniteConductivityModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedFiniteConductivityModel() : SkinLayer2RelativeToTotalThickness(), FractureHalfLength(), FractureFaceSkin(), OrientationOfFracturePlane(), FractureConductivity(), DistanceMidFractureHeightToBottomBoundary(), FractureHeight() { }
        virtual ~prodml21__FracturedFiniteConductivityModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedFiniteConductivityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedFiniteConductivityModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedFiniteConductivityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:820 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel (-345)
/* complex XML schema type 'prodml21:FracturedHorizontalFiniteConductivityModel': */
class SOAP_CMAC prodml21__FracturedHorizontalFiniteConductivityModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:FractureConductivity' of XML schema type 'prodml21:FractureConductivity'
        prodml21__FractureConductivity *FractureConductivity;
        /// Required element 'prodml21:FractureRadius' of XML schema type 'prodml21:FractureRadius'
        prodml21__FractureRadius *FractureRadius;
        /// Required element 'prodml21:DistanceFractureToBottomBoundary' of XML schema type 'prodml21:DistanceFractureToBottomBoundary'
        prodml21__DistanceFractureToBottomBoundary *DistanceFractureToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedHorizontalFiniteConductivityModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedHorizontalFiniteConductivityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedHorizontalFiniteConductivityModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedHorizontalFiniteConductivityModel() : FractureConductivity(), FractureRadius(), DistanceFractureToBottomBoundary() { }
        virtual ~prodml21__FracturedHorizontalFiniteConductivityModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedHorizontalFiniteConductivityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedHorizontalFiniteConductivityModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedHorizontalFiniteConductivityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:822 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel (-346)
/* complex XML schema type 'prodml21:FracturedHorizontalInfiniteConductivityModel': */
class SOAP_CMAC prodml21__FracturedHorizontalInfiniteConductivityModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:FractureRadius' of XML schema type 'prodml21:FractureRadius'
        prodml21__FractureRadius *FractureRadius;
        /// Required element 'prodml21:DistanceFractureToBottomBoundary' of XML schema type 'prodml21:DistanceFractureToBottomBoundary'
        prodml21__DistanceFractureToBottomBoundary *DistanceFractureToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedHorizontalInfiniteConductivityModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedHorizontalInfiniteConductivityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedHorizontalInfiniteConductivityModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedHorizontalInfiniteConductivityModel() : FractureRadius(), DistanceFractureToBottomBoundary() { }
        virtual ~prodml21__FracturedHorizontalInfiniteConductivityModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedHorizontalInfiniteConductivityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedHorizontalInfiniteConductivityModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedHorizontalInfiniteConductivityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:824 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel (-347)
/* complex XML schema type 'prodml21:FracturedHorizontalUniformFluxModel': */
class SOAP_CMAC prodml21__FracturedHorizontalUniformFluxModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:FractureRadius' of XML schema type 'prodml21:FractureRadius'
        prodml21__FractureRadius *FractureRadius;
        /// Required element 'prodml21:DistanceFractureToBottomBoundary' of XML schema type 'prodml21:DistanceFractureToBottomBoundary'
        prodml21__DistanceFractureToBottomBoundary *DistanceFractureToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedHorizontalUniformFluxModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedHorizontalUniformFluxModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedHorizontalUniformFluxModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedHorizontalUniformFluxModel() : FractureRadius(), DistanceFractureToBottomBoundary() { }
        virtual ~prodml21__FracturedHorizontalUniformFluxModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedHorizontalUniformFluxModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedHorizontalUniformFluxModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedHorizontalUniformFluxModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:826 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel (-348)
/* complex XML schema type 'prodml21:FracturedInfiniteConductivityModel': */
class SOAP_CMAC prodml21__FracturedInfiniteConductivityModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Required element 'prodml21:FractureHalfLength' of XML schema type 'prodml21:FractureHalfLength'
        prodml21__FractureHalfLength *FractureHalfLength;
        /// Optional element 'prodml21:FractureFaceSkin' of XML schema type 'prodml21:FractureFaceSkin'
        prodml21__FractureFaceSkin *FractureFaceSkin;
        /// Optional element 'prodml21:OrientationOfFracturePlane' of XML schema type 'prodml21:OrientationOfFracturePlane'
        prodml21__OrientationOfFracturePlane *OrientationOfFracturePlane;
        /// Optional element 'prodml21:DistanceMidFractureHeightToBottomBoundary' of XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary'
        prodml21__DistanceMidFractureHeightToBottomBoundary *DistanceMidFractureHeightToBottomBoundary;
        /// Optional element 'prodml21:FractureHeight' of XML schema type 'prodml21:FractureHeight'
        prodml21__FractureHeight *FractureHeight;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedInfiniteConductivityModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedInfiniteConductivityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedInfiniteConductivityModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedInfiniteConductivityModel() : SkinLayer2RelativeToTotalThickness(), FractureHalfLength(), FractureFaceSkin(), OrientationOfFracturePlane(), DistanceMidFractureHeightToBottomBoundary(), FractureHeight() { }
        virtual ~prodml21__FracturedInfiniteConductivityModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedInfiniteConductivityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedInfiniteConductivityModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedInfiniteConductivityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:828 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel (-349)
/* complex XML schema type 'prodml21:FracturedUniformFluxModel': */
class SOAP_CMAC prodml21__FracturedUniformFluxModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Required element 'prodml21:FractureHalfLength' of XML schema type 'prodml21:FractureHalfLength'
        prodml21__FractureHalfLength *FractureHalfLength;
        /// Optional element 'prodml21:FractureFaceSkin' of XML schema type 'prodml21:FractureFaceSkin'
        prodml21__FractureFaceSkin *FractureFaceSkin;
        /// Optional element 'prodml21:OrientationOfFracturePlane' of XML schema type 'prodml21:OrientationOfFracturePlane'
        prodml21__OrientationOfFracturePlane *OrientationOfFracturePlane;
        /// Optional element 'prodml21:DistanceMidFractureHeightToBottomBoundary' of XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary'
        prodml21__DistanceMidFractureHeightToBottomBoundary *DistanceMidFractureHeightToBottomBoundary;
        /// Optional element 'prodml21:FractureHeight' of XML schema type 'prodml21:FractureHeight'
        prodml21__FractureHeight *FractureHeight;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FracturedUniformFluxModel, default initialized and not managed by a soap context
        virtual prodml21__FracturedUniformFluxModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FracturedUniformFluxModel); }
      public:
        /// Constructor with default initializations
        prodml21__FracturedUniformFluxModel() : SkinLayer2RelativeToTotalThickness(), FractureHalfLength(), FractureFaceSkin(), OrientationOfFracturePlane(), DistanceMidFractureHeightToBottomBoundary(), FractureHeight() { }
        virtual ~prodml21__FracturedUniformFluxModel() { }
        /// Friend allocator used by soap_new_prodml21__FracturedUniformFluxModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FracturedUniformFluxModel * SOAP_FMAC2 soap_instantiate_prodml21__FracturedUniformFluxModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:830 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel (-350)
/* complex XML schema type 'prodml21:HomogeneousModel': */
class SOAP_CMAC prodml21__HomogeneousModel : public prodml21__ReservoirBaseModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HomogeneousModel, default initialized and not managed by a soap context
        virtual prodml21__HomogeneousModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HomogeneousModel); }
      public:
        /// Constructor with default initializations
        prodml21__HomogeneousModel() { }
        virtual ~prodml21__HomogeneousModel() { }
        /// Friend allocator used by soap_new_prodml21__HomogeneousModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HomogeneousModel * SOAP_FMAC2 soap_instantiate_prodml21__HomogeneousModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:832 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel (-351)
/* complex XML schema type 'prodml21:HorizontalWellbore2LayerModel': */
class SOAP_CMAC prodml21__HorizontalWellbore2LayerModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
        /// Required element 'prodml21:LengthHorizontalWellboreFlowing' of XML schema type 'prodml21:LengthHorizontalWellboreFlowing'
        prodml21__LengthHorizontalWellboreFlowing *LengthHorizontalWellboreFlowing;
        /// Required element 'prodml21:DistanceWellboreToBottomBoundary' of XML schema type 'prodml21:DistanceWellboreToBottomBoundary'
        prodml21__DistanceWellboreToBottomBoundary *DistanceWellboreToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalWellbore2LayerModel, default initialized and not managed by a soap context
        virtual prodml21__HorizontalWellbore2LayerModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalWellbore2LayerModel); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalWellbore2LayerModel() : ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), OrientationWellTrajectory(), LengthHorizontalWellboreFlowing(), DistanceWellboreToBottomBoundary() { }
        virtual ~prodml21__HorizontalWellbore2LayerModel() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalWellbore2LayerModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalWellbore2LayerModel * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalWellbore2LayerModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:834 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel (-352)
/* complex XML schema type 'prodml21:HorizontalWellboreModel': */
class SOAP_CMAC prodml21__HorizontalWellboreModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
        /// Required element 'prodml21:LengthHorizontalWellboreFlowing' of XML schema type 'prodml21:LengthHorizontalWellboreFlowing'
        prodml21__LengthHorizontalWellboreFlowing *LengthHorizontalWellboreFlowing;
        /// Required element 'prodml21:DistanceWellboreToBottomBoundary' of XML schema type 'prodml21:DistanceWellboreToBottomBoundary'
        prodml21__DistanceWellboreToBottomBoundary *DistanceWellboreToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalWellboreModel, default initialized and not managed by a soap context
        virtual prodml21__HorizontalWellboreModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalWellboreModel); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalWellboreModel() : ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), OrientationWellTrajectory(), LengthHorizontalWellboreFlowing(), DistanceWellboreToBottomBoundary() { }
        virtual ~prodml21__HorizontalWellboreModel() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalWellboreModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalWellboreModel * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalWellboreModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:836 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel (-353)
/* complex XML schema type 'prodml21:HorizontalWellboreMultipleEqualFracturedModel': */
class SOAP_CMAC prodml21__HorizontalWellboreMultipleEqualFracturedModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Required element 'prodml21:FractureHalfLength' of XML schema type 'prodml21:FractureHalfLength'
        prodml21__FractureHalfLength *FractureHalfLength;
        /// Optional element 'prodml21:FractureFaceSkin' of XML schema type 'prodml21:FractureFaceSkin'
        prodml21__FractureFaceSkin *FractureFaceSkin;
        /// Optional element 'prodml21:FractureConductivity' of XML schema type 'prodml21:FractureConductivity'
        prodml21__FractureConductivity *FractureConductivity;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
        /// Required element 'prodml21:LengthHorizontalWellboreFlowing' of XML schema type 'prodml21:LengthHorizontalWellboreFlowing'
        prodml21__LengthHorizontalWellboreFlowing *LengthHorizontalWellboreFlowing;
        /// Optional element 'prodml21:DistanceWellboreToBottomBoundary' of XML schema type 'prodml21:DistanceWellboreToBottomBoundary'
        prodml21__DistanceWellboreToBottomBoundary *DistanceWellboreToBottomBoundary;
        /// Optional element 'prodml21:DistanceMidFractureHeightToBottomBoundary' of XML schema type 'prodml21:DistanceMidFractureHeightToBottomBoundary'
        prodml21__DistanceMidFractureHeightToBottomBoundary *DistanceMidFractureHeightToBottomBoundary;
        /// Required element 'prodml21:NumberOfFractures' of XML schema type 'prodml21:NumberOfFractures'
        prodml21__NumberOfFractures *NumberOfFractures;
        /// Optional element 'prodml21:FractureHeight' of XML schema type 'prodml21:FractureHeight'
        prodml21__FractureHeight *FractureHeight;
        /// Required element 'prodml21:FractureAngleToWellbore' of XML schema type 'prodml21:FractureAngleToWellbore'
        prodml21__FractureAngleToWellbore *FractureAngleToWellbore;
        /// Optional element 'prodml21:FractureStorativityRatio' of XML schema type 'prodml21:FractureStorativityRatio'
        prodml21__FractureStorativityRatio *FractureStorativityRatio;
        /// Required element 'prodml21:FractureModelType' of XML schema type 'prodml21:FractureModelType'
        prodml21__FractureModelType FractureModelType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalWellboreMultipleEqualFracturedModel, default initialized and not managed by a soap context
        virtual prodml21__HorizontalWellboreMultipleEqualFracturedModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalWellboreMultipleEqualFracturedModel); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalWellboreMultipleEqualFracturedModel() : ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), FractureHalfLength(), FractureFaceSkin(), FractureConductivity(), OrientationWellTrajectory(), LengthHorizontalWellboreFlowing(), DistanceWellboreToBottomBoundary(), DistanceMidFractureHeightToBottomBoundary(), NumberOfFractures(), FractureHeight(), FractureAngleToWellbore(), FractureStorativityRatio(), FractureModelType() { }
        virtual ~prodml21__HorizontalWellboreMultipleEqualFracturedModel() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalWellboreMultipleEqualFracturedModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalWellboreMultipleEqualFracturedModel * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalWellboreMultipleEqualFracturedModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:838 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel (-354)
/* complex XML schema type 'prodml21:HorizontalWellboreMultipleVariableFracturedModel': */
class SOAP_CMAC prodml21__HorizontalWellboreMultipleVariableFracturedModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
        /// Required element 'prodml21:LengthHorizontalWellboreFlowing' of XML schema type 'prodml21:LengthHorizontalWellboreFlowing'
        prodml21__LengthHorizontalWellboreFlowing *LengthHorizontalWellboreFlowing;
        /// Optional element 'prodml21:DistanceWellboreToBottomBoundary' of XML schema type 'prodml21:DistanceWellboreToBottomBoundary'
        prodml21__DistanceWellboreToBottomBoundary *DistanceWellboreToBottomBoundary;
        /// Required element 'prodml21:NumberOfFractures' of XML schema type 'prodml21:NumberOfFractures'
        prodml21__NumberOfFractures *NumberOfFractures;
        /// Optional element 'prodml21:singleFractureSubModel' of XML schema type 'prodml21:SingleFractureSubModel'
        std::vector<prodml21__SingleFractureSubModel *> singleFractureSubModel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__HorizontalWellboreMultipleVariableFracturedModel, default initialized and not managed by a soap context
        virtual prodml21__HorizontalWellboreMultipleVariableFracturedModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__HorizontalWellboreMultipleVariableFracturedModel); }
      public:
        /// Constructor with default initializations
        prodml21__HorizontalWellboreMultipleVariableFracturedModel() : ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), OrientationWellTrajectory(), LengthHorizontalWellboreFlowing(), DistanceWellboreToBottomBoundary(), NumberOfFractures(), singleFractureSubModel() { }
        virtual ~prodml21__HorizontalWellboreMultipleVariableFracturedModel() { }
        /// Friend allocator used by soap_new_prodml21__HorizontalWellboreMultipleVariableFracturedModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__HorizontalWellboreMultipleVariableFracturedModel * SOAP_FMAC2 soap_instantiate_prodml21__HorizontalWellboreMultipleVariableFracturedModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:840 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel (-355)
/* complex XML schema type 'prodml21:InfiniteBoundaryModel': */
class SOAP_CMAC prodml21__InfiniteBoundaryModel : public prodml21__BoundaryBaseModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__InfiniteBoundaryModel, default initialized and not managed by a soap context
        virtual prodml21__InfiniteBoundaryModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__InfiniteBoundaryModel); }
      public:
        /// Constructor with default initializations
        prodml21__InfiniteBoundaryModel() { }
        virtual ~prodml21__InfiniteBoundaryModel() { }
        /// Friend allocator used by soap_new_prodml21__InfiniteBoundaryModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__InfiniteBoundaryModel * SOAP_FMAC2 soap_instantiate_prodml21__InfiniteBoundaryModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:842 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel (-356)
/* complex XML schema type 'prodml21:LinearCompositeModel': */
class SOAP_CMAC prodml21__LinearCompositeModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InnerToOuterZoneMobilityRatio' of XML schema type 'prodml21:InnerToOuterZoneMobilityRatio'
        prodml21__InnerToOuterZoneMobilityRatio *InnerToOuterZoneMobilityRatio;
        /// Required element 'prodml21:InnerToOuterZoneDiffusivityRatio' of XML schema type 'prodml21:InnerToOuterZoneDiffusivityRatio'
        prodml21__InnerToOuterZoneDiffusivityRatio *InnerToOuterZoneDiffusivityRatio;
        /// Required element 'prodml21:DistanceToMobilityInterface' of XML schema type 'prodml21:DistanceToMobilityInterface'
        prodml21__DistanceToMobilityInterface *DistanceToMobilityInterface;
        /// Optional element 'prodml21:OrientationOfLinearFront' of XML schema type 'prodml21:OrientationOfLinearFront'
        prodml21__OrientationOfLinearFront *OrientationOfLinearFront;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LinearCompositeModel, default initialized and not managed by a soap context
        virtual prodml21__LinearCompositeModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LinearCompositeModel); }
      public:
        /// Constructor with default initializations
        prodml21__LinearCompositeModel() : InnerToOuterZoneMobilityRatio(), InnerToOuterZoneDiffusivityRatio(), DistanceToMobilityInterface(), OrientationOfLinearFront() { }
        virtual ~prodml21__LinearCompositeModel() { }
        /// Friend allocator used by soap_new_prodml21__LinearCompositeModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LinearCompositeModel * SOAP_FMAC2 soap_instantiate_prodml21__LinearCompositeModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:844 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel (-357)
/* complex XML schema type 'prodml21:LinearCompositeWithChangingThicknessAcrossLeakyFaultModel': */
class SOAP_CMAC prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:DistanceToMobilityInterface' of XML schema type 'prodml21:DistanceToMobilityInterface'
        prodml21__DistanceToMobilityInterface *DistanceToMobilityInterface;
        /// Optional element 'prodml21:OrientationOfLinearFront' of XML schema type 'prodml21:OrientationOfLinearFront'
        prodml21__OrientationOfLinearFront *OrientationOfLinearFront;
        /// Required element 'prodml21:TransmissibilityReductionFactorOfLinearFront' of XML schema type 'prodml21:TransmissibilityReductionFactorOfLinearFront'
        prodml21__TransmissibilityReductionFactorOfLinearFront *TransmissibilityReductionFactorOfLinearFront;
        /// Required element 'prodml21:Region2Thickness' of XML schema type 'prodml21:Region2Thickness'
        prodml21__Region2Thickness *Region2Thickness;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel, default initialized and not managed by a soap context
        virtual prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel); }
      public:
        /// Constructor with default initializations
        prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel() : DistanceToMobilityInterface(), OrientationOfLinearFront(), TransmissibilityReductionFactorOfLinearFront(), Region2Thickness() { }
        virtual ~prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel() { }
        /// Friend allocator used by soap_new_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel * SOAP_FMAC2 soap_instantiate_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:846 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel (-358)
/* complex XML schema type 'prodml21:LinearCompositeWithConductiveFaultModel': */
class SOAP_CMAC prodml21__LinearCompositeWithConductiveFaultModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InnerToOuterZoneMobilityRatio' of XML schema type 'prodml21:InnerToOuterZoneMobilityRatio'
        prodml21__InnerToOuterZoneMobilityRatio *InnerToOuterZoneMobilityRatio;
        /// Required element 'prodml21:InnerToOuterZoneDiffusivityRatio' of XML schema type 'prodml21:InnerToOuterZoneDiffusivityRatio'
        prodml21__InnerToOuterZoneDiffusivityRatio *InnerToOuterZoneDiffusivityRatio;
        /// Required element 'prodml21:DistanceToMobilityInterface' of XML schema type 'prodml21:DistanceToMobilityInterface'
        prodml21__DistanceToMobilityInterface *DistanceToMobilityInterface;
        /// Optional element 'prodml21:OrientationOfLinearFront' of XML schema type 'prodml21:OrientationOfLinearFront'
        prodml21__OrientationOfLinearFront *OrientationOfLinearFront;
        /// Required element 'prodml21:TransmissibilityReductionFactorOfLinearFront' of XML schema type 'prodml21:TransmissibilityReductionFactorOfLinearFront'
        prodml21__TransmissibilityReductionFactorOfLinearFront *TransmissibilityReductionFactorOfLinearFront;
        /// Required element 'prodml21:FaultConductivity' of XML schema type 'prodml21:FaultConductivity'
        prodml21__FaultConductivity *FaultConductivity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LinearCompositeWithConductiveFaultModel, default initialized and not managed by a soap context
        virtual prodml21__LinearCompositeWithConductiveFaultModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LinearCompositeWithConductiveFaultModel); }
      public:
        /// Constructor with default initializations
        prodml21__LinearCompositeWithConductiveFaultModel() : InnerToOuterZoneMobilityRatio(), InnerToOuterZoneDiffusivityRatio(), DistanceToMobilityInterface(), OrientationOfLinearFront(), TransmissibilityReductionFactorOfLinearFront(), FaultConductivity() { }
        virtual ~prodml21__LinearCompositeWithConductiveFaultModel() { }
        /// Friend allocator used by soap_new_prodml21__LinearCompositeWithConductiveFaultModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LinearCompositeWithConductiveFaultModel * SOAP_FMAC2 soap_instantiate_prodml21__LinearCompositeWithConductiveFaultModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:848 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel (-359)
/* complex XML schema type 'prodml21:LinearCompositeWithLeakyFaultModel': */
class SOAP_CMAC prodml21__LinearCompositeWithLeakyFaultModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InnerToOuterZoneMobilityRatio' of XML schema type 'prodml21:InnerToOuterZoneMobilityRatio'
        prodml21__InnerToOuterZoneMobilityRatio *InnerToOuterZoneMobilityRatio;
        /// Required element 'prodml21:InnerToOuterZoneDiffusivityRatio' of XML schema type 'prodml21:InnerToOuterZoneDiffusivityRatio'
        prodml21__InnerToOuterZoneDiffusivityRatio *InnerToOuterZoneDiffusivityRatio;
        /// Required element 'prodml21:DistanceToMobilityInterface' of XML schema type 'prodml21:DistanceToMobilityInterface'
        prodml21__DistanceToMobilityInterface *DistanceToMobilityInterface;
        /// Optional element 'prodml21:OrientationOfLinearFront' of XML schema type 'prodml21:OrientationOfLinearFront'
        prodml21__OrientationOfLinearFront *OrientationOfLinearFront;
        /// Required element 'prodml21:TransmissibilityReductionFactorOfLinearFront' of XML schema type 'prodml21:TransmissibilityReductionFactorOfLinearFront'
        prodml21__TransmissibilityReductionFactorOfLinearFront *TransmissibilityReductionFactorOfLinearFront;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LinearCompositeWithLeakyFaultModel, default initialized and not managed by a soap context
        virtual prodml21__LinearCompositeWithLeakyFaultModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LinearCompositeWithLeakyFaultModel); }
      public:
        /// Constructor with default initializations
        prodml21__LinearCompositeWithLeakyFaultModel() : InnerToOuterZoneMobilityRatio(), InnerToOuterZoneDiffusivityRatio(), DistanceToMobilityInterface(), OrientationOfLinearFront(), TransmissibilityReductionFactorOfLinearFront() { }
        virtual ~prodml21__LinearCompositeWithLeakyFaultModel() { }
        /// Friend allocator used by soap_new_prodml21__LinearCompositeWithLeakyFaultModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LinearCompositeWithLeakyFaultModel * SOAP_FMAC2 soap_instantiate_prodml21__LinearCompositeWithLeakyFaultModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:852 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel (-361)
/* complex XML schema type 'prodml21:NumericalBoundaryModel': */
class SOAP_CMAC prodml21__NumericalBoundaryModel : public prodml21__BoundaryBaseModel {
      public:
        /// Optional element 'prodml21:DrainageAreaMeasured' of XML schema type 'prodml21:DrainageAreaMeasured'
        prodml21__DrainageAreaMeasured *DrainageAreaMeasured;
        /// Optional element 'prodml21:PoreVolumeMeasured' of XML schema type 'prodml21:PoreVolumeMeasured'
        prodml21__PoreVolumeMeasured *PoreVolumeMeasured;
        /// Optional element 'prodml21:SingleBoundarySubModel' of XML schema type 'prodml21:SingleBoundarySubModel'
        std::vector<prodml21__SingleBoundarySubModel *> SingleBoundarySubModel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NumericalBoundaryModel, default initialized and not managed by a soap context
        virtual prodml21__NumericalBoundaryModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NumericalBoundaryModel); }
      public:
        /// Constructor with default initializations
        prodml21__NumericalBoundaryModel() : DrainageAreaMeasured(), PoreVolumeMeasured(), SingleBoundarySubModel() { }
        virtual ~prodml21__NumericalBoundaryModel() { }
        /// Friend allocator used by soap_new_prodml21__NumericalBoundaryModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NumericalBoundaryModel * SOAP_FMAC2 soap_instantiate_prodml21__NumericalBoundaryModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:854 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel (-362)
/* complex XML schema type 'prodml21:NumericalDualPorosityReservoirModel': */
class SOAP_CMAC prodml21__NumericalDualPorosityReservoirModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InterporosityFlowParameter' of XML schema type 'prodml21:InterporosityFlowParameter'
        prodml21__InterporosityFlowParameter *InterporosityFlowParameter;
        /// Required element 'prodml21:StorativityRatio' of XML schema type 'prodml21:StorativityRatio'
        prodml21__StorativityRatio *StorativityRatio;
        /// Optional element 'prodml21:InternalFaultSubModel' of XML schema type 'prodml21:InternalFaultSubModel'
        std::vector<prodml21__InternalFaultSubModel *> InternalFaultSubModel;
        /// Required element 'prodml21:DistributedParametersSubModel' of XML schema type 'prodml21:DistributedParametersSubModel'
        prodml21__DistributedParametersSubModel *DistributedParametersSubModel;
        /// Optional element 'prodml21:ReservoirZoneSubModel' of XML schema type 'prodml21:ReservoirZoneSubModel'
        std::vector<prodml21__ReservoirZoneSubModel *> ReservoirZoneSubModel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NumericalDualPorosityReservoirModel, default initialized and not managed by a soap context
        virtual prodml21__NumericalDualPorosityReservoirModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NumericalDualPorosityReservoirModel); }
      public:
        /// Constructor with default initializations
        prodml21__NumericalDualPorosityReservoirModel() : InterporosityFlowParameter(), StorativityRatio(), InternalFaultSubModel(), DistributedParametersSubModel(), ReservoirZoneSubModel() { }
        virtual ~prodml21__NumericalDualPorosityReservoirModel() { }
        /// Friend allocator used by soap_new_prodml21__NumericalDualPorosityReservoirModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NumericalDualPorosityReservoirModel * SOAP_FMAC2 soap_instantiate_prodml21__NumericalDualPorosityReservoirModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:856 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel (-363)
/* complex XML schema type 'prodml21:NumericalHomogeneousReservoirModel': */
class SOAP_CMAC prodml21__NumericalHomogeneousReservoirModel : public prodml21__ReservoirBaseModel {
      public:
        /// Optional element 'prodml21:InternalFaultSubModel' of XML schema type 'prodml21:InternalFaultSubModel'
        std::vector<prodml21__InternalFaultSubModel *> InternalFaultSubModel;
        /// Required element 'prodml21:DistributedParametersSubModel' of XML schema type 'prodml21:DistributedParametersSubModel'
        prodml21__DistributedParametersSubModel *DistributedParametersSubModel;
        /// Optional element 'prodml21:ReservoirZoneSubModel' of XML schema type 'prodml21:ReservoirZoneSubModel'
        std::vector<prodml21__ReservoirZoneSubModel *> ReservoirZoneSubModel;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NumericalHomogeneousReservoirModel, default initialized and not managed by a soap context
        virtual prodml21__NumericalHomogeneousReservoirModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NumericalHomogeneousReservoirModel); }
      public:
        /// Constructor with default initializations
        prodml21__NumericalHomogeneousReservoirModel() : InternalFaultSubModel(), DistributedParametersSubModel(), ReservoirZoneSubModel() { }
        virtual ~prodml21__NumericalHomogeneousReservoirModel() { }
        /// Friend allocator used by soap_new_prodml21__NumericalHomogeneousReservoirModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NumericalHomogeneousReservoirModel * SOAP_FMAC2 soap_instantiate_prodml21__NumericalHomogeneousReservoirModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:858 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel (-364)
/* complex XML schema type 'prodml21:PartiallyPenetratingModel': */
class SOAP_CMAC prodml21__PartiallyPenetratingModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Required element 'prodml21:PerforatedLength' of XML schema type 'prodml21:PerforatedLength'
        prodml21__PerforatedLength *PerforatedLength;
        /// Required element 'prodml21:DistanceMidPerforationsToBottomBoundary' of XML schema type 'prodml21:DistanceMidPerforationsToBottomBoundary'
        prodml21__DistanceMidPerforationsToBottomBoundary *DistanceMidPerforationsToBottomBoundary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PartiallyPenetratingModel, default initialized and not managed by a soap context
        virtual prodml21__PartiallyPenetratingModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PartiallyPenetratingModel); }
      public:
        /// Constructor with default initializations
        prodml21__PartiallyPenetratingModel() : SkinLayer2RelativeToTotalThickness(), ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), PerforatedLength(), DistanceMidPerforationsToBottomBoundary() { }
        virtual ~prodml21__PartiallyPenetratingModel() { }
        /// Friend allocator used by soap_new_prodml21__PartiallyPenetratingModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PartiallyPenetratingModel * SOAP_FMAC2 soap_instantiate_prodml21__PartiallyPenetratingModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:860 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel (-365)
/* complex XML schema type 'prodml21:PinchOutModel': */
class SOAP_CMAC prodml21__PinchOutModel : public prodml21__BoundaryBaseModel {
      public:
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:DistanceToPinchOut' of XML schema type 'prodml21:DistanceToPinchOut'
        prodml21__DistanceToPinchOut *DistanceToPinchOut;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PinchOutModel, default initialized and not managed by a soap context
        virtual prodml21__PinchOutModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PinchOutModel); }
      public:
        /// Constructor with default initializations
        prodml21__PinchOutModel() : OrientationOfNormalToBoundary1(), DistanceToPinchOut() { }
        virtual ~prodml21__PinchOutModel() { }
        /// Friend allocator used by soap_new_prodml21__PinchOutModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PinchOutModel * SOAP_FMAC2 soap_instantiate_prodml21__PinchOutModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:862 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel (-366)
/* complex XML schema type 'prodml21:RadialCompositeModel': */
class SOAP_CMAC prodml21__RadialCompositeModel : public prodml21__ReservoirBaseModel {
      public:
        /// Required element 'prodml21:InnerToOuterZoneMobilityRatio' of XML schema type 'prodml21:InnerToOuterZoneMobilityRatio'
        prodml21__InnerToOuterZoneMobilityRatio *InnerToOuterZoneMobilityRatio;
        /// Required element 'prodml21:InnerToOuterZoneDiffusivityRatio' of XML schema type 'prodml21:InnerToOuterZoneDiffusivityRatio'
        prodml21__InnerToOuterZoneDiffusivityRatio *InnerToOuterZoneDiffusivityRatio;
        /// Required element 'prodml21:DistanceToMobilityInterface' of XML schema type 'prodml21:DistanceToMobilityInterface'
        prodml21__DistanceToMobilityInterface *DistanceToMobilityInterface;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RadialCompositeModel, default initialized and not managed by a soap context
        virtual prodml21__RadialCompositeModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RadialCompositeModel); }
      public:
        /// Constructor with default initializations
        prodml21__RadialCompositeModel() : InnerToOuterZoneMobilityRatio(), InnerToOuterZoneDiffusivityRatio(), DistanceToMobilityInterface() { }
        virtual ~prodml21__RadialCompositeModel() { }
        /// Friend allocator used by soap_new_prodml21__RadialCompositeModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RadialCompositeModel * SOAP_FMAC2 soap_instantiate_prodml21__RadialCompositeModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:866 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel (-368)
/* complex XML schema type 'prodml21:SingleFaultModel': */
class SOAP_CMAC prodml21__SingleFaultModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:DistanceToBoundary1' of XML schema type 'prodml21:DistanceToBoundary1'
        prodml21__DistanceToBoundary1 *DistanceToBoundary1;
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SingleFaultModel, default initialized and not managed by a soap context
        virtual prodml21__SingleFaultModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SingleFaultModel); }
      public:
        /// Constructor with default initializations
        prodml21__SingleFaultModel() : DistanceToBoundary1(), OrientationOfNormalToBoundary1(), Boundary1Type() { }
        virtual ~prodml21__SingleFaultModel() { }
        /// Friend allocator used by soap_new_prodml21__SingleFaultModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SingleFaultModel * SOAP_FMAC2 soap_instantiate_prodml21__SingleFaultModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:868 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel (-369)
/* complex XML schema type 'prodml21:SlantedFullyPenetratingModel': */
class SOAP_CMAC prodml21__SlantedFullyPenetratingModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:WellboreDeviationAngle' of XML schema type 'prodml21:WellboreDeviationAngle'
        prodml21__WellboreDeviationAngle *WellboreDeviationAngle;
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlantedFullyPenetratingModel, default initialized and not managed by a soap context
        virtual prodml21__SlantedFullyPenetratingModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlantedFullyPenetratingModel); }
      public:
        /// Constructor with default initializations
        prodml21__SlantedFullyPenetratingModel() : WellboreDeviationAngle(), SkinLayer2RelativeToTotalThickness(), ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), OrientationWellTrajectory() { }
        virtual ~prodml21__SlantedFullyPenetratingModel() { }
        /// Friend allocator used by soap_new_prodml21__SlantedFullyPenetratingModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlantedFullyPenetratingModel * SOAP_FMAC2 soap_instantiate_prodml21__SlantedFullyPenetratingModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:870 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel (-370)
/* complex XML schema type 'prodml21:SlantedPartiallyPenetratingModel': */
class SOAP_CMAC prodml21__SlantedPartiallyPenetratingModel : public prodml21__NearWellboreBaseModel {
      public:
        /// Required element 'prodml21:WellboreDeviationAngle' of XML schema type 'prodml21:WellboreDeviationAngle'
        prodml21__WellboreDeviationAngle *WellboreDeviationAngle;
        /// Optional element 'prodml21:SkinLayer2RelativeToTotalThickness' of XML schema type 'prodml21:SkinLayer2RelativeToTotalThickness'
        prodml21__SkinLayer2RelativeToTotalThickness *SkinLayer2RelativeToTotalThickness;
        /// Optional element 'prodml21:ConvergenceSkinRelativeToTotalThickness' of XML schema type 'prodml21:ConvergenceSkinRelativeToTotalThickness'
        prodml21__ConvergenceSkinRelativeToTotalThickness *ConvergenceSkinRelativeToTotalThickness;
        /// Optional element 'prodml21:MechanicalSkinRelativeToTotalThickness' of XML schema type 'prodml21:MechanicalSkinRelativeToTotalThickness'
        prodml21__MechanicalSkinRelativeToTotalThickness *MechanicalSkinRelativeToTotalThickness;
        /// Required element 'prodml21:PerforatedLength' of XML schema type 'prodml21:PerforatedLength'
        prodml21__PerforatedLength *PerforatedLength;
        /// Required element 'prodml21:DistanceMidPerforationsToBottomBoundary' of XML schema type 'prodml21:DistanceMidPerforationsToBottomBoundary'
        prodml21__DistanceMidPerforationsToBottomBoundary *DistanceMidPerforationsToBottomBoundary;
        /// Optional element 'prodml21:OrientationWellTrajectory' of XML schema type 'prodml21:OrientationWellTrajectory'
        prodml21__OrientationWellTrajectory *OrientationWellTrajectory;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SlantedPartiallyPenetratingModel, default initialized and not managed by a soap context
        virtual prodml21__SlantedPartiallyPenetratingModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SlantedPartiallyPenetratingModel); }
      public:
        /// Constructor with default initializations
        prodml21__SlantedPartiallyPenetratingModel() : WellboreDeviationAngle(), SkinLayer2RelativeToTotalThickness(), ConvergenceSkinRelativeToTotalThickness(), MechanicalSkinRelativeToTotalThickness(), PerforatedLength(), DistanceMidPerforationsToBottomBoundary(), OrientationWellTrajectory() { }
        virtual ~prodml21__SlantedPartiallyPenetratingModel() { }
        /// Friend allocator used by soap_new_prodml21__SlantedPartiallyPenetratingModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SlantedPartiallyPenetratingModel * SOAP_FMAC2 soap_instantiate_prodml21__SlantedPartiallyPenetratingModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:872 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel (-371)
/* complex XML schema type 'prodml21:TwoIntersectingFaultsModel': */
class SOAP_CMAC prodml21__TwoIntersectingFaultsModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:DistanceToBoundary1' of XML schema type 'prodml21:DistanceToBoundary1'
        prodml21__DistanceToBoundary1 *DistanceToBoundary1;
        /// Required element 'prodml21:DistanceToBoundary2' of XML schema type 'prodml21:DistanceToBoundary2'
        prodml21__DistanceToBoundary2 *DistanceToBoundary2;
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:AngleBetweenBoundaries' of XML schema type 'prodml21:AngleBetweenBoundaries'
        prodml21__AngleBetweenBoundaries *AngleBetweenBoundaries;
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
        /// Required element 'prodml21:Boundary2Type' of XML schema type 'prodml21:Boundary2Type'
        prodml21__Boundary2Type Boundary2Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TwoIntersectingFaultsModel, default initialized and not managed by a soap context
        virtual prodml21__TwoIntersectingFaultsModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TwoIntersectingFaultsModel); }
      public:
        /// Constructor with default initializations
        prodml21__TwoIntersectingFaultsModel() : DistanceToBoundary1(), DistanceToBoundary2(), OrientationOfNormalToBoundary1(), AngleBetweenBoundaries(), Boundary1Type(), Boundary2Type() { }
        virtual ~prodml21__TwoIntersectingFaultsModel() { }
        /// Friend allocator used by soap_new_prodml21__TwoIntersectingFaultsModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TwoIntersectingFaultsModel * SOAP_FMAC2 soap_instantiate_prodml21__TwoIntersectingFaultsModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:874 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel (-372)
/* complex XML schema type 'prodml21:TwoParallelFaultsModel': */
class SOAP_CMAC prodml21__TwoParallelFaultsModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:DistanceToBoundary1' of XML schema type 'prodml21:DistanceToBoundary1'
        prodml21__DistanceToBoundary1 *DistanceToBoundary1;
        /// Required element 'prodml21:DistanceToBoundary3' of XML schema type 'prodml21:DistanceToBoundary3'
        prodml21__DistanceToBoundary3 *DistanceToBoundary3;
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
        /// Required element 'prodml21:Boundary3Type' of XML schema type 'prodml21:Boundary3Type'
        prodml21__Boundary3Type Boundary3Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TwoParallelFaultsModel, default initialized and not managed by a soap context
        virtual prodml21__TwoParallelFaultsModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TwoParallelFaultsModel); }
      public:
        /// Constructor with default initializations
        prodml21__TwoParallelFaultsModel() : DistanceToBoundary1(), DistanceToBoundary3(), OrientationOfNormalToBoundary1(), Boundary1Type(), Boundary3Type() { }
        virtual ~prodml21__TwoParallelFaultsModel() { }
        /// Friend allocator used by soap_new_prodml21__TwoParallelFaultsModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TwoParallelFaultsModel * SOAP_FMAC2 soap_instantiate_prodml21__TwoParallelFaultsModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:876 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel (-373)
/* complex XML schema type 'prodml21:UShapedFaultsModel': */
class SOAP_CMAC prodml21__UShapedFaultsModel : public prodml21__BoundaryBaseModel {
      public:
        /// Required element 'prodml21:DistanceToBoundary1' of XML schema type 'prodml21:DistanceToBoundary1'
        prodml21__DistanceToBoundary1 *DistanceToBoundary1;
        /// Required element 'prodml21:DistanceToBoundary2' of XML schema type 'prodml21:DistanceToBoundary2'
        prodml21__DistanceToBoundary2 *DistanceToBoundary2;
        /// Required element 'prodml21:DistanceToBoundary3' of XML schema type 'prodml21:DistanceToBoundary3'
        prodml21__DistanceToBoundary3 *DistanceToBoundary3;
        /// Optional element 'prodml21:OrientationOfNormalToBoundary1' of XML schema type 'prodml21:OrientationOfNormalToBoundary1'
        prodml21__OrientationOfNormalToBoundary1 *OrientationOfNormalToBoundary1;
        /// Required element 'prodml21:Boundary1Type' of XML schema type 'prodml21:Boundary1Type'
        prodml21__Boundary1Type Boundary1Type;
        /// Required element 'prodml21:Boundary2Type' of XML schema type 'prodml21:Boundary2Type'
        prodml21__Boundary2Type Boundary2Type;
        /// Required element 'prodml21:Boundary3Type' of XML schema type 'prodml21:Boundary3Type'
        prodml21__Boundary3Type Boundary3Type;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__UShapedFaultsModel, default initialized and not managed by a soap context
        virtual prodml21__UShapedFaultsModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__UShapedFaultsModel); }
      public:
        /// Constructor with default initializations
        prodml21__UShapedFaultsModel() : DistanceToBoundary1(), DistanceToBoundary2(), DistanceToBoundary3(), OrientationOfNormalToBoundary1(), Boundary1Type(), Boundary2Type(), Boundary3Type() { }
        virtual ~prodml21__UShapedFaultsModel() { }
        /// Friend allocator used by soap_new_prodml21__UShapedFaultsModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__UShapedFaultsModel * SOAP_FMAC2 soap_instantiate_prodml21__UShapedFaultsModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1032 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample (-451)
/* simple XML schema type 'prodml21:TimeSeriesDoubleSample': */
class SOAP_CMAC prodml21__TimeSeriesDoubleSample {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Optional attribute 'dTim' of XML schema type 'eml22:TimeStamp'
        struct tm *dTim;
        /// Optional attribute 'status' of XML schema type 'prodml21:ValueStatus'
        prodml21__ValueStatus *status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TimeSeriesDoubleSample, default initialized and not managed by a soap context
        virtual prodml21__TimeSeriesDoubleSample *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TimeSeriesDoubleSample); }
      public:
        /// Constructor with default initializations
        prodml21__TimeSeriesDoubleSample() : __item(), dTim(), status(), soap() { }
        virtual ~prodml21__TimeSeriesDoubleSample() { }
        /// Friend allocator used by soap_new_prodml21__TimeSeriesDoubleSample(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TimeSeriesDoubleSample * SOAP_FMAC2 soap_instantiate_prodml21__TimeSeriesDoubleSample(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1034 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample (-452)
/* simple XML schema type 'prodml21:TimeSeriesStringSample': */
class SOAP_CMAC prodml21__TimeSeriesStringSample {
      public:
        /// Simple content of XML schema type 'eml22:AbstractString' wrapped by this struct
        std::string __item;
        /// Optional attribute 'dTim' of XML schema type 'eml22:TimeStamp'
        struct tm *dTim;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__TimeSeriesStringSample, default initialized and not managed by a soap context
        virtual prodml21__TimeSeriesStringSample *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__TimeSeriesStringSample); }
      public:
        /// Constructor with default initializations
        prodml21__TimeSeriesStringSample() : __item(), dTim(), soap() { }
        virtual ~prodml21__TimeSeriesStringSample() { }
        /// Friend allocator used by soap_new_prodml21__TimeSeriesStringSample(struct soap*, int)
        friend SOAP_FMAC1 prodml21__TimeSeriesStringSample * SOAP_FMAC2 soap_instantiate_prodml21__TimeSeriesStringSample(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1078 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray (-474)
/* complex XML schema type 'eml22:AbstractFloatingPointArray': */
class SOAP_CMAC eml22__AbstractFloatingPointArray : public eml22__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractFloatingPointArray, default initialized and not managed by a soap context
        virtual eml22__AbstractFloatingPointArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractFloatingPointArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractFloatingPointArray() { }
        virtual ~eml22__AbstractFloatingPointArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractFloatingPointArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractFloatingPointArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractFloatingPointArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1080 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray (-475)
/* complex XML schema type 'eml22:AbstractIntegerArray': */
class SOAP_CMAC eml22__AbstractIntegerArray : public eml22__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbstractIntegerArray, default initialized and not managed by a soap context
        virtual eml22__AbstractIntegerArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbstractIntegerArray); }
      public:
        /// Constructor with default initializations
        eml22__AbstractIntegerArray() { }
        virtual ~eml22__AbstractIntegerArray() { }
        /// Friend allocator used by soap_new_eml22__AbstractIntegerArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbstractIntegerArray * SOAP_FMAC2 soap_instantiate_eml22__AbstractIntegerArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1090 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray (-480)
/* complex XML schema type 'eml22:BooleanArrayFromIndexArray': */
class SOAP_CMAC eml22__BooleanArrayFromIndexArray : public eml22__AbstractBooleanArray {
      public:
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
        /// Required element 'eml22:Indices' of XML schema type 'eml22:AbstractIntegerArray'
        eml22__AbstractIntegerArray *Indices;
        /// Required element 'eml22:IndexIsTrue' of XML schema type 'xsd:boolean'
        bool IndexIsTrue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__BooleanArrayFromIndexArray, default initialized and not managed by a soap context
        virtual eml22__BooleanArrayFromIndexArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__BooleanArrayFromIndexArray); }
      public:
        /// Constructor with default initializations
        eml22__BooleanArrayFromIndexArray() : Count(), Indices(), IndexIsTrue() { }
        virtual ~eml22__BooleanArrayFromIndexArray() { }
        /// Friend allocator used by soap_new_eml22__BooleanArrayFromIndexArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__BooleanArrayFromIndexArray * SOAP_FMAC2 soap_instantiate_eml22__BooleanArrayFromIndexArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1092 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray (-481)
/* complex XML schema type 'eml22:BooleanConstantArray': */
class SOAP_CMAC eml22__BooleanConstantArray : public eml22__AbstractBooleanArray {
      public:
        /// Required element 'eml22:Value' of XML schema type 'xsd:boolean'
        bool Value;
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__BooleanConstantArray, default initialized and not managed by a soap context
        virtual eml22__BooleanConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__BooleanConstantArray); }
      public:
        /// Constructor with default initializations
        eml22__BooleanConstantArray() : Value(), Count() { }
        virtual ~eml22__BooleanConstantArray() { }
        /// Friend allocator used by soap_new_eml22__BooleanConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__BooleanConstantArray * SOAP_FMAC2 soap_instantiate_eml22__BooleanConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1094 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray (-482)
/* complex XML schema type 'eml22:BooleanExternalArray': */
class SOAP_CMAC eml22__BooleanExternalArray : public eml22__AbstractBooleanArray {
      public:
        /// Required element 'eml22:Values' of XML schema type 'eml22:ExternalDataset'
        eml22__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__BooleanExternalArray, default initialized and not managed by a soap context
        virtual eml22__BooleanExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__BooleanExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__BooleanExternalArray() : Values() { }
        virtual ~eml22__BooleanExternalArray() { }
        /// Friend allocator used by soap_new_eml22__BooleanExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__BooleanExternalArray * SOAP_FMAC2 soap_instantiate_eml22__BooleanExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1110 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure (-490)
/* simple XML schema type 'eml22:GenericMeasure': */
class SOAP_CMAC eml22__GenericMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:UomEnum'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__GenericMeasure, default initialized and not managed by a soap context
        virtual eml22__GenericMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__GenericMeasure); }
      public:
        /// Constructor with default initializations
        eml22__GenericMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__GenericMeasure() { }
        /// Friend allocator used by soap_new_eml22__GenericMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__GenericMeasure * SOAP_FMAC2 soap_instantiate_eml22__GenericMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1126 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord (-498)
/* simple XML schema type 'eml22:MeasuredDepthCoord': */
class SOAP_CMAC eml22__MeasuredDepthCoord {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUom'
        eml22__LengthUom uom;
        /// Required attribute 'datum' of XML schema type 'eml22:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MeasuredDepthCoord, default initialized and not managed by a soap context
        virtual eml22__MeasuredDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MeasuredDepthCoord); }
      public:
        /// Constructor with default initializations
        eml22__MeasuredDepthCoord() : __item(), uom(), datum(), soap() { }
        virtual ~eml22__MeasuredDepthCoord() { }
        /// Friend allocator used by soap_new_eml22__MeasuredDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 eml22__MeasuredDepthCoord * SOAP_FMAC2 soap_instantiate_eml22__MeasuredDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1128 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray (-499)
/* complex XML schema type 'eml22:StringConstantArray': */
class SOAP_CMAC eml22__StringConstantArray : public eml22__AbstractStringArray {
      public:
        /// Required element 'eml22:Value' of XML schema type 'eml22:String2000'
        std::string Value;
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__StringConstantArray, default initialized and not managed by a soap context
        virtual eml22__StringConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__StringConstantArray); }
      public:
        /// Constructor with default initializations
        eml22__StringConstantArray() : Value(), Count() { }
        virtual ~eml22__StringConstantArray() { }
        /// Friend allocator used by soap_new_eml22__StringConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__StringConstantArray * SOAP_FMAC2 soap_instantiate_eml22__StringConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1130 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray (-500)
/* complex XML schema type 'eml22:StringExternalArray': */
class SOAP_CMAC eml22__StringExternalArray : public eml22__AbstractStringArray {
      public:
        /// Required element 'eml22:Values' of XML schema type 'eml22:ExternalDataset'
        eml22__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__StringExternalArray, default initialized and not managed by a soap context
        virtual eml22__StringExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__StringExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__StringExternalArray() : Values() { }
        virtual ~eml22__StringExternalArray() { }
        /// Friend allocator used by soap_new_eml22__StringExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__StringExternalArray * SOAP_FMAC2 soap_instantiate_eml22__StringExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1136 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord (-503)
/* simple XML schema type 'eml22:WellVerticalDepthCoord': */
class SOAP_CMAC eml22__WellVerticalDepthCoord {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUom'
        eml22__LengthUom uom;
        /// Required attribute 'datum' of XML schema type 'eml22:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__WellVerticalDepthCoord, default initialized and not managed by a soap context
        virtual eml22__WellVerticalDepthCoord *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__WellVerticalDepthCoord); }
      public:
        /// Constructor with default initializations
        eml22__WellVerticalDepthCoord() : __item(), uom(), datum(), soap() { }
        virtual ~eml22__WellVerticalDepthCoord() { }
        /// Friend allocator used by soap_new_eml22__WellVerticalDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 eml22__WellVerticalDepthCoord * SOAP_FMAC2 soap_instantiate_eml22__WellVerticalDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1138 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure (-504)
/* simple XML schema type 'eml22:AbsorbedDoseMeasure': */
class SOAP_CMAC eml22__AbsorbedDoseMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AbsorbedDoseUom'
        eml22__AbsorbedDoseUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbsorbedDoseMeasure, default initialized and not managed by a soap context
        virtual eml22__AbsorbedDoseMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbsorbedDoseMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AbsorbedDoseMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AbsorbedDoseMeasure() { }
        /// Friend allocator used by soap_new_eml22__AbsorbedDoseMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbsorbedDoseMeasure * SOAP_FMAC2 soap_instantiate_eml22__AbsorbedDoseMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1140 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt (-505)
/* simple XML schema type 'eml22:AbsorbedDoseMeasureExt': */
class SOAP_CMAC eml22__AbsorbedDoseMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AbsorbedDoseUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AbsorbedDoseMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AbsorbedDoseMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AbsorbedDoseMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AbsorbedDoseMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AbsorbedDoseMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AbsorbedDoseMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AbsorbedDoseMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AbsorbedDoseMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1142 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure (-506)
/* simple XML schema type 'eml22:ActivityOfRadioactivityMeasure': */
class SOAP_CMAC eml22__ActivityOfRadioactivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ActivityOfRadioactivityUom'
        eml22__ActivityOfRadioactivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ActivityOfRadioactivityMeasure, default initialized and not managed by a soap context
        virtual eml22__ActivityOfRadioactivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ActivityOfRadioactivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ActivityOfRadioactivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ActivityOfRadioactivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ActivityOfRadioactivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ActivityOfRadioactivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ActivityOfRadioactivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1144 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt (-507)
/* simple XML schema type 'eml22:ActivityOfRadioactivityMeasureExt': */
class SOAP_CMAC eml22__ActivityOfRadioactivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ActivityOfRadioactivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ActivityOfRadioactivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ActivityOfRadioactivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ActivityOfRadioactivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ActivityOfRadioactivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ActivityOfRadioactivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ActivityOfRadioactivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ActivityOfRadioactivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ActivityOfRadioactivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1146 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure (-508)
/* simple XML schema type 'eml22:AmountOfSubstanceMeasure': */
class SOAP_CMAC eml22__AmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstanceUom'
        eml22__AmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1148 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt (-509)
/* simple XML schema type 'eml22:AmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1150 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure (-510)
/* simple XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml22__AmountOfSubstancePerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceUom'
        eml22__AmountOfSubstancePerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1152 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt (-511)
/* simple XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1154 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure (-512)
/* simple XML schema type 'eml22:AmountOfSubstancePerAreaMeasure': */
class SOAP_CMAC eml22__AmountOfSubstancePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerAreaUom'
        eml22__AmountOfSubstancePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1156 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt (-513)
/* simple XML schema type 'eml22:AmountOfSubstancePerAreaMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstancePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1158 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure (-514)
/* simple XML schema type 'eml22:AmountOfSubstancePerTimeMeasure': */
class SOAP_CMAC eml22__AmountOfSubstancePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerTimeUom'
        eml22__AmountOfSubstancePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1160 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt (-515)
/* simple XML schema type 'eml22:AmountOfSubstancePerTimeMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstancePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1162 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure (-516)
/* simple XML schema type 'eml22:AmountOfSubstancePerTimePerAreaMeasure': */
class SOAP_CMAC eml22__AmountOfSubstancePerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerTimePerAreaUom'
        eml22__AmountOfSubstancePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1164 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt (-517)
/* simple XML schema type 'eml22:AmountOfSubstancePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstancePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1166 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure (-518)
/* simple XML schema type 'eml22:AmountOfSubstancePerVolumeMeasure': */
class SOAP_CMAC eml22__AmountOfSubstancePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerVolumeUom'
        eml22__AmountOfSubstancePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1168 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt (-519)
/* simple XML schema type 'eml22:AmountOfSubstancePerVolumeMeasureExt': */
class SOAP_CMAC eml22__AmountOfSubstancePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AmountOfSubstancePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AmountOfSubstancePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AmountOfSubstancePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AmountOfSubstancePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AmountOfSubstancePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AmountOfSubstancePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AmountOfSubstancePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1170 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure (-520)
/* simple XML schema type 'eml22:AnglePerLengthMeasure': */
class SOAP_CMAC eml22__AnglePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AnglePerLengthUom'
        eml22__AnglePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AnglePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__AnglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AnglePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AnglePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AnglePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__AnglePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AnglePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__AnglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1172 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt (-521)
/* simple XML schema type 'eml22:AnglePerLengthMeasureExt': */
class SOAP_CMAC eml22__AnglePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AnglePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AnglePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AnglePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AnglePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AnglePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AnglePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AnglePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AnglePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AnglePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1174 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure (-522)
/* simple XML schema type 'eml22:AnglePerVolumeMeasure': */
class SOAP_CMAC eml22__AnglePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AnglePerVolumeUom'
        eml22__AnglePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AnglePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__AnglePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AnglePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AnglePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AnglePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__AnglePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AnglePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__AnglePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1176 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt (-523)
/* simple XML schema type 'eml22:AnglePerVolumeMeasureExt': */
class SOAP_CMAC eml22__AnglePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AnglePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AnglePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AnglePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AnglePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AnglePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AnglePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AnglePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AnglePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AnglePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1178 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure (-524)
/* simple XML schema type 'eml22:AngularAccelerationMeasure': */
class SOAP_CMAC eml22__AngularAccelerationMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AngularAccelerationUom'
        eml22__AngularAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AngularAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml22__AngularAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AngularAccelerationMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AngularAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AngularAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml22__AngularAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AngularAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml22__AngularAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1180 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt (-525)
/* simple XML schema type 'eml22:AngularAccelerationMeasureExt': */
class SOAP_CMAC eml22__AngularAccelerationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AngularAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AngularAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AngularAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AngularAccelerationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AngularAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AngularAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AngularAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AngularAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AngularAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1182 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure (-526)
/* simple XML schema type 'eml22:AngularVelocityMeasure': */
class SOAP_CMAC eml22__AngularVelocityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AngularVelocityUom'
        eml22__AngularVelocityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AngularVelocityMeasure, default initialized and not managed by a soap context
        virtual eml22__AngularVelocityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AngularVelocityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AngularVelocityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AngularVelocityMeasure() { }
        /// Friend allocator used by soap_new_eml22__AngularVelocityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AngularVelocityMeasure * SOAP_FMAC2 soap_instantiate_eml22__AngularVelocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1184 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt (-527)
/* simple XML schema type 'eml22:AngularVelocityMeasureExt': */
class SOAP_CMAC eml22__AngularVelocityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AngularVelocityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AngularVelocityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AngularVelocityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AngularVelocityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AngularVelocityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AngularVelocityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AngularVelocityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AngularVelocityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AngularVelocityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1186 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure (-528)
/* simple XML schema type 'eml22:APIGammaRayMeasure': */
class SOAP_CMAC eml22__APIGammaRayMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APIGammaRayUom'
        eml22__APIGammaRayUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APIGammaRayMeasure, default initialized and not managed by a soap context
        virtual eml22__APIGammaRayMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APIGammaRayMeasure); }
      public:
        /// Constructor with default initializations
        eml22__APIGammaRayMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__APIGammaRayMeasure() { }
        /// Friend allocator used by soap_new_eml22__APIGammaRayMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__APIGammaRayMeasure * SOAP_FMAC2 soap_instantiate_eml22__APIGammaRayMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1188 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt (-529)
/* simple XML schema type 'eml22:APIGammaRayMeasureExt': */
class SOAP_CMAC eml22__APIGammaRayMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APIGammaRayUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APIGammaRayMeasureExt, default initialized and not managed by a soap context
        virtual eml22__APIGammaRayMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APIGammaRayMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__APIGammaRayMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__APIGammaRayMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__APIGammaRayMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__APIGammaRayMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__APIGammaRayMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1190 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure (-530)
/* simple XML schema type 'eml22:APIGravityMeasure': */
class SOAP_CMAC eml22__APIGravityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APIGravityUom'
        eml22__APIGravityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APIGravityMeasure, default initialized and not managed by a soap context
        virtual eml22__APIGravityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APIGravityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__APIGravityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__APIGravityMeasure() { }
        /// Friend allocator used by soap_new_eml22__APIGravityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__APIGravityMeasure * SOAP_FMAC2 soap_instantiate_eml22__APIGravityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1192 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt (-531)
/* simple XML schema type 'eml22:APIGravityMeasureExt': */
class SOAP_CMAC eml22__APIGravityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APIGravityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APIGravityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__APIGravityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APIGravityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__APIGravityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__APIGravityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__APIGravityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__APIGravityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__APIGravityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1194 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure (-532)
/* simple XML schema type 'eml22:APINeutronMeasure': */
class SOAP_CMAC eml22__APINeutronMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APINeutronUom'
        eml22__APINeutronUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APINeutronMeasure, default initialized and not managed by a soap context
        virtual eml22__APINeutronMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APINeutronMeasure); }
      public:
        /// Constructor with default initializations
        eml22__APINeutronMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__APINeutronMeasure() { }
        /// Friend allocator used by soap_new_eml22__APINeutronMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__APINeutronMeasure * SOAP_FMAC2 soap_instantiate_eml22__APINeutronMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1196 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt (-533)
/* simple XML schema type 'eml22:APINeutronMeasureExt': */
class SOAP_CMAC eml22__APINeutronMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:APINeutronUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__APINeutronMeasureExt, default initialized and not managed by a soap context
        virtual eml22__APINeutronMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__APINeutronMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__APINeutronMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__APINeutronMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__APINeutronMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__APINeutronMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__APINeutronMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1198 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure (-534)
/* simple XML schema type 'eml22:AreaMeasure': */
class SOAP_CMAC eml22__AreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaUom'
        eml22__AreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1200 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt (-535)
/* simple XML schema type 'eml22:AreaMeasureExt': */
class SOAP_CMAC eml22__AreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1202 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure (-536)
/* simple XML schema type 'eml22:AreaPerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml22__AreaPerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerAmountOfSubstanceUom'
        eml22__AreaPerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1204 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt (-537)
/* simple XML schema type 'eml22:AreaPerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml22__AreaPerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1206 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure (-538)
/* simple XML schema type 'eml22:AreaPerAreaMeasure': */
class SOAP_CMAC eml22__AreaPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerAreaUom'
        eml22__AreaPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1208 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt (-539)
/* simple XML schema type 'eml22:AreaPerAreaMeasureExt': */
class SOAP_CMAC eml22__AreaPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1210 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure (-540)
/* simple XML schema type 'eml22:AreaPerCountMeasure': */
class SOAP_CMAC eml22__AreaPerCountMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerCountUom'
        eml22__AreaPerCountUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerCountMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerCountMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerCountMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerCountMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerCountMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerCountMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerCountMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerCountMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1212 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt (-541)
/* simple XML schema type 'eml22:AreaPerCountMeasureExt': */
class SOAP_CMAC eml22__AreaPerCountMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerCountUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerCountMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerCountMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerCountMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerCountMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerCountMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerCountMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerCountMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerCountMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1214 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure (-542)
/* simple XML schema type 'eml22:AreaPerMassMeasure': */
class SOAP_CMAC eml22__AreaPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerMassUom'
        eml22__AreaPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1216 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt (-543)
/* simple XML schema type 'eml22:AreaPerMassMeasureExt': */
class SOAP_CMAC eml22__AreaPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1218 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure (-544)
/* simple XML schema type 'eml22:AreaPerTimeMeasure': */
class SOAP_CMAC eml22__AreaPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerTimeUom'
        eml22__AreaPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1220 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt (-545)
/* simple XML schema type 'eml22:AreaPerTimeMeasureExt': */
class SOAP_CMAC eml22__AreaPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1222 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure (-546)
/* simple XML schema type 'eml22:AreaPerVolumeMeasure': */
class SOAP_CMAC eml22__AreaPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerVolumeUom'
        eml22__AreaPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__AreaPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__AreaPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__AreaPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1224 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt (-547)
/* simple XML schema type 'eml22:AreaPerVolumeMeasureExt': */
class SOAP_CMAC eml22__AreaPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AreaPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AreaPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AreaPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AreaPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AreaPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AreaPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AreaPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AreaPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AreaPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1226 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure (-548)
/* simple XML schema type 'eml22:AttenuationPerFrequencyIntervalMeasure': */
class SOAP_CMAC eml22__AttenuationPerFrequencyIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AttenuationPerFrequencyIntervalUom'
        eml22__AttenuationPerFrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AttenuationPerFrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml22__AttenuationPerFrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AttenuationPerFrequencyIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml22__AttenuationPerFrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__AttenuationPerFrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml22__AttenuationPerFrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__AttenuationPerFrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml22__AttenuationPerFrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1228 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt (-549)
/* simple XML schema type 'eml22:AttenuationPerFrequencyIntervalMeasureExt': */
class SOAP_CMAC eml22__AttenuationPerFrequencyIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:AttenuationPerFrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AttenuationPerFrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml22__AttenuationPerFrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AttenuationPerFrequencyIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__AttenuationPerFrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__AttenuationPerFrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__AttenuationPerFrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1230 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure (-550)
/* simple XML schema type 'eml22:CapacitanceMeasure': */
class SOAP_CMAC eml22__CapacitanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:CapacitanceUom'
        eml22__CapacitanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__CapacitanceMeasure, default initialized and not managed by a soap context
        virtual eml22__CapacitanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__CapacitanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__CapacitanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__CapacitanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__CapacitanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__CapacitanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__CapacitanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1232 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt (-551)
/* simple XML schema type 'eml22:CapacitanceMeasureExt': */
class SOAP_CMAC eml22__CapacitanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:CapacitanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__CapacitanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__CapacitanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__CapacitanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__CapacitanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__CapacitanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__CapacitanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__CapacitanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__CapacitanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1234 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure (-552)
/* simple XML schema type 'eml22:CationExchangeCapacityMeasure': */
class SOAP_CMAC eml22__CationExchangeCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:CationExchangeCapacityUom'
        eml22__CationExchangeCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__CationExchangeCapacityMeasure, default initialized and not managed by a soap context
        virtual eml22__CationExchangeCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__CationExchangeCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__CationExchangeCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__CationExchangeCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml22__CationExchangeCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__CationExchangeCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml22__CationExchangeCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1236 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt (-553)
/* simple XML schema type 'eml22:CationExchangeCapacityMeasureExt': */
class SOAP_CMAC eml22__CationExchangeCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:CationExchangeCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__CationExchangeCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__CationExchangeCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__CationExchangeCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__CationExchangeCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__CationExchangeCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__CationExchangeCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__CationExchangeCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__CationExchangeCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1238 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure (-554)
/* simple XML schema type 'eml22:DataTransferSpeedMeasure': */
class SOAP_CMAC eml22__DataTransferSpeedMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DataTransferSpeedUom'
        eml22__DataTransferSpeedUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DataTransferSpeedMeasure, default initialized and not managed by a soap context
        virtual eml22__DataTransferSpeedMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DataTransferSpeedMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DataTransferSpeedMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DataTransferSpeedMeasure() { }
        /// Friend allocator used by soap_new_eml22__DataTransferSpeedMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DataTransferSpeedMeasure * SOAP_FMAC2 soap_instantiate_eml22__DataTransferSpeedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1240 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt (-555)
/* simple XML schema type 'eml22:DataTransferSpeedMeasureExt': */
class SOAP_CMAC eml22__DataTransferSpeedMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DataTransferSpeedUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DataTransferSpeedMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DataTransferSpeedMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DataTransferSpeedMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DataTransferSpeedMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DataTransferSpeedMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DataTransferSpeedMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DataTransferSpeedMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DataTransferSpeedMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1242 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure (-556)
/* simple XML schema type 'eml22:DiffusionCoefficientMeasure': */
class SOAP_CMAC eml22__DiffusionCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DiffusionCoefficientUom'
        eml22__DiffusionCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DiffusionCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml22__DiffusionCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DiffusionCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DiffusionCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DiffusionCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml22__DiffusionCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DiffusionCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml22__DiffusionCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1244 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt (-557)
/* simple XML schema type 'eml22:DiffusionCoefficientMeasureExt': */
class SOAP_CMAC eml22__DiffusionCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DiffusionCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DiffusionCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DiffusionCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DiffusionCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DiffusionCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DiffusionCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DiffusionCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DiffusionCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DiffusionCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1246 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure (-558)
/* simple XML schema type 'eml22:DiffusiveTimeOfFlightMeasure': */
class SOAP_CMAC eml22__DiffusiveTimeOfFlightMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DiffusiveTimeOfFlightUom'
        eml22__DiffusiveTimeOfFlightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DiffusiveTimeOfFlightMeasure, default initialized and not managed by a soap context
        virtual eml22__DiffusiveTimeOfFlightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DiffusiveTimeOfFlightMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DiffusiveTimeOfFlightMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DiffusiveTimeOfFlightMeasure() { }
        /// Friend allocator used by soap_new_eml22__DiffusiveTimeOfFlightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DiffusiveTimeOfFlightMeasure * SOAP_FMAC2 soap_instantiate_eml22__DiffusiveTimeOfFlightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1248 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt (-559)
/* simple XML schema type 'eml22:DiffusiveTimeOfFlightMeasureExt': */
class SOAP_CMAC eml22__DiffusiveTimeOfFlightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DiffusiveTimeOfFlightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DiffusiveTimeOfFlightMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DiffusiveTimeOfFlightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DiffusiveTimeOfFlightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DiffusiveTimeOfFlightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DiffusiveTimeOfFlightMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DiffusiveTimeOfFlightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DiffusiveTimeOfFlightMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DiffusiveTimeOfFlightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1250 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure (-560)
/* simple XML schema type 'eml22:DigitalStorageMeasure': */
class SOAP_CMAC eml22__DigitalStorageMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DigitalStorageUom'
        eml22__DigitalStorageUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DigitalStorageMeasure, default initialized and not managed by a soap context
        virtual eml22__DigitalStorageMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DigitalStorageMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DigitalStorageMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DigitalStorageMeasure() { }
        /// Friend allocator used by soap_new_eml22__DigitalStorageMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DigitalStorageMeasure * SOAP_FMAC2 soap_instantiate_eml22__DigitalStorageMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1252 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt (-561)
/* simple XML schema type 'eml22:DigitalStorageMeasureExt': */
class SOAP_CMAC eml22__DigitalStorageMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DigitalStorageUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DigitalStorageMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DigitalStorageMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DigitalStorageMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DigitalStorageMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DigitalStorageMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DigitalStorageMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DigitalStorageMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DigitalStorageMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1254 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure (-562)
/* simple XML schema type 'eml22:DimensionlessMeasure': */
class SOAP_CMAC eml22__DimensionlessMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DimensionlessUom'
        eml22__DimensionlessUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DimensionlessMeasure, default initialized and not managed by a soap context
        virtual eml22__DimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DimensionlessMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DimensionlessMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DimensionlessMeasure() { }
        /// Friend allocator used by soap_new_eml22__DimensionlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DimensionlessMeasure * SOAP_FMAC2 soap_instantiate_eml22__DimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1256 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt (-563)
/* simple XML schema type 'eml22:DimensionlessMeasureExt': */
class SOAP_CMAC eml22__DimensionlessMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DimensionlessUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DimensionlessMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DimensionlessMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DimensionlessMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DimensionlessMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DimensionlessMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DimensionlessMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DimensionlessMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DimensionlessMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1258 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure (-564)
/* simple XML schema type 'eml22:DipoleMomentMeasure': */
class SOAP_CMAC eml22__DipoleMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DipoleMomentUom'
        eml22__DipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml22__DipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DipoleMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml22__DipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml22__DipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1260 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt (-565)
/* simple XML schema type 'eml22:DipoleMomentMeasureExt': */
class SOAP_CMAC eml22__DipoleMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DipoleMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1262 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure (-566)
/* simple XML schema type 'eml22:DoseEquivalentMeasure': */
class SOAP_CMAC eml22__DoseEquivalentMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DoseEquivalentUom'
        eml22__DoseEquivalentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DoseEquivalentMeasure, default initialized and not managed by a soap context
        virtual eml22__DoseEquivalentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DoseEquivalentMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DoseEquivalentMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DoseEquivalentMeasure() { }
        /// Friend allocator used by soap_new_eml22__DoseEquivalentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DoseEquivalentMeasure * SOAP_FMAC2 soap_instantiate_eml22__DoseEquivalentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1264 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt (-567)
/* simple XML schema type 'eml22:DoseEquivalentMeasureExt': */
class SOAP_CMAC eml22__DoseEquivalentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DoseEquivalentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DoseEquivalentMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DoseEquivalentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DoseEquivalentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DoseEquivalentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DoseEquivalentMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DoseEquivalentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DoseEquivalentMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DoseEquivalentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1266 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure (-568)
/* simple XML schema type 'eml22:DynamicViscosityMeasure': */
class SOAP_CMAC eml22__DynamicViscosityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DynamicViscosityUom'
        eml22__DynamicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DynamicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml22__DynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DynamicViscosityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__DynamicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__DynamicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml22__DynamicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__DynamicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml22__DynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1268 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt (-569)
/* simple XML schema type 'eml22:DynamicViscosityMeasureExt': */
class SOAP_CMAC eml22__DynamicViscosityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:DynamicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DynamicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__DynamicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DynamicViscosityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__DynamicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__DynamicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__DynamicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__DynamicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__DynamicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1270 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure (-570)
/* simple XML schema type 'eml22:ElectricalResistivityMeasure': */
class SOAP_CMAC eml22__ElectricalResistivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricalResistivityUom'
        eml22__ElectricalResistivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricalResistivityMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricalResistivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricalResistivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricalResistivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricalResistivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricalResistivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricalResistivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricalResistivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1272 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt (-571)
/* simple XML schema type 'eml22:ElectricalResistivityMeasureExt': */
class SOAP_CMAC eml22__ElectricalResistivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricalResistivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricalResistivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricalResistivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricalResistivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricalResistivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricalResistivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricalResistivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricalResistivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricalResistivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1274 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure (-572)
/* simple XML schema type 'eml22:ElectricChargeMeasure': */
class SOAP_CMAC eml22__ElectricChargeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargeUom'
        eml22__ElectricChargeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargeMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricChargeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1276 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt (-573)
/* simple XML schema type 'eml22:ElectricChargeMeasureExt': */
class SOAP_CMAC eml22__ElectricChargeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricChargeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1278 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure (-574)
/* simple XML schema type 'eml22:ElectricChargePerAreaMeasure': */
class SOAP_CMAC eml22__ElectricChargePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerAreaUom'
        eml22__ElectricChargePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1280 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt (-575)
/* simple XML schema type 'eml22:ElectricChargePerAreaMeasureExt': */
class SOAP_CMAC eml22__ElectricChargePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1282 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure (-576)
/* simple XML schema type 'eml22:ElectricChargePerMassMeasure': */
class SOAP_CMAC eml22__ElectricChargePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerMassUom'
        eml22__ElectricChargePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1284 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt (-577)
/* simple XML schema type 'eml22:ElectricChargePerMassMeasureExt': */
class SOAP_CMAC eml22__ElectricChargePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1286 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure (-578)
/* simple XML schema type 'eml22:ElectricChargePerVolumeMeasure': */
class SOAP_CMAC eml22__ElectricChargePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerVolumeUom'
        eml22__ElectricChargePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1288 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt (-579)
/* simple XML schema type 'eml22:ElectricChargePerVolumeMeasureExt': */
class SOAP_CMAC eml22__ElectricChargePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricChargePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricChargePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricChargePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricChargePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricChargePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricChargePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricChargePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricChargePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricChargePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1290 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure (-580)
/* simple XML schema type 'eml22:ElectricConductanceMeasure': */
class SOAP_CMAC eml22__ElectricConductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricConductanceUom'
        eml22__ElectricConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricConductanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricConductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricConductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1292 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt (-581)
/* simple XML schema type 'eml22:ElectricConductanceMeasureExt': */
class SOAP_CMAC eml22__ElectricConductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricConductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1294 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure (-582)
/* simple XML schema type 'eml22:ElectricConductivityMeasure': */
class SOAP_CMAC eml22__ElectricConductivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricConductivityUom'
        eml22__ElectricConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricConductivityMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricConductivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricConductivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1296 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt (-583)
/* simple XML schema type 'eml22:ElectricConductivityMeasureExt': */
class SOAP_CMAC eml22__ElectricConductivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricConductivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1298 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure (-584)
/* simple XML schema type 'eml22:ElectricCurrentDensityMeasure': */
class SOAP_CMAC eml22__ElectricCurrentDensityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricCurrentDensityUom'
        eml22__ElectricCurrentDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricCurrentDensityMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricCurrentDensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricCurrentDensityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricCurrentDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricCurrentDensityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricCurrentDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricCurrentDensityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricCurrentDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1300 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt (-585)
/* simple XML schema type 'eml22:ElectricCurrentDensityMeasureExt': */
class SOAP_CMAC eml22__ElectricCurrentDensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricCurrentDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricCurrentDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricCurrentDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricCurrentDensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricCurrentDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricCurrentDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricCurrentDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricCurrentDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricCurrentDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1302 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure (-586)
/* simple XML schema type 'eml22:ElectricCurrentMeasure': */
class SOAP_CMAC eml22__ElectricCurrentMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricCurrentUom'
        eml22__ElectricCurrentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricCurrentMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricCurrentMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricCurrentMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricCurrentMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricCurrentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricCurrentMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1304 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt (-587)
/* simple XML schema type 'eml22:ElectricCurrentMeasureExt': */
class SOAP_CMAC eml22__ElectricCurrentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricCurrentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricCurrentMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricCurrentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricCurrentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricCurrentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricCurrentMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricCurrentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricCurrentMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricCurrentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1306 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure (-588)
/* simple XML schema type 'eml22:ElectricFieldStrengthMeasure': */
class SOAP_CMAC eml22__ElectricFieldStrengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricFieldStrengthUom'
        eml22__ElectricFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricFieldStrengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1308 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt (-589)
/* simple XML schema type 'eml22:ElectricFieldStrengthMeasureExt': */
class SOAP_CMAC eml22__ElectricFieldStrengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricFieldStrengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1310 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure (-590)
/* simple XML schema type 'eml22:ElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml22__ElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricPotentialDifferenceUom'
        eml22__ElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1312 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt (-591)
/* simple XML schema type 'eml22:ElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml22__ElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1314 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure (-592)
/* simple XML schema type 'eml22:ElectricResistanceMeasure': */
class SOAP_CMAC eml22__ElectricResistanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricResistanceUom'
        eml22__ElectricResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricResistanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricResistanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricResistanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1316 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt (-593)
/* simple XML schema type 'eml22:ElectricResistanceMeasureExt': */
class SOAP_CMAC eml22__ElectricResistanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricResistanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1318 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure (-594)
/* simple XML schema type 'eml22:ElectricResistancePerLengthMeasure': */
class SOAP_CMAC eml22__ElectricResistancePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricResistancePerLengthUom'
        eml22__ElectricResistancePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricResistancePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectricResistancePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricResistancePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectricResistancePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricResistancePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectricResistancePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricResistancePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectricResistancePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1320 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt (-595)
/* simple XML schema type 'eml22:ElectricResistancePerLengthMeasureExt': */
class SOAP_CMAC eml22__ElectricResistancePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectricResistancePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectricResistancePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectricResistancePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectricResistancePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectricResistancePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectricResistancePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectricResistancePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectricResistancePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectricResistancePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1322 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure (-596)
/* simple XML schema type 'eml22:ElectromagneticMomentMeasure': */
class SOAP_CMAC eml22__ElectromagneticMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectromagneticMomentUom'
        eml22__ElectromagneticMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectromagneticMomentMeasure, default initialized and not managed by a soap context
        virtual eml22__ElectromagneticMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectromagneticMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ElectromagneticMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ElectromagneticMomentMeasure() { }
        /// Friend allocator used by soap_new_eml22__ElectromagneticMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectromagneticMomentMeasure * SOAP_FMAC2 soap_instantiate_eml22__ElectromagneticMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1324 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt (-597)
/* simple XML schema type 'eml22:ElectromagneticMomentMeasureExt': */
class SOAP_CMAC eml22__ElectromagneticMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ElectromagneticMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ElectromagneticMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ElectromagneticMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ElectromagneticMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ElectromagneticMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ElectromagneticMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ElectromagneticMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ElectromagneticMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ElectromagneticMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1326 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure (-598)
/* simple XML schema type 'eml22:EnergyLengthPerAreaMeasure': */
class SOAP_CMAC eml22__EnergyLengthPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyLengthPerAreaUom'
        eml22__EnergyLengthPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyLengthPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyLengthPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyLengthPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyLengthPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyLengthPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyLengthPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyLengthPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyLengthPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1328 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt (-599)
/* simple XML schema type 'eml22:EnergyLengthPerAreaMeasureExt': */
class SOAP_CMAC eml22__EnergyLengthPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyLengthPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyLengthPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyLengthPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyLengthPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyLengthPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyLengthPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyLengthPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyLengthPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyLengthPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1330 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure (-600)
/* simple XML schema type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasure': */
class SOAP_CMAC eml22__EnergyLengthPerTimeAreaTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyLengthPerTimeAreaTemperatureUom'
        eml22__EnergyLengthPerTimeAreaTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyLengthPerTimeAreaTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyLengthPerTimeAreaTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyLengthPerTimeAreaTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyLengthPerTimeAreaTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyLengthPerTimeAreaTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyLengthPerTimeAreaTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1332 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt (-601)
/* simple XML schema type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasureExt': */
class SOAP_CMAC eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyLengthPerTimeAreaTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1334 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure (-602)
/* simple XML schema type 'eml22:EnergyMeasure': */
class SOAP_CMAC eml22__EnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyUom'
        eml22__EnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1336 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt (-603)
/* simple XML schema type 'eml22:EnergyMeasureExt': */
class SOAP_CMAC eml22__EnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1338 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure (-604)
/* simple XML schema type 'eml22:EnergyPerAreaMeasure': */
class SOAP_CMAC eml22__EnergyPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerAreaUom'
        eml22__EnergyPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1340 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt (-605)
/* simple XML schema type 'eml22:EnergyPerAreaMeasureExt': */
class SOAP_CMAC eml22__EnergyPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1342 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure (-606)
/* simple XML schema type 'eml22:EnergyPerLengthMeasure': */
class SOAP_CMAC eml22__EnergyPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerLengthUom'
        eml22__EnergyPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1344 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt (-607)
/* simple XML schema type 'eml22:EnergyPerLengthMeasureExt': */
class SOAP_CMAC eml22__EnergyPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1346 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure (-608)
/* simple XML schema type 'eml22:EnergyPerMassMeasure': */
class SOAP_CMAC eml22__EnergyPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerMassUom'
        eml22__EnergyPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1348 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt (-609)
/* simple XML schema type 'eml22:EnergyPerMassMeasureExt': */
class SOAP_CMAC eml22__EnergyPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1350 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure (-610)
/* simple XML schema type 'eml22:EnergyPerMassPerTimeMeasure': */
class SOAP_CMAC eml22__EnergyPerMassPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerMassPerTimeUom'
        eml22__EnergyPerMassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerMassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyPerMassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerMassPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerMassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerMassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerMassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerMassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerMassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1352 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt (-611)
/* simple XML schema type 'eml22:EnergyPerMassPerTimeMeasureExt': */
class SOAP_CMAC eml22__EnergyPerMassPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerMassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerMassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyPerMassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerMassPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerMassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerMassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerMassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerMassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerMassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1354 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure (-612)
/* simple XML schema type 'eml22:EnergyPerVolumeMeasure': */
class SOAP_CMAC eml22__EnergyPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerVolumeUom'
        eml22__EnergyPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__EnergyPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1356 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt (-613)
/* simple XML schema type 'eml22:EnergyPerVolumeMeasureExt': */
class SOAP_CMAC eml22__EnergyPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:EnergyPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__EnergyPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__EnergyPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__EnergyPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__EnergyPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__EnergyPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__EnergyPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__EnergyPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__EnergyPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1358 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure (-614)
/* simple XML schema type 'eml22:ForceAreaMeasure': */
class SOAP_CMAC eml22__ForceAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceAreaUom'
        eml22__ForceAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__ForceAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForceAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForceAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForceAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForceAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1360 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt (-615)
/* simple XML schema type 'eml22:ForceAreaMeasureExt': */
class SOAP_CMAC eml22__ForceAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForceAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForceAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForceAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForceAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForceAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1362 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure (-616)
/* simple XML schema type 'eml22:ForceLengthPerLengthMeasure': */
class SOAP_CMAC eml22__ForceLengthPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceLengthPerLengthUom'
        eml22__ForceLengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceLengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__ForceLengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceLengthPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForceLengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForceLengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForceLengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceLengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForceLengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1364 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt (-617)
/* simple XML schema type 'eml22:ForceLengthPerLengthMeasureExt': */
class SOAP_CMAC eml22__ForceLengthPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceLengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceLengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForceLengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceLengthPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForceLengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForceLengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForceLengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceLengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForceLengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1366 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure (-618)
/* simple XML schema type 'eml22:ForceMeasure': */
class SOAP_CMAC eml22__ForceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceUom'
        eml22__ForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceMeasure, default initialized and not managed by a soap context
        virtual eml22__ForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1368 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt (-619)
/* simple XML schema type 'eml22:ForceMeasureExt': */
class SOAP_CMAC eml22__ForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1370 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure (-620)
/* simple XML schema type 'eml22:ForcePerForceMeasure': */
class SOAP_CMAC eml22__ForcePerForceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerForceUom'
        eml22__ForcePerForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerForceMeasure, default initialized and not managed by a soap context
        virtual eml22__ForcePerForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerForceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerForceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForcePerForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerForceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForcePerForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1372 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt (-621)
/* simple XML schema type 'eml22:ForcePerForceMeasureExt': */
class SOAP_CMAC eml22__ForcePerForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerForceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForcePerForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForcePerForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForcePerForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1374 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure (-622)
/* simple XML schema type 'eml22:ForcePerLengthMeasure': */
class SOAP_CMAC eml22__ForcePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerLengthUom'
        eml22__ForcePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__ForcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForcePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1376 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt (-623)
/* simple XML schema type 'eml22:ForcePerLengthMeasureExt': */
class SOAP_CMAC eml22__ForcePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForcePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForcePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForcePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1378 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure (-624)
/* simple XML schema type 'eml22:ForcePerVolumeMeasure': */
class SOAP_CMAC eml22__ForcePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerVolumeUom'
        eml22__ForcePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__ForcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ForcePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ForcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1380 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt (-625)
/* simple XML schema type 'eml22:ForcePerVolumeMeasureExt': */
class SOAP_CMAC eml22__ForcePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ForcePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ForcePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ForcePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ForcePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ForcePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ForcePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ForcePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ForcePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ForcePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure (-626)
/* simple XML schema type 'eml22:FrequencyIntervalMeasure': */
class SOAP_CMAC eml22__FrequencyIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:FrequencyIntervalUom'
        eml22__FrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml22__FrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FrequencyIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml22__FrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__FrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml22__FrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__FrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml22__FrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1384 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt (-627)
/* simple XML schema type 'eml22:FrequencyIntervalMeasureExt': */
class SOAP_CMAC eml22__FrequencyIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:FrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml22__FrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FrequencyIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__FrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__FrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__FrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__FrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__FrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1386 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure (-628)
/* simple XML schema type 'eml22:FrequencyMeasure': */
class SOAP_CMAC eml22__FrequencyMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:FrequencyUom'
        eml22__FrequencyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FrequencyMeasure, default initialized and not managed by a soap context
        virtual eml22__FrequencyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FrequencyMeasure); }
      public:
        /// Constructor with default initializations
        eml22__FrequencyMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__FrequencyMeasure() { }
        /// Friend allocator used by soap_new_eml22__FrequencyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__FrequencyMeasure * SOAP_FMAC2 soap_instantiate_eml22__FrequencyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1388 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt (-629)
/* simple XML schema type 'eml22:FrequencyMeasureExt': */
class SOAP_CMAC eml22__FrequencyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:FrequencyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FrequencyMeasureExt, default initialized and not managed by a soap context
        virtual eml22__FrequencyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FrequencyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__FrequencyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__FrequencyMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__FrequencyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__FrequencyMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__FrequencyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1390 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure (-630)
/* simple XML schema type 'eml22:HeatCapacityMeasure': */
class SOAP_CMAC eml22__HeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatCapacityUom'
        eml22__HeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml22__HeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__HeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__HeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml22__HeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml22__HeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1392 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt (-631)
/* simple XML schema type 'eml22:HeatCapacityMeasureExt': */
class SOAP_CMAC eml22__HeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__HeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__HeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__HeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__HeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__HeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1394 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure (-632)
/* simple XML schema type 'eml22:HeatFlowRateMeasure': */
class SOAP_CMAC eml22__HeatFlowRateMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatFlowRateUom'
        eml22__HeatFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml22__HeatFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatFlowRateMeasure); }
      public:
        /// Constructor with default initializations
        eml22__HeatFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__HeatFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml22__HeatFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml22__HeatFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1396 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt (-633)
/* simple XML schema type 'eml22:HeatFlowRateMeasureExt': */
class SOAP_CMAC eml22__HeatFlowRateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml22__HeatFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatFlowRateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__HeatFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__HeatFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__HeatFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__HeatFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1398 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure (-634)
/* simple XML schema type 'eml22:HeatTransferCoefficientMeasure': */
class SOAP_CMAC eml22__HeatTransferCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatTransferCoefficientUom'
        eml22__HeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml22__HeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatTransferCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml22__HeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__HeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml22__HeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml22__HeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1400 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt (-635)
/* simple XML schema type 'eml22:HeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml22__HeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:HeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__HeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml22__HeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__HeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__HeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__HeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__HeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__HeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__HeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1402 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure (-636)
/* simple XML schema type 'eml22:IlluminanceMeasure': */
class SOAP_CMAC eml22__IlluminanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:IlluminanceUom'
        eml22__IlluminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IlluminanceMeasure, default initialized and not managed by a soap context
        virtual eml22__IlluminanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IlluminanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__IlluminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__IlluminanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__IlluminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__IlluminanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__IlluminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1404 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt (-637)
/* simple XML schema type 'eml22:IlluminanceMeasureExt': */
class SOAP_CMAC eml22__IlluminanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:IlluminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IlluminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__IlluminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IlluminanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__IlluminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__IlluminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__IlluminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__IlluminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__IlluminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1406 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure (-638)
/* simple XML schema type 'eml22:InductanceMeasure': */
class SOAP_CMAC eml22__InductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:InductanceUom'
        eml22__InductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__InductanceMeasure, default initialized and not managed by a soap context
        virtual eml22__InductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__InductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__InductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__InductanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__InductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__InductanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__InductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1408 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt (-639)
/* simple XML schema type 'eml22:InductanceMeasureExt': */
class SOAP_CMAC eml22__InductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:InductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__InductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__InductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__InductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__InductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__InductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__InductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__InductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__InductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1410 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure (-640)
/* simple XML schema type 'eml22:IsothermalCompressibilityMeasure': */
class SOAP_CMAC eml22__IsothermalCompressibilityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:IsothermalCompressibilityUom'
        eml22__IsothermalCompressibilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IsothermalCompressibilityMeasure, default initialized and not managed by a soap context
        virtual eml22__IsothermalCompressibilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IsothermalCompressibilityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__IsothermalCompressibilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__IsothermalCompressibilityMeasure() { }
        /// Friend allocator used by soap_new_eml22__IsothermalCompressibilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__IsothermalCompressibilityMeasure * SOAP_FMAC2 soap_instantiate_eml22__IsothermalCompressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1412 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt (-641)
/* simple XML schema type 'eml22:IsothermalCompressibilityMeasureExt': */
class SOAP_CMAC eml22__IsothermalCompressibilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:IsothermalCompressibilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IsothermalCompressibilityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__IsothermalCompressibilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IsothermalCompressibilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__IsothermalCompressibilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__IsothermalCompressibilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__IsothermalCompressibilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__IsothermalCompressibilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__IsothermalCompressibilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1414 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure (-642)
/* simple XML schema type 'eml22:KinematicViscosityMeasure': */
class SOAP_CMAC eml22__KinematicViscosityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:KinematicViscosityUom'
        eml22__KinematicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__KinematicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml22__KinematicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__KinematicViscosityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__KinematicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__KinematicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml22__KinematicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__KinematicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml22__KinematicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1416 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt (-643)
/* simple XML schema type 'eml22:KinematicViscosityMeasureExt': */
class SOAP_CMAC eml22__KinematicViscosityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:KinematicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__KinematicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__KinematicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__KinematicViscosityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__KinematicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__KinematicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__KinematicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__KinematicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__KinematicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1418 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure (-644)
/* simple XML schema type 'eml22:LengthMeasure': */
class SOAP_CMAC eml22__LengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUom'
        eml22__LengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1420 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt (-645)
/* simple XML schema type 'eml22:LengthMeasureExt': */
class SOAP_CMAC eml22__LengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1422 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt (-646)
/* simple XML schema type 'eml22:LengthOrTimeMeasureExt': */
class SOAP_CMAC eml22__LengthOrTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthOrTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthOrTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthOrTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthOrTimeMeasureExt() : __item(), soap() { }
        virtual ~eml22__LengthOrTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthOrTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthOrTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthOrTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1424 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure (-647)
/* simple XML schema type 'eml22:LengthPerLengthMeasure': */
class SOAP_CMAC eml22__LengthPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerLengthUom'
        eml22__LengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1426 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt (-648)
/* simple XML schema type 'eml22:LengthPerLengthMeasureExt': */
class SOAP_CMAC eml22__LengthPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1428 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure (-649)
/* simple XML schema type 'eml22:LengthPerMassMeasure': */
class SOAP_CMAC eml22__LengthPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerMassUom'
        eml22__LengthPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1430 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt (-650)
/* simple XML schema type 'eml22:LengthPerMassMeasureExt': */
class SOAP_CMAC eml22__LengthPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1432 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure (-651)
/* simple XML schema type 'eml22:LengthPerPressureMeasure': */
class SOAP_CMAC eml22__LengthPerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerPressureUom'
        eml22__LengthPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1434 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt (-652)
/* simple XML schema type 'eml22:LengthPerPressureMeasureExt': */
class SOAP_CMAC eml22__LengthPerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1436 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure (-653)
/* simple XML schema type 'eml22:LengthPerTemperatureMeasure': */
class SOAP_CMAC eml22__LengthPerTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerTemperatureUom'
        eml22__LengthPerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1438 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt (-654)
/* simple XML schema type 'eml22:LengthPerTemperatureMeasureExt': */
class SOAP_CMAC eml22__LengthPerTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1440 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure (-655)
/* simple XML schema type 'eml22:LengthPerTimeMeasure': */
class SOAP_CMAC eml22__LengthPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerTimeUom'
        eml22__LengthPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1442 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt (-656)
/* simple XML schema type 'eml22:LengthPerTimeMeasureExt': */
class SOAP_CMAC eml22__LengthPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1444 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure (-657)
/* simple XML schema type 'eml22:LengthPerVolumeMeasure': */
class SOAP_CMAC eml22__LengthPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerVolumeUom'
        eml22__LengthPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__LengthPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__LengthPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__LengthPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1446 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt (-658)
/* simple XML schema type 'eml22:LengthPerVolumeMeasureExt': */
class SOAP_CMAC eml22__LengthPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LengthPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LengthPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LengthPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LengthPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LengthPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LengthPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LengthPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LengthPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1448 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure (-659)
/* simple XML schema type 'eml22:LightExposureMeasure': */
class SOAP_CMAC eml22__LightExposureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LightExposureUom'
        eml22__LightExposureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LightExposureMeasure, default initialized and not managed by a soap context
        virtual eml22__LightExposureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LightExposureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LightExposureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LightExposureMeasure() { }
        /// Friend allocator used by soap_new_eml22__LightExposureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LightExposureMeasure * SOAP_FMAC2 soap_instantiate_eml22__LightExposureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1450 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt (-660)
/* simple XML schema type 'eml22:LightExposureMeasureExt': */
class SOAP_CMAC eml22__LightExposureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LightExposureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LightExposureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LightExposureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LightExposureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LightExposureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LightExposureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LightExposureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LightExposureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LightExposureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1452 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure (-661)
/* simple XML schema type 'eml22:LinearAccelerationMeasure': */
class SOAP_CMAC eml22__LinearAccelerationMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LinearAccelerationUom'
        eml22__LinearAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LinearAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml22__LinearAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LinearAccelerationMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LinearAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LinearAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml22__LinearAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LinearAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml22__LinearAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1454 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt (-662)
/* simple XML schema type 'eml22:LinearAccelerationMeasureExt': */
class SOAP_CMAC eml22__LinearAccelerationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LinearAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LinearAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LinearAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LinearAccelerationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LinearAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LinearAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LinearAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LinearAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LinearAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1456 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure (-663)
/* simple XML schema type 'eml22:LinearThermalExpansionMeasure': */
class SOAP_CMAC eml22__LinearThermalExpansionMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LinearThermalExpansionUom'
        eml22__LinearThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LinearThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml22__LinearThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LinearThermalExpansionMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LinearThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LinearThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml22__LinearThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LinearThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml22__LinearThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1458 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt (-664)
/* simple XML schema type 'eml22:LinearThermalExpansionMeasureExt': */
class SOAP_CMAC eml22__LinearThermalExpansionMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LinearThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LinearThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LinearThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LinearThermalExpansionMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LinearThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LinearThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LinearThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LinearThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LinearThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1460 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure (-665)
/* simple XML schema type 'eml22:LogarithmicPowerRatioMeasure': */
class SOAP_CMAC eml22__LogarithmicPowerRatioMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LogarithmicPowerRatioUom'
        eml22__LogarithmicPowerRatioUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LogarithmicPowerRatioMeasure, default initialized and not managed by a soap context
        virtual eml22__LogarithmicPowerRatioMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LogarithmicPowerRatioMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LogarithmicPowerRatioMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LogarithmicPowerRatioMeasure() { }
        /// Friend allocator used by soap_new_eml22__LogarithmicPowerRatioMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LogarithmicPowerRatioMeasure * SOAP_FMAC2 soap_instantiate_eml22__LogarithmicPowerRatioMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1462 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt (-666)
/* simple XML schema type 'eml22:LogarithmicPowerRatioMeasureExt': */
class SOAP_CMAC eml22__LogarithmicPowerRatioMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LogarithmicPowerRatioUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LogarithmicPowerRatioMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LogarithmicPowerRatioMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LogarithmicPowerRatioMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LogarithmicPowerRatioMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LogarithmicPowerRatioMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LogarithmicPowerRatioMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LogarithmicPowerRatioMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LogarithmicPowerRatioMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1464 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure (-667)
/* simple XML schema type 'eml22:LogarithmicPowerRatioPerLengthMeasure': */
class SOAP_CMAC eml22__LogarithmicPowerRatioPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LogarithmicPowerRatioPerLengthUom'
        eml22__LogarithmicPowerRatioPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LogarithmicPowerRatioPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__LogarithmicPowerRatioPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LogarithmicPowerRatioPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LogarithmicPowerRatioPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LogarithmicPowerRatioPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LogarithmicPowerRatioPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1466 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt (-668)
/* simple XML schema type 'eml22:LogarithmicPowerRatioPerLengthMeasureExt': */
class SOAP_CMAC eml22__LogarithmicPowerRatioPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LogarithmicPowerRatioPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LogarithmicPowerRatioPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LogarithmicPowerRatioPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LogarithmicPowerRatioPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LogarithmicPowerRatioPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LogarithmicPowerRatioPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LogarithmicPowerRatioPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1468 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure (-669)
/* simple XML schema type 'eml22:LuminanceMeasure': */
class SOAP_CMAC eml22__LuminanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminanceUom'
        eml22__LuminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminanceMeasure, default initialized and not managed by a soap context
        virtual eml22__LuminanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LuminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LuminanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__LuminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__LuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1470 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt (-670)
/* simple XML schema type 'eml22:LuminanceMeasureExt': */
class SOAP_CMAC eml22__LuminanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LuminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LuminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LuminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LuminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LuminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1472 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure (-671)
/* simple XML schema type 'eml22:LuminousEfficacyMeasure': */
class SOAP_CMAC eml22__LuminousEfficacyMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousEfficacyUom'
        eml22__LuminousEfficacyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousEfficacyMeasure, default initialized and not managed by a soap context
        virtual eml22__LuminousEfficacyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousEfficacyMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LuminousEfficacyMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousEfficacyMeasure() { }
        /// Friend allocator used by soap_new_eml22__LuminousEfficacyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousEfficacyMeasure * SOAP_FMAC2 soap_instantiate_eml22__LuminousEfficacyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1474 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt (-672)
/* simple XML schema type 'eml22:LuminousEfficacyMeasureExt': */
class SOAP_CMAC eml22__LuminousEfficacyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousEfficacyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousEfficacyMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LuminousEfficacyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousEfficacyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LuminousEfficacyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousEfficacyMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LuminousEfficacyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousEfficacyMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LuminousEfficacyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1476 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure (-673)
/* simple XML schema type 'eml22:LuminousFluxMeasure': */
class SOAP_CMAC eml22__LuminousFluxMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousFluxUom'
        eml22__LuminousFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousFluxMeasure, default initialized and not managed by a soap context
        virtual eml22__LuminousFluxMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousFluxMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LuminousFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousFluxMeasure() { }
        /// Friend allocator used by soap_new_eml22__LuminousFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousFluxMeasure * SOAP_FMAC2 soap_instantiate_eml22__LuminousFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1478 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt (-674)
/* simple XML schema type 'eml22:LuminousFluxMeasureExt': */
class SOAP_CMAC eml22__LuminousFluxMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LuminousFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousFluxMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LuminousFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LuminousFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LuminousFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1480 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure (-675)
/* simple XML schema type 'eml22:LuminousIntensityMeasure': */
class SOAP_CMAC eml22__LuminousIntensityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousIntensityUom'
        eml22__LuminousIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousIntensityMeasure, default initialized and not managed by a soap context
        virtual eml22__LuminousIntensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousIntensityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__LuminousIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml22__LuminousIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml22__LuminousIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1482 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt (-676)
/* simple XML schema type 'eml22:LuminousIntensityMeasureExt': */
class SOAP_CMAC eml22__LuminousIntensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LuminousIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__LuminousIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__LuminousIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__LuminousIntensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__LuminousIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__LuminousIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__LuminousIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__LuminousIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__LuminousIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1484 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure (-677)
/* simple XML schema type 'eml22:MagneticDipoleMomentMeasure': */
class SOAP_CMAC eml22__MagneticDipoleMomentMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticDipoleMomentUom'
        eml22__MagneticDipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticDipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticDipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticDipoleMomentMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticDipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticDipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticDipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticDipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticDipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1486 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt (-678)
/* simple XML schema type 'eml22:MagneticDipoleMomentMeasureExt': */
class SOAP_CMAC eml22__MagneticDipoleMomentMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticDipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticDipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticDipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticDipoleMomentMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticDipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticDipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticDipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticDipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticDipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1488 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure (-679)
/* simple XML schema type 'eml22:MagneticFieldStrengthMeasure': */
class SOAP_CMAC eml22__MagneticFieldStrengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFieldStrengthUom'
        eml22__MagneticFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFieldStrengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1490 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt (-680)
/* simple XML schema type 'eml22:MagneticFieldStrengthMeasureExt': */
class SOAP_CMAC eml22__MagneticFieldStrengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFieldStrengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1492 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure (-681)
/* simple XML schema type 'eml22:MagneticFluxDensityMeasure': */
class SOAP_CMAC eml22__MagneticFluxDensityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxDensityUom'
        eml22__MagneticFluxDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxDensityMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxDensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxDensityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxDensityMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxDensityMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1494 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt (-682)
/* simple XML schema type 'eml22:MagneticFluxDensityMeasureExt': */
class SOAP_CMAC eml22__MagneticFluxDensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxDensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1496 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure (-683)
/* simple XML schema type 'eml22:MagneticFluxDensityPerLengthMeasure': */
class SOAP_CMAC eml22__MagneticFluxDensityPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxDensityPerLengthUom'
        eml22__MagneticFluxDensityPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxDensityPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxDensityPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxDensityPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxDensityPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxDensityPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxDensityPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxDensityPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxDensityPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1498 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt (-684)
/* simple XML schema type 'eml22:MagneticFluxDensityPerLengthMeasureExt': */
class SOAP_CMAC eml22__MagneticFluxDensityPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxDensityPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxDensityPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxDensityPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxDensityPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxDensityPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxDensityPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxDensityPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1500 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure (-685)
/* simple XML schema type 'eml22:MagneticFluxMeasure': */
class SOAP_CMAC eml22__MagneticFluxMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxUom'
        eml22__MagneticFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1502 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt (-686)
/* simple XML schema type 'eml22:MagneticFluxMeasureExt': */
class SOAP_CMAC eml22__MagneticFluxMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticFluxMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1504 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure (-687)
/* simple XML schema type 'eml22:MagneticPermeabilityMeasure': */
class SOAP_CMAC eml22__MagneticPermeabilityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticPermeabilityUom'
        eml22__MagneticPermeabilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticPermeabilityMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticPermeabilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticPermeabilityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticPermeabilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticPermeabilityMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticPermeabilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticPermeabilityMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticPermeabilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1506 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt (-688)
/* simple XML schema type 'eml22:MagneticPermeabilityMeasureExt': */
class SOAP_CMAC eml22__MagneticPermeabilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticPermeabilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticPermeabilityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticPermeabilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticPermeabilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticPermeabilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticPermeabilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticPermeabilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticPermeabilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticPermeabilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1508 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure (-689)
/* simple XML schema type 'eml22:MagneticVectorPotentialMeasure': */
class SOAP_CMAC eml22__MagneticVectorPotentialMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticVectorPotentialUom'
        eml22__MagneticVectorPotentialUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticVectorPotentialMeasure, default initialized and not managed by a soap context
        virtual eml22__MagneticVectorPotentialMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticVectorPotentialMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MagneticVectorPotentialMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticVectorPotentialMeasure() { }
        /// Friend allocator used by soap_new_eml22__MagneticVectorPotentialMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticVectorPotentialMeasure * SOAP_FMAC2 soap_instantiate_eml22__MagneticVectorPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1510 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt (-690)
/* simple XML schema type 'eml22:MagneticVectorPotentialMeasureExt': */
class SOAP_CMAC eml22__MagneticVectorPotentialMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MagneticVectorPotentialUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MagneticVectorPotentialMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MagneticVectorPotentialMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MagneticVectorPotentialMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MagneticVectorPotentialMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MagneticVectorPotentialMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MagneticVectorPotentialMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MagneticVectorPotentialMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MagneticVectorPotentialMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1512 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure (-691)
/* simple XML schema type 'eml22:MassLengthMeasure': */
class SOAP_CMAC eml22__MassLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassLengthUom'
        eml22__MassLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MassLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1514 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt (-692)
/* simple XML schema type 'eml22:MassLengthMeasureExt': */
class SOAP_CMAC eml22__MassLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1516 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure (-693)
/* simple XML schema type 'eml22:MassMeasure': */
class SOAP_CMAC eml22__MassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassUom'
        eml22__MassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassMeasure, default initialized and not managed by a soap context
        virtual eml22__MassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1518 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt (-694)
/* simple XML schema type 'eml22:MassMeasureExt': */
class SOAP_CMAC eml22__MassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1520 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure (-695)
/* simple XML schema type 'eml22:MassPerAreaMeasure': */
class SOAP_CMAC eml22__MassPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerAreaUom'
        eml22__MassPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1522 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt (-696)
/* simple XML schema type 'eml22:MassPerAreaMeasureExt': */
class SOAP_CMAC eml22__MassPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1524 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure (-697)
/* simple XML schema type 'eml22:MassPerEnergyMeasure': */
class SOAP_CMAC eml22__MassPerEnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerEnergyUom'
        eml22__MassPerEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerEnergyMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerEnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerEnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1526 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt (-698)
/* simple XML schema type 'eml22:MassPerEnergyMeasureExt': */
class SOAP_CMAC eml22__MassPerEnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerEnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1528 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure (-699)
/* simple XML schema type 'eml22:MassPerLengthMeasure': */
class SOAP_CMAC eml22__MassPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerLengthUom'
        eml22__MassPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1530 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt (-700)
/* simple XML schema type 'eml22:MassPerLengthMeasureExt': */
class SOAP_CMAC eml22__MassPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1532 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure (-701)
/* simple XML schema type 'eml22:MassPerMassMeasure': */
class SOAP_CMAC eml22__MassPerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerMassUom'
        eml22__MassPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1534 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt (-702)
/* simple XML schema type 'eml22:MassPerMassMeasureExt': */
class SOAP_CMAC eml22__MassPerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1536 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure (-703)
/* simple XML schema type 'eml22:MassPerTimeMeasure': */
class SOAP_CMAC eml22__MassPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimeUom'
        eml22__MassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1538 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt (-704)
/* simple XML schema type 'eml22:MassPerTimeMeasureExt': */
class SOAP_CMAC eml22__MassPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1540 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure (-705)
/* simple XML schema type 'eml22:MassPerTimePerAreaMeasure': */
class SOAP_CMAC eml22__MassPerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimePerAreaUom'
        eml22__MassPerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1542 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt (-706)
/* simple XML schema type 'eml22:MassPerTimePerAreaMeasureExt': */
class SOAP_CMAC eml22__MassPerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1544 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure (-707)
/* simple XML schema type 'eml22:MassPerTimePerLengthMeasure': */
class SOAP_CMAC eml22__MassPerTimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimePerLengthUom'
        eml22__MassPerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1546 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt (-708)
/* simple XML schema type 'eml22:MassPerTimePerLengthMeasureExt': */
class SOAP_CMAC eml22__MassPerTimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerTimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1548 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure (-709)
/* simple XML schema type 'eml22:MassPerVolumeMeasure': */
class SOAP_CMAC eml22__MassPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1550 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt (-710)
/* simple XML schema type 'eml22:MassPerVolumeMeasureExt': */
class SOAP_CMAC eml22__MassPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1552 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure (-711)
/* simple XML schema type 'eml22:MassPerVolumePerLengthMeasure': */
class SOAP_CMAC eml22__MassPerVolumePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerLengthUom'
        eml22__MassPerVolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1554 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt (-712)
/* simple XML schema type 'eml22:MassPerVolumePerLengthMeasureExt': */
class SOAP_CMAC eml22__MassPerVolumePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1556 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure (-713)
/* simple XML schema type 'eml22:MassPerVolumePerPressureMeasure': */
class SOAP_CMAC eml22__MassPerVolumePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerPressureUom'
        eml22__MassPerVolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1558 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt (-714)
/* simple XML schema type 'eml22:MassPerVolumePerPressureMeasureExt': */
class SOAP_CMAC eml22__MassPerVolumePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1560 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure (-715)
/* simple XML schema type 'eml22:MassPerVolumePerTemperatureMeasure': */
class SOAP_CMAC eml22__MassPerVolumePerTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerTemperatureUom'
        eml22__MassPerVolumePerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1562 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt (-716)
/* simple XML schema type 'eml22:MassPerVolumePerTemperatureMeasureExt': */
class SOAP_CMAC eml22__MassPerVolumePerTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MassPerVolumePerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MassPerVolumePerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MassPerVolumePerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MassPerVolumePerTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MassPerVolumePerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MassPerVolumePerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MassPerVolumePerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MassPerVolumePerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MassPerVolumePerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1564 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure (-717)
/* simple XML schema type 'eml22:MobilityMeasure': */
class SOAP_CMAC eml22__MobilityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MobilityUom'
        eml22__MobilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MobilityMeasure, default initialized and not managed by a soap context
        virtual eml22__MobilityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MobilityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MobilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MobilityMeasure() { }
        /// Friend allocator used by soap_new_eml22__MobilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MobilityMeasure * SOAP_FMAC2 soap_instantiate_eml22__MobilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1566 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt (-718)
/* simple XML schema type 'eml22:MobilityMeasureExt': */
class SOAP_CMAC eml22__MobilityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MobilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MobilityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MobilityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MobilityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MobilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MobilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MobilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MobilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MobilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1568 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure (-719)
/* simple XML schema type 'eml22:MolarEnergyMeasure': */
class SOAP_CMAC eml22__MolarEnergyMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarEnergyUom'
        eml22__MolarEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarEnergyMeasure, default initialized and not managed by a soap context
        virtual eml22__MolarEnergyMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarEnergyMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MolarEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MolarEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml22__MolarEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml22__MolarEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1570 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt (-720)
/* simple XML schema type 'eml22:MolarEnergyMeasureExt': */
class SOAP_CMAC eml22__MolarEnergyMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MolarEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarEnergyMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MolarEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MolarEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MolarEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MolarEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1572 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure (-721)
/* simple XML schema type 'eml22:MolarHeatCapacityMeasure': */
class SOAP_CMAC eml22__MolarHeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarHeatCapacityUom'
        eml22__MolarHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml22__MolarHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarHeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MolarHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MolarHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml22__MolarHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml22__MolarHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1574 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt (-722)
/* simple XML schema type 'eml22:MolarHeatCapacityMeasureExt': */
class SOAP_CMAC eml22__MolarHeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MolarHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarHeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MolarHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MolarHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MolarHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MolarHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1576 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure (-723)
/* simple XML schema type 'eml22:MolarVolumeMeasure': */
class SOAP_CMAC eml22__MolarVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarVolumeUom'
        eml22__MolarVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__MolarVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MolarVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MolarVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__MolarVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__MolarVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1578 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt (-724)
/* simple XML schema type 'eml22:MolarVolumeMeasureExt': */
class SOAP_CMAC eml22__MolarVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolarVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolarVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MolarVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolarVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MolarVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MolarVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MolarVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolarVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MolarVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1580 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure (-725)
/* simple XML schema type 'eml22:MolecularWeightMeasure': */
class SOAP_CMAC eml22__MolecularWeightMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolecularWeightUom'
        eml22__MolecularWeightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolecularWeightMeasure, default initialized and not managed by a soap context
        virtual eml22__MolecularWeightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolecularWeightMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MolecularWeightMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MolecularWeightMeasure() { }
        /// Friend allocator used by soap_new_eml22__MolecularWeightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolecularWeightMeasure * SOAP_FMAC2 soap_instantiate_eml22__MolecularWeightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1582 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt (-726)
/* simple XML schema type 'eml22:MolecularWeightMeasureExt': */
class SOAP_CMAC eml22__MolecularWeightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MolecularWeightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MolecularWeightMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MolecularWeightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MolecularWeightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MolecularWeightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MolecularWeightMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MolecularWeightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MolecularWeightMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MolecularWeightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1584 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure (-727)
/* simple XML schema type 'eml22:MomentOfForceMeasure': */
class SOAP_CMAC eml22__MomentOfForceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentOfForceUom'
        eml22__MomentOfForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentOfForceMeasure, default initialized and not managed by a soap context
        virtual eml22__MomentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentOfForceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MomentOfForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MomentOfForceMeasure() { }
        /// Friend allocator used by soap_new_eml22__MomentOfForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentOfForceMeasure * SOAP_FMAC2 soap_instantiate_eml22__MomentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1586 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt (-728)
/* simple XML schema type 'eml22:MomentOfForceMeasureExt': */
class SOAP_CMAC eml22__MomentOfForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentOfForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentOfForceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MomentOfForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentOfForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MomentOfForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MomentOfForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MomentOfForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentOfForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MomentOfForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1588 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure (-729)
/* simple XML schema type 'eml22:MomentOfInertiaMeasure': */
class SOAP_CMAC eml22__MomentOfInertiaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentOfInertiaUom'
        eml22__MomentOfInertiaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentOfInertiaMeasure, default initialized and not managed by a soap context
        virtual eml22__MomentOfInertiaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentOfInertiaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MomentOfInertiaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MomentOfInertiaMeasure() { }
        /// Friend allocator used by soap_new_eml22__MomentOfInertiaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentOfInertiaMeasure * SOAP_FMAC2 soap_instantiate_eml22__MomentOfInertiaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1590 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt (-730)
/* simple XML schema type 'eml22:MomentOfInertiaMeasureExt': */
class SOAP_CMAC eml22__MomentOfInertiaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentOfInertiaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentOfInertiaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MomentOfInertiaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentOfInertiaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MomentOfInertiaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MomentOfInertiaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MomentOfInertiaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentOfInertiaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MomentOfInertiaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1592 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure (-731)
/* simple XML schema type 'eml22:MomentumMeasure': */
class SOAP_CMAC eml22__MomentumMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentumUom'
        eml22__MomentumUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentumMeasure, default initialized and not managed by a soap context
        virtual eml22__MomentumMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentumMeasure); }
      public:
        /// Constructor with default initializations
        eml22__MomentumMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__MomentumMeasure() { }
        /// Friend allocator used by soap_new_eml22__MomentumMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentumMeasure * SOAP_FMAC2 soap_instantiate_eml22__MomentumMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1594 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt (-732)
/* simple XML schema type 'eml22:MomentumMeasureExt': */
class SOAP_CMAC eml22__MomentumMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:MomentumUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__MomentumMeasureExt, default initialized and not managed by a soap context
        virtual eml22__MomentumMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__MomentumMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__MomentumMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__MomentumMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__MomentumMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__MomentumMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__MomentumMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1596 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure (-733)
/* simple XML schema type 'eml22:NormalizedPowerMeasure': */
class SOAP_CMAC eml22__NormalizedPowerMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:NormalizedPowerUom'
        eml22__NormalizedPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__NormalizedPowerMeasure, default initialized and not managed by a soap context
        virtual eml22__NormalizedPowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__NormalizedPowerMeasure); }
      public:
        /// Constructor with default initializations
        eml22__NormalizedPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__NormalizedPowerMeasure() { }
        /// Friend allocator used by soap_new_eml22__NormalizedPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__NormalizedPowerMeasure * SOAP_FMAC2 soap_instantiate_eml22__NormalizedPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1598 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt (-734)
/* simple XML schema type 'eml22:NormalizedPowerMeasureExt': */
class SOAP_CMAC eml22__NormalizedPowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:NormalizedPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__NormalizedPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml22__NormalizedPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__NormalizedPowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__NormalizedPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__NormalizedPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__NormalizedPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__NormalizedPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__NormalizedPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1600 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure (-735)
/* simple XML schema type 'eml22:PermeabilityLengthMeasure': */
class SOAP_CMAC eml22__PermeabilityLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermeabilityLengthUom'
        eml22__PermeabilityLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermeabilityLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__PermeabilityLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermeabilityLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PermeabilityLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PermeabilityLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__PermeabilityLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermeabilityLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__PermeabilityLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1602 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt (-736)
/* simple XML schema type 'eml22:PermeabilityLengthMeasureExt': */
class SOAP_CMAC eml22__PermeabilityLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermeabilityLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermeabilityLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PermeabilityLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermeabilityLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PermeabilityLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PermeabilityLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PermeabilityLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermeabilityLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PermeabilityLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1604 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure (-737)
/* simple XML schema type 'eml22:PermeabilityRockMeasure': */
class SOAP_CMAC eml22__PermeabilityRockMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermeabilityRockUom'
        eml22__PermeabilityRockUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermeabilityRockMeasure, default initialized and not managed by a soap context
        virtual eml22__PermeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermeabilityRockMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PermeabilityRockMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PermeabilityRockMeasure() { }
        /// Friend allocator used by soap_new_eml22__PermeabilityRockMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermeabilityRockMeasure * SOAP_FMAC2 soap_instantiate_eml22__PermeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1606 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt (-738)
/* simple XML schema type 'eml22:PermeabilityRockMeasureExt': */
class SOAP_CMAC eml22__PermeabilityRockMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermeabilityRockUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermeabilityRockMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PermeabilityRockMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermeabilityRockMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PermeabilityRockMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PermeabilityRockMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PermeabilityRockMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermeabilityRockMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PermeabilityRockMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1608 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure (-739)
/* simple XML schema type 'eml22:PermittivityMeasure': */
class SOAP_CMAC eml22__PermittivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermittivityUom'
        eml22__PermittivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermittivityMeasure, default initialized and not managed by a soap context
        virtual eml22__PermittivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermittivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PermittivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PermittivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__PermittivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermittivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__PermittivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1610 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt (-740)
/* simple XML schema type 'eml22:PermittivityMeasureExt': */
class SOAP_CMAC eml22__PermittivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PermittivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PermittivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PermittivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PermittivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PermittivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PermittivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PermittivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PermittivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PermittivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1612 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure (-741)
/* simple XML schema type 'eml22:PlaneAngleMeasure': */
class SOAP_CMAC eml22__PlaneAngleMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PlaneAngleUom'
        eml22__PlaneAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PlaneAngleMeasure, default initialized and not managed by a soap context
        virtual eml22__PlaneAngleMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PlaneAngleMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PlaneAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PlaneAngleMeasure() { }
        /// Friend allocator used by soap_new_eml22__PlaneAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PlaneAngleMeasure * SOAP_FMAC2 soap_instantiate_eml22__PlaneAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1614 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt (-742)
/* simple XML schema type 'eml22:PlaneAngleMeasureExt': */
class SOAP_CMAC eml22__PlaneAngleMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PlaneAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PlaneAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PlaneAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PlaneAngleMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PlaneAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PlaneAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PlaneAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PlaneAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PlaneAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1616 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure (-743)
/* simple XML schema type 'eml22:PotentialDifferencePerPowerDropMeasure': */
class SOAP_CMAC eml22__PotentialDifferencePerPowerDropMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PotentialDifferencePerPowerDropUom'
        eml22__PotentialDifferencePerPowerDropUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PotentialDifferencePerPowerDropMeasure, default initialized and not managed by a soap context
        virtual eml22__PotentialDifferencePerPowerDropMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PotentialDifferencePerPowerDropMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PotentialDifferencePerPowerDropMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PotentialDifferencePerPowerDropMeasure() { }
        /// Friend allocator used by soap_new_eml22__PotentialDifferencePerPowerDropMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PotentialDifferencePerPowerDropMeasure * SOAP_FMAC2 soap_instantiate_eml22__PotentialDifferencePerPowerDropMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1618 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt (-744)
/* simple XML schema type 'eml22:PotentialDifferencePerPowerDropMeasureExt': */
class SOAP_CMAC eml22__PotentialDifferencePerPowerDropMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PotentialDifferencePerPowerDropUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PotentialDifferencePerPowerDropMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PotentialDifferencePerPowerDropMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PotentialDifferencePerPowerDropMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PotentialDifferencePerPowerDropMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PotentialDifferencePerPowerDropMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PotentialDifferencePerPowerDropMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1620 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure (-745)
/* simple XML schema type 'eml22:PowerMeasure': */
class SOAP_CMAC eml22__PowerMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerUom'
        eml22__PowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerMeasure, default initialized and not managed by a soap context
        virtual eml22__PowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PowerMeasure() { }
        /// Friend allocator used by soap_new_eml22__PowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerMeasure * SOAP_FMAC2 soap_instantiate_eml22__PowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1622 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt (-746)
/* simple XML schema type 'eml22:PowerMeasureExt': */
class SOAP_CMAC eml22__PowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1624 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure (-747)
/* simple XML schema type 'eml22:PowerPerAreaMeasure': */
class SOAP_CMAC eml22__PowerPerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerAreaUom'
        eml22__PowerPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__PowerPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__PowerPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__PowerPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1626 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt (-748)
/* simple XML schema type 'eml22:PowerPerAreaMeasureExt': */
class SOAP_CMAC eml22__PowerPerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PowerPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PowerPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PowerPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1628 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure (-749)
/* simple XML schema type 'eml22:PowerPerPowerMeasure': */
class SOAP_CMAC eml22__PowerPerPowerMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerPowerUom'
        eml22__PowerPerPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerPowerMeasure, default initialized and not managed by a soap context
        virtual eml22__PowerPerPowerMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerPowerMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerPowerMeasure() { }
        /// Friend allocator used by soap_new_eml22__PowerPerPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerPowerMeasure * SOAP_FMAC2 soap_instantiate_eml22__PowerPerPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1630 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt (-750)
/* simple XML schema type 'eml22:PowerPerPowerMeasureExt': */
class SOAP_CMAC eml22__PowerPerPowerMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PowerPerPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerPowerMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PowerPerPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PowerPerPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1632 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure (-751)
/* simple XML schema type 'eml22:PowerPerVolumeMeasure': */
class SOAP_CMAC eml22__PowerPerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerVolumeUom'
        eml22__PowerPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__PowerPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__PowerPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__PowerPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1634 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt (-752)
/* simple XML schema type 'eml22:PowerPerVolumeMeasureExt': */
class SOAP_CMAC eml22__PowerPerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PowerPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PowerPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PowerPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PowerPerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PowerPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PowerPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PowerPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PowerPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PowerPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1636 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure (-753)
/* simple XML schema type 'eml22:PressureMeasure': */
class SOAP_CMAC eml22__PressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureMeasure, default initialized and not managed by a soap context
        virtual eml22__PressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1638 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt (-754)
/* simple XML schema type 'eml22:PressureMeasureExt': */
class SOAP_CMAC eml22__PressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1640 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure (-755)
/* simple XML schema type 'eml22:PressurePerPressureMeasure': */
class SOAP_CMAC eml22__PressurePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerPressureUom'
        eml22__PressurePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__PressurePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressurePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressurePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1642 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt (-756)
/* simple XML schema type 'eml22:PressurePerPressureMeasureExt': */
class SOAP_CMAC eml22__PressurePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressurePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressurePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressurePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1644 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure (-757)
/* simple XML schema type 'eml22:PressurePerTimeMeasure': */
class SOAP_CMAC eml22__PressurePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerTimeUom'
        eml22__PressurePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__PressurePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressurePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressurePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1646 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt (-758)
/* simple XML schema type 'eml22:PressurePerTimeMeasureExt': */
class SOAP_CMAC eml22__PressurePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressurePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressurePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressurePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1648 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure (-759)
/* simple XML schema type 'eml22:PressurePerVolumeMeasure': */
class SOAP_CMAC eml22__PressurePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__PressurePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressurePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressurePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1650 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt (-760)
/* simple XML schema type 'eml22:PressurePerVolumeMeasureExt': */
class SOAP_CMAC eml22__PressurePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressurePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressurePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressurePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressurePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressurePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressurePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressurePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressurePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressurePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1652 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure (-761)
/* simple XML schema type 'eml22:PressureSquaredMeasure': */
class SOAP_CMAC eml22__PressureSquaredMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureSquaredUom'
        eml22__PressureSquaredUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureSquaredMeasure, default initialized and not managed by a soap context
        virtual eml22__PressureSquaredMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureSquaredMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressureSquaredMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressureSquaredMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressureSquaredMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureSquaredMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressureSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1654 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt (-762)
/* simple XML schema type 'eml22:PressureSquaredMeasureExt': */
class SOAP_CMAC eml22__PressureSquaredMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureSquaredUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureSquaredMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressureSquaredMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureSquaredMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressureSquaredMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressureSquaredMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressureSquaredMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureSquaredMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressureSquaredMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1656 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure (-763)
/* simple XML schema type 'eml22:PressureSquaredPerForceTimePerAreaMeasure': */
class SOAP_CMAC eml22__PressureSquaredPerForceTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureSquaredPerForceTimePerAreaUom'
        eml22__PressureSquaredPerForceTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureSquaredPerForceTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__PressureSquaredPerForceTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureSquaredPerForceTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressureSquaredPerForceTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressureSquaredPerForceTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureSquaredPerForceTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1658 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt (-764)
/* simple XML schema type 'eml22:PressureSquaredPerForceTimePerAreaMeasureExt': */
class SOAP_CMAC eml22__PressureSquaredPerForceTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureSquaredPerForceTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureSquaredPerForceTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressureSquaredPerForceTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureSquaredPerForceTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressureSquaredPerForceTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressureSquaredPerForceTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureSquaredPerForceTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1660 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure (-765)
/* simple XML schema type 'eml22:PressureTimePerVolumeMeasure': */
class SOAP_CMAC eml22__PressureTimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureTimePerVolumeUom'
        eml22__PressureTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__PressureTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureTimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__PressureTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__PressureTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__PressureTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__PressureTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1662 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt (-766)
/* simple XML schema type 'eml22:PressureTimePerVolumeMeasureExt': */
class SOAP_CMAC eml22__PressureTimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__PressureTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__PressureTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__PressureTimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__PressureTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__PressureTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__PressureTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__PressureTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__PressureTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1664 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure (-767)
/* simple XML schema type 'eml22:QuantityOfLightMeasure': */
class SOAP_CMAC eml22__QuantityOfLightMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:QuantityOfLightUom'
        eml22__QuantityOfLightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__QuantityOfLightMeasure, default initialized and not managed by a soap context
        virtual eml22__QuantityOfLightMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__QuantityOfLightMeasure); }
      public:
        /// Constructor with default initializations
        eml22__QuantityOfLightMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__QuantityOfLightMeasure() { }
        /// Friend allocator used by soap_new_eml22__QuantityOfLightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__QuantityOfLightMeasure * SOAP_FMAC2 soap_instantiate_eml22__QuantityOfLightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1666 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt (-768)
/* simple XML schema type 'eml22:QuantityOfLightMeasureExt': */
class SOAP_CMAC eml22__QuantityOfLightMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:QuantityOfLightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__QuantityOfLightMeasureExt, default initialized and not managed by a soap context
        virtual eml22__QuantityOfLightMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__QuantityOfLightMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__QuantityOfLightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__QuantityOfLightMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__QuantityOfLightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__QuantityOfLightMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__QuantityOfLightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1668 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure (-769)
/* simple XML schema type 'eml22:RadianceMeasure': */
class SOAP_CMAC eml22__RadianceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:RadianceUom'
        eml22__RadianceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__RadianceMeasure, default initialized and not managed by a soap context
        virtual eml22__RadianceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__RadianceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__RadianceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__RadianceMeasure() { }
        /// Friend allocator used by soap_new_eml22__RadianceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__RadianceMeasure * SOAP_FMAC2 soap_instantiate_eml22__RadianceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1670 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt (-770)
/* simple XML schema type 'eml22:RadianceMeasureExt': */
class SOAP_CMAC eml22__RadianceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:RadianceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__RadianceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__RadianceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__RadianceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__RadianceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__RadianceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__RadianceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__RadianceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__RadianceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1672 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure (-771)
/* simple XML schema type 'eml22:RadiantIntensityMeasure': */
class SOAP_CMAC eml22__RadiantIntensityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:RadiantIntensityUom'
        eml22__RadiantIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__RadiantIntensityMeasure, default initialized and not managed by a soap context
        virtual eml22__RadiantIntensityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__RadiantIntensityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__RadiantIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__RadiantIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml22__RadiantIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__RadiantIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml22__RadiantIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1674 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt (-772)
/* simple XML schema type 'eml22:RadiantIntensityMeasureExt': */
class SOAP_CMAC eml22__RadiantIntensityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:RadiantIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__RadiantIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__RadiantIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__RadiantIntensityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__RadiantIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__RadiantIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__RadiantIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__RadiantIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__RadiantIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1676 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure (-773)
/* simple XML schema type 'eml22:ReciprocalAreaMeasure': */
class SOAP_CMAC eml22__ReciprocalAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalAreaUom'
        eml22__ReciprocalAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1678 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt (-774)
/* simple XML schema type 'eml22:ReciprocalAreaMeasureExt': */
class SOAP_CMAC eml22__ReciprocalAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1680 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure (-775)
/* simple XML schema type 'eml22:ReciprocalElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml22__ReciprocalElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalElectricPotentialDifferenceUom'
        eml22__ReciprocalElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1682 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt (-776)
/* simple XML schema type 'eml22:ReciprocalElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml22__ReciprocalElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1684 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure (-777)
/* simple XML schema type 'eml22:ReciprocalForceMeasure': */
class SOAP_CMAC eml22__ReciprocalForceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalForceUom'
        eml22__ReciprocalForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalForceMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalForceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalForceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalForceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalForceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1686 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt (-778)
/* simple XML schema type 'eml22:ReciprocalForceMeasureExt': */
class SOAP_CMAC eml22__ReciprocalForceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalForceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalForceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalForceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1688 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure (-779)
/* simple XML schema type 'eml22:ReciprocalLengthMeasure': */
class SOAP_CMAC eml22__ReciprocalLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalLengthUom'
        eml22__ReciprocalLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1690 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt (-780)
/* simple XML schema type 'eml22:ReciprocalLengthMeasureExt': */
class SOAP_CMAC eml22__ReciprocalLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1692 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure (-781)
/* simple XML schema type 'eml22:ReciprocalMassMeasure': */
class SOAP_CMAC eml22__ReciprocalMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalMassUom'
        eml22__ReciprocalMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalMassMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1694 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt (-782)
/* simple XML schema type 'eml22:ReciprocalMassMeasureExt': */
class SOAP_CMAC eml22__ReciprocalMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1696 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure (-783)
/* simple XML schema type 'eml22:ReciprocalMassTimeMeasure': */
class SOAP_CMAC eml22__ReciprocalMassTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalMassTimeUom'
        eml22__ReciprocalMassTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalMassTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalMassTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalMassTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalMassTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalMassTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalMassTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalMassTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalMassTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1698 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt (-784)
/* simple XML schema type 'eml22:ReciprocalMassTimeMeasureExt': */
class SOAP_CMAC eml22__ReciprocalMassTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalMassTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalMassTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalMassTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalMassTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalMassTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalMassTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalMassTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalMassTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalMassTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1700 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure (-785)
/* simple XML schema type 'eml22:ReciprocalPressureMeasure': */
class SOAP_CMAC eml22__ReciprocalPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalPressureUom'
        eml22__ReciprocalPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1702 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt (-786)
/* simple XML schema type 'eml22:ReciprocalPressureMeasureExt': */
class SOAP_CMAC eml22__ReciprocalPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1704 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure (-787)
/* simple XML schema type 'eml22:ReciprocalTimeMeasure': */
class SOAP_CMAC eml22__ReciprocalTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalTimeUom'
        eml22__ReciprocalTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1706 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt (-788)
/* simple XML schema type 'eml22:ReciprocalTimeMeasureExt': */
class SOAP_CMAC eml22__ReciprocalTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1708 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure (-789)
/* simple XML schema type 'eml22:ReciprocalVolumeMeasure': */
class SOAP_CMAC eml22__ReciprocalVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalVolumeUom'
        eml22__ReciprocalVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__ReciprocalVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1710 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt (-790)
/* simple XML schema type 'eml22:ReciprocalVolumeMeasureExt': */
class SOAP_CMAC eml22__ReciprocalVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReciprocalVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReciprocalVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReciprocalVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReciprocalVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReciprocalVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReciprocalVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReciprocalVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReciprocalVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReciprocalVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1712 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure (-791)
/* simple XML schema type 'eml22:ReluctanceMeasure': */
class SOAP_CMAC eml22__ReluctanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReluctanceUom'
        eml22__ReluctanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReluctanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ReluctanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReluctanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ReluctanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ReluctanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ReluctanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReluctanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ReluctanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1714 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt (-792)
/* simple XML schema type 'eml22:ReluctanceMeasureExt': */
class SOAP_CMAC eml22__ReluctanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ReluctanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReluctanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ReluctanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReluctanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ReluctanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ReluctanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ReluctanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReluctanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ReluctanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1716 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure (-793)
/* simple XML schema type 'eml22:SecondMomentOfAreaMeasure': */
class SOAP_CMAC eml22__SecondMomentOfAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SecondMomentOfAreaUom'
        eml22__SecondMomentOfAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SecondMomentOfAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__SecondMomentOfAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SecondMomentOfAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__SecondMomentOfAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__SecondMomentOfAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__SecondMomentOfAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__SecondMomentOfAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__SecondMomentOfAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1718 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt (-794)
/* simple XML schema type 'eml22:SecondMomentOfAreaMeasureExt': */
class SOAP_CMAC eml22__SecondMomentOfAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SecondMomentOfAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SecondMomentOfAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__SecondMomentOfAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SecondMomentOfAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__SecondMomentOfAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__SecondMomentOfAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__SecondMomentOfAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__SecondMomentOfAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__SecondMomentOfAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1720 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure (-795)
/* simple XML schema type 'eml22:SignalingEventPerTimeMeasure': */
class SOAP_CMAC eml22__SignalingEventPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SignalingEventPerTimeUom'
        eml22__SignalingEventPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SignalingEventPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__SignalingEventPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SignalingEventPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__SignalingEventPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__SignalingEventPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__SignalingEventPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__SignalingEventPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__SignalingEventPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1722 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt (-796)
/* simple XML schema type 'eml22:SignalingEventPerTimeMeasureExt': */
class SOAP_CMAC eml22__SignalingEventPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SignalingEventPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SignalingEventPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__SignalingEventPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SignalingEventPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__SignalingEventPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__SignalingEventPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__SignalingEventPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__SignalingEventPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__SignalingEventPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1724 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure (-797)
/* simple XML schema type 'eml22:SolidAngleMeasure': */
class SOAP_CMAC eml22__SolidAngleMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SolidAngleUom'
        eml22__SolidAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SolidAngleMeasure, default initialized and not managed by a soap context
        virtual eml22__SolidAngleMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SolidAngleMeasure); }
      public:
        /// Constructor with default initializations
        eml22__SolidAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__SolidAngleMeasure() { }
        /// Friend allocator used by soap_new_eml22__SolidAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__SolidAngleMeasure * SOAP_FMAC2 soap_instantiate_eml22__SolidAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1726 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt (-798)
/* simple XML schema type 'eml22:SolidAngleMeasureExt': */
class SOAP_CMAC eml22__SolidAngleMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SolidAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SolidAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml22__SolidAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SolidAngleMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__SolidAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__SolidAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__SolidAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__SolidAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__SolidAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1728 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure (-799)
/* simple XML schema type 'eml22:SpecificHeatCapacityMeasure': */
class SOAP_CMAC eml22__SpecificHeatCapacityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SpecificHeatCapacityUom'
        eml22__SpecificHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SpecificHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml22__SpecificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SpecificHeatCapacityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__SpecificHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__SpecificHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml22__SpecificHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__SpecificHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml22__SpecificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1730 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt (-800)
/* simple XML schema type 'eml22:SpecificHeatCapacityMeasureExt': */
class SOAP_CMAC eml22__SpecificHeatCapacityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:SpecificHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__SpecificHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__SpecificHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__SpecificHeatCapacityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__SpecificHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__SpecificHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__SpecificHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__SpecificHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__SpecificHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1732 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure (-801)
/* simple XML schema type 'eml22:TemperatureIntervalMeasure': */
class SOAP_CMAC eml22__TemperatureIntervalMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalUom'
        eml22__TemperatureIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalMeasure, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1734 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt (-802)
/* simple XML schema type 'eml22:TemperatureIntervalMeasureExt': */
class SOAP_CMAC eml22__TemperatureIntervalMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1736 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure (-803)
/* simple XML schema type 'eml22:TemperatureIntervalPerLengthMeasure': */
class SOAP_CMAC eml22__TemperatureIntervalPerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerLengthUom'
        eml22__TemperatureIntervalPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1738 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt (-804)
/* simple XML schema type 'eml22:TemperatureIntervalPerLengthMeasureExt': */
class SOAP_CMAC eml22__TemperatureIntervalPerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1740 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure (-805)
/* simple XML schema type 'eml22:TemperatureIntervalPerPressureMeasure': */
class SOAP_CMAC eml22__TemperatureIntervalPerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerPressureUom'
        eml22__TemperatureIntervalPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1742 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt (-806)
/* simple XML schema type 'eml22:TemperatureIntervalPerPressureMeasureExt': */
class SOAP_CMAC eml22__TemperatureIntervalPerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1744 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure (-807)
/* simple XML schema type 'eml22:TemperatureIntervalPerTimeMeasure': */
class SOAP_CMAC eml22__TemperatureIntervalPerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerTimeUom'
        eml22__TemperatureIntervalPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1746 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt (-808)
/* simple XML schema type 'eml22:TemperatureIntervalPerTimeMeasureExt': */
class SOAP_CMAC eml22__TemperatureIntervalPerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TemperatureIntervalPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TemperatureIntervalPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TemperatureIntervalPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TemperatureIntervalPerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TemperatureIntervalPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TemperatureIntervalPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TemperatureIntervalPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TemperatureIntervalPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TemperatureIntervalPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1748 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure (-809)
/* simple XML schema type 'eml22:ThermalConductanceMeasure': */
class SOAP_CMAC eml22__ThermalConductanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalConductanceUom'
        eml22__ThermalConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalConductanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermalConductanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalConductanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermalConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermalConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermalConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1750 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt (-810)
/* simple XML schema type 'eml22:ThermalConductanceMeasureExt': */
class SOAP_CMAC eml22__ThermalConductanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermalConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalConductanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermalConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermalConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermalConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1752 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure (-811)
/* simple XML schema type 'eml22:ThermalConductivityMeasure': */
class SOAP_CMAC eml22__ThermalConductivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalConductivityUom'
        eml22__ThermalConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalConductivityMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalConductivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermalConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermalConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1754 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt (-812)
/* simple XML schema type 'eml22:ThermalConductivityMeasureExt': */
class SOAP_CMAC eml22__ThermalConductivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermalConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalConductivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermalConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermalConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermalConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1756 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure (-813)
/* simple XML schema type 'eml22:ThermalDiffusivityMeasure': */
class SOAP_CMAC eml22__ThermalDiffusivityMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalDiffusivityUom'
        eml22__ThermalDiffusivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalDiffusivityMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermalDiffusivityMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalDiffusivityMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermalDiffusivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalDiffusivityMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermalDiffusivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalDiffusivityMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermalDiffusivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1758 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt (-814)
/* simple XML schema type 'eml22:ThermalDiffusivityMeasureExt': */
class SOAP_CMAC eml22__ThermalDiffusivityMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalDiffusivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalDiffusivityMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermalDiffusivityMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalDiffusivityMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermalDiffusivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalDiffusivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermalDiffusivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalDiffusivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermalDiffusivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1760 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure (-815)
/* simple XML schema type 'eml22:ThermalInsulanceMeasure': */
class SOAP_CMAC eml22__ThermalInsulanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalInsulanceUom'
        eml22__ThermalInsulanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalInsulanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermalInsulanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalInsulanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermalInsulanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalInsulanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermalInsulanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalInsulanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermalInsulanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1762 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt (-816)
/* simple XML schema type 'eml22:ThermalInsulanceMeasureExt': */
class SOAP_CMAC eml22__ThermalInsulanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalInsulanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalInsulanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermalInsulanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalInsulanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermalInsulanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalInsulanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermalInsulanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalInsulanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermalInsulanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1764 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure (-817)
/* simple XML schema type 'eml22:ThermalResistanceMeasure': */
class SOAP_CMAC eml22__ThermalResistanceMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalResistanceUom'
        eml22__ThermalResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalResistanceMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermalResistanceMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalResistanceMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermalResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermalResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermalResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1766 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt (-818)
/* simple XML schema type 'eml22:ThermalResistanceMeasureExt': */
class SOAP_CMAC eml22__ThermalResistanceMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermalResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermalResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermalResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermalResistanceMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermalResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermalResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermalResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermalResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermalResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1768 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure (-819)
/* simple XML schema type 'eml22:ThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml22__ThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermodynamicTemperatureUom'
        eml22__ThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1770 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt (-820)
/* simple XML schema type 'eml22:ThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml22__ThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1772 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (-821)
/* simple XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureUom'
        eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1774 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (-822)
/* simple XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1776 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure (-823)
/* simple XML schema type 'eml22:TimeMeasure': */
class SOAP_CMAC eml22__TimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimeUom'
        eml22__TimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeMeasure, default initialized and not managed by a soap context
        virtual eml22__TimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__TimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__TimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1778 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt (-824)
/* simple XML schema type 'eml22:TimeMeasureExt': */
class SOAP_CMAC eml22__TimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1780 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure (-825)
/* simple XML schema type 'eml22:TimePerLengthMeasure': */
class SOAP_CMAC eml22__TimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerLengthUom'
        eml22__TimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__TimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__TimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__TimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1782 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt (-826)
/* simple XML schema type 'eml22:TimePerLengthMeasureExt': */
class SOAP_CMAC eml22__TimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1784 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure (-827)
/* simple XML schema type 'eml22:TimePerMassMeasure': */
class SOAP_CMAC eml22__TimePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerMassUom'
        eml22__TimePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__TimePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TimePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__TimePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__TimePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1786 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt (-828)
/* simple XML schema type 'eml22:TimePerMassMeasureExt': */
class SOAP_CMAC eml22__TimePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TimePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TimePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TimePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TimePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1788 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure (-829)
/* simple XML schema type 'eml22:TimePerTimeMeasure': */
class SOAP_CMAC eml22__TimePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerTimeUom'
        eml22__TimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__TimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__TimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__TimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1790 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt (-830)
/* simple XML schema type 'eml22:TimePerTimeMeasureExt': */
class SOAP_CMAC eml22__TimePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1792 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure (-831)
/* simple XML schema type 'eml22:TimePerVolumeMeasure': */
class SOAP_CMAC eml22__TimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerVolumeUom'
        eml22__TimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__TimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__TimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__TimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__TimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1794 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt (-832)
/* simple XML schema type 'eml22:TimePerVolumeMeasureExt': */
class SOAP_CMAC eml22__TimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:TimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__TimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__TimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__TimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__TimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__TimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__TimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__TimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__TimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1796 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure (-833)
/* simple XML schema type 'eml22:UnitlessMeasure': */
class SOAP_CMAC eml22__UnitlessMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__UnitlessMeasure, default initialized and not managed by a soap context
        virtual eml22__UnitlessMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__UnitlessMeasure); }
      public:
        /// Constructor with default initializations
        eml22__UnitlessMeasure() : __item(), soap() { }
        virtual ~eml22__UnitlessMeasure() { }
        /// Friend allocator used by soap_new_eml22__UnitlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__UnitlessMeasure * SOAP_FMAC2 soap_instantiate_eml22__UnitlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1798 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure (-834)
/* simple XML schema type 'eml22:VerticalCoordinateMeasure': */
class SOAP_CMAC eml22__VerticalCoordinateMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VerticalCoordinateUom'
        eml22__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalCoordinateMeasure, default initialized and not managed by a soap context
        virtual eml22__VerticalCoordinateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalCoordinateMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VerticalCoordinateMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VerticalCoordinateMeasure() { }
        /// Friend allocator used by soap_new_eml22__VerticalCoordinateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalCoordinateMeasure * SOAP_FMAC2 soap_instantiate_eml22__VerticalCoordinateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1800 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt (-835)
/* simple XML schema type 'eml22:VerticalCoordinateMeasureExt': */
class SOAP_CMAC eml22__VerticalCoordinateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VerticalCoordinateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VerticalCoordinateMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VerticalCoordinateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VerticalCoordinateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VerticalCoordinateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VerticalCoordinateMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VerticalCoordinateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VerticalCoordinateMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VerticalCoordinateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1802 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure (-836)
/* simple XML schema type 'eml22:VolumeFlowRatePerVolumeFlowRateMeasure': */
class SOAP_CMAC eml22__VolumeFlowRatePerVolumeFlowRateMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumeFlowRatePerVolumeFlowRateUom'
        eml22__VolumeFlowRatePerVolumeFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumeFlowRatePerVolumeFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumeFlowRatePerVolumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumeFlowRatePerVolumeFlowRateMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumeFlowRatePerVolumeFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumeFlowRatePerVolumeFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumeFlowRatePerVolumeFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1804 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt (-837)
/* simple XML schema type 'eml22:VolumeFlowRatePerVolumeFlowRateMeasureExt': */
class SOAP_CMAC eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumeFlowRatePerVolumeFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1806 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure (-838)
/* simple XML schema type 'eml22:VolumeMeasure': */
class SOAP_CMAC eml22__VolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1808 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt (-839)
/* simple XML schema type 'eml22:VolumeMeasureExt': */
class SOAP_CMAC eml22__VolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1810 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure (-840)
/* simple XML schema type 'eml22:VolumePerAreaMeasure': */
class SOAP_CMAC eml22__VolumePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerAreaUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1812 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt (-841)
/* simple XML schema type 'eml22:VolumePerAreaMeasureExt': */
class SOAP_CMAC eml22__VolumePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1814 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure (-842)
/* simple XML schema type 'eml22:VolumePerLengthMeasure': */
class SOAP_CMAC eml22__VolumePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerLengthUom'
        eml22__VolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1816 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt (-843)
/* simple XML schema type 'eml22:VolumePerLengthMeasureExt': */
class SOAP_CMAC eml22__VolumePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1818 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure (-844)
/* simple XML schema type 'eml22:VolumePerMassMeasure': */
class SOAP_CMAC eml22__VolumePerMassMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerMassUom'
        eml22__VolumePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerMassMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerMassMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerMassMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1820 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt (-845)
/* simple XML schema type 'eml22:VolumePerMassMeasureExt': */
class SOAP_CMAC eml22__VolumePerMassMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerMassMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1822 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure (-846)
/* simple XML schema type 'eml22:VolumePerPressureMeasure': */
class SOAP_CMAC eml22__VolumePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerPressureUom'
        eml22__VolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1824 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt (-847)
/* simple XML schema type 'eml22:VolumePerPressureMeasureExt': */
class SOAP_CMAC eml22__VolumePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1826 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure (-848)
/* simple XML schema type 'eml22:VolumePerRotationMeasure': */
class SOAP_CMAC eml22__VolumePerRotationMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerRotationUom'
        eml22__VolumePerRotationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerRotationMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerRotationMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerRotationMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerRotationMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerRotationMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerRotationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerRotationMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerRotationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1828 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt (-849)
/* simple XML schema type 'eml22:VolumePerRotationMeasureExt': */
class SOAP_CMAC eml22__VolumePerRotationMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerRotationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerRotationMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerRotationMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerRotationMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerRotationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerRotationMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerRotationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerRotationMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerRotationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1830 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure (-850)
/* simple XML schema type 'eml22:VolumePerTimeLengthMeasure': */
class SOAP_CMAC eml22__VolumePerTimeLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimeLengthUom'
        eml22__VolumePerTimeLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimeLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimeLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimeLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimeLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimeLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimeLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimeLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimeLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1832 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt (-851)
/* simple XML schema type 'eml22:VolumePerTimeLengthMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimeLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimeLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimeLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimeLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimeLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimeLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimeLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimeLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimeLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimeLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1834 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure (-852)
/* simple XML schema type 'eml22:VolumePerTimeMeasure': */
class SOAP_CMAC eml22__VolumePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1836 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt (-853)
/* simple XML schema type 'eml22:VolumePerTimeMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1838 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure (-854)
/* simple XML schema type 'eml22:VolumePerTimePerAreaMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerAreaMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerAreaUom'
        eml22__VolumePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerAreaMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1840 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt (-855)
/* simple XML schema type 'eml22:VolumePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1842 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure (-856)
/* simple XML schema type 'eml22:VolumePerTimePerLengthMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerLengthUom'
        eml22__VolumePerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1844 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt (-857)
/* simple XML schema type 'eml22:VolumePerTimePerLengthMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1846 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure (-858)
/* simple XML schema type 'eml22:VolumePerTimePerPressureLengthMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerPressureLengthMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerPressureLengthUom'
        eml22__VolumePerTimePerPressureLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerPressureLengthMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerPressureLengthMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerPressureLengthMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerPressureLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerPressureLengthMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerPressureLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerPressureLengthMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerPressureLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1848 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt (-859)
/* simple XML schema type 'eml22:VolumePerTimePerPressureLengthMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerPressureLengthMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerPressureLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerPressureLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerPressureLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerPressureLengthMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerPressureLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerPressureLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerPressureLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1850 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure (-860)
/* simple XML schema type 'eml22:VolumePerTimePerPressureMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerPressureMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerPressureUom'
        eml22__VolumePerTimePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerPressureMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1852 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt (-861)
/* simple XML schema type 'eml22:VolumePerTimePerPressureMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerPressureMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerPressureMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1854 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure (-862)
/* simple XML schema type 'eml22:VolumePerTimePerTimeMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerTimeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerTimeUom'
        eml22__VolumePerTimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerTimeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1856 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt (-863)
/* simple XML schema type 'eml22:VolumePerTimePerTimeMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerTimeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerTimeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1858 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure (-864)
/* simple XML schema type 'eml22:VolumePerTimePerVolumeMeasure': */
class SOAP_CMAC eml22__VolumePerTimePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerVolumeUom'
        eml22__VolumePerTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1860 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt (-865)
/* simple XML schema type 'eml22:VolumePerTimePerVolumeMeasureExt': */
class SOAP_CMAC eml22__VolumePerTimePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerTimePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1862 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure (-866)
/* simple XML schema type 'eml22:VolumePerVolumeMeasure': */
class SOAP_CMAC eml22__VolumePerVolumeMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerVolumeUomWithLegacy'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerVolumeMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1864 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt (-867)
/* simple XML schema type 'eml22:VolumePerVolumeMeasureExt': */
class SOAP_CMAC eml22__VolumePerVolumeMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumePerVolumeMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1866 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure (-868)
/* simple XML schema type 'eml22:VolumetricHeatTransferCoefficientMeasure': */
class SOAP_CMAC eml22__VolumetricHeatTransferCoefficientMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumetricHeatTransferCoefficientUom'
        eml22__VolumetricHeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumetricHeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumetricHeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumetricHeatTransferCoefficientMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumetricHeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumetricHeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumetricHeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumetricHeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumetricHeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1868 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt (-869)
/* simple XML schema type 'eml22:VolumetricHeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml22__VolumetricHeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumetricHeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumetricHeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumetricHeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumetricHeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumetricHeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumetricHeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumetricHeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1870 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure (-870)
/* simple XML schema type 'eml22:VolumetricThermalExpansionMeasure': */
class SOAP_CMAC eml22__VolumetricThermalExpansionMeasure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumetricThermalExpansionUom'
        eml22__VolumetricThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumetricThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml22__VolumetricThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumetricThermalExpansionMeasure); }
      public:
        /// Constructor with default initializations
        eml22__VolumetricThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__VolumetricThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml22__VolumetricThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumetricThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml22__VolumetricThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1872 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt (-871)
/* simple XML schema type 'eml22:VolumetricThermalExpansionMeasureExt': */
class SOAP_CMAC eml22__VolumetricThermalExpansionMeasureExt {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:VolumetricThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__VolumetricThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml22__VolumetricThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__VolumetricThermalExpansionMeasureExt); }
      public:
        /// Constructor with default initializations
        eml22__VolumetricThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml22__VolumetricThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml22__VolumetricThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml22__VolumetricThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml22__VolumetricThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1920 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure (-895)
/* simple XML schema type 'eml22:ReferencePressure': */
class SOAP_CMAC eml22__ReferencePressure {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:PressureUom'
        eml22__PressureUom uom;
        /// Optional attribute 'referencePressureKind' of XML schema type 'eml22:ReferencePressureKind'
        eml22__ReferencePressureKind *referencePressureKind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__ReferencePressure, default initialized and not managed by a soap context
        virtual eml22__ReferencePressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__ReferencePressure); }
      public:
        /// Constructor with default initializations
        eml22__ReferencePressure() : __item(), uom(), referencePressureKind(), soap() { }
        virtual ~eml22__ReferencePressure() { }
        /// Friend allocator used by soap_new_eml22__ReferencePressure(struct soap*, int)
        friend SOAP_FMAC1 eml22__ReferencePressure * SOAP_FMAC2 soap_instantiate_eml22__ReferencePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1936 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest
#define SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest (-903)
/* simple XML schema type 'eml22:DistanceEastWest': */
class SOAP_CMAC eml22__DistanceEastWest {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUom'
        eml22__LengthUom uom;
        /// Required attribute 'reference' of XML schema type 'eml22:EastOrWest'
        eml22__EastOrWest reference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DistanceEastWest, default initialized and not managed by a soap context
        virtual eml22__DistanceEastWest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DistanceEastWest); }
      public:
        /// Constructor with default initializations
        eml22__DistanceEastWest() : __item(), uom(), reference(), soap() { }
        virtual ~eml22__DistanceEastWest() { }
        /// Friend allocator used by soap_new_eml22__DistanceEastWest(struct soap*, int)
        friend SOAP_FMAC1 eml22__DistanceEastWest * SOAP_FMAC2 soap_instantiate_eml22__DistanceEastWest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1938 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth
#define SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth (-904)
/* simple XML schema type 'eml22:DistanceNorthSouth': */
class SOAP_CMAC eml22__DistanceNorthSouth {
      public:
        /// Simple content of XML schema type 'eml22:AbstractMeasure' wrapped by this struct
        double __item;
        /// Required attribute 'uom' of XML schema type 'eml22:LengthUom'
        eml22__LengthUom uom;
        /// Required attribute 'reference' of XML schema type 'eml22:NorthOrSouth'
        eml22__NorthOrSouth reference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DistanceNorthSouth, default initialized and not managed by a soap context
        virtual eml22__DistanceNorthSouth *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DistanceNorthSouth); }
      public:
        /// Constructor with default initializations
        eml22__DistanceNorthSouth() : __item(), uom(), reference(), soap() { }
        virtual ~eml22__DistanceNorthSouth() { }
        /// Friend allocator used by soap_new_eml22__DistanceNorthSouth(struct soap*, int)
        friend SOAP_FMAC1 eml22__DistanceNorthSouth * SOAP_FMAC2 soap_instantiate_eml22__DistanceNorthSouth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:168 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel (-19)
/* complex XML schema type 'prodml21:AbstractCorrelationViscosityDeadModel': */
class SOAP_CMAC prodml21__AbstractCorrelationViscosityDeadModel : public prodml21__AbstractCorrelationViscosityModel {
      public:
        /// Optional element 'prodml21:DeadOilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *DeadOilViscosity;
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationViscosityDeadModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationViscosityDeadModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationViscosityDeadModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationViscosityDeadModel() : DeadOilViscosity(), ReservoirTemperature() { }
        virtual ~prodml21__AbstractCorrelationViscosityDeadModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationViscosityDeadModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationViscosityDeadModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationViscosityDeadModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:176 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel (-23)
/* complex XML schema type 'prodml21:AbstractCorrelationGasViscosityModel': */
class SOAP_CMAC prodml21__AbstractCorrelationGasViscosityModel : public prodml21__AbstractCorrelationViscosityModel {
      public:
        /// Optional element 'prodml21:GasViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosity;
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationGasViscosityModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationGasViscosityModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationGasViscosityModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationGasViscosityModel() : GasViscosity(), ReservoirTemperature() { }
        virtual ~prodml21__AbstractCorrelationGasViscosityModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationGasViscosityModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationGasViscosityModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationGasViscosityModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:178 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel (-24)
/* complex XML schema type 'prodml21:AbstractCorrelationViscosityBubblePointModel': */
class SOAP_CMAC prodml21__AbstractCorrelationViscosityBubblePointModel : public prodml21__AbstractCorrelationViscosityModel {
      public:
        /// Optional element 'prodml21:DeadOilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *DeadOilViscosity;
        /// Optional element 'prodml21:BubblePointOilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *BubblePointOilViscosity;
        /// Optional element 'prodml21:SolutionGasOilRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGasOilRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationViscosityBubblePointModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationViscosityBubblePointModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationViscosityBubblePointModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationViscosityBubblePointModel() : DeadOilViscosity(), BubblePointOilViscosity(), SolutionGasOilRatio() { }
        virtual ~prodml21__AbstractCorrelationViscosityBubblePointModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationViscosityBubblePointModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationViscosityBubblePointModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationViscosityBubblePointModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:182 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel (-26)
/* complex XML schema type 'prodml21:AbstractCorrelationViscosityUndersaturatedModel': */
class SOAP_CMAC prodml21__AbstractCorrelationViscosityUndersaturatedModel : public prodml21__AbstractCorrelationViscosityModel {
      public:
        /// Optional element 'prodml21:UndersaturatedOilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *UndersaturatedOilViscosity;
        /// Optional element 'prodml21:BubblePointOilViscosity' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *BubblePointOilViscosity;
        /// Optional element 'prodml21:BubblePointPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *BubblePointPressure;
        /// Optional element 'prodml21:Pressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__AbstractCorrelationViscosityUndersaturatedModel, default initialized and not managed by a soap context
        virtual prodml21__AbstractCorrelationViscosityUndersaturatedModel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__AbstractCorrelationViscosityUndersaturatedModel); }
      public:
        /// Constructor with default initializations
        prodml21__AbstractCorrelationViscosityUndersaturatedModel() : UndersaturatedOilViscosity(), BubblePointOilViscosity(), BubblePointPressure(), Pressure() { }
        virtual ~prodml21__AbstractCorrelationViscosityUndersaturatedModel() { }
        /// Friend allocator used by soap_new_prodml21__AbstractCorrelationViscosityUndersaturatedModel(struct soap*, int)
        friend SOAP_FMAC1 prodml21__AbstractCorrelationViscosityUndersaturatedModel * SOAP_FMAC2 soap_instantiate_prodml21__AbstractCorrelationViscosityUndersaturatedModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:206 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84 (-38)
/* complex XML schema type 'prodml21:CSPedersen84': */
class SOAP_CMAC prodml21__CSPedersen84 : public prodml21__AbstractCompositionalViscosityModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CSPedersen84, default initialized and not managed by a soap context
        virtual prodml21__CSPedersen84 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CSPedersen84); }
      public:
        /// Constructor with default initializations
        prodml21__CSPedersen84() { }
        virtual ~prodml21__CSPedersen84() { }
        /// Friend allocator used by soap_new_prodml21__CSPedersen84(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CSPedersen84 * SOAP_FMAC2 soap_instantiate_prodml21__CSPedersen84(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:208 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87 (-39)
/* complex XML schema type 'prodml21:CSPedersen87': */
class SOAP_CMAC prodml21__CSPedersen87 : public prodml21__AbstractCompositionalViscosityModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CSPedersen87, default initialized and not managed by a soap context
        virtual prodml21__CSPedersen87 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CSPedersen87); }
      public:
        /// Constructor with default initializations
        prodml21__CSPedersen87() { }
        virtual ~prodml21__CSPedersen87() { }
        /// Friend allocator used by soap_new_prodml21__CSPedersen87(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CSPedersen87 * SOAP_FMAC2 soap_instantiate_prodml21__CSPedersen87(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:246 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory (-58)
/* complex XML schema type 'prodml21:FrictionTheory': */
class SOAP_CMAC prodml21__FrictionTheory : public prodml21__AbstractCompositionalViscosityModel {
      public:
        /// Optional element 'prodml21:PrsvParameter' of XML schema type 'prodml21:PrsvParameter'
        std::vector<prodml21__PrsvParameter *> PrsvParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__FrictionTheory, default initialized and not managed by a soap context
        virtual prodml21__FrictionTheory *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__FrictionTheory); }
      public:
        /// Constructor with default initializations
        prodml21__FrictionTheory() : PrsvParameter() { }
        virtual ~prodml21__FrictionTheory() { }
        /// Friend allocator used by soap_new_prodml21__FrictionTheory(struct soap*, int)
        friend SOAP_FMAC1 prodml21__FrictionTheory * SOAP_FMAC2 soap_instantiate_prodml21__FrictionTheory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:250 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation (-60)
/* complex XML schema type 'prodml21:Lohrenz-Bray-ClarkCorrelation': */
class SOAP_CMAC prodml21__Lohrenz_Bray_ClarkCorrelation : public prodml21__AbstractCompositionalViscosityModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Lohrenz_Bray_ClarkCorrelation, default initialized and not managed by a soap context
        virtual prodml21__Lohrenz_Bray_ClarkCorrelation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Lohrenz_Bray_ClarkCorrelation); }
      public:
        /// Constructor with default initializations
        prodml21__Lohrenz_Bray_ClarkCorrelation() { }
        virtual ~prodml21__Lohrenz_Bray_ClarkCorrelation() { }
        /// Friend allocator used by soap_new_prodml21__Lohrenz_Bray_ClarkCorrelation(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Lohrenz_Bray_ClarkCorrelation * SOAP_FMAC2 soap_instantiate_prodml21__Lohrenz_Bray_ClarkCorrelation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:256 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS (-63)
/* complex XML schema type 'prodml21:PengRobinson76_EOS': */
class SOAP_CMAC prodml21__PengRobinson76_USCOREEOS : public prodml21__AbstractCompositionalEoSModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PengRobinson76_USCOREEOS, default initialized and not managed by a soap context
        virtual prodml21__PengRobinson76_USCOREEOS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PengRobinson76_USCOREEOS); }
      public:
        /// Constructor with default initializations
        prodml21__PengRobinson76_USCOREEOS() { }
        virtual ~prodml21__PengRobinson76_USCOREEOS() { }
        /// Friend allocator used by soap_new_prodml21__PengRobinson76_USCOREEOS(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PengRobinson76_USCOREEOS * SOAP_FMAC2 soap_instantiate_prodml21__PengRobinson76_USCOREEOS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:258 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS (-64)
/* complex XML schema type 'prodml21:PengRobinson78_EOS': */
class SOAP_CMAC prodml21__PengRobinson78_USCOREEOS : public prodml21__AbstractCompositionalEoSModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PengRobinson78_USCOREEOS, default initialized and not managed by a soap context
        virtual prodml21__PengRobinson78_USCOREEOS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PengRobinson78_USCOREEOS); }
      public:
        /// Constructor with default initializations
        prodml21__PengRobinson78_USCOREEOS() { }
        virtual ~prodml21__PengRobinson78_USCOREEOS() { }
        /// Friend allocator used by soap_new_prodml21__PengRobinson78_USCOREEOS(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PengRobinson78_USCOREEOS * SOAP_FMAC2 soap_instantiate_prodml21__PengRobinson78_USCOREEOS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:274 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS (-72)
/* complex XML schema type 'prodml21:Srk_EOS': */
class SOAP_CMAC prodml21__Srk_USCOREEOS : public prodml21__AbstractCompositionalEoSModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Srk_USCOREEOS, default initialized and not managed by a soap context
        virtual prodml21__Srk_USCOREEOS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Srk_USCOREEOS); }
      public:
        /// Constructor with default initializations
        prodml21__Srk_USCOREEOS() { }
        virtual ~prodml21__Srk_USCOREEOS() { }
        /// Friend allocator used by soap_new_prodml21__Srk_USCOREEOS(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Srk_USCOREEOS * SOAP_FMAC2 soap_instantiate_prodml21__Srk_USCOREEOS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:294 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct (-82)
/* simple XML schema type 'prodml21:EmailQualifierStruct': */
class SOAP_CMAC prodml21__EmailQualifierStruct {
      public:
        /// Simple content of XML schema type 'eml22:String64' wrapped by this struct
        std::string __item;
        /// Optional attribute 'qualifier' of XML schema type 'prodml21:AddressQualifier'
        prodml21__AddressQualifier *qualifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__EmailQualifierStruct, default initialized and not managed by a soap context
        virtual prodml21__EmailQualifierStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__EmailQualifierStruct); }
      public:
        /// Constructor with default initializations
        prodml21__EmailQualifierStruct() : __item(), qualifier(), soap() { }
        virtual ~prodml21__EmailQualifierStruct() { }
        /// Friend allocator used by soap_new_prodml21__EmailQualifierStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__EmailQualifierStruct * SOAP_FMAC2 soap_instantiate_prodml21__EmailQualifierStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:332 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct (-101)
/* simple XML schema type 'prodml21:NameStruct': */
class SOAP_CMAC prodml21__NameStruct {
      public:
        /// Simple content of XML schema type 'eml22:String64' wrapped by this struct
        std::string __item;
        /// Optional attribute 'authority' of XML schema type 'eml22:String64'
        std::string *authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__NameStruct, default initialized and not managed by a soap context
        virtual prodml21__NameStruct *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__NameStruct); }
      public:
        /// Constructor with default initializations
        prodml21__NameStruct() : __item(), authority(), soap() { }
        virtual ~prodml21__NameStruct() { }
        /// Friend allocator used by soap_new_prodml21__NameStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml21__NameStruct * SOAP_FMAC2 soap_instantiate_prodml21__NameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:518 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility (-194)
/* simple XML schema type 'prodml21:OilCompressibility': */
class SOAP_CMAC prodml21__OilCompressibility : public eml22__ReciprocalPressureMeasure {
      public:
        /// Required attribute 'kind' of XML schema type 'prodml21:CompressibilityKind'
        prodml21__CompressibilityKind kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__OilCompressibility, default initialized and not managed by a soap context
        virtual prodml21__OilCompressibility *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__OilCompressibility); }
      public:
        /// Constructor with default initializations
        prodml21__OilCompressibility() : kind() { }
        virtual ~prodml21__OilCompressibility() { }
        /// Friend allocator used by soap_new_prodml21__OilCompressibility(struct soap*, int)
        friend SOAP_FMAC1 prodml21__OilCompressibility * SOAP_FMAC2 soap_instantiate_prodml21__OilCompressibility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:536 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded (-203)
/* simple XML schema type 'prodml21:RefInjectedGasAdded': */
class SOAP_CMAC prodml21__RefInjectedGasAdded : public eml22__AmountOfSubstancePerAmountOfSubstanceMeasure {
      public:
        /// Required attribute 'injectionGasReference' of XML schema type 'eml22:String64'
        std::string injectionGasReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RefInjectedGasAdded, default initialized and not managed by a soap context
        virtual prodml21__RefInjectedGasAdded *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RefInjectedGasAdded); }
      public:
        /// Constructor with default initializations
        prodml21__RefInjectedGasAdded() : injectionGasReference() { }
        virtual ~prodml21__RefInjectedGasAdded() { }
        /// Friend allocator used by soap_new_prodml21__RefInjectedGasAdded(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RefInjectedGasAdded * SOAP_FMAC2 soap_instantiate_prodml21__RefInjectedGasAdded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:538 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio (-204)
/* simple XML schema type 'prodml21:RelativeVolumeRatio': */
class SOAP_CMAC prodml21__RelativeVolumeRatio : public eml22__VolumePerVolumeMeasure {
      public:
        /// Required attribute 'fluidVolumeReference' of XML schema type 'eml22:String64'
        std::string fluidVolumeReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__RelativeVolumeRatio, default initialized and not managed by a soap context
        virtual prodml21__RelativeVolumeRatio *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__RelativeVolumeRatio); }
      public:
        /// Constructor with default initializations
        prodml21__RelativeVolumeRatio() : fluidVolumeReference() { }
        virtual ~prodml21__RelativeVolumeRatio() { }
        /// Friend allocator used by soap_new_prodml21__RelativeVolumeRatio(struct soap*, int)
        friend SOAP_FMAC1 prodml21__RelativeVolumeRatio * SOAP_FMAC2 soap_instantiate_prodml21__RelativeVolumeRatio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:550 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure (-210)
/* simple XML schema type 'prodml21:SaturationPressure': */
class SOAP_CMAC prodml21__SaturationPressure : public eml22__PressureMeasureExt {
      public:
        /// Required attribute 'kind' of XML schema type 'prodml21:SaturationPointKind'
        prodml21__SaturationPointKind kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SaturationPressure, default initialized and not managed by a soap context
        virtual prodml21__SaturationPressure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SaturationPressure); }
      public:
        /// Constructor with default initializations
        prodml21__SaturationPressure() : kind() { }
        virtual ~prodml21__SaturationPressure() { }
        /// Friend allocator used by soap_new_prodml21__SaturationPressure(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SaturationPressure * SOAP_FMAC2 soap_instantiate_prodml21__SaturationPressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:552 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature (-211)
/* simple XML schema type 'prodml21:SaturationTemperature': */
class SOAP_CMAC prodml21__SaturationTemperature : public eml22__ThermodynamicTemperatureMeasure {
      public:
        /// Required attribute 'kind' of XML schema type 'prodml21:SaturationPointKind'
        prodml21__SaturationPointKind kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__SaturationTemperature, default initialized and not managed by a soap context
        virtual prodml21__SaturationTemperature *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__SaturationTemperature); }
      public:
        /// Constructor with default initializations
        prodml21__SaturationTemperature() : kind() { }
        virtual ~prodml21__SaturationTemperature() { }
        /// Friend allocator used by soap_new_prodml21__SaturationTemperature(struct soap*, int)
        friend SOAP_FMAC1 prodml21__SaturationTemperature * SOAP_FMAC2 soap_instantiate_prodml21__SaturationTemperature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1088 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName (-479)
/* simple XML schema type 'eml22:AuthorityQualifiedName': */
class SOAP_CMAC eml22__AuthorityQualifiedName {
      public:
        /// Simple content of XML schema type 'eml22:String64' wrapped by this struct
        std::string __item;
        /// Required attribute 'authority' of XML schema type 'eml22:String64'
        std::string authority;
        /// Optional attribute 'code' of XML schema type 'eml22:String64'
        std::string *code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__AuthorityQualifiedName, default initialized and not managed by a soap context
        virtual eml22__AuthorityQualifiedName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__AuthorityQualifiedName); }
      public:
        /// Constructor with default initializations
        eml22__AuthorityQualifiedName() : __item(), authority(), code(), soap() { }
        virtual ~eml22__AuthorityQualifiedName() { }
        /// Friend allocator used by soap_new_eml22__AuthorityQualifiedName(struct soap*, int)
        friend SOAP_FMAC1 eml22__AuthorityQualifiedName * SOAP_FMAC2 soap_instantiate_eml22__AuthorityQualifiedName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1104 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray (-487)
/* complex XML schema type 'eml22:FloatingPointConstantArray': */
class SOAP_CMAC eml22__FloatingPointConstantArray : public eml22__AbstractFloatingPointArray {
      public:
        /// Required element 'eml22:Value' of XML schema type 'xsd:double'
        double Value;
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FloatingPointConstantArray, default initialized and not managed by a soap context
        virtual eml22__FloatingPointConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FloatingPointConstantArray); }
      public:
        /// Constructor with default initializations
        eml22__FloatingPointConstantArray() : Value(), Count() { }
        virtual ~eml22__FloatingPointConstantArray() { }
        /// Friend allocator used by soap_new_eml22__FloatingPointConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__FloatingPointConstantArray * SOAP_FMAC2 soap_instantiate_eml22__FloatingPointConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1106 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray (-488)
/* complex XML schema type 'eml22:FloatingPointExternalArray': */
class SOAP_CMAC eml22__FloatingPointExternalArray : public eml22__AbstractFloatingPointArray {
      public:
        /// Required element 'eml22:Values' of XML schema type 'eml22:ExternalDataset'
        eml22__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FloatingPointExternalArray, default initialized and not managed by a soap context
        virtual eml22__FloatingPointExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FloatingPointExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__FloatingPointExternalArray() : Values() { }
        virtual ~eml22__FloatingPointExternalArray() { }
        /// Friend allocator used by soap_new_eml22__FloatingPointExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__FloatingPointExternalArray * SOAP_FMAC2 soap_instantiate_eml22__FloatingPointExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1108 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray (-489)
/* complex XML schema type 'eml22:FloatingPointLatticeArray': */
class SOAP_CMAC eml22__FloatingPointLatticeArray : public eml22__AbstractFloatingPointArray {
      public:
        /// Required element 'eml22:StartValue' of XML schema type 'xsd:double'
        double StartValue;
        /// Required element 'eml22:Offset' of XML schema type 'eml22:FloatingPointConstantArray'
        std::vector<eml22__FloatingPointConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FloatingPointLatticeArray, default initialized and not managed by a soap context
        virtual eml22__FloatingPointLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FloatingPointLatticeArray); }
      public:
        /// Constructor with default initializations
        eml22__FloatingPointLatticeArray() : StartValue(), Offset() { }
        virtual ~eml22__FloatingPointLatticeArray() { }
        /// Friend allocator used by soap_new_eml22__FloatingPointLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__FloatingPointLatticeArray * SOAP_FMAC2 soap_instantiate_eml22__FloatingPointLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1112 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray (-491)
/* complex XML schema type 'eml22:IntegerArrayFromBooleanMaskArray': */
class SOAP_CMAC eml22__IntegerArrayFromBooleanMaskArray : public eml22__AbstractIntegerArray {
      public:
        /// Required element 'eml22:TotalIndexCount' of XML schema type 'eml22:PositiveLong'
        LONG64 TotalIndexCount;
        /// Required element 'eml22:Mask' of XML schema type 'eml22:AbstractBooleanArray'
        eml22__AbstractBooleanArray *Mask;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerArrayFromBooleanMaskArray, default initialized and not managed by a soap context
        virtual eml22__IntegerArrayFromBooleanMaskArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerArrayFromBooleanMaskArray); }
      public:
        /// Constructor with default initializations
        eml22__IntegerArrayFromBooleanMaskArray() : TotalIndexCount(), Mask() { }
        virtual ~eml22__IntegerArrayFromBooleanMaskArray() { }
        /// Friend allocator used by soap_new_eml22__IntegerArrayFromBooleanMaskArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerArrayFromBooleanMaskArray * SOAP_FMAC2 soap_instantiate_eml22__IntegerArrayFromBooleanMaskArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1114 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray (-492)
/* complex XML schema type 'eml22:IntegerConstantArray': */
class SOAP_CMAC eml22__IntegerConstantArray : public eml22__AbstractIntegerArray {
      public:
        /// Required element 'eml22:Value' of XML schema type 'xsd:long'
        LONG64 Value;
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerConstantArray, default initialized and not managed by a soap context
        virtual eml22__IntegerConstantArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerConstantArray); }
      public:
        /// Constructor with default initializations
        eml22__IntegerConstantArray() : Value(), Count() { }
        virtual ~eml22__IntegerConstantArray() { }
        /// Friend allocator used by soap_new_eml22__IntegerConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerConstantArray * SOAP_FMAC2 soap_instantiate_eml22__IntegerConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1116 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray (-493)
/* complex XML schema type 'eml22:IntegerExternalArray': */
class SOAP_CMAC eml22__IntegerExternalArray : public eml22__AbstractIntegerArray {
      public:
        /// Required element 'eml22:NullValue' of XML schema type 'xsd:long'
        LONG64 NullValue;
        /// Required element 'eml22:Values' of XML schema type 'eml22:ExternalDataset'
        eml22__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerExternalArray, default initialized and not managed by a soap context
        virtual eml22__IntegerExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__IntegerExternalArray() : NullValue(), Values() { }
        virtual ~eml22__IntegerExternalArray() { }
        /// Friend allocator used by soap_new_eml22__IntegerExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerExternalArray * SOAP_FMAC2 soap_instantiate_eml22__IntegerExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1118 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray (-494)
/* complex XML schema type 'eml22:IntegerLatticeArray': */
class SOAP_CMAC eml22__IntegerLatticeArray : public eml22__AbstractIntegerArray {
      public:
        /// Required element 'eml22:StartValue' of XML schema type 'xsd:long'
        LONG64 StartValue;
        /// Required element 'eml22:Offset' of XML schema type 'eml22:IntegerConstantArray'
        std::vector<eml22__IntegerConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerLatticeArray, default initialized and not managed by a soap context
        virtual eml22__IntegerLatticeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerLatticeArray); }
      public:
        /// Constructor with default initializations
        eml22__IntegerLatticeArray() : StartValue(), Offset() { }
        virtual ~eml22__IntegerLatticeArray() { }
        /// Friend allocator used by soap_new_eml22__IntegerLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerLatticeArray * SOAP_FMAC2 soap_instantiate_eml22__IntegerLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1120 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray (-495)
/* complex XML schema type 'eml22:IntegerRangeArray': */
class SOAP_CMAC eml22__IntegerRangeArray : public eml22__AbstractIntegerArray {
      public:
        /// Required element 'eml22:Count' of XML schema type 'eml22:PositiveLong'
        LONG64 Count;
        /// Required element 'eml22:Value' of XML schema type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__IntegerRangeArray, default initialized and not managed by a soap context
        virtual eml22__IntegerRangeArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__IntegerRangeArray); }
      public:
        /// Constructor with default initializations
        eml22__IntegerRangeArray() : Count(), Value() { }
        virtual ~eml22__IntegerRangeArray() { }
        /// Friend allocator used by soap_new_eml22__IntegerRangeArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__IntegerRangeArray * SOAP_FMAC2 soap_instantiate_eml22__IntegerRangeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1132 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure (-501)
/* simple XML schema type 'eml22:StringMeasure': */
class SOAP_CMAC eml22__StringMeasure {
      public:
        /// Simple content of XML schema type 'eml22:String64' wrapped by this struct
        std::string __item;
        /// Optional attribute 'uom' of XML schema type 'eml22:UnitOfMeasureExt'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__StringMeasure, default initialized and not managed by a soap context
        virtual eml22__StringMeasure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__StringMeasure); }
      public:
        /// Constructor with default initializations
        eml22__StringMeasure() : __item(), uom(), soap() { }
        virtual ~eml22__StringMeasure() { }
        /// Friend allocator used by soap_new_eml22__StringMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml22__StringMeasure * SOAP_FMAC2 soap_instantiate_eml22__StringMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:188 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated (-29)
/* complex XML schema type 'prodml21:BerganAndSutton-Undersaturated': */
class SOAP_CMAC prodml21__BerganAndSutton_Undersaturated : public prodml21__AbstractCorrelationViscosityUndersaturatedModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BerganAndSutton_Undersaturated, default initialized and not managed by a soap context
        virtual prodml21__BerganAndSutton_Undersaturated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BerganAndSutton_Undersaturated); }
      public:
        /// Constructor with default initializations
        prodml21__BerganAndSutton_Undersaturated() { }
        virtual ~prodml21__BerganAndSutton_Undersaturated() { }
        /// Friend allocator used by soap_new_prodml21__BerganAndSutton_Undersaturated(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BerganAndSutton_Undersaturated * SOAP_FMAC2 soap_instantiate_prodml21__BerganAndSutton_Undersaturated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:190 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead (-30)
/* complex XML schema type 'prodml21:BerganSutton-Dead': */
class SOAP_CMAC prodml21__BerganSutton_Dead : public prodml21__AbstractCorrelationViscosityDeadModel {
      public:
        /// Optional element 'prodml21:DeadOilViscosityAt100F' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *DeadOilViscosityAt100F;
        /// Optional element 'prodml21:DeadOilViscosityAt210F' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *DeadOilViscosityAt210F;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BerganSutton_Dead, default initialized and not managed by a soap context
        virtual prodml21__BerganSutton_Dead *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BerganSutton_Dead); }
      public:
        /// Constructor with default initializations
        prodml21__BerganSutton_Dead() : DeadOilViscosityAt100F(), DeadOilViscosityAt210F() { }
        virtual ~prodml21__BerganSutton_Dead() { }
        /// Friend allocator used by soap_new_prodml21__BerganSutton_Dead(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BerganSutton_Dead * SOAP_FMAC2 soap_instantiate_prodml21__BerganSutton_Dead(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:192 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint (-31)
/* complex XML schema type 'prodml21:BergmanSutton-BubblePoint': */
class SOAP_CMAC prodml21__BergmanSutton_BubblePoint : public prodml21__AbstractCorrelationViscosityBubblePointModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__BergmanSutton_BubblePoint, default initialized and not managed by a soap context
        virtual prodml21__BergmanSutton_BubblePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__BergmanSutton_BubblePoint); }
      public:
        /// Constructor with default initializations
        prodml21__BergmanSutton_BubblePoint() { }
        virtual ~prodml21__BergmanSutton_BubblePoint() { }
        /// Friend allocator used by soap_new_prodml21__BergmanSutton_BubblePoint(struct soap*, int)
        friend SOAP_FMAC1 prodml21__BergmanSutton_BubblePoint * SOAP_FMAC2 soap_instantiate_prodml21__BergmanSutton_BubblePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:198 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey (-34)
/* complex XML schema type 'prodml21:CarrDempsey': */
class SOAP_CMAC prodml21__CarrDempsey : public prodml21__AbstractCorrelationGasViscosityModel {
      public:
        /// Optional element 'prodml21:GasMolarWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolarWeight;
        /// Optional element 'prodml21:GasViscosityAt1Atm' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosityAt1Atm;
        /// Optional element 'prodml21:PseudoReducedTemperature' of XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure *PseudoReducedTemperature;
        /// Optional element 'prodml21:PseudoReducedPressure' of XML schema type 'eml22:PressurePerPressureMeasure'
        eml22__PressurePerPressureMeasure *PseudoReducedPressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__CarrDempsey, default initialized and not managed by a soap context
        virtual prodml21__CarrDempsey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__CarrDempsey); }
      public:
        /// Constructor with default initializations
        prodml21__CarrDempsey() : GasMolarWeight(), GasViscosityAt1Atm(), PseudoReducedTemperature(), PseudoReducedPressure() { }
        virtual ~prodml21__CarrDempsey() { }
        /// Friend allocator used by soap_new_prodml21__CarrDempsey(struct soap*, int)
        friend SOAP_FMAC1 prodml21__CarrDempsey * SOAP_FMAC2 soap_instantiate_prodml21__CarrDempsey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:214 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint (-42)
/* complex XML schema type 'prodml21:DeGhetto-BubblePoint': */
class SOAP_CMAC prodml21__DeGhetto_BubblePoint : public prodml21__AbstractCorrelationViscosityBubblePointModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeGhetto_BubblePoint, default initialized and not managed by a soap context
        virtual prodml21__DeGhetto_BubblePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeGhetto_BubblePoint); }
      public:
        /// Constructor with default initializations
        prodml21__DeGhetto_BubblePoint() { }
        virtual ~prodml21__DeGhetto_BubblePoint() { }
        /// Friend allocator used by soap_new_prodml21__DeGhetto_BubblePoint(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeGhetto_BubblePoint * SOAP_FMAC2 soap_instantiate_prodml21__DeGhetto_BubblePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:216 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead (-43)
/* complex XML schema type 'prodml21:DeGhetto-Dead': */
class SOAP_CMAC prodml21__DeGhetto_Dead : public prodml21__AbstractCorrelationViscosityDeadModel {
      public:
        /// Optional element 'prodml21:OilAPIAtStockTank' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilAPIAtStockTank;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeGhetto_Dead, default initialized and not managed by a soap context
        virtual prodml21__DeGhetto_Dead *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeGhetto_Dead); }
      public:
        /// Constructor with default initializations
        prodml21__DeGhetto_Dead() : OilAPIAtStockTank() { }
        virtual ~prodml21__DeGhetto_Dead() { }
        /// Friend allocator used by soap_new_prodml21__DeGhetto_Dead(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeGhetto_Dead * SOAP_FMAC2 soap_instantiate_prodml21__DeGhetto_Dead(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:218 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated (-44)
/* complex XML schema type 'prodml21:DeGhetto-Undersaturated': */
class SOAP_CMAC prodml21__DeGhetto_Undersaturated : public prodml21__AbstractCorrelationViscosityUndersaturatedModel {
      public:
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
        /// Optional element 'prodml21:SolutionGasOilRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGasOilRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DeGhetto_Undersaturated, default initialized and not managed by a soap context
        virtual prodml21__DeGhetto_Undersaturated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DeGhetto_Undersaturated); }
      public:
        /// Constructor with default initializations
        prodml21__DeGhetto_Undersaturated() : ReservoirTemperature(), SolutionGasOilRatio() { }
        virtual ~prodml21__DeGhetto_Undersaturated() { }
        /// Friend allocator used by soap_new_prodml21__DeGhetto_Undersaturated(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DeGhetto_Undersaturated * SOAP_FMAC2 soap_instantiate_prodml21__DeGhetto_Undersaturated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:220 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint (-45)
/* complex XML schema type 'prodml21:DindorukChristman-BubblePoint': */
class SOAP_CMAC prodml21__DindorukChristman_BubblePoint : public prodml21__AbstractCorrelationViscosityBubblePointModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DindorukChristman_BubblePoint, default initialized and not managed by a soap context
        virtual prodml21__DindorukChristman_BubblePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DindorukChristman_BubblePoint); }
      public:
        /// Constructor with default initializations
        prodml21__DindorukChristman_BubblePoint() { }
        virtual ~prodml21__DindorukChristman_BubblePoint() { }
        /// Friend allocator used by soap_new_prodml21__DindorukChristman_BubblePoint(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DindorukChristman_BubblePoint * SOAP_FMAC2 soap_instantiate_prodml21__DindorukChristman_BubblePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:222 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead (-46)
/* complex XML schema type 'prodml21:DindorukChristman-Dead': */
class SOAP_CMAC prodml21__DindorukChristman_Dead : public prodml21__AbstractCorrelationViscosityDeadModel {
      public:
        /// Optional element 'prodml21:OilGravityAtStockTank' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilGravityAtStockTank;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DindorukChristman_Dead, default initialized and not managed by a soap context
        virtual prodml21__DindorukChristman_Dead *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DindorukChristman_Dead); }
      public:
        /// Constructor with default initializations
        prodml21__DindorukChristman_Dead() : OilGravityAtStockTank() { }
        virtual ~prodml21__DindorukChristman_Dead() { }
        /// Friend allocator used by soap_new_prodml21__DindorukChristman_Dead(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DindorukChristman_Dead * SOAP_FMAC2 soap_instantiate_prodml21__DindorukChristman_Dead(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:224 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated (-47)
/* complex XML schema type 'prodml21:DindorukChristman-Undersaturated': */
class SOAP_CMAC prodml21__DindorukChristman_Undersaturated : public prodml21__AbstractCorrelationViscosityUndersaturatedModel {
      public:
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
        /// Optional element 'prodml21:SolutionGasOilRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGasOilRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__DindorukChristman_Undersaturated, default initialized and not managed by a soap context
        virtual prodml21__DindorukChristman_Undersaturated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__DindorukChristman_Undersaturated); }
      public:
        /// Constructor with default initializations
        prodml21__DindorukChristman_Undersaturated() : ReservoirTemperature(), SolutionGasOilRatio() { }
        virtual ~prodml21__DindorukChristman_Undersaturated() { }
        /// Friend allocator used by soap_new_prodml21__DindorukChristman_Undersaturated(struct soap*, int)
        friend SOAP_FMAC1 prodml21__DindorukChristman_Undersaturated * SOAP_FMAC2 soap_instantiate_prodml21__DindorukChristman_Undersaturated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:248 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez (-59)
/* complex XML schema type 'prodml21:LeeGonzalez': */
class SOAP_CMAC prodml21__LeeGonzalez : public prodml21__AbstractCorrelationGasViscosityModel {
      public:
        /// Optional element 'prodml21:GasMolarWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolarWeight;
        /// Optional element 'prodml21:GasDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasDensity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LeeGonzalez, default initialized and not managed by a soap context
        virtual prodml21__LeeGonzalez *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LeeGonzalez); }
      public:
        /// Constructor with default initializations
        prodml21__LeeGonzalez() : GasMolarWeight(), GasDensity() { }
        virtual ~prodml21__LeeGonzalez() { }
        /// Friend allocator used by soap_new_prodml21__LeeGonzalez(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LeeGonzalez * SOAP_FMAC2 soap_instantiate_prodml21__LeeGonzalez(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:252 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame (-61)
/* complex XML schema type 'prodml21:LondonoArcherBlasinggame': */
class SOAP_CMAC prodml21__LondonoArcherBlasinggame : public prodml21__AbstractCorrelationGasViscosityModel {
      public:
        /// Optional element 'prodml21:GasDensity' of XML schema type 'eml22:MassPerVolumeMeasure'
        eml22__MassPerVolumeMeasure *GasDensity;
        /// Optional element 'prodml21:GasViscosityAt1Atm' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosityAt1Atm;
        /// Optional element 'prodml21:GasViscosityCoefficient1Atm' of XML schema type 'prodml21:PvtModelParameter'
        std::vector<prodml21__PvtModelParameter *> GasViscosityCoefficient1Atm;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__LondonoArcherBlasinggame, default initialized and not managed by a soap context
        virtual prodml21__LondonoArcherBlasinggame *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__LondonoArcherBlasinggame); }
      public:
        /// Constructor with default initializations
        prodml21__LondonoArcherBlasinggame() : GasDensity(), GasViscosityAt1Atm(), GasViscosityCoefficient1Atm() { }
        virtual ~prodml21__LondonoArcherBlasinggame() { }
        /// Friend allocator used by soap_new_prodml21__LondonoArcherBlasinggame(struct soap*, int)
        friend SOAP_FMAC1 prodml21__LondonoArcherBlasinggame * SOAP_FMAC2 soap_instantiate_prodml21__LondonoArcherBlasinggame(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:254 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas (-62)
/* complex XML schema type 'prodml21:Lucas': */
class SOAP_CMAC prodml21__Lucas : public prodml21__AbstractCorrelationGasViscosityModel {
      public:
        /// Optional element 'prodml21:GasMolarWeight' of XML schema type 'eml22:MolecularWeightMeasure'
        eml22__MolecularWeightMeasure *GasMolarWeight;
        /// Optional element 'prodml21:GasViscosityAt1Atm' of XML schema type 'eml22:DynamicViscosityMeasure'
        eml22__DynamicViscosityMeasure *GasViscosityAt1Atm;
        /// Optional element 'prodml21:PseudoCriticalTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *PseudoCriticalTemperature;
        /// Optional element 'prodml21:PseudoCriticalPressure' of XML schema type 'eml22:PressureMeasure'
        eml22__PressureMeasure *PseudoCriticalPressure;
        /// Optional element 'prodml21:PseudoReducedTemperature' of XML schema type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure *PseudoReducedTemperature;
        /// Optional element 'prodml21:PseudoReducedPressure' of XML schema type 'eml22:PressurePerPressureMeasure'
        eml22__PressurePerPressureMeasure *PseudoReducedPressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Lucas, default initialized and not managed by a soap context
        virtual prodml21__Lucas *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Lucas); }
      public:
        /// Constructor with default initializations
        prodml21__Lucas() : GasMolarWeight(), GasViscosityAt1Atm(), PseudoCriticalTemperature(), PseudoCriticalPressure(), PseudoReducedTemperature(), PseudoReducedPressure() { }
        virtual ~prodml21__Lucas() { }
        /// Friend allocator used by soap_new_prodml21__Lucas(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Lucas * SOAP_FMAC2 soap_instantiate_prodml21__Lucas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:260 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint (-65)
/* complex XML schema type 'prodml21:PetroskyFarshad-BubblePoint': */
class SOAP_CMAC prodml21__PetroskyFarshad_BubblePoint : public prodml21__AbstractCorrelationViscosityBubblePointModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PetroskyFarshad_BubblePoint, default initialized and not managed by a soap context
        virtual prodml21__PetroskyFarshad_BubblePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PetroskyFarshad_BubblePoint); }
      public:
        /// Constructor with default initializations
        prodml21__PetroskyFarshad_BubblePoint() { }
        virtual ~prodml21__PetroskyFarshad_BubblePoint() { }
        /// Friend allocator used by soap_new_prodml21__PetroskyFarshad_BubblePoint(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PetroskyFarshad_BubblePoint * SOAP_FMAC2 soap_instantiate_prodml21__PetroskyFarshad_BubblePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:262 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead (-66)
/* complex XML schema type 'prodml21:PetroskyFarshad-Dead': */
class SOAP_CMAC prodml21__PetroskyFarshad_Dead : public prodml21__AbstractCorrelationViscosityDeadModel {
      public:
        /// Optional element 'prodml21:OilGravityAtStockTank' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilGravityAtStockTank;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PetroskyFarshad_Dead, default initialized and not managed by a soap context
        virtual prodml21__PetroskyFarshad_Dead *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PetroskyFarshad_Dead); }
      public:
        /// Constructor with default initializations
        prodml21__PetroskyFarshad_Dead() : OilGravityAtStockTank() { }
        virtual ~prodml21__PetroskyFarshad_Dead() { }
        /// Friend allocator used by soap_new_prodml21__PetroskyFarshad_Dead(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PetroskyFarshad_Dead * SOAP_FMAC2 soap_instantiate_prodml21__PetroskyFarshad_Dead(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:264 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated (-67)
/* complex XML schema type 'prodml21:PetroskyFarshad-Undersaturated': */
class SOAP_CMAC prodml21__PetroskyFarshad_Undersaturated : public prodml21__AbstractCorrelationViscosityUndersaturatedModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__PetroskyFarshad_Undersaturated, default initialized and not managed by a soap context
        virtual prodml21__PetroskyFarshad_Undersaturated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__PetroskyFarshad_Undersaturated); }
      public:
        /// Constructor with default initializations
        prodml21__PetroskyFarshad_Undersaturated() { }
        virtual ~prodml21__PetroskyFarshad_Undersaturated() { }
        /// Friend allocator used by soap_new_prodml21__PetroskyFarshad_Undersaturated(struct soap*, int)
        friend SOAP_FMAC1 prodml21__PetroskyFarshad_Undersaturated * SOAP_FMAC2 soap_instantiate_prodml21__PetroskyFarshad_Undersaturated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:276 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint (-73)
/* complex XML schema type 'prodml21:Standing-BubblePoint': */
class SOAP_CMAC prodml21__Standing_BubblePoint : public prodml21__AbstractCorrelationViscosityBubblePointModel {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Standing_BubblePoint, default initialized and not managed by a soap context
        virtual prodml21__Standing_BubblePoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Standing_BubblePoint); }
      public:
        /// Constructor with default initializations
        prodml21__Standing_BubblePoint() { }
        virtual ~prodml21__Standing_BubblePoint() { }
        /// Friend allocator used by soap_new_prodml21__Standing_BubblePoint(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Standing_BubblePoint * SOAP_FMAC2 soap_instantiate_prodml21__Standing_BubblePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:278 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead (-74)
/* complex XML schema type 'prodml21:Standing-Dead': */
class SOAP_CMAC prodml21__Standing_Dead : public prodml21__AbstractCorrelationViscosityDeadModel {
      public:
        /// Optional element 'prodml21:OilGravityAtStockTank' of XML schema type 'eml22:APIGravityMeasure'
        eml22__APIGravityMeasure *OilGravityAtStockTank;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Standing_Dead, default initialized and not managed by a soap context
        virtual prodml21__Standing_Dead *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Standing_Dead); }
      public:
        /// Constructor with default initializations
        prodml21__Standing_Dead() : OilGravityAtStockTank() { }
        virtual ~prodml21__Standing_Dead() { }
        /// Friend allocator used by soap_new_prodml21__Standing_Dead(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Standing_Dead * SOAP_FMAC2 soap_instantiate_prodml21__Standing_Dead(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:280 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated (-75)
/* complex XML schema type 'prodml21:Standing-Undersaturated': */
class SOAP_CMAC prodml21__Standing_Undersaturated : public prodml21__AbstractCorrelationViscosityUndersaturatedModel {
      public:
        /// Optional element 'prodml21:ReservoirTemperature' of XML schema type 'eml22:ThermodynamicTemperatureMeasure'
        eml22__ThermodynamicTemperatureMeasure *ReservoirTemperature;
        /// Optional element 'prodml21:SolutionGasOilRatio' of XML schema type 'eml22:VolumePerVolumeMeasure'
        eml22__VolumePerVolumeMeasure *SolutionGasOilRatio;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml21__Standing_Undersaturated, default initialized and not managed by a soap context
        virtual prodml21__Standing_Undersaturated *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(prodml21__Standing_Undersaturated); }
      public:
        /// Constructor with default initializations
        prodml21__Standing_Undersaturated() : ReservoirTemperature(), SolutionGasOilRatio() { }
        virtual ~prodml21__Standing_Undersaturated() { }
        /// Friend allocator used by soap_new_prodml21__Standing_Undersaturated(struct soap*, int)
        friend SOAP_FMAC1 prodml21__Standing_Undersaturated * SOAP_FMAC2 soap_instantiate_prodml21__Standing_Undersaturated(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1098 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray (-484)
/* complex XML schema type 'eml22:DoubleExternalArray': */
class SOAP_CMAC eml22__DoubleExternalArray : public eml22__FloatingPointExternalArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__DoubleExternalArray, default initialized and not managed by a soap context
        virtual eml22__DoubleExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__DoubleExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__DoubleExternalArray() { }
        virtual ~eml22__DoubleExternalArray() { }
        /// Friend allocator used by soap_new_eml22__DoubleExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__DoubleExternalArray * SOAP_FMAC2 soap_instantiate_eml22__DoubleExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:1102 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray (-486)
/* complex XML schema type 'eml22:FloatExternalArray': */
class SOAP_CMAC eml22__FloatExternalArray : public eml22__FloatingPointExternalArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray
        virtual long soap_type(void) const { return SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml22__FloatExternalArray, default initialized and not managed by a soap context
        virtual eml22__FloatExternalArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(eml22__FloatExternalArray); }
      public:
        /// Constructor with default initializations
        eml22__FloatExternalArray() { }
        virtual ~eml22__FloatExternalArray() { }
        /// Friend allocator used by soap_new_eml22__FloatExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml22__FloatExternalArray * SOAP_FMAC2 soap_instantiate_eml22__FloatExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_2ForGsoap.h:59307 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header (-845619200)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_2ForGsoap.h:59307 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code (-845619201)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_2ForGsoap.h:59307 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail (-845619203)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_2ForGsoap.h:59307 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason (-845619206)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_2ForGsoap.h:59307 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault (-845619207)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_2__XML
#define SOAP_TYPE_gsoap_eml2_2__XML (-5)

typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_2__QName
#define SOAP_TYPE_gsoap_eml2_2__QName (-6)

typedef char *_QName;
#endif

/* eml2_2ForGsoap.h:145 */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__integer
#define SOAP_TYPE_gsoap_eml2_2_xsd__integer (-11)

typedef LONG64 xsd__integer;
#endif

/* eml2_2ForGsoap.h:148 */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_2_xsd__nonNegativeInteger (-13)

typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* eml2_2ForGsoap.h:151 */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_2_xsd__anyURI (-15)

typedef std::string xsd__anyURI;
#endif

/* eml2_2ForGsoap.h:154 */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__date
#define SOAP_TYPE_gsoap_eml2_2_xsd__date (-16)

typedef std::string xsd__date;
#endif

/* eml2_2ForGsoap.h:1999 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidPropertyExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidPropertyExt (-930)

typedef std::string prodml21__OutputFluidPropertyExt;
#endif

/* eml2_2ForGsoap.h:2002 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKindExt (-931)

typedef std::string prodml21__PvtModelParameterKindExt;
#endif

/* eml2_2ForGsoap.h:2005 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityKindExt (-932)

typedef std::string prodml21__FacilityKindExt;
#endif

/* eml2_2ForGsoap.h:2008 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnumExt (-933)

typedef std::string prodml21__PlusComponentEnumExt;
#endif

/* eml2_2ForGsoap.h:2011 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnumExt (-934)

typedef std::string prodml21__PseudoComponentEnumExt;
#endif

/* eml2_2ForGsoap.h:2014 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnumExt (-935)

typedef std::string prodml21__PureComponentEnumExt;
#endif

/* eml2_2ForGsoap.h:2017 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKindExt (-936)

typedef std::string prodml21__ReportingDurationKindExt;
#endif

/* eml2_2ForGsoap.h:2020 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacilityExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacilityExt (-937)

typedef std::string prodml21__ReportingFacilityExt;
#endif

/* eml2_2ForGsoap.h:2023 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKindExt (-938)

typedef std::string prodml21__DispositionKindExt;
#endif

/* eml2_2ForGsoap.h:2026 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethodExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethodExt (-939)

typedef std::string prodml21__EstimationMethodExt;
#endif

/* eml2_2ForGsoap.h:2029 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKindExt (-940)

typedef std::string prodml21__ProductFluidKindExt;
#endif

/* eml2_2ForGsoap.h:2032 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethodExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethodExt (-941)

typedef std::string prodml21__QuantityMethodExt;
#endif

/* eml2_2ForGsoap.h:2035 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKindExt (-942)

typedef std::string prodml21__ServiceFluidKindExt;
#endif

/* eml2_2ForGsoap.h:2038 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioningExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioningExt (-943)

typedef std::string prodml21__DataConditioningExt;
#endif

/* eml2_2ForGsoap.h:2049 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FacetExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FacetExt (-944)

typedef std::string eml22__FacetExt;
#endif

/* eml2_2ForGsoap.h:2052 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKindExt (-945)

typedef std::string eml22__LithologyKindExt;
#endif

/* eml2_2ForGsoap.h:2055 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKindExt (-946)

typedef std::string eml22__LithologyQualifierKindExt;
#endif

/* eml2_2ForGsoap.h:2058 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKindExt (-947)

typedef std::string eml22__QuantityClassKindExt;
#endif

/* eml2_2ForGsoap.h:2061 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceConditionExt (-948)

typedef std::string eml22__ReferenceConditionExt;
#endif

/* eml2_2ForGsoap.h:2064 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasureExt (-949)

typedef std::string eml22__UnitOfMeasureExt;
#endif

/* eml2_2ForGsoap.h:2067 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUomExt (-950)

typedef std::string eml22__AbsorbedDoseUomExt;
#endif

/* eml2_2ForGsoap.h:2070 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUomExt (-951)

typedef std::string eml22__ActivityOfRadioactivityUomExt;
#endif

/* eml2_2ForGsoap.h:2073 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUomExt (-952)

typedef std::string eml22__AmountOfSubstancePerAmountOfSubstanceUomExt;
#endif

/* eml2_2ForGsoap.h:2076 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUomExt (-953)

typedef std::string eml22__AmountOfSubstancePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2079 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUomExt (-954)

typedef std::string eml22__AmountOfSubstancePerTimePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2082 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUomExt (-955)

typedef std::string eml22__AmountOfSubstancePerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2085 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUomExt (-956)

typedef std::string eml22__AmountOfSubstancePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2088 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUomExt (-957)

typedef std::string eml22__AmountOfSubstanceUomExt;
#endif

/* eml2_2ForGsoap.h:2091 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUomExt (-958)

typedef std::string eml22__AnglePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2094 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUomExt (-959)

typedef std::string eml22__AnglePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2097 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUomExt (-960)

typedef std::string eml22__AngularAccelerationUomExt;
#endif

/* eml2_2ForGsoap.h:2100 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUomExt (-961)

typedef std::string eml22__AngularVelocityUomExt;
#endif

/* eml2_2ForGsoap.h:2103 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUomExt (-962)

typedef std::string eml22__APIGammaRayUomExt;
#endif

/* eml2_2ForGsoap.h:2106 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUomExt (-963)

typedef std::string eml22__APIGravityUomExt;
#endif

/* eml2_2ForGsoap.h:2109 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUomExt (-964)

typedef std::string eml22__APINeutronUomExt;
#endif

/* eml2_2ForGsoap.h:2112 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUomExt (-965)

typedef std::string eml22__AreaPerAmountOfSubstanceUomExt;
#endif

/* eml2_2ForGsoap.h:2115 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUomExt (-966)

typedef std::string eml22__AreaPerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2118 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUomExt (-967)

typedef std::string eml22__AreaPerCountUomExt;
#endif

/* eml2_2ForGsoap.h:2121 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUomExt (-968)

typedef std::string eml22__AreaPerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2124 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUomExt (-969)

typedef std::string eml22__AreaPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2127 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUomExt (-970)

typedef std::string eml22__AreaPerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2130 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaUomExt (-971)

typedef std::string eml22__AreaUomExt;
#endif

/* eml2_2ForGsoap.h:2133 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUomExt (-972)

typedef std::string eml22__AttenuationPerFrequencyIntervalUomExt;
#endif

/* eml2_2ForGsoap.h:2136 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUomExt (-973)

typedef std::string eml22__CapacitanceUomExt;
#endif

/* eml2_2ForGsoap.h:2139 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUomExt (-974)

typedef std::string eml22__CationExchangeCapacityUomExt;
#endif

/* eml2_2ForGsoap.h:2142 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUomExt (-975)

typedef std::string eml22__DataTransferSpeedUomExt;
#endif

/* eml2_2ForGsoap.h:2145 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUomExt (-976)

typedef std::string eml22__DiffusionCoefficientUomExt;
#endif

/* eml2_2ForGsoap.h:2148 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUomExt (-977)

typedef std::string eml22__DiffusiveTimeOfFlightUomExt;
#endif

/* eml2_2ForGsoap.h:2151 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUomExt (-978)

typedef std::string eml22__DigitalStorageUomExt;
#endif

/* eml2_2ForGsoap.h:2154 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUomExt (-979)

typedef std::string eml22__DimensionlessUomExt;
#endif

/* eml2_2ForGsoap.h:2157 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUomExt (-980)

typedef std::string eml22__DipoleMomentUomExt;
#endif

/* eml2_2ForGsoap.h:2160 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUomExt (-981)

typedef std::string eml22__DoseEquivalentUomExt;
#endif

/* eml2_2ForGsoap.h:2163 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUomExt (-982)

typedef std::string eml22__DynamicViscosityUomExt;
#endif

/* eml2_2ForGsoap.h:2166 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUomExt (-983)

typedef std::string eml22__ElectricalResistivityUomExt;
#endif

/* eml2_2ForGsoap.h:2169 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUomExt (-984)

typedef std::string eml22__ElectricChargePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2172 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUomExt (-985)

typedef std::string eml22__ElectricChargePerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2175 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUomExt (-986)

typedef std::string eml22__ElectricChargePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2178 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUomExt (-987)

typedef std::string eml22__ElectricChargeUomExt;
#endif

/* eml2_2ForGsoap.h:2181 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUomExt (-988)

typedef std::string eml22__ElectricConductanceUomExt;
#endif

/* eml2_2ForGsoap.h:2184 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUomExt (-989)

typedef std::string eml22__ElectricConductivityUomExt;
#endif

/* eml2_2ForGsoap.h:2187 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUomExt (-990)

typedef std::string eml22__ElectricCurrentDensityUomExt;
#endif

/* eml2_2ForGsoap.h:2190 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUomExt (-991)

typedef std::string eml22__ElectricCurrentUomExt;
#endif

/* eml2_2ForGsoap.h:2193 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUomExt (-992)

typedef std::string eml22__ElectricFieldStrengthUomExt;
#endif

/* eml2_2ForGsoap.h:2196 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUomExt (-993)

typedef std::string eml22__ElectricPotentialDifferenceUomExt;
#endif

/* eml2_2ForGsoap.h:2199 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUomExt (-994)

typedef std::string eml22__ElectricResistancePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2202 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUomExt (-995)

typedef std::string eml22__ElectricResistanceUomExt;
#endif

/* eml2_2ForGsoap.h:2205 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUomExt (-996)

typedef std::string eml22__ElectromagneticMomentUomExt;
#endif

/* eml2_2ForGsoap.h:2208 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUomExt (-997)

typedef std::string eml22__EnergyLengthPerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2211 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUomExt (-998)

typedef std::string eml22__EnergyLengthPerTimeAreaTemperatureUomExt;
#endif

/* eml2_2ForGsoap.h:2214 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUomExt (-999)

typedef std::string eml22__EnergyPerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2217 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUomExt (-1000)

typedef std::string eml22__EnergyPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2220 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUomExt (-1001)

typedef std::string eml22__EnergyPerMassPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2223 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUomExt (-1002)

typedef std::string eml22__EnergyPerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2226 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUomExt (-1003)

typedef std::string eml22__EnergyPerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2229 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUomExt (-1004)

typedef std::string eml22__EnergyUomExt;
#endif

/* eml2_2ForGsoap.h:2232 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUomExt (-1005)

typedef std::string eml22__ForceAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2235 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUomExt (-1006)

typedef std::string eml22__ForceLengthPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2238 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUomExt (-1007)

typedef std::string eml22__ForcePerForceUomExt;
#endif

/* eml2_2ForGsoap.h:2241 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUomExt (-1008)

typedef std::string eml22__ForcePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2244 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUomExt (-1009)

typedef std::string eml22__ForcePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2247 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceUomExt (-1010)

typedef std::string eml22__ForceUomExt;
#endif

/* eml2_2ForGsoap.h:2250 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUomExt (-1011)

typedef std::string eml22__FrequencyIntervalUomExt;
#endif

/* eml2_2ForGsoap.h:2253 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUomExt (-1012)

typedef std::string eml22__FrequencyUomExt;
#endif

/* eml2_2ForGsoap.h:2256 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUomExt (-1013)

typedef std::string eml22__HeatCapacityUomExt;
#endif

/* eml2_2ForGsoap.h:2259 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUomExt (-1014)

typedef std::string eml22__HeatFlowRateUomExt;
#endif

/* eml2_2ForGsoap.h:2262 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUomExt (-1015)

typedef std::string eml22__HeatTransferCoefficientUomExt;
#endif

/* eml2_2ForGsoap.h:2265 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUomExt (-1016)

typedef std::string eml22__IlluminanceUomExt;
#endif

/* eml2_2ForGsoap.h:2268 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUomExt (-1017)

typedef std::string eml22__InductanceUomExt;
#endif

/* eml2_2ForGsoap.h:2271 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUomExt (-1018)

typedef std::string eml22__IsothermalCompressibilityUomExt;
#endif

/* eml2_2ForGsoap.h:2274 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUomExt (-1019)

typedef std::string eml22__KinematicViscosityUomExt;
#endif

/* eml2_2ForGsoap.h:2277 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthAndTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthAndTimeUomExt (-1020)

typedef std::string eml22__LengthAndTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2280 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUomExt (-1021)

typedef std::string eml22__LengthPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2283 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUomExt (-1022)

typedef std::string eml22__LengthPerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2286 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUomExt (-1023)

typedef std::string eml22__LengthPerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2289 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUomExt (-1024)

typedef std::string eml22__LengthPerTemperatureUomExt;
#endif

/* eml2_2ForGsoap.h:2292 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUomExt (-1025)

typedef std::string eml22__LengthPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2295 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUomExt (-1026)

typedef std::string eml22__LengthPerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2298 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthUomExt (-1027)

typedef std::string eml22__LengthUomExt;
#endif

/* eml2_2ForGsoap.h:2301 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUomExt (-1028)

typedef std::string eml22__LightExposureUomExt;
#endif

/* eml2_2ForGsoap.h:2304 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUomExt (-1029)

typedef std::string eml22__LinearAccelerationUomExt;
#endif

/* eml2_2ForGsoap.h:2307 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUomExt (-1030)

typedef std::string eml22__LinearThermalExpansionUomExt;
#endif

/* eml2_2ForGsoap.h:2310 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUomExt (-1031)

typedef std::string eml22__LogarithmicPowerRatioPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2313 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUomExt (-1032)

typedef std::string eml22__LogarithmicPowerRatioUomExt;
#endif

/* eml2_2ForGsoap.h:2316 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUomExt (-1033)

typedef std::string eml22__LuminanceUomExt;
#endif

/* eml2_2ForGsoap.h:2319 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUomExt (-1034)

typedef std::string eml22__LuminousEfficacyUomExt;
#endif

/* eml2_2ForGsoap.h:2322 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUomExt (-1035)

typedef std::string eml22__LuminousFluxUomExt;
#endif

/* eml2_2ForGsoap.h:2325 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUomExt (-1036)

typedef std::string eml22__LuminousIntensityUomExt;
#endif

/* eml2_2ForGsoap.h:2328 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUomExt (-1037)

typedef std::string eml22__MagneticDipoleMomentUomExt;
#endif

/* eml2_2ForGsoap.h:2331 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUomExt (-1038)

typedef std::string eml22__MagneticFieldStrengthUomExt;
#endif

/* eml2_2ForGsoap.h:2334 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUomExt (-1039)

typedef std::string eml22__MagneticFluxDensityPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2337 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUomExt (-1040)

typedef std::string eml22__MagneticFluxDensityUomExt;
#endif

/* eml2_2ForGsoap.h:2340 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUomExt (-1041)

typedef std::string eml22__MagneticFluxUomExt;
#endif

/* eml2_2ForGsoap.h:2343 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUomExt (-1042)

typedef std::string eml22__MagneticPermeabilityUomExt;
#endif

/* eml2_2ForGsoap.h:2346 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUomExt (-1043)

typedef std::string eml22__MagneticVectorPotentialUomExt;
#endif

/* eml2_2ForGsoap.h:2349 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUomExt (-1044)

typedef std::string eml22__MassLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2352 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUomExt (-1045)

typedef std::string eml22__MassPerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2355 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUomExt (-1046)

typedef std::string eml22__MassPerEnergyUomExt;
#endif

/* eml2_2ForGsoap.h:2358 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUomExt (-1047)

typedef std::string eml22__MassPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2361 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUomExt (-1048)

typedef std::string eml22__MassPerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2364 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUomExt (-1049)

typedef std::string eml22__MassPerTimePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2367 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUomExt (-1050)

typedef std::string eml22__MassPerTimePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2370 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUomExt (-1051)

typedef std::string eml22__MassPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2373 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUomExt (-1052)

typedef std::string eml22__MassPerVolumePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2376 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUomExt (-1053)

typedef std::string eml22__MassPerVolumePerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2379 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUomExt (-1054)

typedef std::string eml22__MassPerVolumePerTemperatureUomExt;
#endif

/* eml2_2ForGsoap.h:2382 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomExt (-1055)

typedef std::string eml22__MassPerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2385 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassUomExt (-1056)

typedef std::string eml22__MassUomExt;
#endif

/* eml2_2ForGsoap.h:2388 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUomExt (-1057)

typedef std::string eml22__MobilityUomExt;
#endif

/* eml2_2ForGsoap.h:2391 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUomExt (-1058)

typedef std::string eml22__MolarEnergyUomExt;
#endif

/* eml2_2ForGsoap.h:2394 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUomExt (-1059)

typedef std::string eml22__MolarHeatCapacityUomExt;
#endif

/* eml2_2ForGsoap.h:2397 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUomExt (-1060)

typedef std::string eml22__MolarVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2400 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUomExt (-1061)

typedef std::string eml22__MolecularWeightUomExt;
#endif

/* eml2_2ForGsoap.h:2403 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUomExt (-1062)

typedef std::string eml22__MomentOfForceUomExt;
#endif

/* eml2_2ForGsoap.h:2406 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUomExt (-1063)

typedef std::string eml22__MomentOfInertiaUomExt;
#endif

/* eml2_2ForGsoap.h:2409 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUomExt (-1064)

typedef std::string eml22__MomentumUomExt;
#endif

/* eml2_2ForGsoap.h:2412 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUomExt (-1065)

typedef std::string eml22__NormalizedPowerUomExt;
#endif

/* eml2_2ForGsoap.h:2415 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUomExt (-1066)

typedef std::string eml22__PermeabilityLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2418 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUomExt (-1067)

typedef std::string eml22__PermeabilityRockUomExt;
#endif

/* eml2_2ForGsoap.h:2421 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUomExt (-1068)

typedef std::string eml22__PermittivityUomExt;
#endif

/* eml2_2ForGsoap.h:2424 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUomExt (-1069)

typedef std::string eml22__PlaneAngleUomExt;
#endif

/* eml2_2ForGsoap.h:2427 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUomExt (-1070)

typedef std::string eml22__PotentialDifferencePerPowerDropUomExt;
#endif

/* eml2_2ForGsoap.h:2430 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUomExt (-1071)

typedef std::string eml22__PowerPerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2433 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUomExt (-1072)

typedef std::string eml22__PowerPerPowerUomExt;
#endif

/* eml2_2ForGsoap.h:2436 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUomExt (-1073)

typedef std::string eml22__PowerPerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2439 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerUomExt (-1074)

typedef std::string eml22__PowerUomExt;
#endif

/* eml2_2ForGsoap.h:2442 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUomExt (-1075)

typedef std::string eml22__PressurePerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2445 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUomExt (-1076)

typedef std::string eml22__PressurePerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2448 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomExt (-1077)

typedef std::string eml22__PressurePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2451 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUomExt (-1078)

typedef std::string eml22__PressureSquaredPerForceTimePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2454 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUomExt (-1079)

typedef std::string eml22__PressureSquaredUomExt;
#endif

/* eml2_2ForGsoap.h:2457 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUomExt (-1080)

typedef std::string eml22__PressureTimePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2460 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomExt (-1081)

typedef std::string eml22__PressureUomExt;
#endif

/* eml2_2ForGsoap.h:2463 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUomExt (-1082)

typedef std::string eml22__QuantityOfLightUomExt;
#endif

/* eml2_2ForGsoap.h:2466 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUomExt (-1083)

typedef std::string eml22__RadianceUomExt;
#endif

/* eml2_2ForGsoap.h:2469 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUomExt (-1084)

typedef std::string eml22__RadiantIntensityUomExt;
#endif

/* eml2_2ForGsoap.h:2472 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUomExt (-1085)

typedef std::string eml22__ReciprocalAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2475 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUomExt (-1086)

typedef std::string eml22__ReciprocalElectricPotentialDifferenceUomExt;
#endif

/* eml2_2ForGsoap.h:2478 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUomExt (-1087)

typedef std::string eml22__ReciprocalForceUomExt;
#endif

/* eml2_2ForGsoap.h:2481 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUomExt (-1088)

typedef std::string eml22__ReciprocalLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2484 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUomExt (-1089)

typedef std::string eml22__ReciprocalMassTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2487 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUomExt (-1090)

typedef std::string eml22__ReciprocalMassUomExt;
#endif

/* eml2_2ForGsoap.h:2490 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUomExt (-1091)

typedef std::string eml22__ReciprocalPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2493 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUomExt (-1092)

typedef std::string eml22__ReciprocalTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2496 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUomExt (-1093)

typedef std::string eml22__ReciprocalVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2499 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUomExt (-1094)

typedef std::string eml22__ReluctanceUomExt;
#endif

/* eml2_2ForGsoap.h:2502 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUomExt (-1095)

typedef std::string eml22__SecondMomentOfAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2505 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUomExt (-1096)

typedef std::string eml22__SignalingEventPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2508 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUomExt (-1097)

typedef std::string eml22__SolidAngleUomExt;
#endif

/* eml2_2ForGsoap.h:2511 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUomExt (-1098)

typedef std::string eml22__SpecificHeatCapacityUomExt;
#endif

/* eml2_2ForGsoap.h:2514 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUomExt (-1099)

typedef std::string eml22__TemperatureIntervalPerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2517 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUomExt (-1100)

typedef std::string eml22__TemperatureIntervalPerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2520 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUomExt (-1101)

typedef std::string eml22__TemperatureIntervalPerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2523 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUomExt (-1102)

typedef std::string eml22__TemperatureIntervalUomExt;
#endif

/* eml2_2ForGsoap.h:2526 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUomExt (-1103)

typedef std::string eml22__ThermalConductanceUomExt;
#endif

/* eml2_2ForGsoap.h:2529 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUomExt (-1104)

typedef std::string eml22__ThermalConductivityUomExt;
#endif

/* eml2_2ForGsoap.h:2532 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUomExt (-1105)

typedef std::string eml22__ThermalDiffusivityUomExt;
#endif

/* eml2_2ForGsoap.h:2535 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUomExt (-1106)

typedef std::string eml22__ThermalInsulanceUomExt;
#endif

/* eml2_2ForGsoap.h:2538 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUomExt (-1107)

typedef std::string eml22__ThermalResistanceUomExt;
#endif

/* eml2_2ForGsoap.h:2541 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (-1108)

typedef std::string eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt;
#endif

/* eml2_2ForGsoap.h:2544 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUomExt (-1109)

typedef std::string eml22__ThermodynamicTemperatureUomExt;
#endif

/* eml2_2ForGsoap.h:2547 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUomExt (-1110)

typedef std::string eml22__TimePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2550 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUomExt (-1111)

typedef std::string eml22__TimePerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2553 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUomExt (-1112)

typedef std::string eml22__TimePerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2556 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUomExt (-1113)

typedef std::string eml22__TimePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2559 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeUomExt (-1114)

typedef std::string eml22__TimeUomExt;
#endif

/* eml2_2ForGsoap.h:2562 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUomExt (-1115)

typedef std::string eml22__VerticalCoordinateUomExt;
#endif

/* eml2_2ForGsoap.h:2565 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUomExt (-1116)

typedef std::string eml22__VolumeFlowRatePerVolumeFlowRateUomExt;
#endif

/* eml2_2ForGsoap.h:2568 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomExt (-1117)

typedef std::string eml22__VolumePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2571 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUomExt (-1118)

typedef std::string eml22__VolumePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2574 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUomExt (-1119)

typedef std::string eml22__VolumePerMassUomExt;
#endif

/* eml2_2ForGsoap.h:2577 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUomExt (-1120)

typedef std::string eml22__VolumePerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2580 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUomExt (-1121)

typedef std::string eml22__VolumePerRotationUomExt;
#endif

/* eml2_2ForGsoap.h:2583 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUomExt (-1122)

typedef std::string eml22__VolumePerTimeLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2586 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUomExt (-1123)

typedef std::string eml22__VolumePerTimePerAreaUomExt;
#endif

/* eml2_2ForGsoap.h:2589 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUomExt (-1124)

typedef std::string eml22__VolumePerTimePerLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2592 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUomExt (-1125)

typedef std::string eml22__VolumePerTimePerPressureLengthUomExt;
#endif

/* eml2_2ForGsoap.h:2595 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUomExt (-1126)

typedef std::string eml22__VolumePerTimePerPressureUomExt;
#endif

/* eml2_2ForGsoap.h:2598 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUomExt (-1127)

typedef std::string eml22__VolumePerTimePerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2601 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUomExt (-1128)

typedef std::string eml22__VolumePerTimePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2604 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomExt (-1129)

typedef std::string eml22__VolumePerTimeUomExt;
#endif

/* eml2_2ForGsoap.h:2607 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomExt (-1130)

typedef std::string eml22__VolumePerVolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2610 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUomExt (-1131)

typedef std::string eml22__VolumetricHeatTransferCoefficientUomExt;
#endif

/* eml2_2ForGsoap.h:2613 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUomExt (-1132)

typedef std::string eml22__VolumetricThermalExpansionUomExt;
#endif

/* eml2_2ForGsoap.h:2616 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomExt (-1133)

typedef std::string eml22__VolumeUomExt;
#endif

/* eml2_2ForGsoap.h:2619 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomWithLegacy (-1134)

typedef std::string eml22__MassPerVolumeUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2622 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomWithLegacy (-1135)

typedef std::string eml22__PressurePerVolumeUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2625 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomWithLegacy (-1136)

typedef std::string eml22__PressureUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2628 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomWithLegacy (-1137)

typedef std::string eml22__VolumePerAreaUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2631 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomWithLegacy (-1138)

typedef std::string eml22__VolumePerTimeUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2634 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomWithLegacy (-1139)

typedef std::string eml22__VolumePerVolumeUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2637 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomWithLegacy (-1140)

typedef std::string eml22__VolumeUomWithLegacy;
#endif

/* eml2_2ForGsoap.h:2646 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarYear
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarYear (-1141)

typedef xsd__integer prodml21__CalendarYear;
#endif

/* eml2_2ForGsoap.h:2655 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NonNegativeFraction (-1143)

typedef float prodml21__NonNegativeFraction;
#endif

/* eml2_2ForGsoap.h:2663 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProdmlRelativeIdentifier (-1144)

typedef xsd__anyURI prodml21__ProdmlRelativeIdentifier;
#endif

/* eml2_2ForGsoap.h:2721 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMeasure (-1148)

typedef double eml22__AbstractMeasure;
#endif

/* eml2_2ForGsoap.h:2729 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractString
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractString (-1149)

typedef std::string eml22__AbstractString;
#endif

/* eml2_2ForGsoap.h:2734 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_2_eml22__NonNegativeLong (-1150)

typedef LONG64 eml22__NonNegativeLong;
#endif

/* eml2_2ForGsoap.h:2739 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveDouble
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveDouble (-1151)

typedef double eml22__PositiveDouble;
#endif

/* eml2_2ForGsoap.h:2744 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveFloat
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveFloat (-1152)

typedef float eml22__PositiveFloat;
#endif

/* eml2_2ForGsoap.h:2749 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveLong
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveLong (-1153)

typedef LONG64 eml22__PositiveLong;
#endif

/* eml2_2ForGsoap.h:2754 */
#ifndef SOAP_TYPE_eml22__TimeStamp
#define SOAP_TYPE_eml22__TimeStamp (-1154)

typedef struct tm eml22__TimeStamp;
#endif

/* eml2_2ForGsoap.h:2815 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnumExtensionPattern (-1156)

typedef std::string eml22__EnumExtensionPattern;
#endif

/* eml2_2ForGsoap.h:2820 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String2000
#define SOAP_TYPE_gsoap_eml2_2_eml22__String2000 (-1157)

typedef std::string eml22__String2000;
#endif

/* eml2_2ForGsoap.h:2825 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String256
#define SOAP_TYPE_gsoap_eml2_2_eml22__String256 (-1158)

typedef std::string eml22__String256;
#endif

/* eml2_2ForGsoap.h:2830 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String64
#define SOAP_TYPE_gsoap_eml2_2_eml22__String64 (-1159)

typedef std::string eml22__String64;
#endif

/* eml2_2ForGsoap.h:2840 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UomEnum
#define SOAP_TYPE_gsoap_eml2_2_eml22__UomEnum (-1160)

typedef std::string eml22__UomEnum;
#endif

/* eml2_2ForGsoap.h:2845 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UuidString
#define SOAP_TYPE_gsoap_eml2_2_eml22__UuidString (-1161)

typedef std::string eml22__UuidString;
#endif

/* eml2_2ForGsoap.h:2854 */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarMonth (-1162)

typedef std::string prodml21__CalendarMonth;
#endif

/* eml2_2ForGsoap.h:4393 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeZone
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeZone (-1165)

typedef std::string eml22__TimeZone;
#endif

/* eml2_2ForGsoap.h:4401 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TypeEnum
#define SOAP_TYPE_gsoap_eml2_2_eml22__TypeEnum (-1166)

typedef eml22__String64 eml22__TypeEnum;
#endif

/* eml2_2ForGsoap.h:13200 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterSection (-1357)

typedef std::string eml22__PublicLandSurveySystemQuarterSection;
#endif

/* eml2_2ForGsoap.h:13209 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterTownship (-1358)

typedef std::string eml22__PublicLandSurveySystemQuarterTownship;
#endif

/* eml2_2ForGsoap.h:13218 */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SectionNumber
#define SOAP_TYPE_gsoap_eml2_2_eml22__SectionNumber (-1359)

typedef std::string eml22__SectionNumber;
#endif

/* eml2_2ForGsoap.h:58611 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidCharacterization
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidCharacterization (-2071)

typedef prodml21__FluidCharacterization _prodml21__FluidCharacterization;
#endif

/* eml2_2ForGsoap.h:58614 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductVolume
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductVolume (-2072)

typedef prodml21__ProductVolume _prodml21__ProductVolume;
#endif

/* eml2_2ForGsoap.h:58617 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductFlowModel (-2073)

typedef prodml21__ProductFlowModel _prodml21__ProductFlowModel;
#endif

/* eml2_2ForGsoap.h:58620 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSystem
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSystem (-2074)

typedef prodml21__FluidSystem _prodml21__FluidSystem;
#endif

/* eml2_2ForGsoap.h:58623 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidAnalysis (-2075)

typedef prodml21__FluidAnalysis _prodml21__FluidAnalysis;
#endif

/* eml2_2ForGsoap.h:58626 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__HydrocarbonAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__HydrocarbonAnalysis (-2076)

typedef prodml21__HydrocarbonAnalysis _prodml21__HydrocarbonAnalysis;
#endif

/* eml2_2ForGsoap.h:58629 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WaterAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WaterAnalysis (-2077)

typedef prodml21__WaterAnalysis _prodml21__WaterAnalysis;
#endif

/* eml2_2ForGsoap.h:58632 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSample
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSample (-2078)

typedef prodml21__FluidSample _prodml21__FluidSample;
#endif

/* eml2_2ForGsoap.h:58635 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleContainer
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleContainer (-2079)

typedef prodml21__FluidSampleContainer _prodml21__FluidSampleContainer;
#endif

/* eml2_2ForGsoap.h:58638 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleAcquisitionJob (-2080)

typedef prodml21__FluidSampleAcquisitionJob _prodml21__FluidSampleAcquisitionJob;
#endif

/* eml2_2ForGsoap.h:58641 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WftRun
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WftRun (-2081)

typedef prodml21__WftRun _prodml21__WftRun;
#endif

/* eml2_2ForGsoap.h:58644 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__AssetProductionVolumes
#define SOAP_TYPE_gsoap_eml2_2__prodml21__AssetProductionVolumes (-2082)

typedef prodml21__AssetProductionVolumes _prodml21__AssetProductionVolumes;
#endif

/* eml2_2ForGsoap.h:58647 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductionWellTests
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductionWellTests (-2083)

typedef prodml21__ProductionWellTests _prodml21__ProductionWellTests;
#endif

/* eml2_2ForGsoap.h:58650 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__TerminalLifting
#define SOAP_TYPE_gsoap_eml2_2__prodml21__TerminalLifting (-2084)

typedef prodml21__TerminalLifting _prodml21__TerminalLifting;
#endif

/* eml2_2ForGsoap.h:58653 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Transfer
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Transfer (-2085)

typedef prodml21__Transfer _prodml21__Transfer;
#endif

/* eml2_2ForGsoap.h:58656 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WellProductionParameters
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WellProductionParameters (-2086)

typedef prodml21__WellProductionParameters _prodml21__WellProductionParameters;
#endif

/* eml2_2ForGsoap.h:58659 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Channel (-2087)

typedef prodml21__Channel _prodml21__Channel;
#endif

/* eml2_2ForGsoap.h:58662 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ChannelSet
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ChannelSet (-2088)

typedef prodml21__ChannelSet _prodml21__ChannelSet;
#endif

/* eml2_2ForGsoap.h:58665 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FlowTestActivity
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FlowTestActivity (-2089)

typedef prodml21__FlowTestActivity _prodml21__FlowTestActivity;
#endif

/* eml2_2ForGsoap.h:58668 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PressureTransientAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PressureTransientAnalysis (-2090)

typedef prodml21__PressureTransientAnalysis _prodml21__PressureTransientAnalysis;
#endif

/* eml2_2ForGsoap.h:58671 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDataPreProcess
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDataPreProcess (-2091)

typedef prodml21__PtaDataPreProcess _prodml21__PtaDataPreProcess;
#endif

/* eml2_2ForGsoap.h:58674 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDeconvolution
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDeconvolution (-2092)

typedef prodml21__PtaDeconvolution _prodml21__PtaDeconvolution;
#endif

/* eml2_2ForGsoap.h:58677 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Facility
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Facility (-2093)

typedef prodml21__Facility _prodml21__Facility;
#endif

/* eml2_2ForGsoap.h:58680 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingEntity
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingEntity (-2094)

typedef prodml21__ReportingEntity _prodml21__ReportingEntity;
#endif

/* eml2_2ForGsoap.h:58683 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingHierarchy
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingHierarchy (-2095)

typedef prodml21__ReportingHierarchy _prodml21__ReportingHierarchy;
#endif

/* eml2_2ForGsoap.h:58686 */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__TimeSeriesData
#define SOAP_TYPE_gsoap_eml2_2__prodml21__TimeSeriesData (-2096)

typedef prodml21__TimeSeriesData _prodml21__TimeSeriesData;
#endif

/* eml2_2ForGsoap.h:58705 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKind (-2097)

typedef eml22__PropertyKind _eml22__PropertyKind;
#endif

/* eml2_2ForGsoap.h:58708 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKindDictionary (-2098)

typedef eml22__PropertyKindDictionary _eml22__PropertyKindDictionary;
#endif

/* eml2_2ForGsoap.h:58711 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__TimeSeries
#define SOAP_TYPE_gsoap_eml2_2__eml22__TimeSeries (-2099)

typedef eml22__TimeSeries _eml22__TimeSeries;
#endif

/* eml2_2ForGsoap.h:58714 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_2__eml22__EpcExternalPartReference (-2100)

typedef eml22__EpcExternalPartReference _eml22__EpcExternalPartReference;
#endif

/* eml2_2ForGsoap.h:58717 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__Activity
#define SOAP_TYPE_gsoap_eml2_2__eml22__Activity (-2101)

typedef eml22__Activity _eml22__Activity;
#endif

/* eml2_2ForGsoap.h:58720 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_2__eml22__ActivityTemplate (-2102)

typedef eml22__ActivityTemplate _eml22__ActivityTemplate;
#endif

/* eml2_2ForGsoap.h:58723 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_2__eml22__DataAssuranceRecord (-2103)

typedef eml22__DataAssuranceRecord _eml22__DataAssuranceRecord;
#endif

/* eml2_2ForGsoap.h:58726 */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_2__eml22__GraphicalInformationSet (-2104)

typedef eml22__GraphicalInformationSet _eml22__GraphicalInformationSet;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_gsoap_eml2_2_byte
#define SOAP_TYPE_gsoap_eml2_2_byte (-3)

#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_2_int
#define SOAP_TYPE_gsoap_eml2_2_int (-1)

#endif

/* eml22__PositiveLong has binding name 'eml22__PositiveLong' for type 'eml22:PositiveLong' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveLong
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveLong (-1153)

#endif

/* eml22__NonNegativeLong has binding name 'eml22__NonNegativeLong' for type 'eml22:NonNegativeLong' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_2_eml22__NonNegativeLong (-1150)

#endif

/* prodml21__CalendarYear has binding name 'prodml21__CalendarYear' for type 'prodml21:CalendarYear' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarYear
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarYear (-1141)

#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__integer
#define SOAP_TYPE_gsoap_eml2_2_xsd__integer (-11)

#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_2_LONG64
#define SOAP_TYPE_gsoap_eml2_2_LONG64 (-10)

#endif

/* eml22__PositiveFloat has binding name 'eml22__PositiveFloat' for type 'eml22:PositiveFloat' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveFloat
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveFloat (-1152)

#endif

/* prodml21__NonNegativeFraction has binding name 'prodml21__NonNegativeFraction' for type 'prodml21:NonNegativeFraction' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NonNegativeFraction (-1143)

#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_gsoap_eml2_2_float
#define SOAP_TYPE_gsoap_eml2_2_float (-1142)

#endif

/* eml22__PositiveDouble has binding name 'eml22__PositiveDouble' for type 'eml22:PositiveDouble' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PositiveDouble
#define SOAP_TYPE_gsoap_eml2_2_eml22__PositiveDouble (-1151)

#endif

/* eml22__AbstractMeasure has binding name 'eml22__AbstractMeasure' for type 'eml22:AbstractMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMeasure (-1148)

#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_2_double
#define SOAP_TYPE_gsoap_eml2_2_double (-1147)

#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_2_xsd__nonNegativeInteger (-13)

#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_eml2_2_ULONG64
#define SOAP_TYPE_gsoap_eml2_2_ULONG64 (-12)

#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_2_bool
#define SOAP_TYPE_gsoap_eml2_2_bool (-1578)

#endif

/* eml22__VerticalDirection has binding name 'eml22__VerticalDirection' for type 'eml22:VerticalDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalDirection (-1461)

#endif

/* eml22__PrincipalMeridian has binding name 'eml22__PrincipalMeridian' for type 'eml22:PrincipalMeridian' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_2_eml22__PrincipalMeridian (-1460)

#endif

/* eml22__NorthOrSouth has binding name 'eml22__NorthOrSouth' for type 'eml22:NorthOrSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_2_eml22__NorthOrSouth (-1459)

#endif

/* eml22__EastOrWest has binding name 'eml22__EastOrWest' for type 'eml22:EastOrWest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EastOrWest
#define SOAP_TYPE_gsoap_eml2_2_eml22__EastOrWest (-1458)

#endif

/* eml22__AxisOrder2d has binding name 'eml22__AxisOrder2d' for type 'eml22:AxisOrder2d' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_2_eml22__AxisOrder2d (-1457)

#endif

/* eml22__ReferencePressureKind has binding name 'eml22__ReferencePressureKind' for type 'eml22:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressureKind (-1456)

#endif

/* eml22__ActivityParameterKind has binding name 'eml22__ActivityParameterKind' for type 'eml22:ActivityParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityParameterKind (-1455)

#endif

/* eml22__WellStatus has binding name 'eml22__WellStatus' for type 'eml22:WellStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellStatus
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellStatus (-1454)

#endif

/* eml22__WellboreDatumReference has binding name 'eml22__WellboreDatumReference' for type 'eml22:WellboreDatumReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellboreDatumReference (-1453)

#endif

/* eml22__ReferenceCondition has binding name 'eml22__ReferenceCondition' for type 'eml22:ReferenceCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceCondition (-1452)

#endif

/* eml22__QuantityClassKind has binding name 'eml22__QuantityClassKind' for type 'eml22:QuantityClassKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKind (-1451)

#endif

/* eml22__MeasureClass has binding name 'eml22__MeasureClass' for type 'eml22:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MeasureClass
#define SOAP_TYPE_gsoap_eml2_2_eml22__MeasureClass (-1450)

#endif

/* eml22__MatrixCementKind has binding name 'eml22__MatrixCementKind' for type 'eml22:MatrixCementKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__MatrixCementKind (-1449)

#endif

/* eml22__LithostratigraphicRank has binding name 'eml22__LithostratigraphicRank' for type 'eml22:LithostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithostratigraphicRank (-1448)

#endif

/* eml22__LithologyQualifierKind has binding name 'eml22__LithologyQualifierKind' for type 'eml22:LithologyQualifierKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKind (-1447)

#endif

/* eml22__LithologyKind has binding name 'eml22__LithologyKind' for type 'eml22:LithologyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKind (-1446)

#endif

/* eml22__GeochronologicalRank has binding name 'eml22__GeochronologicalRank' for type 'eml22:GeochronologicalRank' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeochronologicalRank (-1445)

#endif

/* eml22__ExistenceKind has binding name 'eml22__ExistenceKind' for type 'eml22:ExistenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExistenceKind (-1444)

#endif

/* eml22__ChannelStatusKind has binding name 'eml22__ChannelStatusKind' for type 'eml22:ChannelStatusKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ChannelStatusKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__ChannelStatusKind (-1443)

#endif

/* eml22__FacetKind has binding name 'eml22__FacetKind' for type 'eml22:FacetKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FacetKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__FacetKind (-1442)

#endif

/* eml22__Facet has binding name 'eml22__Facet' for type 'eml22:Facet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Facet
#define SOAP_TYPE_gsoap_eml2_2_eml22__Facet (-1441)

#endif

/* prodml21__WellboreStorageMechanismType has binding name 'prodml21__WellboreStorageMechanismType' for type 'prodml21:WellboreStorageMechanismType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageMechanismType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageMechanismType (-1440)

#endif

/* prodml21__UpperBoundaryType has binding name 'prodml21__UpperBoundaryType' for type 'prodml21:UpperBoundaryType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__UpperBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__UpperBoundaryType (-1439)

#endif

/* prodml21__ParameterDirection has binding name 'prodml21__ParameterDirection' for type 'prodml21:ParameterDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ParameterDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ParameterDirection (-1438)

#endif

/* prodml21__LowerBoundaryType has binding name 'prodml21__LowerBoundaryType' for type 'prodml21:LowerBoundaryType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LowerBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LowerBoundaryType (-1437)

#endif

/* prodml21__FractureModelType has binding name 'prodml21__FractureModelType' for type 'prodml21:FractureModelType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureModelType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureModelType (-1436)

#endif

/* prodml21__Boundary4Type has binding name 'prodml21__Boundary4Type' for type 'prodml21:Boundary4Type' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary4Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary4Type (-1435)

#endif

/* prodml21__Boundary3Type has binding name 'prodml21__Boundary3Type' for type 'prodml21:Boundary3Type' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary3Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary3Type (-1434)

#endif

/* prodml21__Boundary2Type has binding name 'prodml21__Boundary2Type' for type 'prodml21:Boundary2Type' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary2Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary2Type (-1433)

#endif

/* prodml21__Boundary1Type has binding name 'prodml21__Boundary1Type' for type 'prodml21:Boundary1Type' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary1Type
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Boundary1Type (-1432)

#endif

/* prodml21__TimeNonLinearTransformKind has binding name 'prodml21__TimeNonLinearTransformKind' for type 'prodml21:TimeNonLinearTransformKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeNonLinearTransformKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeNonLinearTransformKind (-1431)

#endif

/* prodml21__PseudoPressureEffectApplied has binding name 'prodml21__PseudoPressureEffectApplied' for type 'prodml21:PseudoPressureEffectApplied' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoPressureEffectApplied
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoPressureEffectApplied (-1430)

#endif

/* prodml21__PressureNonLinearTransformKind has binding name 'prodml21__PressureNonLinearTransformKind' for type 'prodml21:PressureNonLinearTransformKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureNonLinearTransformKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureNonLinearTransformKind (-1429)

#endif

/* prodml21__LogLogTimeTransform has binding name 'prodml21__LogLogTimeTransform' for type 'prodml21:LogLogTimeTransform' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogTimeTransform
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogTimeTransform (-1428)

#endif

/* prodml21__LogLogPressureTransform has binding name 'prodml21__LogLogPressureTransform' for type 'prodml21:LogLogPressureTransform' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogPressureTransform
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogPressureTransform (-1427)

#endif

/* prodml21__FluidPhaseKind has binding name 'prodml21__FluidPhaseKind' for type 'prodml21:FluidPhaseKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseKind (-1426)

#endif

/* prodml21__TimeSeriesPointRepresentation has binding name 'prodml21__TimeSeriesPointRepresentation' for type 'prodml21:TimeSeriesPointRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesPointRepresentation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesPointRepresentation (-1425)

#endif

/* prodml21__TestPeriodKind has binding name 'prodml21__TestPeriodKind' for type 'prodml21:TestPeriodKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodKind (-1424)

#endif

/* prodml21__FluidPhaseMeasuredKind has binding name 'prodml21__FluidPhaseMeasuredKind' for type 'prodml21:FluidPhaseMeasuredKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseMeasuredKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidPhaseMeasuredKind (-1423)

#endif

/* prodml21__DataConditioning has binding name 'prodml21__DataConditioning' for type 'prodml21:DataConditioning' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioning
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioning (-1422)

#endif

/* prodml21__TransferKind has binding name 'prodml21__TransferKind' for type 'prodml21:TransferKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransferKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransferKind (-1421)

#endif

/* prodml21__QuantityMethod has binding name 'prodml21__QuantityMethod' for type 'prodml21:QuantityMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethod (-1420)

#endif

/* prodml21__EstimationMethod has binding name 'prodml21__EstimationMethod' for type 'prodml21:EstimationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethod (-1419)

#endif

/* prodml21__DispositionKind has binding name 'prodml21__DispositionKind' for type 'prodml21:DispositionKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKind (-1418)

#endif

/* prodml21__DeferredKind has binding name 'prodml21__DeferredKind' for type 'prodml21:DeferredKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredKind (-1417)

#endif

/* prodml21__WftTestResultKind has binding name 'prodml21__WftTestResultKind' for type 'prodml21:WftTestResultKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResultKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResultKind (-1416)

#endif

/* prodml21__WftTestKind has binding name 'prodml21__WftTestKind' for type 'prodml21:WftTestKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestKind (-1415)

#endif

/* prodml21__WftTestDataRole has binding name 'prodml21__WftTestDataRole' for type 'prodml21:WftTestDataRole' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestDataRole
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestDataRole (-1414)

#endif

/* prodml21__WftStationKind has binding name 'prodml21__WftStationKind' for type 'prodml21:WftStationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftStationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftStationKind (-1413)

#endif

/* prodml21__WftFlowingIntervalKind has binding name 'prodml21__WftFlowingIntervalKind' for type 'prodml21:WftFlowingIntervalKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftFlowingIntervalKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftFlowingIntervalKind (-1412)

#endif

/* prodml21__WftEventKind has binding name 'prodml21__WftEventKind' for type 'prodml21:WftEventKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftEventKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftEventKind (-1411)

#endif

/* prodml21__SampleAction has binding name 'prodml21__SampleAction' for type 'prodml21:SampleAction' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleAction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleAction (-1410)

#endif

/* prodml21__FluidSampleKind has binding name 'prodml21__FluidSampleKind' for type 'prodml21:FluidSampleKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleKind (-1409)

#endif

/* prodml21__VolumeReferenceKind has binding name 'prodml21__VolumeReferenceKind' for type 'prodml21:VolumeReferenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeReferenceKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeReferenceKind (-1408)

#endif

/* prodml21__ThermodynamicPhase has binding name 'prodml21__ThermodynamicPhase' for type 'prodml21:ThermodynamicPhase' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ThermodynamicPhase
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ThermodynamicPhase (-1407)

#endif

/* prodml21__SampleQuality has binding name 'prodml21__SampleQuality' for type 'prodml21:SampleQuality' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleQuality
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleQuality (-1406)

#endif

/* prodml21__FluidContaminant has binding name 'prodml21__FluidContaminant' for type 'prodml21:FluidContaminant' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidContaminant
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidContaminant (-1405)

#endif

/* prodml21__FluidAnalysisStepCondition has binding name 'prodml21__FluidAnalysisStepCondition' for type 'prodml21:FluidAnalysisStepCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisStepCondition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisStepCondition (-1404)

#endif

/* prodml21__CompressibilityKind has binding name 'prodml21__CompressibilityKind' for type 'prodml21:CompressibilityKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityKind (-1403)

#endif

/* prodml21__ReservoirLifeCycleState has binding name 'prodml21__ReservoirLifeCycleState' for type 'prodml21:ReservoirLifeCycleState' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirLifeCycleState
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirLifeCycleState (-1402)

#endif

/* prodml21__PhasePresent has binding name 'prodml21__PhasePresent' for type 'prodml21:PhasePresent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhasePresent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhasePresent (-1401)

#endif

/* prodml21__WellOperationMethod has binding name 'prodml21__WellOperationMethod' for type 'prodml21:WellOperationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellOperationMethod (-1400)

#endif

/* prodml21__FluidComponentBasis has binding name 'prodml21__FluidComponentBasis' for type 'prodml21:FluidComponentBasis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentBasis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentBasis (-1399)

#endif

/* prodml21__CalculationMethod has binding name 'prodml21__CalculationMethod' for type 'prodml21:CalculationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalculationMethod (-1398)

#endif

/* prodml21__BalanceFlowPart has binding name 'prodml21__BalanceFlowPart' for type 'prodml21:BalanceFlowPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceFlowPart (-1397)

#endif

/* prodml21__BalanceEventKind has binding name 'prodml21__BalanceEventKind' for type 'prodml21:BalanceEventKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceEventKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceEventKind (-1396)

#endif

/* prodml21__BalanceDestinationType has binding name 'prodml21__BalanceDestinationType' for type 'prodml21:BalanceDestinationType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BalanceDestinationType (-1395)

#endif

/* prodml21__WellFluid has binding name 'prodml21__WellFluid' for type 'prodml21:WellFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellFluid (-1394)

#endif

/* prodml21__WellDirection has binding name 'prodml21__WellDirection' for type 'prodml21:WellDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellDirection (-1393)

#endif

/* prodml21__ValueStatus has binding name 'prodml21__ValueStatus' for type 'prodml21:ValueStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ValueStatus
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ValueStatus (-1392)

#endif

/* prodml21__TimeSeriesKeyword has binding name 'prodml21__TimeSeriesKeyword' for type 'prodml21:TimeSeriesKeyword' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesKeyword
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesKeyword (-1391)

#endif

/* prodml21__ServiceFluidKind has binding name 'prodml21__ServiceFluidKind' for type 'prodml21:ServiceFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKind (-1390)

#endif

/* prodml21__SaturationPointKind has binding name 'prodml21__SaturationPointKind' for type 'prodml21:SaturationPointKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPointKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPointKind (-1389)

#endif

/* prodml21__SafetyType has binding name 'prodml21__SafetyType' for type 'prodml21:SafetyType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SafetyType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SafetyType (-1388)

#endif

/* prodml21__ReservoirFluidKind has binding name 'prodml21__ReservoirFluidKind' for type 'prodml21:ReservoirFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirFluidKind (-1387)

#endif

/* prodml21__ReportingProduct has binding name 'prodml21__ReportingProduct' for type 'prodml21:ReportingProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingProduct (-1386)

#endif

/* prodml21__ReportingFlow has binding name 'prodml21__ReportingFlow' for type 'prodml21:ReportingFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFlow (-1385)

#endif

/* prodml21__ReportingFacility has binding name 'prodml21__ReportingFacility' for type 'prodml21:ReportingFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacility (-1384)

#endif

/* prodml21__ReportingEntityKind has binding name 'prodml21__ReportingEntityKind' for type 'prodml21:ReportingEntityKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityKind (-1383)

#endif

/* prodml21__ReportingDurationKind has binding name 'prodml21__ReportingDurationKind' for type 'prodml21:ReportingDurationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKind (-1382)

#endif

/* prodml21__PureComponentEnum has binding name 'prodml21__PureComponentEnum' for type 'prodml21:PureComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnum (-1381)

#endif

/* prodml21__PseudoComponentEnum has binding name 'prodml21__PseudoComponentEnum' for type 'prodml21:PseudoComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnum (-1380)

#endif

/* prodml21__ProductFluidKind has binding name 'prodml21__ProductFluidKind' for type 'prodml21:ProductFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKind (-1379)

#endif

/* prodml21__ProductFlowPortType has binding name 'prodml21__ProductFlowPortType' for type 'prodml21:ProductFlowPortType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPortType (-1378)

#endif

/* prodml21__PressurePerFlowrateUom has binding name 'prodml21__PressurePerFlowrateUom' for type 'prodml21:PressurePerFlowrateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateUom
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateUom (-1377)

#endif

/* prodml21__PressurePerFlowrateSquaredUom has binding name 'prodml21__PressurePerFlowrateSquaredUom' for type 'prodml21:PressurePerFlowrateSquaredUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredUom
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredUom (-1376)

#endif

/* prodml21__PlusComponentEnum has binding name 'prodml21__PlusComponentEnum' for type 'prodml21:PlusComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnum (-1375)

#endif

/* prodml21__PhoneType has binding name 'prodml21__PhoneType' for type 'prodml21:PhoneType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneType (-1374)

#endif

/* prodml21__GeologyType has binding name 'prodml21__GeologyType' for type 'prodml21:GeologyType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyType (-1373)

#endif

/* prodml21__FlowSubQualifier has binding name 'prodml21__FlowSubQualifier' for type 'prodml21:FlowSubQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowSubQualifier (-1372)

#endif

/* prodml21__FlowQualifier has binding name 'prodml21__FlowQualifier' for type 'prodml21:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowQualifier (-1371)

#endif

/* prodml21__FiberMode has binding name 'prodml21__FiberMode' for type 'prodml21:FiberMode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FiberMode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FiberMode (-1370)

#endif

/* prodml21__FacilityParameter has binding name 'prodml21__FacilityParameter' for type 'prodml21:FacilityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParameter (-1369)

#endif

/* prodml21__EndpointQualifierInterval has binding name 'prodml21__EndpointQualifierInterval' for type 'prodml21:EndpointQualifierInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifierInterval
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifierInterval (-1368)

#endif

/* prodml21__EndpointQualifier has binding name 'prodml21__EndpointQualifier' for type 'prodml21:EndpointQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifier (-1367)

#endif

/* prodml21__BusinessUnitKind has binding name 'prodml21__BusinessUnitKind' for type 'prodml21:BusinessUnitKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessUnitKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessUnitKind (-1366)

#endif

/* prodml21__AddressQualifier has binding name 'prodml21__AddressQualifier' for type 'prodml21:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AddressQualifier (-1365)

#endif

/* prodml21__AddressKindEnum has binding name 'prodml21__AddressKindEnum' for type 'prodml21:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AddressKindEnum (-1364)

#endif

/* prodml21__saturationKind has binding name 'prodml21__saturationKind' for type 'prodml21:saturationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__saturationKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__saturationKind (-1363)

#endif

/* prodml21__PvtModelParameterKind has binding name 'prodml21__PvtModelParameterKind' for type 'prodml21:PvtModelParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKind
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKind (-1362)

#endif

/* prodml21__OutputFluidProperty has binding name 'prodml21__OutputFluidProperty' for type 'prodml21:OutputFluidProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidProperty (-1361)

#endif

/* prodml21__MixingRule has binding name 'prodml21__MixingRule' for type 'prodml21:MixingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MixingRule
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MixingRule (-1360)

#endif

/* eml22__LegacyVolumeUom has binding name 'eml22__LegacyVolumeUom' for type 'eml22:LegacyVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumeUom (-1356)

#endif

/* eml22__LegacyVolumePerVolumeUom has binding name 'eml22__LegacyVolumePerVolumeUom' for type 'eml22:LegacyVolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerVolumeUom (-1355)

#endif

/* eml22__LegacyVolumePerTimeUom has binding name 'eml22__LegacyVolumePerTimeUom' for type 'eml22:LegacyVolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerTimeUom (-1354)

#endif

/* eml22__LegacyVolumePerAreaUom has binding name 'eml22__LegacyVolumePerAreaUom' for type 'eml22:LegacyVolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyVolumePerAreaUom (-1353)

#endif

/* eml22__LegacyPressureUom has binding name 'eml22__LegacyPressureUom' for type 'eml22:LegacyPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressureUom (-1352)

#endif

/* eml22__LegacyPressurePerVolumeUom has binding name 'eml22__LegacyPressurePerVolumeUom' for type 'eml22:LegacyPressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyPressurePerVolumeUom (-1351)

#endif

/* eml22__LegacyMassPerVolumeUom has binding name 'eml22__LegacyMassPerVolumeUom' for type 'eml22:LegacyMassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyMassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyMassPerVolumeUom (-1350)

#endif

/* eml22__VolumeUom has binding name 'eml22__VolumeUom' for type 'eml22:VolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUom (-1349)

#endif

/* eml22__VolumetricThermalExpansionUom has binding name 'eml22__VolumetricThermalExpansionUom' for type 'eml22:VolumetricThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUom (-1348)

#endif

/* eml22__VolumetricHeatTransferCoefficientUom has binding name 'eml22__VolumetricHeatTransferCoefficientUom' for type 'eml22:VolumetricHeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUom (-1347)

#endif

/* eml22__VolumePerVolumeUom has binding name 'eml22__VolumePerVolumeUom' for type 'eml22:VolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUom (-1346)

#endif

/* eml22__VolumePerTimeUom has binding name 'eml22__VolumePerTimeUom' for type 'eml22:VolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUom (-1345)

#endif

/* eml22__VolumePerTimePerVolumeUom has binding name 'eml22__VolumePerTimePerVolumeUom' for type 'eml22:VolumePerTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUom (-1344)

#endif

/* eml22__VolumePerTimePerTimeUom has binding name 'eml22__VolumePerTimePerTimeUom' for type 'eml22:VolumePerTimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUom (-1343)

#endif

/* eml22__VolumePerTimePerPressureUom has binding name 'eml22__VolumePerTimePerPressureUom' for type 'eml22:VolumePerTimePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUom (-1342)

#endif

/* eml22__VolumePerTimePerPressureLengthUom has binding name 'eml22__VolumePerTimePerPressureLengthUom' for type 'eml22:VolumePerTimePerPressureLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUom (-1341)

#endif

/* eml22__VolumePerTimePerLengthUom has binding name 'eml22__VolumePerTimePerLengthUom' for type 'eml22:VolumePerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUom (-1340)

#endif

/* eml22__VolumePerTimePerAreaUom has binding name 'eml22__VolumePerTimePerAreaUom' for type 'eml22:VolumePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUom (-1339)

#endif

/* eml22__VolumePerTimeLengthUom has binding name 'eml22__VolumePerTimeLengthUom' for type 'eml22:VolumePerTimeLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUom (-1338)

#endif

/* eml22__VolumePerRotationUom has binding name 'eml22__VolumePerRotationUom' for type 'eml22:VolumePerRotationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUom (-1337)

#endif

/* eml22__VolumePerPressureUom has binding name 'eml22__VolumePerPressureUom' for type 'eml22:VolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUom (-1336)

#endif

/* eml22__VolumePerMassUom has binding name 'eml22__VolumePerMassUom' for type 'eml22:VolumePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUom (-1335)

#endif

/* eml22__VolumePerLengthUom has binding name 'eml22__VolumePerLengthUom' for type 'eml22:VolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUom (-1334)

#endif

/* eml22__VolumePerAreaUom has binding name 'eml22__VolumePerAreaUom' for type 'eml22:VolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUom (-1333)

#endif

/* eml22__VolumeFlowRatePerVolumeFlowRateUom has binding name 'eml22__VolumeFlowRatePerVolumeFlowRateUom' for type 'eml22:VolumeFlowRatePerVolumeFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUom (-1332)

#endif

/* eml22__VerticalCoordinateUom has binding name 'eml22__VerticalCoordinateUom' for type 'eml22:VerticalCoordinateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUom (-1331)

#endif

/* eml22__TimeUom has binding name 'eml22__TimeUom' for type 'eml22:TimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeUom (-1330)

#endif

/* eml22__TimePerVolumeUom has binding name 'eml22__TimePerVolumeUom' for type 'eml22:TimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUom (-1329)

#endif

/* eml22__TimePerTimeUom has binding name 'eml22__TimePerTimeUom' for type 'eml22:TimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUom (-1328)

#endif

/* eml22__TimePerMassUom has binding name 'eml22__TimePerMassUom' for type 'eml22:TimePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUom (-1327)

#endif

/* eml22__TimePerLengthUom has binding name 'eml22__TimePerLengthUom' for type 'eml22:TimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUom (-1326)

#endif

/* eml22__ThermodynamicTemperatureUom has binding name 'eml22__ThermodynamicTemperatureUom' for type 'eml22:ThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUom (-1325)

#endif

/* eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom has binding name 'eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom' for type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUom (-1324)

#endif

/* eml22__ThermalResistanceUom has binding name 'eml22__ThermalResistanceUom' for type 'eml22:ThermalResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUom (-1323)

#endif

/* eml22__ThermalInsulanceUom has binding name 'eml22__ThermalInsulanceUom' for type 'eml22:ThermalInsulanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUom (-1322)

#endif

/* eml22__ThermalDiffusivityUom has binding name 'eml22__ThermalDiffusivityUom' for type 'eml22:ThermalDiffusivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUom (-1321)

#endif

/* eml22__ThermalConductivityUom has binding name 'eml22__ThermalConductivityUom' for type 'eml22:ThermalConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUom (-1320)

#endif

/* eml22__ThermalConductanceUom has binding name 'eml22__ThermalConductanceUom' for type 'eml22:ThermalConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUom (-1319)

#endif

/* eml22__TemperatureIntervalUom has binding name 'eml22__TemperatureIntervalUom' for type 'eml22:TemperatureIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUom (-1318)

#endif

/* eml22__TemperatureIntervalPerTimeUom has binding name 'eml22__TemperatureIntervalPerTimeUom' for type 'eml22:TemperatureIntervalPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUom (-1317)

#endif

/* eml22__TemperatureIntervalPerPressureUom has binding name 'eml22__TemperatureIntervalPerPressureUom' for type 'eml22:TemperatureIntervalPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUom (-1316)

#endif

/* eml22__TemperatureIntervalPerLengthUom has binding name 'eml22__TemperatureIntervalPerLengthUom' for type 'eml22:TemperatureIntervalPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUom (-1315)

#endif

/* eml22__SpecificHeatCapacityUom has binding name 'eml22__SpecificHeatCapacityUom' for type 'eml22:SpecificHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUom (-1314)

#endif

/* eml22__SolidAngleUom has binding name 'eml22__SolidAngleUom' for type 'eml22:SolidAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUom (-1313)

#endif

/* eml22__SignalingEventPerTimeUom has binding name 'eml22__SignalingEventPerTimeUom' for type 'eml22:SignalingEventPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUom (-1312)

#endif

/* eml22__SecondMomentOfAreaUom has binding name 'eml22__SecondMomentOfAreaUom' for type 'eml22:SecondMomentOfAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUom (-1311)

#endif

/* eml22__ReluctanceUom has binding name 'eml22__ReluctanceUom' for type 'eml22:ReluctanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUom (-1310)

#endif

/* eml22__ReciprocalVolumeUom has binding name 'eml22__ReciprocalVolumeUom' for type 'eml22:ReciprocalVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUom (-1309)

#endif

/* eml22__ReciprocalTimeUom has binding name 'eml22__ReciprocalTimeUom' for type 'eml22:ReciprocalTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUom (-1308)

#endif

/* eml22__ReciprocalPressureUom has binding name 'eml22__ReciprocalPressureUom' for type 'eml22:ReciprocalPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUom (-1307)

#endif

/* eml22__ReciprocalMassUom has binding name 'eml22__ReciprocalMassUom' for type 'eml22:ReciprocalMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUom (-1306)

#endif

/* eml22__ReciprocalMassTimeUom has binding name 'eml22__ReciprocalMassTimeUom' for type 'eml22:ReciprocalMassTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUom (-1305)

#endif

/* eml22__ReciprocalLengthUom has binding name 'eml22__ReciprocalLengthUom' for type 'eml22:ReciprocalLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUom (-1304)

#endif

/* eml22__ReciprocalForceUom has binding name 'eml22__ReciprocalForceUom' for type 'eml22:ReciprocalForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUom (-1303)

#endif

/* eml22__ReciprocalElectricPotentialDifferenceUom has binding name 'eml22__ReciprocalElectricPotentialDifferenceUom' for type 'eml22:ReciprocalElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUom (-1302)

#endif

/* eml22__ReciprocalAreaUom has binding name 'eml22__ReciprocalAreaUom' for type 'eml22:ReciprocalAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUom (-1301)

#endif

/* eml22__RadiantIntensityUom has binding name 'eml22__RadiantIntensityUom' for type 'eml22:RadiantIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUom (-1300)

#endif

/* eml22__RadianceUom has binding name 'eml22__RadianceUom' for type 'eml22:RadianceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUom (-1299)

#endif

/* eml22__QuantityOfLightUom has binding name 'eml22__QuantityOfLightUom' for type 'eml22:QuantityOfLightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUom (-1298)

#endif

/* eml22__PressureUom has binding name 'eml22__PressureUom' for type 'eml22:PressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUom (-1297)

#endif

/* eml22__PressureTimePerVolumeUom has binding name 'eml22__PressureTimePerVolumeUom' for type 'eml22:PressureTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUom (-1296)

#endif

/* eml22__PressureSquaredUom has binding name 'eml22__PressureSquaredUom' for type 'eml22:PressureSquaredUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUom (-1295)

#endif

/* eml22__PressureSquaredPerForceTimePerAreaUom has binding name 'eml22__PressureSquaredPerForceTimePerAreaUom' for type 'eml22:PressureSquaredPerForceTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUom (-1294)

#endif

/* eml22__PressurePerVolumeUom has binding name 'eml22__PressurePerVolumeUom' for type 'eml22:PressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUom (-1293)

#endif

/* eml22__PressurePerTimeUom has binding name 'eml22__PressurePerTimeUom' for type 'eml22:PressurePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUom (-1292)

#endif

/* eml22__PressurePerPressureUom has binding name 'eml22__PressurePerPressureUom' for type 'eml22:PressurePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUom (-1291)

#endif

/* eml22__PowerUom has binding name 'eml22__PowerUom' for type 'eml22:PowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerUom (-1290)

#endif

/* eml22__PowerPerVolumeUom has binding name 'eml22__PowerPerVolumeUom' for type 'eml22:PowerPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUom (-1289)

#endif

/* eml22__PowerPerPowerUom has binding name 'eml22__PowerPerPowerUom' for type 'eml22:PowerPerPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUom (-1288)

#endif

/* eml22__PowerPerAreaUom has binding name 'eml22__PowerPerAreaUom' for type 'eml22:PowerPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUom (-1287)

#endif

/* eml22__PotentialDifferencePerPowerDropUom has binding name 'eml22__PotentialDifferencePerPowerDropUom' for type 'eml22:PotentialDifferencePerPowerDropUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUom (-1286)

#endif

/* eml22__PlaneAngleUom has binding name 'eml22__PlaneAngleUom' for type 'eml22:PlaneAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUom (-1285)

#endif

/* eml22__PermittivityUom has binding name 'eml22__PermittivityUom' for type 'eml22:PermittivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUom (-1284)

#endif

/* eml22__PermeabilityRockUom has binding name 'eml22__PermeabilityRockUom' for type 'eml22:PermeabilityRockUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUom (-1283)

#endif

/* eml22__PermeabilityLengthUom has binding name 'eml22__PermeabilityLengthUom' for type 'eml22:PermeabilityLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUom (-1282)

#endif

/* eml22__NormalizedPowerUom has binding name 'eml22__NormalizedPowerUom' for type 'eml22:NormalizedPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUom (-1281)

#endif

/* eml22__MomentumUom has binding name 'eml22__MomentumUom' for type 'eml22:MomentumUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUom (-1280)

#endif

/* eml22__MomentOfInertiaUom has binding name 'eml22__MomentOfInertiaUom' for type 'eml22:MomentOfInertiaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUom (-1279)

#endif

/* eml22__MomentOfForceUom has binding name 'eml22__MomentOfForceUom' for type 'eml22:MomentOfForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUom (-1278)

#endif

/* eml22__MolecularWeightUom has binding name 'eml22__MolecularWeightUom' for type 'eml22:MolecularWeightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUom (-1277)

#endif

/* eml22__MolarVolumeUom has binding name 'eml22__MolarVolumeUom' for type 'eml22:MolarVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUom (-1276)

#endif

/* eml22__MolarHeatCapacityUom has binding name 'eml22__MolarHeatCapacityUom' for type 'eml22:MolarHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUom (-1275)

#endif

/* eml22__MolarEnergyUom has binding name 'eml22__MolarEnergyUom' for type 'eml22:MolarEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUom (-1274)

#endif

/* eml22__MobilityUom has binding name 'eml22__MobilityUom' for type 'eml22:MobilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUom (-1273)

#endif

/* eml22__MassUom has binding name 'eml22__MassUom' for type 'eml22:MassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassUom (-1272)

#endif

/* eml22__MassPerVolumeUom has binding name 'eml22__MassPerVolumeUom' for type 'eml22:MassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUom (-1271)

#endif

/* eml22__MassPerVolumePerTemperatureUom has binding name 'eml22__MassPerVolumePerTemperatureUom' for type 'eml22:MassPerVolumePerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUom (-1270)

#endif

/* eml22__MassPerVolumePerPressureUom has binding name 'eml22__MassPerVolumePerPressureUom' for type 'eml22:MassPerVolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUom (-1269)

#endif

/* eml22__MassPerVolumePerLengthUom has binding name 'eml22__MassPerVolumePerLengthUom' for type 'eml22:MassPerVolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUom (-1268)

#endif

/* eml22__MassPerTimeUom has binding name 'eml22__MassPerTimeUom' for type 'eml22:MassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUom (-1267)

#endif

/* eml22__MassPerTimePerLengthUom has binding name 'eml22__MassPerTimePerLengthUom' for type 'eml22:MassPerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUom (-1266)

#endif

/* eml22__MassPerTimePerAreaUom has binding name 'eml22__MassPerTimePerAreaUom' for type 'eml22:MassPerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUom (-1265)

#endif

/* eml22__MassPerMassUom has binding name 'eml22__MassPerMassUom' for type 'eml22:MassPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUom (-1264)

#endif

/* eml22__MassPerLengthUom has binding name 'eml22__MassPerLengthUom' for type 'eml22:MassPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUom (-1263)

#endif

/* eml22__MassPerEnergyUom has binding name 'eml22__MassPerEnergyUom' for type 'eml22:MassPerEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUom (-1262)

#endif

/* eml22__MassPerAreaUom has binding name 'eml22__MassPerAreaUom' for type 'eml22:MassPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUom (-1261)

#endif

/* eml22__MassLengthUom has binding name 'eml22__MassLengthUom' for type 'eml22:MassLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUom (-1260)

#endif

/* eml22__MagneticVectorPotentialUom has binding name 'eml22__MagneticVectorPotentialUom' for type 'eml22:MagneticVectorPotentialUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUom (-1259)

#endif

/* eml22__MagneticPermeabilityUom has binding name 'eml22__MagneticPermeabilityUom' for type 'eml22:MagneticPermeabilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUom (-1258)

#endif

/* eml22__MagneticFluxUom has binding name 'eml22__MagneticFluxUom' for type 'eml22:MagneticFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUom (-1257)

#endif

/* eml22__MagneticFluxDensityUom has binding name 'eml22__MagneticFluxDensityUom' for type 'eml22:MagneticFluxDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUom (-1256)

#endif

/* eml22__MagneticFluxDensityPerLengthUom has binding name 'eml22__MagneticFluxDensityPerLengthUom' for type 'eml22:MagneticFluxDensityPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUom (-1255)

#endif

/* eml22__MagneticFieldStrengthUom has binding name 'eml22__MagneticFieldStrengthUom' for type 'eml22:MagneticFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUom (-1254)

#endif

/* eml22__MagneticDipoleMomentUom has binding name 'eml22__MagneticDipoleMomentUom' for type 'eml22:MagneticDipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUom (-1253)

#endif

/* eml22__LuminousIntensityUom has binding name 'eml22__LuminousIntensityUom' for type 'eml22:LuminousIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUom (-1252)

#endif

/* eml22__LuminousFluxUom has binding name 'eml22__LuminousFluxUom' for type 'eml22:LuminousFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUom (-1251)

#endif

/* eml22__LuminousEfficacyUom has binding name 'eml22__LuminousEfficacyUom' for type 'eml22:LuminousEfficacyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUom (-1250)

#endif

/* eml22__LuminanceUom has binding name 'eml22__LuminanceUom' for type 'eml22:LuminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUom (-1249)

#endif

/* eml22__LogarithmicPowerRatioUom has binding name 'eml22__LogarithmicPowerRatioUom' for type 'eml22:LogarithmicPowerRatioUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUom (-1248)

#endif

/* eml22__LogarithmicPowerRatioPerLengthUom has binding name 'eml22__LogarithmicPowerRatioPerLengthUom' for type 'eml22:LogarithmicPowerRatioPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUom (-1247)

#endif

/* eml22__LinearThermalExpansionUom has binding name 'eml22__LinearThermalExpansionUom' for type 'eml22:LinearThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUom (-1246)

#endif

/* eml22__LinearAccelerationUom has binding name 'eml22__LinearAccelerationUom' for type 'eml22:LinearAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUom (-1245)

#endif

/* eml22__LightExposureUom has binding name 'eml22__LightExposureUom' for type 'eml22:LightExposureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUom (-1244)

#endif

/* eml22__LengthUom has binding name 'eml22__LengthUom' for type 'eml22:LengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthUom (-1243)

#endif

/* eml22__LengthPerVolumeUom has binding name 'eml22__LengthPerVolumeUom' for type 'eml22:LengthPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUom (-1242)

#endif

/* eml22__LengthPerTimeUom has binding name 'eml22__LengthPerTimeUom' for type 'eml22:LengthPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUom (-1241)

#endif

/* eml22__LengthPerTemperatureUom has binding name 'eml22__LengthPerTemperatureUom' for type 'eml22:LengthPerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUom (-1240)

#endif

/* eml22__LengthPerPressureUom has binding name 'eml22__LengthPerPressureUom' for type 'eml22:LengthPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUom (-1239)

#endif

/* eml22__LengthPerMassUom has binding name 'eml22__LengthPerMassUom' for type 'eml22:LengthPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUom (-1238)

#endif

/* eml22__LengthPerLengthUom has binding name 'eml22__LengthPerLengthUom' for type 'eml22:LengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUom (-1237)

#endif

/* eml22__KinematicViscosityUom has binding name 'eml22__KinematicViscosityUom' for type 'eml22:KinematicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUom (-1236)

#endif

/* eml22__IsothermalCompressibilityUom has binding name 'eml22__IsothermalCompressibilityUom' for type 'eml22:IsothermalCompressibilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUom (-1235)

#endif

/* eml22__InductanceUom has binding name 'eml22__InductanceUom' for type 'eml22:InductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUom (-1234)

#endif

/* eml22__IlluminanceUom has binding name 'eml22__IlluminanceUom' for type 'eml22:IlluminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUom (-1233)

#endif

/* eml22__HeatTransferCoefficientUom has binding name 'eml22__HeatTransferCoefficientUom' for type 'eml22:HeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUom (-1232)

#endif

/* eml22__HeatFlowRateUom has binding name 'eml22__HeatFlowRateUom' for type 'eml22:HeatFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUom (-1231)

#endif

/* eml22__HeatCapacityUom has binding name 'eml22__HeatCapacityUom' for type 'eml22:HeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUom (-1230)

#endif

/* eml22__FrequencyUom has binding name 'eml22__FrequencyUom' for type 'eml22:FrequencyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUom (-1229)

#endif

/* eml22__FrequencyIntervalUom has binding name 'eml22__FrequencyIntervalUom' for type 'eml22:FrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUom (-1228)

#endif

/* eml22__ForceUom has binding name 'eml22__ForceUom' for type 'eml22:ForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceUom (-1227)

#endif

/* eml22__ForcePerVolumeUom has binding name 'eml22__ForcePerVolumeUom' for type 'eml22:ForcePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUom (-1226)

#endif

/* eml22__ForcePerLengthUom has binding name 'eml22__ForcePerLengthUom' for type 'eml22:ForcePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUom (-1225)

#endif

/* eml22__ForcePerForceUom has binding name 'eml22__ForcePerForceUom' for type 'eml22:ForcePerForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUom (-1224)

#endif

/* eml22__ForceLengthPerLengthUom has binding name 'eml22__ForceLengthPerLengthUom' for type 'eml22:ForceLengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUom (-1223)

#endif

/* eml22__ForceAreaUom has binding name 'eml22__ForceAreaUom' for type 'eml22:ForceAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUom (-1222)

#endif

/* eml22__EnergyUom has binding name 'eml22__EnergyUom' for type 'eml22:EnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUom (-1221)

#endif

/* eml22__EnergyPerVolumeUom has binding name 'eml22__EnergyPerVolumeUom' for type 'eml22:EnergyPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUom (-1220)

#endif

/* eml22__EnergyPerMassUom has binding name 'eml22__EnergyPerMassUom' for type 'eml22:EnergyPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUom (-1219)

#endif

/* eml22__EnergyPerMassPerTimeUom has binding name 'eml22__EnergyPerMassPerTimeUom' for type 'eml22:EnergyPerMassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUom (-1218)

#endif

/* eml22__EnergyPerLengthUom has binding name 'eml22__EnergyPerLengthUom' for type 'eml22:EnergyPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUom (-1217)

#endif

/* eml22__EnergyPerAreaUom has binding name 'eml22__EnergyPerAreaUom' for type 'eml22:EnergyPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUom (-1216)

#endif

/* eml22__EnergyLengthPerTimeAreaTemperatureUom has binding name 'eml22__EnergyLengthPerTimeAreaTemperatureUom' for type 'eml22:EnergyLengthPerTimeAreaTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUom (-1215)

#endif

/* eml22__EnergyLengthPerAreaUom has binding name 'eml22__EnergyLengthPerAreaUom' for type 'eml22:EnergyLengthPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUom (-1214)

#endif

/* eml22__ElectromagneticMomentUom has binding name 'eml22__ElectromagneticMomentUom' for type 'eml22:ElectromagneticMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUom (-1213)

#endif

/* eml22__ElectricResistanceUom has binding name 'eml22__ElectricResistanceUom' for type 'eml22:ElectricResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUom (-1212)

#endif

/* eml22__ElectricResistancePerLengthUom has binding name 'eml22__ElectricResistancePerLengthUom' for type 'eml22:ElectricResistancePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUom (-1211)

#endif

/* eml22__ElectricPotentialDifferenceUom has binding name 'eml22__ElectricPotentialDifferenceUom' for type 'eml22:ElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUom (-1210)

#endif

/* eml22__ElectricFieldStrengthUom has binding name 'eml22__ElectricFieldStrengthUom' for type 'eml22:ElectricFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUom (-1209)

#endif

/* eml22__ElectricCurrentUom has binding name 'eml22__ElectricCurrentUom' for type 'eml22:ElectricCurrentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUom (-1208)

#endif

/* eml22__ElectricCurrentDensityUom has binding name 'eml22__ElectricCurrentDensityUom' for type 'eml22:ElectricCurrentDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUom (-1207)

#endif

/* eml22__ElectricConductivityUom has binding name 'eml22__ElectricConductivityUom' for type 'eml22:ElectricConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUom (-1206)

#endif

/* eml22__ElectricConductanceUom has binding name 'eml22__ElectricConductanceUom' for type 'eml22:ElectricConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUom (-1205)

#endif

/* eml22__ElectricChargeUom has binding name 'eml22__ElectricChargeUom' for type 'eml22:ElectricChargeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUom (-1204)

#endif

/* eml22__ElectricChargePerVolumeUom has binding name 'eml22__ElectricChargePerVolumeUom' for type 'eml22:ElectricChargePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUom (-1203)

#endif

/* eml22__ElectricChargePerMassUom has binding name 'eml22__ElectricChargePerMassUom' for type 'eml22:ElectricChargePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUom (-1202)

#endif

/* eml22__ElectricChargePerAreaUom has binding name 'eml22__ElectricChargePerAreaUom' for type 'eml22:ElectricChargePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUom (-1201)

#endif

/* eml22__ElectricalResistivityUom has binding name 'eml22__ElectricalResistivityUom' for type 'eml22:ElectricalResistivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUom (-1200)

#endif

/* eml22__DynamicViscosityUom has binding name 'eml22__DynamicViscosityUom' for type 'eml22:DynamicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUom (-1199)

#endif

/* eml22__DoseEquivalentUom has binding name 'eml22__DoseEquivalentUom' for type 'eml22:DoseEquivalentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUom (-1198)

#endif

/* eml22__DipoleMomentUom has binding name 'eml22__DipoleMomentUom' for type 'eml22:DipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUom (-1197)

#endif

/* eml22__DimensionlessUom has binding name 'eml22__DimensionlessUom' for type 'eml22:DimensionlessUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUom (-1196)

#endif

/* eml22__DigitalStorageUom has binding name 'eml22__DigitalStorageUom' for type 'eml22:DigitalStorageUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUom (-1195)

#endif

/* eml22__DiffusiveTimeOfFlightUom has binding name 'eml22__DiffusiveTimeOfFlightUom' for type 'eml22:DiffusiveTimeOfFlightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUom (-1194)

#endif

/* eml22__DiffusionCoefficientUom has binding name 'eml22__DiffusionCoefficientUom' for type 'eml22:DiffusionCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUom (-1193)

#endif

/* eml22__DataTransferSpeedUom has binding name 'eml22__DataTransferSpeedUom' for type 'eml22:DataTransferSpeedUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUom (-1192)

#endif

/* eml22__CationExchangeCapacityUom has binding name 'eml22__CationExchangeCapacityUom' for type 'eml22:CationExchangeCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUom (-1191)

#endif

/* eml22__CapacitanceUom has binding name 'eml22__CapacitanceUom' for type 'eml22:CapacitanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUom (-1190)

#endif

/* eml22__AttenuationPerFrequencyIntervalUom has binding name 'eml22__AttenuationPerFrequencyIntervalUom' for type 'eml22:AttenuationPerFrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUom (-1189)

#endif

/* eml22__AreaUom has binding name 'eml22__AreaUom' for type 'eml22:AreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaUom (-1188)

#endif

/* eml22__AreaPerVolumeUom has binding name 'eml22__AreaPerVolumeUom' for type 'eml22:AreaPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUom (-1187)

#endif

/* eml22__AreaPerTimeUom has binding name 'eml22__AreaPerTimeUom' for type 'eml22:AreaPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUom (-1186)

#endif

/* eml22__AreaPerMassUom has binding name 'eml22__AreaPerMassUom' for type 'eml22:AreaPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUom (-1185)

#endif

/* eml22__AreaPerCountUom has binding name 'eml22__AreaPerCountUom' for type 'eml22:AreaPerCountUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUom (-1184)

#endif

/* eml22__AreaPerAreaUom has binding name 'eml22__AreaPerAreaUom' for type 'eml22:AreaPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUom (-1183)

#endif

/* eml22__AreaPerAmountOfSubstanceUom has binding name 'eml22__AreaPerAmountOfSubstanceUom' for type 'eml22:AreaPerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUom (-1182)

#endif

/* eml22__APINeutronUom has binding name 'eml22__APINeutronUom' for type 'eml22:APINeutronUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUom (-1181)

#endif

/* eml22__APIGravityUom has binding name 'eml22__APIGravityUom' for type 'eml22:APIGravityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUom (-1180)

#endif

/* eml22__APIGammaRayUom has binding name 'eml22__APIGammaRayUom' for type 'eml22:APIGammaRayUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUom (-1179)

#endif

/* eml22__AngularVelocityUom has binding name 'eml22__AngularVelocityUom' for type 'eml22:AngularVelocityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUom (-1178)

#endif

/* eml22__AngularAccelerationUom has binding name 'eml22__AngularAccelerationUom' for type 'eml22:AngularAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUom (-1177)

#endif

/* eml22__AnglePerVolumeUom has binding name 'eml22__AnglePerVolumeUom' for type 'eml22:AnglePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUom (-1176)

#endif

/* eml22__AnglePerLengthUom has binding name 'eml22__AnglePerLengthUom' for type 'eml22:AnglePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUom (-1175)

#endif

/* eml22__AmountOfSubstanceUom has binding name 'eml22__AmountOfSubstanceUom' for type 'eml22:AmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUom (-1174)

#endif

/* eml22__AmountOfSubstancePerVolumeUom has binding name 'eml22__AmountOfSubstancePerVolumeUom' for type 'eml22:AmountOfSubstancePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUom (-1173)

#endif

/* eml22__AmountOfSubstancePerTimeUom has binding name 'eml22__AmountOfSubstancePerTimeUom' for type 'eml22:AmountOfSubstancePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUom (-1172)

#endif

/* eml22__AmountOfSubstancePerTimePerAreaUom has binding name 'eml22__AmountOfSubstancePerTimePerAreaUom' for type 'eml22:AmountOfSubstancePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUom (-1171)

#endif

/* eml22__AmountOfSubstancePerAreaUom has binding name 'eml22__AmountOfSubstancePerAreaUom' for type 'eml22:AmountOfSubstancePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUom (-1170)

#endif

/* eml22__AmountOfSubstancePerAmountOfSubstanceUom has binding name 'eml22__AmountOfSubstancePerAmountOfSubstanceUom' for type 'eml22:AmountOfSubstancePerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUom (-1169)

#endif

/* eml22__ActivityOfRadioactivityUom has binding name 'eml22__ActivityOfRadioactivityUom' for type 'eml22:ActivityOfRadioactivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUom (-1168)

#endif

/* eml22__AbsorbedDoseUom has binding name 'eml22__AbsorbedDoseUom' for type 'eml22:AbsorbedDoseUom' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUom (-1167)

#endif

/* eml22__UnitOfMeasure has binding name 'eml22__UnitOfMeasure' for type 'eml22:UnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasure (-1164)

#endif

/* eml22__LegacyUnitOfMeasure has binding name 'eml22__LegacyUnitOfMeasure' for type 'eml22:LegacyUnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LegacyUnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LegacyUnitOfMeasure (-1163)

#endif

/* eml22__AxisDirectionKind has binding name 'eml22__AxisDirectionKind' for type 'eml22:AxisDirectionKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AxisDirectionKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__AxisDirectionKind (-1155)

#endif

/* eml22__NorthReferenceKind has binding name 'eml22__NorthReferenceKind' for type 'eml22:NorthReferenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NorthReferenceKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__NorthReferenceKind (-1146)

#endif

/* eml22__GrowingStatusKind has binding name 'eml22__GrowingStatusKind' for type 'eml22:GrowingStatusKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GrowingStatusKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__GrowingStatusKind (-1145)

#endif

/* _eml22__GraphicalInformationSet has binding name '_eml22__GraphicalInformationSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_2__eml22__GraphicalInformationSet (-2104)

#endif

/* _eml22__DataAssuranceRecord has binding name '_eml22__DataAssuranceRecord' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_2__eml22__DataAssuranceRecord (-2103)

#endif

/* _eml22__ActivityTemplate has binding name '_eml22__ActivityTemplate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_2__eml22__ActivityTemplate (-2102)

#endif

/* _eml22__Activity has binding name '_eml22__Activity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__Activity
#define SOAP_TYPE_gsoap_eml2_2__eml22__Activity (-2101)

#endif

/* _eml22__EpcExternalPartReference has binding name '_eml22__EpcExternalPartReference' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_2__eml22__EpcExternalPartReference (-2100)

#endif

/* _eml22__TimeSeries has binding name '_eml22__TimeSeries' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__TimeSeries
#define SOAP_TYPE_gsoap_eml2_2__eml22__TimeSeries (-2099)

#endif

/* _eml22__PropertyKindDictionary has binding name '_eml22__PropertyKindDictionary' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKindDictionary (-2098)

#endif

/* _eml22__PropertyKind has binding name '_eml22__PropertyKind' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2__eml22__PropertyKind (-2097)

#endif

/* _prodml21__TimeSeriesData has binding name '_prodml21__TimeSeriesData' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__TimeSeriesData
#define SOAP_TYPE_gsoap_eml2_2__prodml21__TimeSeriesData (-2096)

#endif

/* _prodml21__ReportingHierarchy has binding name '_prodml21__ReportingHierarchy' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingHierarchy
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingHierarchy (-2095)

#endif

/* _prodml21__ReportingEntity has binding name '_prodml21__ReportingEntity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingEntity
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ReportingEntity (-2094)

#endif

/* _prodml21__Facility has binding name '_prodml21__Facility' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Facility
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Facility (-2093)

#endif

/* _prodml21__PtaDeconvolution has binding name '_prodml21__PtaDeconvolution' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDeconvolution
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDeconvolution (-2092)

#endif

/* _prodml21__PtaDataPreProcess has binding name '_prodml21__PtaDataPreProcess' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDataPreProcess
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PtaDataPreProcess (-2091)

#endif

/* _prodml21__PressureTransientAnalysis has binding name '_prodml21__PressureTransientAnalysis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__PressureTransientAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__PressureTransientAnalysis (-2090)

#endif

/* _prodml21__FlowTestActivity has binding name '_prodml21__FlowTestActivity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FlowTestActivity
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FlowTestActivity (-2089)

#endif

/* _prodml21__ChannelSet has binding name '_prodml21__ChannelSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ChannelSet
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ChannelSet (-2088)

#endif

/* _prodml21__Channel has binding name '_prodml21__Channel' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Channel (-2087)

#endif

/* _prodml21__WellProductionParameters has binding name '_prodml21__WellProductionParameters' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WellProductionParameters
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WellProductionParameters (-2086)

#endif

/* _prodml21__Transfer has binding name '_prodml21__Transfer' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__Transfer
#define SOAP_TYPE_gsoap_eml2_2__prodml21__Transfer (-2085)

#endif

/* _prodml21__TerminalLifting has binding name '_prodml21__TerminalLifting' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__TerminalLifting
#define SOAP_TYPE_gsoap_eml2_2__prodml21__TerminalLifting (-2084)

#endif

/* _prodml21__ProductionWellTests has binding name '_prodml21__ProductionWellTests' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductionWellTests
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductionWellTests (-2083)

#endif

/* _prodml21__AssetProductionVolumes has binding name '_prodml21__AssetProductionVolumes' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__AssetProductionVolumes
#define SOAP_TYPE_gsoap_eml2_2__prodml21__AssetProductionVolumes (-2082)

#endif

/* _prodml21__WftRun has binding name '_prodml21__WftRun' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WftRun
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WftRun (-2081)

#endif

/* _prodml21__FluidSampleAcquisitionJob has binding name '_prodml21__FluidSampleAcquisitionJob' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleAcquisitionJob (-2080)

#endif

/* _prodml21__FluidSampleContainer has binding name '_prodml21__FluidSampleContainer' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleContainer
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSampleContainer (-2079)

#endif

/* _prodml21__FluidSample has binding name '_prodml21__FluidSample' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSample
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSample (-2078)

#endif

/* _prodml21__WaterAnalysis has binding name '_prodml21__WaterAnalysis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__WaterAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__WaterAnalysis (-2077)

#endif

/* _prodml21__HydrocarbonAnalysis has binding name '_prodml21__HydrocarbonAnalysis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__HydrocarbonAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__HydrocarbonAnalysis (-2076)

#endif

/* _prodml21__FluidAnalysis has binding name '_prodml21__FluidAnalysis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidAnalysis
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidAnalysis (-2075)

#endif

/* _prodml21__FluidSystem has binding name '_prodml21__FluidSystem' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSystem
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidSystem (-2074)

#endif

/* _prodml21__ProductFlowModel has binding name '_prodml21__ProductFlowModel' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductFlowModel (-2073)

#endif

/* _prodml21__ProductVolume has binding name '_prodml21__ProductVolume' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__ProductVolume
#define SOAP_TYPE_gsoap_eml2_2__prodml21__ProductVolume (-2072)

#endif

/* _prodml21__FluidCharacterization has binding name '_prodml21__FluidCharacterization' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__prodml21__FluidCharacterization
#define SOAP_TYPE_gsoap_eml2_2__prodml21__FluidCharacterization (-2071)

#endif

/* eml22__SectionNumber has binding name 'eml22__SectionNumber' for type 'eml22:SectionNumber' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SectionNumber
#define SOAP_TYPE_gsoap_eml2_2_eml22__SectionNumber (-1359)

#endif

/* eml22__PublicLandSurveySystemQuarterTownship has binding name 'eml22__PublicLandSurveySystemQuarterTownship' for type 'eml22:PublicLandSurveySystemQuarterTownship' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterTownship (-1358)

#endif

/* eml22__PublicLandSurveySystemQuarterSection has binding name 'eml22__PublicLandSurveySystemQuarterSection' for type 'eml22:PublicLandSurveySystemQuarterSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystemQuarterSection (-1357)

#endif

/* eml22__TypeEnum has binding name 'eml22__TypeEnum' for type 'eml22:TypeEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TypeEnum
#define SOAP_TYPE_gsoap_eml2_2_eml22__TypeEnum (-1166)

#endif

/* eml22__TimeZone has binding name 'eml22__TimeZone' for type 'eml22:TimeZone' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeZone
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeZone (-1165)

#endif

/* prodml21__CalendarMonth has binding name 'prodml21__CalendarMonth' for type 'prodml21:CalendarMonth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalendarMonth (-1162)

#endif

/* eml22__UuidString has binding name 'eml22__UuidString' for type 'eml22:UuidString' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UuidString
#define SOAP_TYPE_gsoap_eml2_2_eml22__UuidString (-1161)

#endif

/* eml22__UomEnum has binding name 'eml22__UomEnum' for type 'eml22:UomEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UomEnum
#define SOAP_TYPE_gsoap_eml2_2_eml22__UomEnum (-1160)

#endif

/* eml22__String64 has binding name 'eml22__String64' for type 'eml22:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String64
#define SOAP_TYPE_gsoap_eml2_2_eml22__String64 (-1159)

#endif

/* eml22__String256 has binding name 'eml22__String256' for type 'eml22:String256' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String256
#define SOAP_TYPE_gsoap_eml2_2_eml22__String256 (-1158)

#endif

/* eml22__String2000 has binding name 'eml22__String2000' for type 'eml22:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__String2000
#define SOAP_TYPE_gsoap_eml2_2_eml22__String2000 (-1157)

#endif

/* eml22__EnumExtensionPattern has binding name 'eml22__EnumExtensionPattern' for type 'eml22:EnumExtensionPattern' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnumExtensionPattern (-1156)

#endif

/* eml22__AbstractString has binding name 'eml22__AbstractString' for type 'eml22:AbstractString' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractString
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractString (-1149)

#endif

/* prodml21__ProdmlRelativeIdentifier has binding name 'prodml21__ProdmlRelativeIdentifier' for type 'prodml21:ProdmlRelativeIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProdmlRelativeIdentifier (-1144)

#endif

/* eml22__VolumeUomWithLegacy has binding name 'eml22__VolumeUomWithLegacy' for type 'eml22:VolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomWithLegacy (-1140)

#endif

/* eml22__VolumePerVolumeUomWithLegacy has binding name 'eml22__VolumePerVolumeUomWithLegacy' for type 'eml22:VolumePerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomWithLegacy (-1139)

#endif

/* eml22__VolumePerTimeUomWithLegacy has binding name 'eml22__VolumePerTimeUomWithLegacy' for type 'eml22:VolumePerTimeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomWithLegacy (-1138)

#endif

/* eml22__VolumePerAreaUomWithLegacy has binding name 'eml22__VolumePerAreaUomWithLegacy' for type 'eml22:VolumePerAreaUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomWithLegacy (-1137)

#endif

/* eml22__PressureUomWithLegacy has binding name 'eml22__PressureUomWithLegacy' for type 'eml22:PressureUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomWithLegacy (-1136)

#endif

/* eml22__PressurePerVolumeUomWithLegacy has binding name 'eml22__PressurePerVolumeUomWithLegacy' for type 'eml22:PressurePerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomWithLegacy (-1135)

#endif

/* eml22__MassPerVolumeUomWithLegacy has binding name 'eml22__MassPerVolumeUomWithLegacy' for type 'eml22:MassPerVolumeUomWithLegacy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomWithLegacy
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomWithLegacy (-1134)

#endif

/* eml22__VolumeUomExt has binding name 'eml22__VolumeUomExt' for type 'eml22:VolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeUomExt (-1133)

#endif

/* eml22__VolumetricThermalExpansionUomExt has binding name 'eml22__VolumetricThermalExpansionUomExt' for type 'eml22:VolumetricThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionUomExt (-1132)

#endif

/* eml22__VolumetricHeatTransferCoefficientUomExt has binding name 'eml22__VolumetricHeatTransferCoefficientUomExt' for type 'eml22:VolumetricHeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientUomExt (-1131)

#endif

/* eml22__VolumePerVolumeUomExt has binding name 'eml22__VolumePerVolumeUomExt' for type 'eml22:VolumePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeUomExt (-1130)

#endif

/* eml22__VolumePerTimeUomExt has binding name 'eml22__VolumePerTimeUomExt' for type 'eml22:VolumePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeUomExt (-1129)

#endif

/* eml22__VolumePerTimePerVolumeUomExt has binding name 'eml22__VolumePerTimePerVolumeUomExt' for type 'eml22:VolumePerTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeUomExt (-1128)

#endif

/* eml22__VolumePerTimePerTimeUomExt has binding name 'eml22__VolumePerTimePerTimeUomExt' for type 'eml22:VolumePerTimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeUomExt (-1127)

#endif

/* eml22__VolumePerTimePerPressureUomExt has binding name 'eml22__VolumePerTimePerPressureUomExt' for type 'eml22:VolumePerTimePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureUomExt (-1126)

#endif

/* eml22__VolumePerTimePerPressureLengthUomExt has binding name 'eml22__VolumePerTimePerPressureLengthUomExt' for type 'eml22:VolumePerTimePerPressureLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthUomExt (-1125)

#endif

/* eml22__VolumePerTimePerLengthUomExt has binding name 'eml22__VolumePerTimePerLengthUomExt' for type 'eml22:VolumePerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthUomExt (-1124)

#endif

/* eml22__VolumePerTimePerAreaUomExt has binding name 'eml22__VolumePerTimePerAreaUomExt' for type 'eml22:VolumePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaUomExt (-1123)

#endif

/* eml22__VolumePerTimeLengthUomExt has binding name 'eml22__VolumePerTimeLengthUomExt' for type 'eml22:VolumePerTimeLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthUomExt (-1122)

#endif

/* eml22__VolumePerRotationUomExt has binding name 'eml22__VolumePerRotationUomExt' for type 'eml22:VolumePerRotationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationUomExt (-1121)

#endif

/* eml22__VolumePerPressureUomExt has binding name 'eml22__VolumePerPressureUomExt' for type 'eml22:VolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureUomExt (-1120)

#endif

/* eml22__VolumePerMassUomExt has binding name 'eml22__VolumePerMassUomExt' for type 'eml22:VolumePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassUomExt (-1119)

#endif

/* eml22__VolumePerLengthUomExt has binding name 'eml22__VolumePerLengthUomExt' for type 'eml22:VolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthUomExt (-1118)

#endif

/* eml22__VolumePerAreaUomExt has binding name 'eml22__VolumePerAreaUomExt' for type 'eml22:VolumePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaUomExt (-1117)

#endif

/* eml22__VolumeFlowRatePerVolumeFlowRateUomExt has binding name 'eml22__VolumeFlowRatePerVolumeFlowRateUomExt' for type 'eml22:VolumeFlowRatePerVolumeFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateUomExt (-1116)

#endif

/* eml22__VerticalCoordinateUomExt has binding name 'eml22__VerticalCoordinateUomExt' for type 'eml22:VerticalCoordinateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateUomExt (-1115)

#endif

/* eml22__TimeUomExt has binding name 'eml22__TimeUomExt' for type 'eml22:TimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeUomExt (-1114)

#endif

/* eml22__TimePerVolumeUomExt has binding name 'eml22__TimePerVolumeUomExt' for type 'eml22:TimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeUomExt (-1113)

#endif

/* eml22__TimePerTimeUomExt has binding name 'eml22__TimePerTimeUomExt' for type 'eml22:TimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeUomExt (-1112)

#endif

/* eml22__TimePerMassUomExt has binding name 'eml22__TimePerMassUomExt' for type 'eml22:TimePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassUomExt (-1111)

#endif

/* eml22__TimePerLengthUomExt has binding name 'eml22__TimePerLengthUomExt' for type 'eml22:TimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthUomExt (-1110)

#endif

/* eml22__ThermodynamicTemperatureUomExt has binding name 'eml22__ThermodynamicTemperatureUomExt' for type 'eml22:ThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureUomExt (-1109)

#endif

/* eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt has binding name 'eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' for type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (-1108)

#endif

/* eml22__ThermalResistanceUomExt has binding name 'eml22__ThermalResistanceUomExt' for type 'eml22:ThermalResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceUomExt (-1107)

#endif

/* eml22__ThermalInsulanceUomExt has binding name 'eml22__ThermalInsulanceUomExt' for type 'eml22:ThermalInsulanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceUomExt (-1106)

#endif

/* eml22__ThermalDiffusivityUomExt has binding name 'eml22__ThermalDiffusivityUomExt' for type 'eml22:ThermalDiffusivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityUomExt (-1105)

#endif

/* eml22__ThermalConductivityUomExt has binding name 'eml22__ThermalConductivityUomExt' for type 'eml22:ThermalConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityUomExt (-1104)

#endif

/* eml22__ThermalConductanceUomExt has binding name 'eml22__ThermalConductanceUomExt' for type 'eml22:ThermalConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceUomExt (-1103)

#endif

/* eml22__TemperatureIntervalUomExt has binding name 'eml22__TemperatureIntervalUomExt' for type 'eml22:TemperatureIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalUomExt (-1102)

#endif

/* eml22__TemperatureIntervalPerTimeUomExt has binding name 'eml22__TemperatureIntervalPerTimeUomExt' for type 'eml22:TemperatureIntervalPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeUomExt (-1101)

#endif

/* eml22__TemperatureIntervalPerPressureUomExt has binding name 'eml22__TemperatureIntervalPerPressureUomExt' for type 'eml22:TemperatureIntervalPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureUomExt (-1100)

#endif

/* eml22__TemperatureIntervalPerLengthUomExt has binding name 'eml22__TemperatureIntervalPerLengthUomExt' for type 'eml22:TemperatureIntervalPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthUomExt (-1099)

#endif

/* eml22__SpecificHeatCapacityUomExt has binding name 'eml22__SpecificHeatCapacityUomExt' for type 'eml22:SpecificHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityUomExt (-1098)

#endif

/* eml22__SolidAngleUomExt has binding name 'eml22__SolidAngleUomExt' for type 'eml22:SolidAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleUomExt (-1097)

#endif

/* eml22__SignalingEventPerTimeUomExt has binding name 'eml22__SignalingEventPerTimeUomExt' for type 'eml22:SignalingEventPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeUomExt (-1096)

#endif

/* eml22__SecondMomentOfAreaUomExt has binding name 'eml22__SecondMomentOfAreaUomExt' for type 'eml22:SecondMomentOfAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaUomExt (-1095)

#endif

/* eml22__ReluctanceUomExt has binding name 'eml22__ReluctanceUomExt' for type 'eml22:ReluctanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceUomExt (-1094)

#endif

/* eml22__ReciprocalVolumeUomExt has binding name 'eml22__ReciprocalVolumeUomExt' for type 'eml22:ReciprocalVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeUomExt (-1093)

#endif

/* eml22__ReciprocalTimeUomExt has binding name 'eml22__ReciprocalTimeUomExt' for type 'eml22:ReciprocalTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeUomExt (-1092)

#endif

/* eml22__ReciprocalPressureUomExt has binding name 'eml22__ReciprocalPressureUomExt' for type 'eml22:ReciprocalPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureUomExt (-1091)

#endif

/* eml22__ReciprocalMassUomExt has binding name 'eml22__ReciprocalMassUomExt' for type 'eml22:ReciprocalMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassUomExt (-1090)

#endif

/* eml22__ReciprocalMassTimeUomExt has binding name 'eml22__ReciprocalMassTimeUomExt' for type 'eml22:ReciprocalMassTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeUomExt (-1089)

#endif

/* eml22__ReciprocalLengthUomExt has binding name 'eml22__ReciprocalLengthUomExt' for type 'eml22:ReciprocalLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthUomExt (-1088)

#endif

/* eml22__ReciprocalForceUomExt has binding name 'eml22__ReciprocalForceUomExt' for type 'eml22:ReciprocalForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceUomExt (-1087)

#endif

/* eml22__ReciprocalElectricPotentialDifferenceUomExt has binding name 'eml22__ReciprocalElectricPotentialDifferenceUomExt' for type 'eml22:ReciprocalElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceUomExt (-1086)

#endif

/* eml22__ReciprocalAreaUomExt has binding name 'eml22__ReciprocalAreaUomExt' for type 'eml22:ReciprocalAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaUomExt (-1085)

#endif

/* eml22__RadiantIntensityUomExt has binding name 'eml22__RadiantIntensityUomExt' for type 'eml22:RadiantIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityUomExt (-1084)

#endif

/* eml22__RadianceUomExt has binding name 'eml22__RadianceUomExt' for type 'eml22:RadianceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceUomExt (-1083)

#endif

/* eml22__QuantityOfLightUomExt has binding name 'eml22__QuantityOfLightUomExt' for type 'eml22:QuantityOfLightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightUomExt (-1082)

#endif

/* eml22__PressureUomExt has binding name 'eml22__PressureUomExt' for type 'eml22:PressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureUomExt (-1081)

#endif

/* eml22__PressureTimePerVolumeUomExt has binding name 'eml22__PressureTimePerVolumeUomExt' for type 'eml22:PressureTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeUomExt (-1080)

#endif

/* eml22__PressureSquaredUomExt has binding name 'eml22__PressureSquaredUomExt' for type 'eml22:PressureSquaredUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredUomExt (-1079)

#endif

/* eml22__PressureSquaredPerForceTimePerAreaUomExt has binding name 'eml22__PressureSquaredPerForceTimePerAreaUomExt' for type 'eml22:PressureSquaredPerForceTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaUomExt (-1078)

#endif

/* eml22__PressurePerVolumeUomExt has binding name 'eml22__PressurePerVolumeUomExt' for type 'eml22:PressurePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeUomExt (-1077)

#endif

/* eml22__PressurePerTimeUomExt has binding name 'eml22__PressurePerTimeUomExt' for type 'eml22:PressurePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeUomExt (-1076)

#endif

/* eml22__PressurePerPressureUomExt has binding name 'eml22__PressurePerPressureUomExt' for type 'eml22:PressurePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureUomExt (-1075)

#endif

/* eml22__PowerUomExt has binding name 'eml22__PowerUomExt' for type 'eml22:PowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerUomExt (-1074)

#endif

/* eml22__PowerPerVolumeUomExt has binding name 'eml22__PowerPerVolumeUomExt' for type 'eml22:PowerPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeUomExt (-1073)

#endif

/* eml22__PowerPerPowerUomExt has binding name 'eml22__PowerPerPowerUomExt' for type 'eml22:PowerPerPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerUomExt (-1072)

#endif

/* eml22__PowerPerAreaUomExt has binding name 'eml22__PowerPerAreaUomExt' for type 'eml22:PowerPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaUomExt (-1071)

#endif

/* eml22__PotentialDifferencePerPowerDropUomExt has binding name 'eml22__PotentialDifferencePerPowerDropUomExt' for type 'eml22:PotentialDifferencePerPowerDropUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropUomExt (-1070)

#endif

/* eml22__PlaneAngleUomExt has binding name 'eml22__PlaneAngleUomExt' for type 'eml22:PlaneAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleUomExt (-1069)

#endif

/* eml22__PermittivityUomExt has binding name 'eml22__PermittivityUomExt' for type 'eml22:PermittivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityUomExt (-1068)

#endif

/* eml22__PermeabilityRockUomExt has binding name 'eml22__PermeabilityRockUomExt' for type 'eml22:PermeabilityRockUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockUomExt (-1067)

#endif

/* eml22__PermeabilityLengthUomExt has binding name 'eml22__PermeabilityLengthUomExt' for type 'eml22:PermeabilityLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthUomExt (-1066)

#endif

/* eml22__NormalizedPowerUomExt has binding name 'eml22__NormalizedPowerUomExt' for type 'eml22:NormalizedPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerUomExt (-1065)

#endif

/* eml22__MomentumUomExt has binding name 'eml22__MomentumUomExt' for type 'eml22:MomentumUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumUomExt (-1064)

#endif

/* eml22__MomentOfInertiaUomExt has binding name 'eml22__MomentOfInertiaUomExt' for type 'eml22:MomentOfInertiaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaUomExt (-1063)

#endif

/* eml22__MomentOfForceUomExt has binding name 'eml22__MomentOfForceUomExt' for type 'eml22:MomentOfForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceUomExt (-1062)

#endif

/* eml22__MolecularWeightUomExt has binding name 'eml22__MolecularWeightUomExt' for type 'eml22:MolecularWeightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightUomExt (-1061)

#endif

/* eml22__MolarVolumeUomExt has binding name 'eml22__MolarVolumeUomExt' for type 'eml22:MolarVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeUomExt (-1060)

#endif

/* eml22__MolarHeatCapacityUomExt has binding name 'eml22__MolarHeatCapacityUomExt' for type 'eml22:MolarHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityUomExt (-1059)

#endif

/* eml22__MolarEnergyUomExt has binding name 'eml22__MolarEnergyUomExt' for type 'eml22:MolarEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyUomExt (-1058)

#endif

/* eml22__MobilityUomExt has binding name 'eml22__MobilityUomExt' for type 'eml22:MobilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityUomExt (-1057)

#endif

/* eml22__MassUomExt has binding name 'eml22__MassUomExt' for type 'eml22:MassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassUomExt (-1056)

#endif

/* eml22__MassPerVolumeUomExt has binding name 'eml22__MassPerVolumeUomExt' for type 'eml22:MassPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeUomExt (-1055)

#endif

/* eml22__MassPerVolumePerTemperatureUomExt has binding name 'eml22__MassPerVolumePerTemperatureUomExt' for type 'eml22:MassPerVolumePerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureUomExt (-1054)

#endif

/* eml22__MassPerVolumePerPressureUomExt has binding name 'eml22__MassPerVolumePerPressureUomExt' for type 'eml22:MassPerVolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureUomExt (-1053)

#endif

/* eml22__MassPerVolumePerLengthUomExt has binding name 'eml22__MassPerVolumePerLengthUomExt' for type 'eml22:MassPerVolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthUomExt (-1052)

#endif

/* eml22__MassPerTimeUomExt has binding name 'eml22__MassPerTimeUomExt' for type 'eml22:MassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeUomExt (-1051)

#endif

/* eml22__MassPerTimePerLengthUomExt has binding name 'eml22__MassPerTimePerLengthUomExt' for type 'eml22:MassPerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthUomExt (-1050)

#endif

/* eml22__MassPerTimePerAreaUomExt has binding name 'eml22__MassPerTimePerAreaUomExt' for type 'eml22:MassPerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaUomExt (-1049)

#endif

/* eml22__MassPerMassUomExt has binding name 'eml22__MassPerMassUomExt' for type 'eml22:MassPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassUomExt (-1048)

#endif

/* eml22__MassPerLengthUomExt has binding name 'eml22__MassPerLengthUomExt' for type 'eml22:MassPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthUomExt (-1047)

#endif

/* eml22__MassPerEnergyUomExt has binding name 'eml22__MassPerEnergyUomExt' for type 'eml22:MassPerEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyUomExt (-1046)

#endif

/* eml22__MassPerAreaUomExt has binding name 'eml22__MassPerAreaUomExt' for type 'eml22:MassPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaUomExt (-1045)

#endif

/* eml22__MassLengthUomExt has binding name 'eml22__MassLengthUomExt' for type 'eml22:MassLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthUomExt (-1044)

#endif

/* eml22__MagneticVectorPotentialUomExt has binding name 'eml22__MagneticVectorPotentialUomExt' for type 'eml22:MagneticVectorPotentialUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialUomExt (-1043)

#endif

/* eml22__MagneticPermeabilityUomExt has binding name 'eml22__MagneticPermeabilityUomExt' for type 'eml22:MagneticPermeabilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityUomExt (-1042)

#endif

/* eml22__MagneticFluxUomExt has binding name 'eml22__MagneticFluxUomExt' for type 'eml22:MagneticFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxUomExt (-1041)

#endif

/* eml22__MagneticFluxDensityUomExt has binding name 'eml22__MagneticFluxDensityUomExt' for type 'eml22:MagneticFluxDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityUomExt (-1040)

#endif

/* eml22__MagneticFluxDensityPerLengthUomExt has binding name 'eml22__MagneticFluxDensityPerLengthUomExt' for type 'eml22:MagneticFluxDensityPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthUomExt (-1039)

#endif

/* eml22__MagneticFieldStrengthUomExt has binding name 'eml22__MagneticFieldStrengthUomExt' for type 'eml22:MagneticFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthUomExt (-1038)

#endif

/* eml22__MagneticDipoleMomentUomExt has binding name 'eml22__MagneticDipoleMomentUomExt' for type 'eml22:MagneticDipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentUomExt (-1037)

#endif

/* eml22__LuminousIntensityUomExt has binding name 'eml22__LuminousIntensityUomExt' for type 'eml22:LuminousIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityUomExt (-1036)

#endif

/* eml22__LuminousFluxUomExt has binding name 'eml22__LuminousFluxUomExt' for type 'eml22:LuminousFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxUomExt (-1035)

#endif

/* eml22__LuminousEfficacyUomExt has binding name 'eml22__LuminousEfficacyUomExt' for type 'eml22:LuminousEfficacyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyUomExt (-1034)

#endif

/* eml22__LuminanceUomExt has binding name 'eml22__LuminanceUomExt' for type 'eml22:LuminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceUomExt (-1033)

#endif

/* eml22__LogarithmicPowerRatioUomExt has binding name 'eml22__LogarithmicPowerRatioUomExt' for type 'eml22:LogarithmicPowerRatioUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioUomExt (-1032)

#endif

/* eml22__LogarithmicPowerRatioPerLengthUomExt has binding name 'eml22__LogarithmicPowerRatioPerLengthUomExt' for type 'eml22:LogarithmicPowerRatioPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthUomExt (-1031)

#endif

/* eml22__LinearThermalExpansionUomExt has binding name 'eml22__LinearThermalExpansionUomExt' for type 'eml22:LinearThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionUomExt (-1030)

#endif

/* eml22__LinearAccelerationUomExt has binding name 'eml22__LinearAccelerationUomExt' for type 'eml22:LinearAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationUomExt (-1029)

#endif

/* eml22__LightExposureUomExt has binding name 'eml22__LightExposureUomExt' for type 'eml22:LightExposureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureUomExt (-1028)

#endif

/* eml22__LengthUomExt has binding name 'eml22__LengthUomExt' for type 'eml22:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthUomExt (-1027)

#endif

/* eml22__LengthPerVolumeUomExt has binding name 'eml22__LengthPerVolumeUomExt' for type 'eml22:LengthPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeUomExt (-1026)

#endif

/* eml22__LengthPerTimeUomExt has binding name 'eml22__LengthPerTimeUomExt' for type 'eml22:LengthPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeUomExt (-1025)

#endif

/* eml22__LengthPerTemperatureUomExt has binding name 'eml22__LengthPerTemperatureUomExt' for type 'eml22:LengthPerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureUomExt (-1024)

#endif

/* eml22__LengthPerPressureUomExt has binding name 'eml22__LengthPerPressureUomExt' for type 'eml22:LengthPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureUomExt (-1023)

#endif

/* eml22__LengthPerMassUomExt has binding name 'eml22__LengthPerMassUomExt' for type 'eml22:LengthPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassUomExt (-1022)

#endif

/* eml22__LengthPerLengthUomExt has binding name 'eml22__LengthPerLengthUomExt' for type 'eml22:LengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthUomExt (-1021)

#endif

/* eml22__LengthAndTimeUomExt has binding name 'eml22__LengthAndTimeUomExt' for type 'eml22:LengthAndTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthAndTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthAndTimeUomExt (-1020)

#endif

/* eml22__KinematicViscosityUomExt has binding name 'eml22__KinematicViscosityUomExt' for type 'eml22:KinematicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityUomExt (-1019)

#endif

/* eml22__IsothermalCompressibilityUomExt has binding name 'eml22__IsothermalCompressibilityUomExt' for type 'eml22:IsothermalCompressibilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityUomExt (-1018)

#endif

/* eml22__InductanceUomExt has binding name 'eml22__InductanceUomExt' for type 'eml22:InductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceUomExt (-1017)

#endif

/* eml22__IlluminanceUomExt has binding name 'eml22__IlluminanceUomExt' for type 'eml22:IlluminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceUomExt (-1016)

#endif

/* eml22__HeatTransferCoefficientUomExt has binding name 'eml22__HeatTransferCoefficientUomExt' for type 'eml22:HeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientUomExt (-1015)

#endif

/* eml22__HeatFlowRateUomExt has binding name 'eml22__HeatFlowRateUomExt' for type 'eml22:HeatFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateUomExt (-1014)

#endif

/* eml22__HeatCapacityUomExt has binding name 'eml22__HeatCapacityUomExt' for type 'eml22:HeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityUomExt (-1013)

#endif

/* eml22__FrequencyUomExt has binding name 'eml22__FrequencyUomExt' for type 'eml22:FrequencyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyUomExt (-1012)

#endif

/* eml22__FrequencyIntervalUomExt has binding name 'eml22__FrequencyIntervalUomExt' for type 'eml22:FrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalUomExt (-1011)

#endif

/* eml22__ForceUomExt has binding name 'eml22__ForceUomExt' for type 'eml22:ForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceUomExt (-1010)

#endif

/* eml22__ForcePerVolumeUomExt has binding name 'eml22__ForcePerVolumeUomExt' for type 'eml22:ForcePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeUomExt (-1009)

#endif

/* eml22__ForcePerLengthUomExt has binding name 'eml22__ForcePerLengthUomExt' for type 'eml22:ForcePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthUomExt (-1008)

#endif

/* eml22__ForcePerForceUomExt has binding name 'eml22__ForcePerForceUomExt' for type 'eml22:ForcePerForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceUomExt (-1007)

#endif

/* eml22__ForceLengthPerLengthUomExt has binding name 'eml22__ForceLengthPerLengthUomExt' for type 'eml22:ForceLengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthUomExt (-1006)

#endif

/* eml22__ForceAreaUomExt has binding name 'eml22__ForceAreaUomExt' for type 'eml22:ForceAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaUomExt (-1005)

#endif

/* eml22__EnergyUomExt has binding name 'eml22__EnergyUomExt' for type 'eml22:EnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyUomExt (-1004)

#endif

/* eml22__EnergyPerVolumeUomExt has binding name 'eml22__EnergyPerVolumeUomExt' for type 'eml22:EnergyPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeUomExt (-1003)

#endif

/* eml22__EnergyPerMassUomExt has binding name 'eml22__EnergyPerMassUomExt' for type 'eml22:EnergyPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassUomExt (-1002)

#endif

/* eml22__EnergyPerMassPerTimeUomExt has binding name 'eml22__EnergyPerMassPerTimeUomExt' for type 'eml22:EnergyPerMassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeUomExt (-1001)

#endif

/* eml22__EnergyPerLengthUomExt has binding name 'eml22__EnergyPerLengthUomExt' for type 'eml22:EnergyPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthUomExt (-1000)

#endif

/* eml22__EnergyPerAreaUomExt has binding name 'eml22__EnergyPerAreaUomExt' for type 'eml22:EnergyPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaUomExt (-999)

#endif

/* eml22__EnergyLengthPerTimeAreaTemperatureUomExt has binding name 'eml22__EnergyLengthPerTimeAreaTemperatureUomExt' for type 'eml22:EnergyLengthPerTimeAreaTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureUomExt (-998)

#endif

/* eml22__EnergyLengthPerAreaUomExt has binding name 'eml22__EnergyLengthPerAreaUomExt' for type 'eml22:EnergyLengthPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaUomExt (-997)

#endif

/* eml22__ElectromagneticMomentUomExt has binding name 'eml22__ElectromagneticMomentUomExt' for type 'eml22:ElectromagneticMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentUomExt (-996)

#endif

/* eml22__ElectricResistanceUomExt has binding name 'eml22__ElectricResistanceUomExt' for type 'eml22:ElectricResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceUomExt (-995)

#endif

/* eml22__ElectricResistancePerLengthUomExt has binding name 'eml22__ElectricResistancePerLengthUomExt' for type 'eml22:ElectricResistancePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthUomExt (-994)

#endif

/* eml22__ElectricPotentialDifferenceUomExt has binding name 'eml22__ElectricPotentialDifferenceUomExt' for type 'eml22:ElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceUomExt (-993)

#endif

/* eml22__ElectricFieldStrengthUomExt has binding name 'eml22__ElectricFieldStrengthUomExt' for type 'eml22:ElectricFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthUomExt (-992)

#endif

/* eml22__ElectricCurrentUomExt has binding name 'eml22__ElectricCurrentUomExt' for type 'eml22:ElectricCurrentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentUomExt (-991)

#endif

/* eml22__ElectricCurrentDensityUomExt has binding name 'eml22__ElectricCurrentDensityUomExt' for type 'eml22:ElectricCurrentDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityUomExt (-990)

#endif

/* eml22__ElectricConductivityUomExt has binding name 'eml22__ElectricConductivityUomExt' for type 'eml22:ElectricConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityUomExt (-989)

#endif

/* eml22__ElectricConductanceUomExt has binding name 'eml22__ElectricConductanceUomExt' for type 'eml22:ElectricConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceUomExt (-988)

#endif

/* eml22__ElectricChargeUomExt has binding name 'eml22__ElectricChargeUomExt' for type 'eml22:ElectricChargeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeUomExt (-987)

#endif

/* eml22__ElectricChargePerVolumeUomExt has binding name 'eml22__ElectricChargePerVolumeUomExt' for type 'eml22:ElectricChargePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeUomExt (-986)

#endif

/* eml22__ElectricChargePerMassUomExt has binding name 'eml22__ElectricChargePerMassUomExt' for type 'eml22:ElectricChargePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassUomExt (-985)

#endif

/* eml22__ElectricChargePerAreaUomExt has binding name 'eml22__ElectricChargePerAreaUomExt' for type 'eml22:ElectricChargePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaUomExt (-984)

#endif

/* eml22__ElectricalResistivityUomExt has binding name 'eml22__ElectricalResistivityUomExt' for type 'eml22:ElectricalResistivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityUomExt (-983)

#endif

/* eml22__DynamicViscosityUomExt has binding name 'eml22__DynamicViscosityUomExt' for type 'eml22:DynamicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityUomExt (-982)

#endif

/* eml22__DoseEquivalentUomExt has binding name 'eml22__DoseEquivalentUomExt' for type 'eml22:DoseEquivalentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentUomExt (-981)

#endif

/* eml22__DipoleMomentUomExt has binding name 'eml22__DipoleMomentUomExt' for type 'eml22:DipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentUomExt (-980)

#endif

/* eml22__DimensionlessUomExt has binding name 'eml22__DimensionlessUomExt' for type 'eml22:DimensionlessUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessUomExt (-979)

#endif

/* eml22__DigitalStorageUomExt has binding name 'eml22__DigitalStorageUomExt' for type 'eml22:DigitalStorageUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageUomExt (-978)

#endif

/* eml22__DiffusiveTimeOfFlightUomExt has binding name 'eml22__DiffusiveTimeOfFlightUomExt' for type 'eml22:DiffusiveTimeOfFlightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightUomExt (-977)

#endif

/* eml22__DiffusionCoefficientUomExt has binding name 'eml22__DiffusionCoefficientUomExt' for type 'eml22:DiffusionCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientUomExt (-976)

#endif

/* eml22__DataTransferSpeedUomExt has binding name 'eml22__DataTransferSpeedUomExt' for type 'eml22:DataTransferSpeedUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedUomExt (-975)

#endif

/* eml22__CationExchangeCapacityUomExt has binding name 'eml22__CationExchangeCapacityUomExt' for type 'eml22:CationExchangeCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityUomExt (-974)

#endif

/* eml22__CapacitanceUomExt has binding name 'eml22__CapacitanceUomExt' for type 'eml22:CapacitanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceUomExt (-973)

#endif

/* eml22__AttenuationPerFrequencyIntervalUomExt has binding name 'eml22__AttenuationPerFrequencyIntervalUomExt' for type 'eml22:AttenuationPerFrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalUomExt (-972)

#endif

/* eml22__AreaUomExt has binding name 'eml22__AreaUomExt' for type 'eml22:AreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaUomExt (-971)

#endif

/* eml22__AreaPerVolumeUomExt has binding name 'eml22__AreaPerVolumeUomExt' for type 'eml22:AreaPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeUomExt (-970)

#endif

/* eml22__AreaPerTimeUomExt has binding name 'eml22__AreaPerTimeUomExt' for type 'eml22:AreaPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeUomExt (-969)

#endif

/* eml22__AreaPerMassUomExt has binding name 'eml22__AreaPerMassUomExt' for type 'eml22:AreaPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassUomExt (-968)

#endif

/* eml22__AreaPerCountUomExt has binding name 'eml22__AreaPerCountUomExt' for type 'eml22:AreaPerCountUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountUomExt (-967)

#endif

/* eml22__AreaPerAreaUomExt has binding name 'eml22__AreaPerAreaUomExt' for type 'eml22:AreaPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaUomExt (-966)

#endif

/* eml22__AreaPerAmountOfSubstanceUomExt has binding name 'eml22__AreaPerAmountOfSubstanceUomExt' for type 'eml22:AreaPerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceUomExt (-965)

#endif

/* eml22__APINeutronUomExt has binding name 'eml22__APINeutronUomExt' for type 'eml22:APINeutronUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronUomExt (-964)

#endif

/* eml22__APIGravityUomExt has binding name 'eml22__APIGravityUomExt' for type 'eml22:APIGravityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityUomExt (-963)

#endif

/* eml22__APIGammaRayUomExt has binding name 'eml22__APIGammaRayUomExt' for type 'eml22:APIGammaRayUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayUomExt (-962)

#endif

/* eml22__AngularVelocityUomExt has binding name 'eml22__AngularVelocityUomExt' for type 'eml22:AngularVelocityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityUomExt (-961)

#endif

/* eml22__AngularAccelerationUomExt has binding name 'eml22__AngularAccelerationUomExt' for type 'eml22:AngularAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationUomExt (-960)

#endif

/* eml22__AnglePerVolumeUomExt has binding name 'eml22__AnglePerVolumeUomExt' for type 'eml22:AnglePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeUomExt (-959)

#endif

/* eml22__AnglePerLengthUomExt has binding name 'eml22__AnglePerLengthUomExt' for type 'eml22:AnglePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthUomExt (-958)

#endif

/* eml22__AmountOfSubstanceUomExt has binding name 'eml22__AmountOfSubstanceUomExt' for type 'eml22:AmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceUomExt (-957)

#endif

/* eml22__AmountOfSubstancePerVolumeUomExt has binding name 'eml22__AmountOfSubstancePerVolumeUomExt' for type 'eml22:AmountOfSubstancePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeUomExt (-956)

#endif

/* eml22__AmountOfSubstancePerTimeUomExt has binding name 'eml22__AmountOfSubstancePerTimeUomExt' for type 'eml22:AmountOfSubstancePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeUomExt (-955)

#endif

/* eml22__AmountOfSubstancePerTimePerAreaUomExt has binding name 'eml22__AmountOfSubstancePerTimePerAreaUomExt' for type 'eml22:AmountOfSubstancePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaUomExt (-954)

#endif

/* eml22__AmountOfSubstancePerAreaUomExt has binding name 'eml22__AmountOfSubstancePerAreaUomExt' for type 'eml22:AmountOfSubstancePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaUomExt (-953)

#endif

/* eml22__AmountOfSubstancePerAmountOfSubstanceUomExt has binding name 'eml22__AmountOfSubstancePerAmountOfSubstanceUomExt' for type 'eml22:AmountOfSubstancePerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceUomExt (-952)

#endif

/* eml22__ActivityOfRadioactivityUomExt has binding name 'eml22__ActivityOfRadioactivityUomExt' for type 'eml22:ActivityOfRadioactivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityUomExt (-951)

#endif

/* eml22__AbsorbedDoseUomExt has binding name 'eml22__AbsorbedDoseUomExt' for type 'eml22:AbsorbedDoseUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseUomExt (-950)

#endif

/* eml22__UnitOfMeasureExt has binding name 'eml22__UnitOfMeasureExt' for type 'eml22:UnitOfMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitOfMeasureExt (-949)

#endif

/* eml22__ReferenceConditionExt has binding name 'eml22__ReferenceConditionExt' for type 'eml22:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceConditionExt (-948)

#endif

/* eml22__QuantityClassKindExt has binding name 'eml22__QuantityClassKindExt' for type 'eml22:QuantityClassKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityClassKindExt (-947)

#endif

/* eml22__LithologyQualifierKindExt has binding name 'eml22__LithologyQualifierKindExt' for type 'eml22:LithologyQualifierKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyQualifierKindExt (-946)

#endif

/* eml22__LithologyKindExt has binding name 'eml22__LithologyKindExt' for type 'eml22:LithologyKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LithologyKindExt (-945)

#endif

/* eml22__FacetExt has binding name 'eml22__FacetExt' for type 'eml22:FacetExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FacetExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FacetExt (-944)

#endif

/* prodml21__DataConditioningExt has binding name 'prodml21__DataConditioningExt' for type 'prodml21:DataConditioningExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioningExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DataConditioningExt (-943)

#endif

/* prodml21__ServiceFluidKindExt has binding name 'prodml21__ServiceFluidKindExt' for type 'prodml21:ServiceFluidKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluidKindExt (-942)

#endif

/* prodml21__QuantityMethodExt has binding name 'prodml21__QuantityMethodExt' for type 'prodml21:QuantityMethodExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethodExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__QuantityMethodExt (-941)

#endif

/* prodml21__ProductFluidKindExt has binding name 'prodml21__ProductFluidKindExt' for type 'prodml21:ProductFluidKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluidKindExt (-940)

#endif

/* prodml21__EstimationMethodExt has binding name 'prodml21__EstimationMethodExt' for type 'prodml21:EstimationMethodExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethodExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EstimationMethodExt (-939)

#endif

/* prodml21__DispositionKindExt has binding name 'prodml21__DispositionKindExt' for type 'prodml21:DispositionKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DispositionKindExt (-938)

#endif

/* prodml21__ReportingFacilityExt has binding name 'prodml21__ReportingFacilityExt' for type 'prodml21:ReportingFacilityExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacilityExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingFacilityExt (-937)

#endif

/* prodml21__ReportingDurationKindExt has binding name 'prodml21__ReportingDurationKindExt' for type 'prodml21:ReportingDurationKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingDurationKindExt (-936)

#endif

/* prodml21__PureComponentEnumExt has binding name 'prodml21__PureComponentEnumExt' for type 'prodml21:PureComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureComponentEnumExt (-935)

#endif

/* prodml21__PseudoComponentEnumExt has binding name 'prodml21__PseudoComponentEnumExt' for type 'prodml21:PseudoComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoComponentEnumExt (-934)

#endif

/* prodml21__PlusComponentEnumExt has binding name 'prodml21__PlusComponentEnumExt' for type 'prodml21:PlusComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusComponentEnumExt (-933)

#endif

/* prodml21__FacilityKindExt has binding name 'prodml21__FacilityKindExt' for type 'prodml21:FacilityKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityKindExt (-932)

#endif

/* prodml21__PvtModelParameterKindExt has binding name 'prodml21__PvtModelParameterKindExt' for type 'prodml21:PvtModelParameterKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKindExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterKindExt (-931)

#endif

/* prodml21__OutputFluidPropertyExt has binding name 'prodml21__OutputFluidPropertyExt' for type 'prodml21:OutputFluidPropertyExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidPropertyExt
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFluidPropertyExt (-930)

#endif

/* eml22__GraphicalInformationSet has binding name 'eml22__GraphicalInformationSet' for type 'eml22:GraphicalInformationSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_2_eml22__GraphicalInformationSet (-929)

#endif

/* eml22__AbstractGraphicalInformation has binding name 'eml22__AbstractGraphicalInformation' for type 'eml22:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGraphicalInformation (-928)

#endif

/* eml22__IndexRange has binding name 'eml22__IndexRange' for type 'eml22:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange
#define SOAP_TYPE_gsoap_eml2_2_eml22__IndexRange (-927)

#endif

/* eml22__FailingRule has binding name 'eml22__FailingRule' for type 'eml22:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule
#define SOAP_TYPE_gsoap_eml2_2_eml22__FailingRule (-926)

#endif

/* eml22__DataAssuranceRecord has binding name 'eml22__DataAssuranceRecord' for type 'eml22:DataAssuranceRecord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataAssuranceRecord (-925)

#endif

/* eml22__VerticalWktCrs has binding name 'eml22__VerticalWktCrs' for type 'eml22:VerticalWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalWktCrs (-924)

#endif

/* eml22__VerticalUnknownCrs has binding name 'eml22__VerticalUnknownCrs' for type 'eml22:VerticalUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalUnknownCrs (-923)

#endif

/* eml22__VerticalLocalAuthorityCrs has binding name 'eml22__VerticalLocalAuthorityCrs' for type 'eml22:VerticalLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalLocalAuthorityCrs (-922)

#endif

/* eml22__VerticalEpsgCrs has binding name 'eml22__VerticalEpsgCrs' for type 'eml22:VerticalEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalEpsgCrs (-921)

#endif

/* eml22__VerticalCrs has binding name 'eml22__VerticalCrs' for type 'eml22:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCrs (-920)

#endif

/* eml22__VerticalAxis has binding name 'eml22__VerticalAxis' for type 'eml22:VerticalAxis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalAxis (-919)

#endif

/* eml22__Vector has binding name 'eml22__Vector' for type 'eml22:Vector' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Vector
#define SOAP_TYPE_gsoap_eml2_2_eml22__Vector (-918)

#endif

/* eml22__PublicLandSurveySystem has binding name 'eml22__PublicLandSurveySystem' for type 'eml22:PublicLandSurveySystem' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem
#define SOAP_TYPE_gsoap_eml2_2_eml22__PublicLandSurveySystem (-917)

#endif

/* eml22__ProjectedWktCrs has binding name 'eml22__ProjectedWktCrs' for type 'eml22:ProjectedWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedWktCrs (-916)

#endif

/* eml22__ProjectedUnknownCrs has binding name 'eml22__ProjectedUnknownCrs' for type 'eml22:ProjectedUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedUnknownCrs (-915)

#endif

/* eml22__ProjectedLocalAuthorityCrs has binding name 'eml22__ProjectedLocalAuthorityCrs' for type 'eml22:ProjectedLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedLocalAuthorityCrs (-914)

#endif

/* eml22__ProjectedEpsgCrs has binding name 'eml22__ProjectedEpsgCrs' for type 'eml22:ProjectedEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedEpsgCrs (-913)

#endif

/* eml22__ProjectedCrs has binding name 'eml22__ProjectedCrs' for type 'eml22:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__ProjectedCrs (-912)

#endif

/* eml22__LocalEngineeringCompoundCrs has binding name 'eml22__LocalEngineeringCompoundCrs' for type 'eml22:LocalEngineeringCompoundCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__LocalEngineeringCompoundCrs (-911)

#endif

/* eml22__HorizontalAxes has binding name 'eml22__HorizontalAxes' for type 'eml22:HorizontalAxes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_2_eml22__HorizontalAxes (-910)

#endif

/* eml22__GeodeticWktCrs has binding name 'eml22__GeodeticWktCrs' for type 'eml22:GeodeticWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticWktCrs (-909)

#endif

/* eml22__GeodeticUnknownCrs has binding name 'eml22__GeodeticUnknownCrs' for type 'eml22:GeodeticUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticUnknownCrs (-908)

#endif

/* eml22__GeodeticLocalAuthorityCrs has binding name 'eml22__GeodeticLocalAuthorityCrs' for type 'eml22:GeodeticLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticLocalAuthorityCrs (-907)

#endif

/* eml22__GeodeticEpsgCrs has binding name 'eml22__GeodeticEpsgCrs' for type 'eml22:GeodeticEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticEpsgCrs (-906)

#endif

/* eml22__GeodeticCrs has binding name 'eml22__GeodeticCrs' for type 'eml22:GeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeodeticCrs (-905)

#endif

/* eml22__DistanceNorthSouth has binding name 'eml22__DistanceNorthSouth' for type 'eml22:DistanceNorthSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth
#define SOAP_TYPE_gsoap_eml2_2_eml22__DistanceNorthSouth (-904)

#endif

/* eml22__DistanceEastWest has binding name 'eml22__DistanceEastWest' for type 'eml22:DistanceEastWest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest
#define SOAP_TYPE_gsoap_eml2_2_eml22__DistanceEastWest (-903)

#endif

/* eml22__AbstractVerticalCrs has binding name 'eml22__AbstractVerticalCrs' for type 'eml22:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractVerticalCrs (-902)

#endif

/* eml22__AbstractProjectedCrs has binding name 'eml22__AbstractProjectedCrs' for type 'eml22:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractProjectedCrs (-901)

#endif

/* eml22__AbstractGeodeticCrs has binding name 'eml22__AbstractGeodeticCrs' for type 'eml22:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGeodeticCrs (-900)

#endif

/* eml22__VolumeValue has binding name 'eml22__VolumeValue' for type 'eml22:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeValue (-899)

#endif

/* eml22__TemperaturePressure has binding name 'eml22__TemperaturePressure' for type 'eml22:TemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperaturePressure (-898)

#endif

/* eml22__RelativePressure has binding name 'eml22__RelativePressure' for type 'eml22:RelativePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RelativePressure (-897)

#endif

/* eml22__ReferenceTemperaturePressure has binding name 'eml22__ReferenceTemperaturePressure' for type 'eml22:ReferenceTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferenceTemperaturePressure (-896)

#endif

/* eml22__ReferencePressure has binding name 'eml22__ReferencePressure' for type 'eml22:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReferencePressure (-895)

#endif

/* eml22__PressureValue has binding name 'eml22__PressureValue' for type 'eml22:PressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureValue (-894)

#endif

/* eml22__GaugePressure has binding name 'eml22__GaugePressure' for type 'eml22:GaugePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__GaugePressure (-893)

#endif

/* eml22__FlowRateValue has binding name 'eml22__FlowRateValue' for type 'eml22:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__FlowRateValue (-892)

#endif

/* eml22__DensityValue has binding name 'eml22__DensityValue' for type 'eml22:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__DensityValue (-891)

#endif

/* eml22__AbstractTemperaturePressure has binding name 'eml22__AbstractTemperaturePressure' for type 'eml22:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTemperaturePressure (-890)

#endif

/* eml22__AbstractPressureValue has binding name 'eml22__AbstractPressureValue' for type 'eml22:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractPressureValue (-889)

#endif

/* eml22__AbsolutePressure has binding name 'eml22__AbsolutePressure' for type 'eml22:AbsolutePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsolutePressure (-888)

#endif

/* eml22__TimeIndexParameterKey has binding name 'eml22__TimeIndexParameterKey' for type 'eml22:TimeIndexParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameterKey (-887)

#endif

/* eml22__TimeIndexParameter has binding name 'eml22__TimeIndexParameter' for type 'eml22:TimeIndexParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndexParameter (-886)

#endif

/* eml22__StringParameter has binding name 'eml22__StringParameter' for type 'eml22:StringParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringParameter (-885)

#endif

/* eml22__ParameterTemplate has binding name 'eml22__ParameterTemplate' for type 'eml22:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_2_eml22__ParameterTemplate (-884)

#endif

/* eml22__ObjectParameterKey has binding name 'eml22__ObjectParameterKey' for type 'eml22:ObjectParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__ObjectParameterKey (-883)

#endif

/* eml22__IntegerQuantityParameter has binding name 'eml22__IntegerQuantityParameter' for type 'eml22:IntegerQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerQuantityParameter (-882)

#endif

/* eml22__DoubleQuantityParameter has binding name 'eml22__DoubleQuantityParameter' for type 'eml22:DoubleQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoubleQuantityParameter (-881)

#endif

/* eml22__DataObjectParameter has binding name 'eml22__DataObjectParameter' for type 'eml22:DataObjectParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectParameter (-880)

#endif

/* eml22__ActivityTemplate has binding name 'eml22__ActivityTemplate' for type 'eml22:ActivityTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityTemplate (-879)

#endif

/* eml22__Activity has binding name 'eml22__Activity' for type 'eml22:Activity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Activity
#define SOAP_TYPE_gsoap_eml2_2_eml22__Activity (-878)

#endif

/* eml22__AbstractParameterKey has binding name 'eml22__AbstractParameterKey' for type 'eml22:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractParameterKey (-877)

#endif

/* eml22__AbstractActivityParameter has binding name 'eml22__AbstractActivityParameter' for type 'eml22:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractActivityParameter (-876)

#endif

/* eml22__ExternalDatasetPart has binding name 'eml22__ExternalDatasetPart' for type 'eml22:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDatasetPart (-875)

#endif

/* eml22__ExternalDataset has binding name 'eml22__ExternalDataset' for type 'eml22:ExternalDataset' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExternalDataset (-874)

#endif

/* eml22__EpcExternalPartReference has binding name 'eml22__EpcExternalPartReference' for type 'eml22:EpcExternalPartReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__EpcExternalPartReference (-873)

#endif

/* eml22__DataObjectReference has binding name 'eml22__DataObjectReference' for type 'eml22:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataObjectReference (-872)

#endif

/* eml22__VolumetricThermalExpansionMeasureExt has binding name 'eml22__VolumetricThermalExpansionMeasureExt' for type 'eml22:VolumetricThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasureExt (-871)

#endif

/* eml22__VolumetricThermalExpansionMeasure has binding name 'eml22__VolumetricThermalExpansionMeasure' for type 'eml22:VolumetricThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricThermalExpansionMeasure (-870)

#endif

/* eml22__VolumetricHeatTransferCoefficientMeasureExt has binding name 'eml22__VolumetricHeatTransferCoefficientMeasureExt' for type 'eml22:VolumetricHeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasureExt (-869)

#endif

/* eml22__VolumetricHeatTransferCoefficientMeasure has binding name 'eml22__VolumetricHeatTransferCoefficientMeasure' for type 'eml22:VolumetricHeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumetricHeatTransferCoefficientMeasure (-868)

#endif

/* eml22__VolumePerVolumeMeasureExt has binding name 'eml22__VolumePerVolumeMeasureExt' for type 'eml22:VolumePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasureExt (-867)

#endif

/* eml22__VolumePerVolumeMeasure has binding name 'eml22__VolumePerVolumeMeasure' for type 'eml22:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerVolumeMeasure (-866)

#endif

/* eml22__VolumePerTimePerVolumeMeasureExt has binding name 'eml22__VolumePerTimePerVolumeMeasureExt' for type 'eml22:VolumePerTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasureExt (-865)

#endif

/* eml22__VolumePerTimePerVolumeMeasure has binding name 'eml22__VolumePerTimePerVolumeMeasure' for type 'eml22:VolumePerTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerVolumeMeasure (-864)

#endif

/* eml22__VolumePerTimePerTimeMeasureExt has binding name 'eml22__VolumePerTimePerTimeMeasureExt' for type 'eml22:VolumePerTimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasureExt (-863)

#endif

/* eml22__VolumePerTimePerTimeMeasure has binding name 'eml22__VolumePerTimePerTimeMeasure' for type 'eml22:VolumePerTimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerTimeMeasure (-862)

#endif

/* eml22__VolumePerTimePerPressureMeasureExt has binding name 'eml22__VolumePerTimePerPressureMeasureExt' for type 'eml22:VolumePerTimePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasureExt (-861)

#endif

/* eml22__VolumePerTimePerPressureMeasure has binding name 'eml22__VolumePerTimePerPressureMeasure' for type 'eml22:VolumePerTimePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureMeasure (-860)

#endif

/* eml22__VolumePerTimePerPressureLengthMeasureExt has binding name 'eml22__VolumePerTimePerPressureLengthMeasureExt' for type 'eml22:VolumePerTimePerPressureLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasureExt (-859)

#endif

/* eml22__VolumePerTimePerPressureLengthMeasure has binding name 'eml22__VolumePerTimePerPressureLengthMeasure' for type 'eml22:VolumePerTimePerPressureLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerPressureLengthMeasure (-858)

#endif

/* eml22__VolumePerTimePerLengthMeasureExt has binding name 'eml22__VolumePerTimePerLengthMeasureExt' for type 'eml22:VolumePerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasureExt (-857)

#endif

/* eml22__VolumePerTimePerLengthMeasure has binding name 'eml22__VolumePerTimePerLengthMeasure' for type 'eml22:VolumePerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerLengthMeasure (-856)

#endif

/* eml22__VolumePerTimePerAreaMeasureExt has binding name 'eml22__VolumePerTimePerAreaMeasureExt' for type 'eml22:VolumePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasureExt (-855)

#endif

/* eml22__VolumePerTimePerAreaMeasure has binding name 'eml22__VolumePerTimePerAreaMeasure' for type 'eml22:VolumePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimePerAreaMeasure (-854)

#endif

/* eml22__VolumePerTimeMeasureExt has binding name 'eml22__VolumePerTimeMeasureExt' for type 'eml22:VolumePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasureExt (-853)

#endif

/* eml22__VolumePerTimeMeasure has binding name 'eml22__VolumePerTimeMeasure' for type 'eml22:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeMeasure (-852)

#endif

/* eml22__VolumePerTimeLengthMeasureExt has binding name 'eml22__VolumePerTimeLengthMeasureExt' for type 'eml22:VolumePerTimeLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasureExt (-851)

#endif

/* eml22__VolumePerTimeLengthMeasure has binding name 'eml22__VolumePerTimeLengthMeasure' for type 'eml22:VolumePerTimeLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerTimeLengthMeasure (-850)

#endif

/* eml22__VolumePerRotationMeasureExt has binding name 'eml22__VolumePerRotationMeasureExt' for type 'eml22:VolumePerRotationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasureExt (-849)

#endif

/* eml22__VolumePerRotationMeasure has binding name 'eml22__VolumePerRotationMeasure' for type 'eml22:VolumePerRotationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerRotationMeasure (-848)

#endif

/* eml22__VolumePerPressureMeasureExt has binding name 'eml22__VolumePerPressureMeasureExt' for type 'eml22:VolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasureExt (-847)

#endif

/* eml22__VolumePerPressureMeasure has binding name 'eml22__VolumePerPressureMeasure' for type 'eml22:VolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerPressureMeasure (-846)

#endif

/* eml22__VolumePerMassMeasureExt has binding name 'eml22__VolumePerMassMeasureExt' for type 'eml22:VolumePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasureExt (-845)

#endif

/* eml22__VolumePerMassMeasure has binding name 'eml22__VolumePerMassMeasure' for type 'eml22:VolumePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerMassMeasure (-844)

#endif

/* eml22__VolumePerLengthMeasureExt has binding name 'eml22__VolumePerLengthMeasureExt' for type 'eml22:VolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasureExt (-843)

#endif

/* eml22__VolumePerLengthMeasure has binding name 'eml22__VolumePerLengthMeasure' for type 'eml22:VolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerLengthMeasure (-842)

#endif

/* eml22__VolumePerAreaMeasureExt has binding name 'eml22__VolumePerAreaMeasureExt' for type 'eml22:VolumePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasureExt (-841)

#endif

/* eml22__VolumePerAreaMeasure has binding name 'eml22__VolumePerAreaMeasure' for type 'eml22:VolumePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumePerAreaMeasure (-840)

#endif

/* eml22__VolumeMeasureExt has binding name 'eml22__VolumeMeasureExt' for type 'eml22:VolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasureExt (-839)

#endif

/* eml22__VolumeMeasure has binding name 'eml22__VolumeMeasure' for type 'eml22:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeMeasure (-838)

#endif

/* eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt has binding name 'eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt' for type 'eml22:VolumeFlowRatePerVolumeFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasureExt (-837)

#endif

/* eml22__VolumeFlowRatePerVolumeFlowRateMeasure has binding name 'eml22__VolumeFlowRatePerVolumeFlowRateMeasure' for type 'eml22:VolumeFlowRatePerVolumeFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VolumeFlowRatePerVolumeFlowRateMeasure (-836)

#endif

/* eml22__VerticalCoordinateMeasureExt has binding name 'eml22__VerticalCoordinateMeasureExt' for type 'eml22:VerticalCoordinateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasureExt (-835)

#endif

/* eml22__VerticalCoordinateMeasure has binding name 'eml22__VerticalCoordinateMeasure' for type 'eml22:VerticalCoordinateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__VerticalCoordinateMeasure (-834)

#endif

/* eml22__UnitlessMeasure has binding name 'eml22__UnitlessMeasure' for type 'eml22:UnitlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__UnitlessMeasure (-833)

#endif

/* eml22__TimePerVolumeMeasureExt has binding name 'eml22__TimePerVolumeMeasureExt' for type 'eml22:TimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasureExt (-832)

#endif

/* eml22__TimePerVolumeMeasure has binding name 'eml22__TimePerVolumeMeasure' for type 'eml22:TimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerVolumeMeasure (-831)

#endif

/* eml22__TimePerTimeMeasureExt has binding name 'eml22__TimePerTimeMeasureExt' for type 'eml22:TimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasureExt (-830)

#endif

/* eml22__TimePerTimeMeasure has binding name 'eml22__TimePerTimeMeasure' for type 'eml22:TimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerTimeMeasure (-829)

#endif

/* eml22__TimePerMassMeasureExt has binding name 'eml22__TimePerMassMeasureExt' for type 'eml22:TimePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasureExt (-828)

#endif

/* eml22__TimePerMassMeasure has binding name 'eml22__TimePerMassMeasure' for type 'eml22:TimePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerMassMeasure (-827)

#endif

/* eml22__TimePerLengthMeasureExt has binding name 'eml22__TimePerLengthMeasureExt' for type 'eml22:TimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasureExt (-826)

#endif

/* eml22__TimePerLengthMeasure has binding name 'eml22__TimePerLengthMeasure' for type 'eml22:TimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimePerLengthMeasure (-825)

#endif

/* eml22__TimeMeasureExt has binding name 'eml22__TimeMeasureExt' for type 'eml22:TimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasureExt (-824)

#endif

/* eml22__TimeMeasure has binding name 'eml22__TimeMeasure' for type 'eml22:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeMeasure (-823)

#endif

/* eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt has binding name 'eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' for type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (-822)

#endif

/* eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure has binding name 'eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' for type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (-821)

#endif

/* eml22__ThermodynamicTemperatureMeasureExt has binding name 'eml22__ThermodynamicTemperatureMeasureExt' for type 'eml22:ThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasureExt (-820)

#endif

/* eml22__ThermodynamicTemperatureMeasure has binding name 'eml22__ThermodynamicTemperatureMeasure' for type 'eml22:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermodynamicTemperatureMeasure (-819)

#endif

/* eml22__ThermalResistanceMeasureExt has binding name 'eml22__ThermalResistanceMeasureExt' for type 'eml22:ThermalResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasureExt (-818)

#endif

/* eml22__ThermalResistanceMeasure has binding name 'eml22__ThermalResistanceMeasure' for type 'eml22:ThermalResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalResistanceMeasure (-817)

#endif

/* eml22__ThermalInsulanceMeasureExt has binding name 'eml22__ThermalInsulanceMeasureExt' for type 'eml22:ThermalInsulanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasureExt (-816)

#endif

/* eml22__ThermalInsulanceMeasure has binding name 'eml22__ThermalInsulanceMeasure' for type 'eml22:ThermalInsulanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalInsulanceMeasure (-815)

#endif

/* eml22__ThermalDiffusivityMeasureExt has binding name 'eml22__ThermalDiffusivityMeasureExt' for type 'eml22:ThermalDiffusivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasureExt (-814)

#endif

/* eml22__ThermalDiffusivityMeasure has binding name 'eml22__ThermalDiffusivityMeasure' for type 'eml22:ThermalDiffusivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalDiffusivityMeasure (-813)

#endif

/* eml22__ThermalConductivityMeasureExt has binding name 'eml22__ThermalConductivityMeasureExt' for type 'eml22:ThermalConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasureExt (-812)

#endif

/* eml22__ThermalConductivityMeasure has binding name 'eml22__ThermalConductivityMeasure' for type 'eml22:ThermalConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductivityMeasure (-811)

#endif

/* eml22__ThermalConductanceMeasureExt has binding name 'eml22__ThermalConductanceMeasureExt' for type 'eml22:ThermalConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasureExt (-810)

#endif

/* eml22__ThermalConductanceMeasure has binding name 'eml22__ThermalConductanceMeasure' for type 'eml22:ThermalConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ThermalConductanceMeasure (-809)

#endif

/* eml22__TemperatureIntervalPerTimeMeasureExt has binding name 'eml22__TemperatureIntervalPerTimeMeasureExt' for type 'eml22:TemperatureIntervalPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasureExt (-808)

#endif

/* eml22__TemperatureIntervalPerTimeMeasure has binding name 'eml22__TemperatureIntervalPerTimeMeasure' for type 'eml22:TemperatureIntervalPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerTimeMeasure (-807)

#endif

/* eml22__TemperatureIntervalPerPressureMeasureExt has binding name 'eml22__TemperatureIntervalPerPressureMeasureExt' for type 'eml22:TemperatureIntervalPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasureExt (-806)

#endif

/* eml22__TemperatureIntervalPerPressureMeasure has binding name 'eml22__TemperatureIntervalPerPressureMeasure' for type 'eml22:TemperatureIntervalPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerPressureMeasure (-805)

#endif

/* eml22__TemperatureIntervalPerLengthMeasureExt has binding name 'eml22__TemperatureIntervalPerLengthMeasureExt' for type 'eml22:TemperatureIntervalPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasureExt (-804)

#endif

/* eml22__TemperatureIntervalPerLengthMeasure has binding name 'eml22__TemperatureIntervalPerLengthMeasure' for type 'eml22:TemperatureIntervalPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalPerLengthMeasure (-803)

#endif

/* eml22__TemperatureIntervalMeasureExt has binding name 'eml22__TemperatureIntervalMeasureExt' for type 'eml22:TemperatureIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasureExt (-802)

#endif

/* eml22__TemperatureIntervalMeasure has binding name 'eml22__TemperatureIntervalMeasure' for type 'eml22:TemperatureIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__TemperatureIntervalMeasure (-801)

#endif

/* eml22__SpecificHeatCapacityMeasureExt has binding name 'eml22__SpecificHeatCapacityMeasureExt' for type 'eml22:SpecificHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasureExt (-800)

#endif

/* eml22__SpecificHeatCapacityMeasure has binding name 'eml22__SpecificHeatCapacityMeasure' for type 'eml22:SpecificHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SpecificHeatCapacityMeasure (-799)

#endif

/* eml22__SolidAngleMeasureExt has binding name 'eml22__SolidAngleMeasureExt' for type 'eml22:SolidAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasureExt (-798)

#endif

/* eml22__SolidAngleMeasure has binding name 'eml22__SolidAngleMeasure' for type 'eml22:SolidAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SolidAngleMeasure (-797)

#endif

/* eml22__SignalingEventPerTimeMeasureExt has binding name 'eml22__SignalingEventPerTimeMeasureExt' for type 'eml22:SignalingEventPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasureExt (-796)

#endif

/* eml22__SignalingEventPerTimeMeasure has binding name 'eml22__SignalingEventPerTimeMeasure' for type 'eml22:SignalingEventPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SignalingEventPerTimeMeasure (-795)

#endif

/* eml22__SecondMomentOfAreaMeasureExt has binding name 'eml22__SecondMomentOfAreaMeasureExt' for type 'eml22:SecondMomentOfAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasureExt (-794)

#endif

/* eml22__SecondMomentOfAreaMeasure has binding name 'eml22__SecondMomentOfAreaMeasure' for type 'eml22:SecondMomentOfAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__SecondMomentOfAreaMeasure (-793)

#endif

/* eml22__ReluctanceMeasureExt has binding name 'eml22__ReluctanceMeasureExt' for type 'eml22:ReluctanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasureExt (-792)

#endif

/* eml22__ReluctanceMeasure has binding name 'eml22__ReluctanceMeasure' for type 'eml22:ReluctanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReluctanceMeasure (-791)

#endif

/* eml22__ReciprocalVolumeMeasureExt has binding name 'eml22__ReciprocalVolumeMeasureExt' for type 'eml22:ReciprocalVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasureExt (-790)

#endif

/* eml22__ReciprocalVolumeMeasure has binding name 'eml22__ReciprocalVolumeMeasure' for type 'eml22:ReciprocalVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalVolumeMeasure (-789)

#endif

/* eml22__ReciprocalTimeMeasureExt has binding name 'eml22__ReciprocalTimeMeasureExt' for type 'eml22:ReciprocalTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasureExt (-788)

#endif

/* eml22__ReciprocalTimeMeasure has binding name 'eml22__ReciprocalTimeMeasure' for type 'eml22:ReciprocalTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalTimeMeasure (-787)

#endif

/* eml22__ReciprocalPressureMeasureExt has binding name 'eml22__ReciprocalPressureMeasureExt' for type 'eml22:ReciprocalPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasureExt (-786)

#endif

/* eml22__ReciprocalPressureMeasure has binding name 'eml22__ReciprocalPressureMeasure' for type 'eml22:ReciprocalPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalPressureMeasure (-785)

#endif

/* eml22__ReciprocalMassTimeMeasureExt has binding name 'eml22__ReciprocalMassTimeMeasureExt' for type 'eml22:ReciprocalMassTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasureExt (-784)

#endif

/* eml22__ReciprocalMassTimeMeasure has binding name 'eml22__ReciprocalMassTimeMeasure' for type 'eml22:ReciprocalMassTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassTimeMeasure (-783)

#endif

/* eml22__ReciprocalMassMeasureExt has binding name 'eml22__ReciprocalMassMeasureExt' for type 'eml22:ReciprocalMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasureExt (-782)

#endif

/* eml22__ReciprocalMassMeasure has binding name 'eml22__ReciprocalMassMeasure' for type 'eml22:ReciprocalMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalMassMeasure (-781)

#endif

/* eml22__ReciprocalLengthMeasureExt has binding name 'eml22__ReciprocalLengthMeasureExt' for type 'eml22:ReciprocalLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasureExt (-780)

#endif

/* eml22__ReciprocalLengthMeasure has binding name 'eml22__ReciprocalLengthMeasure' for type 'eml22:ReciprocalLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalLengthMeasure (-779)

#endif

/* eml22__ReciprocalForceMeasureExt has binding name 'eml22__ReciprocalForceMeasureExt' for type 'eml22:ReciprocalForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasureExt (-778)

#endif

/* eml22__ReciprocalForceMeasure has binding name 'eml22__ReciprocalForceMeasure' for type 'eml22:ReciprocalForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalForceMeasure (-777)

#endif

/* eml22__ReciprocalElectricPotentialDifferenceMeasureExt has binding name 'eml22__ReciprocalElectricPotentialDifferenceMeasureExt' for type 'eml22:ReciprocalElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasureExt (-776)

#endif

/* eml22__ReciprocalElectricPotentialDifferenceMeasure has binding name 'eml22__ReciprocalElectricPotentialDifferenceMeasure' for type 'eml22:ReciprocalElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalElectricPotentialDifferenceMeasure (-775)

#endif

/* eml22__ReciprocalAreaMeasureExt has binding name 'eml22__ReciprocalAreaMeasureExt' for type 'eml22:ReciprocalAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasureExt (-774)

#endif

/* eml22__ReciprocalAreaMeasure has binding name 'eml22__ReciprocalAreaMeasure' for type 'eml22:ReciprocalAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ReciprocalAreaMeasure (-773)

#endif

/* eml22__RadiantIntensityMeasureExt has binding name 'eml22__RadiantIntensityMeasureExt' for type 'eml22:RadiantIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasureExt (-772)

#endif

/* eml22__RadiantIntensityMeasure has binding name 'eml22__RadiantIntensityMeasure' for type 'eml22:RadiantIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadiantIntensityMeasure (-771)

#endif

/* eml22__RadianceMeasureExt has binding name 'eml22__RadianceMeasureExt' for type 'eml22:RadianceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasureExt (-770)

#endif

/* eml22__RadianceMeasure has binding name 'eml22__RadianceMeasure' for type 'eml22:RadianceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__RadianceMeasure (-769)

#endif

/* eml22__QuantityOfLightMeasureExt has binding name 'eml22__QuantityOfLightMeasureExt' for type 'eml22:QuantityOfLightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasureExt (-768)

#endif

/* eml22__QuantityOfLightMeasure has binding name 'eml22__QuantityOfLightMeasure' for type 'eml22:QuantityOfLightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__QuantityOfLightMeasure (-767)

#endif

/* eml22__PressureTimePerVolumeMeasureExt has binding name 'eml22__PressureTimePerVolumeMeasureExt' for type 'eml22:PressureTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasureExt (-766)

#endif

/* eml22__PressureTimePerVolumeMeasure has binding name 'eml22__PressureTimePerVolumeMeasure' for type 'eml22:PressureTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureTimePerVolumeMeasure (-765)

#endif

/* eml22__PressureSquaredPerForceTimePerAreaMeasureExt has binding name 'eml22__PressureSquaredPerForceTimePerAreaMeasureExt' for type 'eml22:PressureSquaredPerForceTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasureExt (-764)

#endif

/* eml22__PressureSquaredPerForceTimePerAreaMeasure has binding name 'eml22__PressureSquaredPerForceTimePerAreaMeasure' for type 'eml22:PressureSquaredPerForceTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredPerForceTimePerAreaMeasure (-763)

#endif

/* eml22__PressureSquaredMeasureExt has binding name 'eml22__PressureSquaredMeasureExt' for type 'eml22:PressureSquaredMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasureExt (-762)

#endif

/* eml22__PressureSquaredMeasure has binding name 'eml22__PressureSquaredMeasure' for type 'eml22:PressureSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureSquaredMeasure (-761)

#endif

/* eml22__PressurePerVolumeMeasureExt has binding name 'eml22__PressurePerVolumeMeasureExt' for type 'eml22:PressurePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasureExt (-760)

#endif

/* eml22__PressurePerVolumeMeasure has binding name 'eml22__PressurePerVolumeMeasure' for type 'eml22:PressurePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerVolumeMeasure (-759)

#endif

/* eml22__PressurePerTimeMeasureExt has binding name 'eml22__PressurePerTimeMeasureExt' for type 'eml22:PressurePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasureExt (-758)

#endif

/* eml22__PressurePerTimeMeasure has binding name 'eml22__PressurePerTimeMeasure' for type 'eml22:PressurePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerTimeMeasure (-757)

#endif

/* eml22__PressurePerPressureMeasureExt has binding name 'eml22__PressurePerPressureMeasureExt' for type 'eml22:PressurePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasureExt (-756)

#endif

/* eml22__PressurePerPressureMeasure has binding name 'eml22__PressurePerPressureMeasure' for type 'eml22:PressurePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressurePerPressureMeasure (-755)

#endif

/* eml22__PressureMeasureExt has binding name 'eml22__PressureMeasureExt' for type 'eml22:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasureExt (-754)

#endif

/* eml22__PressureMeasure has binding name 'eml22__PressureMeasure' for type 'eml22:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PressureMeasure (-753)

#endif

/* eml22__PowerPerVolumeMeasureExt has binding name 'eml22__PowerPerVolumeMeasureExt' for type 'eml22:PowerPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasureExt (-752)

#endif

/* eml22__PowerPerVolumeMeasure has binding name 'eml22__PowerPerVolumeMeasure' for type 'eml22:PowerPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerVolumeMeasure (-751)

#endif

/* eml22__PowerPerPowerMeasureExt has binding name 'eml22__PowerPerPowerMeasureExt' for type 'eml22:PowerPerPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasureExt (-750)

#endif

/* eml22__PowerPerPowerMeasure has binding name 'eml22__PowerPerPowerMeasure' for type 'eml22:PowerPerPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerPowerMeasure (-749)

#endif

/* eml22__PowerPerAreaMeasureExt has binding name 'eml22__PowerPerAreaMeasureExt' for type 'eml22:PowerPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasureExt (-748)

#endif

/* eml22__PowerPerAreaMeasure has binding name 'eml22__PowerPerAreaMeasure' for type 'eml22:PowerPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerPerAreaMeasure (-747)

#endif

/* eml22__PowerMeasureExt has binding name 'eml22__PowerMeasureExt' for type 'eml22:PowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasureExt (-746)

#endif

/* eml22__PowerMeasure has binding name 'eml22__PowerMeasure' for type 'eml22:PowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PowerMeasure (-745)

#endif

/* eml22__PotentialDifferencePerPowerDropMeasureExt has binding name 'eml22__PotentialDifferencePerPowerDropMeasureExt' for type 'eml22:PotentialDifferencePerPowerDropMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasureExt (-744)

#endif

/* eml22__PotentialDifferencePerPowerDropMeasure has binding name 'eml22__PotentialDifferencePerPowerDropMeasure' for type 'eml22:PotentialDifferencePerPowerDropMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PotentialDifferencePerPowerDropMeasure (-743)

#endif

/* eml22__PlaneAngleMeasureExt has binding name 'eml22__PlaneAngleMeasureExt' for type 'eml22:PlaneAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasureExt (-742)

#endif

/* eml22__PlaneAngleMeasure has binding name 'eml22__PlaneAngleMeasure' for type 'eml22:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PlaneAngleMeasure (-741)

#endif

/* eml22__PermittivityMeasureExt has binding name 'eml22__PermittivityMeasureExt' for type 'eml22:PermittivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasureExt (-740)

#endif

/* eml22__PermittivityMeasure has binding name 'eml22__PermittivityMeasure' for type 'eml22:PermittivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermittivityMeasure (-739)

#endif

/* eml22__PermeabilityRockMeasureExt has binding name 'eml22__PermeabilityRockMeasureExt' for type 'eml22:PermeabilityRockMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasureExt (-738)

#endif

/* eml22__PermeabilityRockMeasure has binding name 'eml22__PermeabilityRockMeasure' for type 'eml22:PermeabilityRockMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityRockMeasure (-737)

#endif

/* eml22__PermeabilityLengthMeasureExt has binding name 'eml22__PermeabilityLengthMeasureExt' for type 'eml22:PermeabilityLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasureExt (-736)

#endif

/* eml22__PermeabilityLengthMeasure has binding name 'eml22__PermeabilityLengthMeasure' for type 'eml22:PermeabilityLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__PermeabilityLengthMeasure (-735)

#endif

/* eml22__NormalizedPowerMeasureExt has binding name 'eml22__NormalizedPowerMeasureExt' for type 'eml22:NormalizedPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasureExt (-734)

#endif

/* eml22__NormalizedPowerMeasure has binding name 'eml22__NormalizedPowerMeasure' for type 'eml22:NormalizedPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__NormalizedPowerMeasure (-733)

#endif

/* eml22__MomentumMeasureExt has binding name 'eml22__MomentumMeasureExt' for type 'eml22:MomentumMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasureExt (-732)

#endif

/* eml22__MomentumMeasure has binding name 'eml22__MomentumMeasure' for type 'eml22:MomentumMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentumMeasure (-731)

#endif

/* eml22__MomentOfInertiaMeasureExt has binding name 'eml22__MomentOfInertiaMeasureExt' for type 'eml22:MomentOfInertiaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasureExt (-730)

#endif

/* eml22__MomentOfInertiaMeasure has binding name 'eml22__MomentOfInertiaMeasure' for type 'eml22:MomentOfInertiaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfInertiaMeasure (-729)

#endif

/* eml22__MomentOfForceMeasureExt has binding name 'eml22__MomentOfForceMeasureExt' for type 'eml22:MomentOfForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasureExt (-728)

#endif

/* eml22__MomentOfForceMeasure has binding name 'eml22__MomentOfForceMeasure' for type 'eml22:MomentOfForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MomentOfForceMeasure (-727)

#endif

/* eml22__MolecularWeightMeasureExt has binding name 'eml22__MolecularWeightMeasureExt' for type 'eml22:MolecularWeightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasureExt (-726)

#endif

/* eml22__MolecularWeightMeasure has binding name 'eml22__MolecularWeightMeasure' for type 'eml22:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolecularWeightMeasure (-725)

#endif

/* eml22__MolarVolumeMeasureExt has binding name 'eml22__MolarVolumeMeasureExt' for type 'eml22:MolarVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasureExt (-724)

#endif

/* eml22__MolarVolumeMeasure has binding name 'eml22__MolarVolumeMeasure' for type 'eml22:MolarVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarVolumeMeasure (-723)

#endif

/* eml22__MolarHeatCapacityMeasureExt has binding name 'eml22__MolarHeatCapacityMeasureExt' for type 'eml22:MolarHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasureExt (-722)

#endif

/* eml22__MolarHeatCapacityMeasure has binding name 'eml22__MolarHeatCapacityMeasure' for type 'eml22:MolarHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarHeatCapacityMeasure (-721)

#endif

/* eml22__MolarEnergyMeasureExt has binding name 'eml22__MolarEnergyMeasureExt' for type 'eml22:MolarEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasureExt (-720)

#endif

/* eml22__MolarEnergyMeasure has binding name 'eml22__MolarEnergyMeasure' for type 'eml22:MolarEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MolarEnergyMeasure (-719)

#endif

/* eml22__MobilityMeasureExt has binding name 'eml22__MobilityMeasureExt' for type 'eml22:MobilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasureExt (-718)

#endif

/* eml22__MobilityMeasure has binding name 'eml22__MobilityMeasure' for type 'eml22:MobilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MobilityMeasure (-717)

#endif

/* eml22__MassPerVolumePerTemperatureMeasureExt has binding name 'eml22__MassPerVolumePerTemperatureMeasureExt' for type 'eml22:MassPerVolumePerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasureExt (-716)

#endif

/* eml22__MassPerVolumePerTemperatureMeasure has binding name 'eml22__MassPerVolumePerTemperatureMeasure' for type 'eml22:MassPerVolumePerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerTemperatureMeasure (-715)

#endif

/* eml22__MassPerVolumePerPressureMeasureExt has binding name 'eml22__MassPerVolumePerPressureMeasureExt' for type 'eml22:MassPerVolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasureExt (-714)

#endif

/* eml22__MassPerVolumePerPressureMeasure has binding name 'eml22__MassPerVolumePerPressureMeasure' for type 'eml22:MassPerVolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerPressureMeasure (-713)

#endif

/* eml22__MassPerVolumePerLengthMeasureExt has binding name 'eml22__MassPerVolumePerLengthMeasureExt' for type 'eml22:MassPerVolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasureExt (-712)

#endif

/* eml22__MassPerVolumePerLengthMeasure has binding name 'eml22__MassPerVolumePerLengthMeasure' for type 'eml22:MassPerVolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumePerLengthMeasure (-711)

#endif

/* eml22__MassPerVolumeMeasureExt has binding name 'eml22__MassPerVolumeMeasureExt' for type 'eml22:MassPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasureExt (-710)

#endif

/* eml22__MassPerVolumeMeasure has binding name 'eml22__MassPerVolumeMeasure' for type 'eml22:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerVolumeMeasure (-709)

#endif

/* eml22__MassPerTimePerLengthMeasureExt has binding name 'eml22__MassPerTimePerLengthMeasureExt' for type 'eml22:MassPerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasureExt (-708)

#endif

/* eml22__MassPerTimePerLengthMeasure has binding name 'eml22__MassPerTimePerLengthMeasure' for type 'eml22:MassPerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerLengthMeasure (-707)

#endif

/* eml22__MassPerTimePerAreaMeasureExt has binding name 'eml22__MassPerTimePerAreaMeasureExt' for type 'eml22:MassPerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasureExt (-706)

#endif

/* eml22__MassPerTimePerAreaMeasure has binding name 'eml22__MassPerTimePerAreaMeasure' for type 'eml22:MassPerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimePerAreaMeasure (-705)

#endif

/* eml22__MassPerTimeMeasureExt has binding name 'eml22__MassPerTimeMeasureExt' for type 'eml22:MassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasureExt (-704)

#endif

/* eml22__MassPerTimeMeasure has binding name 'eml22__MassPerTimeMeasure' for type 'eml22:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerTimeMeasure (-703)

#endif

/* eml22__MassPerMassMeasureExt has binding name 'eml22__MassPerMassMeasureExt' for type 'eml22:MassPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasureExt (-702)

#endif

/* eml22__MassPerMassMeasure has binding name 'eml22__MassPerMassMeasure' for type 'eml22:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerMassMeasure (-701)

#endif

/* eml22__MassPerLengthMeasureExt has binding name 'eml22__MassPerLengthMeasureExt' for type 'eml22:MassPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasureExt (-700)

#endif

/* eml22__MassPerLengthMeasure has binding name 'eml22__MassPerLengthMeasure' for type 'eml22:MassPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerLengthMeasure (-699)

#endif

/* eml22__MassPerEnergyMeasureExt has binding name 'eml22__MassPerEnergyMeasureExt' for type 'eml22:MassPerEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasureExt (-698)

#endif

/* eml22__MassPerEnergyMeasure has binding name 'eml22__MassPerEnergyMeasure' for type 'eml22:MassPerEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerEnergyMeasure (-697)

#endif

/* eml22__MassPerAreaMeasureExt has binding name 'eml22__MassPerAreaMeasureExt' for type 'eml22:MassPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasureExt (-696)

#endif

/* eml22__MassPerAreaMeasure has binding name 'eml22__MassPerAreaMeasure' for type 'eml22:MassPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassPerAreaMeasure (-695)

#endif

/* eml22__MassMeasureExt has binding name 'eml22__MassMeasureExt' for type 'eml22:MassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasureExt (-694)

#endif

/* eml22__MassMeasure has binding name 'eml22__MassMeasure' for type 'eml22:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassMeasure (-693)

#endif

/* eml22__MassLengthMeasureExt has binding name 'eml22__MassLengthMeasureExt' for type 'eml22:MassLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasureExt (-692)

#endif

/* eml22__MassLengthMeasure has binding name 'eml22__MassLengthMeasure' for type 'eml22:MassLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MassLengthMeasure (-691)

#endif

/* eml22__MagneticVectorPotentialMeasureExt has binding name 'eml22__MagneticVectorPotentialMeasureExt' for type 'eml22:MagneticVectorPotentialMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasureExt (-690)

#endif

/* eml22__MagneticVectorPotentialMeasure has binding name 'eml22__MagneticVectorPotentialMeasure' for type 'eml22:MagneticVectorPotentialMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticVectorPotentialMeasure (-689)

#endif

/* eml22__MagneticPermeabilityMeasureExt has binding name 'eml22__MagneticPermeabilityMeasureExt' for type 'eml22:MagneticPermeabilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasureExt (-688)

#endif

/* eml22__MagneticPermeabilityMeasure has binding name 'eml22__MagneticPermeabilityMeasure' for type 'eml22:MagneticPermeabilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticPermeabilityMeasure (-687)

#endif

/* eml22__MagneticFluxMeasureExt has binding name 'eml22__MagneticFluxMeasureExt' for type 'eml22:MagneticFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasureExt (-686)

#endif

/* eml22__MagneticFluxMeasure has binding name 'eml22__MagneticFluxMeasure' for type 'eml22:MagneticFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxMeasure (-685)

#endif

/* eml22__MagneticFluxDensityPerLengthMeasureExt has binding name 'eml22__MagneticFluxDensityPerLengthMeasureExt' for type 'eml22:MagneticFluxDensityPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasureExt (-684)

#endif

/* eml22__MagneticFluxDensityPerLengthMeasure has binding name 'eml22__MagneticFluxDensityPerLengthMeasure' for type 'eml22:MagneticFluxDensityPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityPerLengthMeasure (-683)

#endif

/* eml22__MagneticFluxDensityMeasureExt has binding name 'eml22__MagneticFluxDensityMeasureExt' for type 'eml22:MagneticFluxDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasureExt (-682)

#endif

/* eml22__MagneticFluxDensityMeasure has binding name 'eml22__MagneticFluxDensityMeasure' for type 'eml22:MagneticFluxDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFluxDensityMeasure (-681)

#endif

/* eml22__MagneticFieldStrengthMeasureExt has binding name 'eml22__MagneticFieldStrengthMeasureExt' for type 'eml22:MagneticFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasureExt (-680)

#endif

/* eml22__MagneticFieldStrengthMeasure has binding name 'eml22__MagneticFieldStrengthMeasure' for type 'eml22:MagneticFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticFieldStrengthMeasure (-679)

#endif

/* eml22__MagneticDipoleMomentMeasureExt has binding name 'eml22__MagneticDipoleMomentMeasureExt' for type 'eml22:MagneticDipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasureExt (-678)

#endif

/* eml22__MagneticDipoleMomentMeasure has binding name 'eml22__MagneticDipoleMomentMeasure' for type 'eml22:MagneticDipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__MagneticDipoleMomentMeasure (-677)

#endif

/* eml22__LuminousIntensityMeasureExt has binding name 'eml22__LuminousIntensityMeasureExt' for type 'eml22:LuminousIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasureExt (-676)

#endif

/* eml22__LuminousIntensityMeasure has binding name 'eml22__LuminousIntensityMeasure' for type 'eml22:LuminousIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousIntensityMeasure (-675)

#endif

/* eml22__LuminousFluxMeasureExt has binding name 'eml22__LuminousFluxMeasureExt' for type 'eml22:LuminousFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasureExt (-674)

#endif

/* eml22__LuminousFluxMeasure has binding name 'eml22__LuminousFluxMeasure' for type 'eml22:LuminousFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousFluxMeasure (-673)

#endif

/* eml22__LuminousEfficacyMeasureExt has binding name 'eml22__LuminousEfficacyMeasureExt' for type 'eml22:LuminousEfficacyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasureExt (-672)

#endif

/* eml22__LuminousEfficacyMeasure has binding name 'eml22__LuminousEfficacyMeasure' for type 'eml22:LuminousEfficacyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminousEfficacyMeasure (-671)

#endif

/* eml22__LuminanceMeasureExt has binding name 'eml22__LuminanceMeasureExt' for type 'eml22:LuminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasureExt (-670)

#endif

/* eml22__LuminanceMeasure has binding name 'eml22__LuminanceMeasure' for type 'eml22:LuminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LuminanceMeasure (-669)

#endif

/* eml22__LogarithmicPowerRatioPerLengthMeasureExt has binding name 'eml22__LogarithmicPowerRatioPerLengthMeasureExt' for type 'eml22:LogarithmicPowerRatioPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasureExt (-668)

#endif

/* eml22__LogarithmicPowerRatioPerLengthMeasure has binding name 'eml22__LogarithmicPowerRatioPerLengthMeasure' for type 'eml22:LogarithmicPowerRatioPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioPerLengthMeasure (-667)

#endif

/* eml22__LogarithmicPowerRatioMeasureExt has binding name 'eml22__LogarithmicPowerRatioMeasureExt' for type 'eml22:LogarithmicPowerRatioMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasureExt (-666)

#endif

/* eml22__LogarithmicPowerRatioMeasure has binding name 'eml22__LogarithmicPowerRatioMeasure' for type 'eml22:LogarithmicPowerRatioMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LogarithmicPowerRatioMeasure (-665)

#endif

/* eml22__LinearThermalExpansionMeasureExt has binding name 'eml22__LinearThermalExpansionMeasureExt' for type 'eml22:LinearThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasureExt (-664)

#endif

/* eml22__LinearThermalExpansionMeasure has binding name 'eml22__LinearThermalExpansionMeasure' for type 'eml22:LinearThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearThermalExpansionMeasure (-663)

#endif

/* eml22__LinearAccelerationMeasureExt has binding name 'eml22__LinearAccelerationMeasureExt' for type 'eml22:LinearAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasureExt (-662)

#endif

/* eml22__LinearAccelerationMeasure has binding name 'eml22__LinearAccelerationMeasure' for type 'eml22:LinearAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LinearAccelerationMeasure (-661)

#endif

/* eml22__LightExposureMeasureExt has binding name 'eml22__LightExposureMeasureExt' for type 'eml22:LightExposureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasureExt (-660)

#endif

/* eml22__LightExposureMeasure has binding name 'eml22__LightExposureMeasure' for type 'eml22:LightExposureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LightExposureMeasure (-659)

#endif

/* eml22__LengthPerVolumeMeasureExt has binding name 'eml22__LengthPerVolumeMeasureExt' for type 'eml22:LengthPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasureExt (-658)

#endif

/* eml22__LengthPerVolumeMeasure has binding name 'eml22__LengthPerVolumeMeasure' for type 'eml22:LengthPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerVolumeMeasure (-657)

#endif

/* eml22__LengthPerTimeMeasureExt has binding name 'eml22__LengthPerTimeMeasureExt' for type 'eml22:LengthPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasureExt (-656)

#endif

/* eml22__LengthPerTimeMeasure has binding name 'eml22__LengthPerTimeMeasure' for type 'eml22:LengthPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTimeMeasure (-655)

#endif

/* eml22__LengthPerTemperatureMeasureExt has binding name 'eml22__LengthPerTemperatureMeasureExt' for type 'eml22:LengthPerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasureExt (-654)

#endif

/* eml22__LengthPerTemperatureMeasure has binding name 'eml22__LengthPerTemperatureMeasure' for type 'eml22:LengthPerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerTemperatureMeasure (-653)

#endif

/* eml22__LengthPerPressureMeasureExt has binding name 'eml22__LengthPerPressureMeasureExt' for type 'eml22:LengthPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasureExt (-652)

#endif

/* eml22__LengthPerPressureMeasure has binding name 'eml22__LengthPerPressureMeasure' for type 'eml22:LengthPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerPressureMeasure (-651)

#endif

/* eml22__LengthPerMassMeasureExt has binding name 'eml22__LengthPerMassMeasureExt' for type 'eml22:LengthPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasureExt (-650)

#endif

/* eml22__LengthPerMassMeasure has binding name 'eml22__LengthPerMassMeasure' for type 'eml22:LengthPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerMassMeasure (-649)

#endif

/* eml22__LengthPerLengthMeasureExt has binding name 'eml22__LengthPerLengthMeasureExt' for type 'eml22:LengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasureExt (-648)

#endif

/* eml22__LengthPerLengthMeasure has binding name 'eml22__LengthPerLengthMeasure' for type 'eml22:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthPerLengthMeasure (-647)

#endif

/* eml22__LengthOrTimeMeasureExt has binding name 'eml22__LengthOrTimeMeasureExt' for type 'eml22:LengthOrTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthOrTimeMeasureExt (-646)

#endif

/* eml22__LengthMeasureExt has binding name 'eml22__LengthMeasureExt' for type 'eml22:LengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasureExt (-645)

#endif

/* eml22__LengthMeasure has binding name 'eml22__LengthMeasure' for type 'eml22:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__LengthMeasure (-644)

#endif

/* eml22__KinematicViscosityMeasureExt has binding name 'eml22__KinematicViscosityMeasureExt' for type 'eml22:KinematicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasureExt (-643)

#endif

/* eml22__KinematicViscosityMeasure has binding name 'eml22__KinematicViscosityMeasure' for type 'eml22:KinematicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__KinematicViscosityMeasure (-642)

#endif

/* eml22__IsothermalCompressibilityMeasureExt has binding name 'eml22__IsothermalCompressibilityMeasureExt' for type 'eml22:IsothermalCompressibilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasureExt (-641)

#endif

/* eml22__IsothermalCompressibilityMeasure has binding name 'eml22__IsothermalCompressibilityMeasure' for type 'eml22:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__IsothermalCompressibilityMeasure (-640)

#endif

/* eml22__InductanceMeasureExt has binding name 'eml22__InductanceMeasureExt' for type 'eml22:InductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasureExt (-639)

#endif

/* eml22__InductanceMeasure has binding name 'eml22__InductanceMeasure' for type 'eml22:InductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__InductanceMeasure (-638)

#endif

/* eml22__IlluminanceMeasureExt has binding name 'eml22__IlluminanceMeasureExt' for type 'eml22:IlluminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasureExt (-637)

#endif

/* eml22__IlluminanceMeasure has binding name 'eml22__IlluminanceMeasure' for type 'eml22:IlluminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__IlluminanceMeasure (-636)

#endif

/* eml22__HeatTransferCoefficientMeasureExt has binding name 'eml22__HeatTransferCoefficientMeasureExt' for type 'eml22:HeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasureExt (-635)

#endif

/* eml22__HeatTransferCoefficientMeasure has binding name 'eml22__HeatTransferCoefficientMeasure' for type 'eml22:HeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatTransferCoefficientMeasure (-634)

#endif

/* eml22__HeatFlowRateMeasureExt has binding name 'eml22__HeatFlowRateMeasureExt' for type 'eml22:HeatFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasureExt (-633)

#endif

/* eml22__HeatFlowRateMeasure has binding name 'eml22__HeatFlowRateMeasure' for type 'eml22:HeatFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatFlowRateMeasure (-632)

#endif

/* eml22__HeatCapacityMeasureExt has binding name 'eml22__HeatCapacityMeasureExt' for type 'eml22:HeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasureExt (-631)

#endif

/* eml22__HeatCapacityMeasure has binding name 'eml22__HeatCapacityMeasure' for type 'eml22:HeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__HeatCapacityMeasure (-630)

#endif

/* eml22__FrequencyMeasureExt has binding name 'eml22__FrequencyMeasureExt' for type 'eml22:FrequencyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasureExt (-629)

#endif

/* eml22__FrequencyMeasure has binding name 'eml22__FrequencyMeasure' for type 'eml22:FrequencyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyMeasure (-628)

#endif

/* eml22__FrequencyIntervalMeasureExt has binding name 'eml22__FrequencyIntervalMeasureExt' for type 'eml22:FrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasureExt (-627)

#endif

/* eml22__FrequencyIntervalMeasure has binding name 'eml22__FrequencyIntervalMeasure' for type 'eml22:FrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__FrequencyIntervalMeasure (-626)

#endif

/* eml22__ForcePerVolumeMeasureExt has binding name 'eml22__ForcePerVolumeMeasureExt' for type 'eml22:ForcePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasureExt (-625)

#endif

/* eml22__ForcePerVolumeMeasure has binding name 'eml22__ForcePerVolumeMeasure' for type 'eml22:ForcePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerVolumeMeasure (-624)

#endif

/* eml22__ForcePerLengthMeasureExt has binding name 'eml22__ForcePerLengthMeasureExt' for type 'eml22:ForcePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasureExt (-623)

#endif

/* eml22__ForcePerLengthMeasure has binding name 'eml22__ForcePerLengthMeasure' for type 'eml22:ForcePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerLengthMeasure (-622)

#endif

/* eml22__ForcePerForceMeasureExt has binding name 'eml22__ForcePerForceMeasureExt' for type 'eml22:ForcePerForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasureExt (-621)

#endif

/* eml22__ForcePerForceMeasure has binding name 'eml22__ForcePerForceMeasure' for type 'eml22:ForcePerForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForcePerForceMeasure (-620)

#endif

/* eml22__ForceMeasureExt has binding name 'eml22__ForceMeasureExt' for type 'eml22:ForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasureExt (-619)

#endif

/* eml22__ForceMeasure has binding name 'eml22__ForceMeasure' for type 'eml22:ForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceMeasure (-618)

#endif

/* eml22__ForceLengthPerLengthMeasureExt has binding name 'eml22__ForceLengthPerLengthMeasureExt' for type 'eml22:ForceLengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasureExt (-617)

#endif

/* eml22__ForceLengthPerLengthMeasure has binding name 'eml22__ForceLengthPerLengthMeasure' for type 'eml22:ForceLengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceLengthPerLengthMeasure (-616)

#endif

/* eml22__ForceAreaMeasureExt has binding name 'eml22__ForceAreaMeasureExt' for type 'eml22:ForceAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasureExt (-615)

#endif

/* eml22__ForceAreaMeasure has binding name 'eml22__ForceAreaMeasure' for type 'eml22:ForceAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ForceAreaMeasure (-614)

#endif

/* eml22__EnergyPerVolumeMeasureExt has binding name 'eml22__EnergyPerVolumeMeasureExt' for type 'eml22:EnergyPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasureExt (-613)

#endif

/* eml22__EnergyPerVolumeMeasure has binding name 'eml22__EnergyPerVolumeMeasure' for type 'eml22:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerVolumeMeasure (-612)

#endif

/* eml22__EnergyPerMassPerTimeMeasureExt has binding name 'eml22__EnergyPerMassPerTimeMeasureExt' for type 'eml22:EnergyPerMassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasureExt (-611)

#endif

/* eml22__EnergyPerMassPerTimeMeasure has binding name 'eml22__EnergyPerMassPerTimeMeasure' for type 'eml22:EnergyPerMassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassPerTimeMeasure (-610)

#endif

/* eml22__EnergyPerMassMeasureExt has binding name 'eml22__EnergyPerMassMeasureExt' for type 'eml22:EnergyPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasureExt (-609)

#endif

/* eml22__EnergyPerMassMeasure has binding name 'eml22__EnergyPerMassMeasure' for type 'eml22:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerMassMeasure (-608)

#endif

/* eml22__EnergyPerLengthMeasureExt has binding name 'eml22__EnergyPerLengthMeasureExt' for type 'eml22:EnergyPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasureExt (-607)

#endif

/* eml22__EnergyPerLengthMeasure has binding name 'eml22__EnergyPerLengthMeasure' for type 'eml22:EnergyPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerLengthMeasure (-606)

#endif

/* eml22__EnergyPerAreaMeasureExt has binding name 'eml22__EnergyPerAreaMeasureExt' for type 'eml22:EnergyPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasureExt (-605)

#endif

/* eml22__EnergyPerAreaMeasure has binding name 'eml22__EnergyPerAreaMeasure' for type 'eml22:EnergyPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyPerAreaMeasure (-604)

#endif

/* eml22__EnergyMeasureExt has binding name 'eml22__EnergyMeasureExt' for type 'eml22:EnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasureExt (-603)

#endif

/* eml22__EnergyMeasure has binding name 'eml22__EnergyMeasure' for type 'eml22:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyMeasure (-602)

#endif

/* eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt has binding name 'eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt' for type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasureExt (-601)

#endif

/* eml22__EnergyLengthPerTimeAreaTemperatureMeasure has binding name 'eml22__EnergyLengthPerTimeAreaTemperatureMeasure' for type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerTimeAreaTemperatureMeasure (-600)

#endif

/* eml22__EnergyLengthPerAreaMeasureExt has binding name 'eml22__EnergyLengthPerAreaMeasureExt' for type 'eml22:EnergyLengthPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasureExt (-599)

#endif

/* eml22__EnergyLengthPerAreaMeasure has binding name 'eml22__EnergyLengthPerAreaMeasure' for type 'eml22:EnergyLengthPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__EnergyLengthPerAreaMeasure (-598)

#endif

/* eml22__ElectromagneticMomentMeasureExt has binding name 'eml22__ElectromagneticMomentMeasureExt' for type 'eml22:ElectromagneticMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasureExt (-597)

#endif

/* eml22__ElectromagneticMomentMeasure has binding name 'eml22__ElectromagneticMomentMeasure' for type 'eml22:ElectromagneticMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectromagneticMomentMeasure (-596)

#endif

/* eml22__ElectricResistancePerLengthMeasureExt has binding name 'eml22__ElectricResistancePerLengthMeasureExt' for type 'eml22:ElectricResistancePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasureExt (-595)

#endif

/* eml22__ElectricResistancePerLengthMeasure has binding name 'eml22__ElectricResistancePerLengthMeasure' for type 'eml22:ElectricResistancePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistancePerLengthMeasure (-594)

#endif

/* eml22__ElectricResistanceMeasureExt has binding name 'eml22__ElectricResistanceMeasureExt' for type 'eml22:ElectricResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasureExt (-593)

#endif

/* eml22__ElectricResistanceMeasure has binding name 'eml22__ElectricResistanceMeasure' for type 'eml22:ElectricResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricResistanceMeasure (-592)

#endif

/* eml22__ElectricPotentialDifferenceMeasureExt has binding name 'eml22__ElectricPotentialDifferenceMeasureExt' for type 'eml22:ElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasureExt (-591)

#endif

/* eml22__ElectricPotentialDifferenceMeasure has binding name 'eml22__ElectricPotentialDifferenceMeasure' for type 'eml22:ElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricPotentialDifferenceMeasure (-590)

#endif

/* eml22__ElectricFieldStrengthMeasureExt has binding name 'eml22__ElectricFieldStrengthMeasureExt' for type 'eml22:ElectricFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasureExt (-589)

#endif

/* eml22__ElectricFieldStrengthMeasure has binding name 'eml22__ElectricFieldStrengthMeasure' for type 'eml22:ElectricFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricFieldStrengthMeasure (-588)

#endif

/* eml22__ElectricCurrentMeasureExt has binding name 'eml22__ElectricCurrentMeasureExt' for type 'eml22:ElectricCurrentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasureExt (-587)

#endif

/* eml22__ElectricCurrentMeasure has binding name 'eml22__ElectricCurrentMeasure' for type 'eml22:ElectricCurrentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentMeasure (-586)

#endif

/* eml22__ElectricCurrentDensityMeasureExt has binding name 'eml22__ElectricCurrentDensityMeasureExt' for type 'eml22:ElectricCurrentDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasureExt (-585)

#endif

/* eml22__ElectricCurrentDensityMeasure has binding name 'eml22__ElectricCurrentDensityMeasure' for type 'eml22:ElectricCurrentDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricCurrentDensityMeasure (-584)

#endif

/* eml22__ElectricConductivityMeasureExt has binding name 'eml22__ElectricConductivityMeasureExt' for type 'eml22:ElectricConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasureExt (-583)

#endif

/* eml22__ElectricConductivityMeasure has binding name 'eml22__ElectricConductivityMeasure' for type 'eml22:ElectricConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductivityMeasure (-582)

#endif

/* eml22__ElectricConductanceMeasureExt has binding name 'eml22__ElectricConductanceMeasureExt' for type 'eml22:ElectricConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasureExt (-581)

#endif

/* eml22__ElectricConductanceMeasure has binding name 'eml22__ElectricConductanceMeasure' for type 'eml22:ElectricConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricConductanceMeasure (-580)

#endif

/* eml22__ElectricChargePerVolumeMeasureExt has binding name 'eml22__ElectricChargePerVolumeMeasureExt' for type 'eml22:ElectricChargePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasureExt (-579)

#endif

/* eml22__ElectricChargePerVolumeMeasure has binding name 'eml22__ElectricChargePerVolumeMeasure' for type 'eml22:ElectricChargePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerVolumeMeasure (-578)

#endif

/* eml22__ElectricChargePerMassMeasureExt has binding name 'eml22__ElectricChargePerMassMeasureExt' for type 'eml22:ElectricChargePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasureExt (-577)

#endif

/* eml22__ElectricChargePerMassMeasure has binding name 'eml22__ElectricChargePerMassMeasure' for type 'eml22:ElectricChargePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerMassMeasure (-576)

#endif

/* eml22__ElectricChargePerAreaMeasureExt has binding name 'eml22__ElectricChargePerAreaMeasureExt' for type 'eml22:ElectricChargePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasureExt (-575)

#endif

/* eml22__ElectricChargePerAreaMeasure has binding name 'eml22__ElectricChargePerAreaMeasure' for type 'eml22:ElectricChargePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargePerAreaMeasure (-574)

#endif

/* eml22__ElectricChargeMeasureExt has binding name 'eml22__ElectricChargeMeasureExt' for type 'eml22:ElectricChargeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasureExt (-573)

#endif

/* eml22__ElectricChargeMeasure has binding name 'eml22__ElectricChargeMeasure' for type 'eml22:ElectricChargeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricChargeMeasure (-572)

#endif

/* eml22__ElectricalResistivityMeasureExt has binding name 'eml22__ElectricalResistivityMeasureExt' for type 'eml22:ElectricalResistivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasureExt (-571)

#endif

/* eml22__ElectricalResistivityMeasure has binding name 'eml22__ElectricalResistivityMeasure' for type 'eml22:ElectricalResistivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ElectricalResistivityMeasure (-570)

#endif

/* eml22__DynamicViscosityMeasureExt has binding name 'eml22__DynamicViscosityMeasureExt' for type 'eml22:DynamicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasureExt (-569)

#endif

/* eml22__DynamicViscosityMeasure has binding name 'eml22__DynamicViscosityMeasure' for type 'eml22:DynamicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DynamicViscosityMeasure (-568)

#endif

/* eml22__DoseEquivalentMeasureExt has binding name 'eml22__DoseEquivalentMeasureExt' for type 'eml22:DoseEquivalentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasureExt (-567)

#endif

/* eml22__DoseEquivalentMeasure has binding name 'eml22__DoseEquivalentMeasure' for type 'eml22:DoseEquivalentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoseEquivalentMeasure (-566)

#endif

/* eml22__DipoleMomentMeasureExt has binding name 'eml22__DipoleMomentMeasureExt' for type 'eml22:DipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasureExt (-565)

#endif

/* eml22__DipoleMomentMeasure has binding name 'eml22__DipoleMomentMeasure' for type 'eml22:DipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DipoleMomentMeasure (-564)

#endif

/* eml22__DimensionlessMeasureExt has binding name 'eml22__DimensionlessMeasureExt' for type 'eml22:DimensionlessMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasureExt (-563)

#endif

/* eml22__DimensionlessMeasure has binding name 'eml22__DimensionlessMeasure' for type 'eml22:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DimensionlessMeasure (-562)

#endif

/* eml22__DigitalStorageMeasureExt has binding name 'eml22__DigitalStorageMeasureExt' for type 'eml22:DigitalStorageMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasureExt (-561)

#endif

/* eml22__DigitalStorageMeasure has binding name 'eml22__DigitalStorageMeasure' for type 'eml22:DigitalStorageMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DigitalStorageMeasure (-560)

#endif

/* eml22__DiffusiveTimeOfFlightMeasureExt has binding name 'eml22__DiffusiveTimeOfFlightMeasureExt' for type 'eml22:DiffusiveTimeOfFlightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasureExt (-559)

#endif

/* eml22__DiffusiveTimeOfFlightMeasure has binding name 'eml22__DiffusiveTimeOfFlightMeasure' for type 'eml22:DiffusiveTimeOfFlightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusiveTimeOfFlightMeasure (-558)

#endif

/* eml22__DiffusionCoefficientMeasureExt has binding name 'eml22__DiffusionCoefficientMeasureExt' for type 'eml22:DiffusionCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasureExt (-557)

#endif

/* eml22__DiffusionCoefficientMeasure has binding name 'eml22__DiffusionCoefficientMeasure' for type 'eml22:DiffusionCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DiffusionCoefficientMeasure (-556)

#endif

/* eml22__DataTransferSpeedMeasureExt has binding name 'eml22__DataTransferSpeedMeasureExt' for type 'eml22:DataTransferSpeedMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasureExt (-555)

#endif

/* eml22__DataTransferSpeedMeasure has binding name 'eml22__DataTransferSpeedMeasure' for type 'eml22:DataTransferSpeedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__DataTransferSpeedMeasure (-554)

#endif

/* eml22__CationExchangeCapacityMeasureExt has binding name 'eml22__CationExchangeCapacityMeasureExt' for type 'eml22:CationExchangeCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasureExt (-553)

#endif

/* eml22__CationExchangeCapacityMeasure has binding name 'eml22__CationExchangeCapacityMeasure' for type 'eml22:CationExchangeCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__CationExchangeCapacityMeasure (-552)

#endif

/* eml22__CapacitanceMeasureExt has binding name 'eml22__CapacitanceMeasureExt' for type 'eml22:CapacitanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasureExt (-551)

#endif

/* eml22__CapacitanceMeasure has binding name 'eml22__CapacitanceMeasure' for type 'eml22:CapacitanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__CapacitanceMeasure (-550)

#endif

/* eml22__AttenuationPerFrequencyIntervalMeasureExt has binding name 'eml22__AttenuationPerFrequencyIntervalMeasureExt' for type 'eml22:AttenuationPerFrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasureExt (-549)

#endif

/* eml22__AttenuationPerFrequencyIntervalMeasure has binding name 'eml22__AttenuationPerFrequencyIntervalMeasure' for type 'eml22:AttenuationPerFrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AttenuationPerFrequencyIntervalMeasure (-548)

#endif

/* eml22__AreaPerVolumeMeasureExt has binding name 'eml22__AreaPerVolumeMeasureExt' for type 'eml22:AreaPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasureExt (-547)

#endif

/* eml22__AreaPerVolumeMeasure has binding name 'eml22__AreaPerVolumeMeasure' for type 'eml22:AreaPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerVolumeMeasure (-546)

#endif

/* eml22__AreaPerTimeMeasureExt has binding name 'eml22__AreaPerTimeMeasureExt' for type 'eml22:AreaPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasureExt (-545)

#endif

/* eml22__AreaPerTimeMeasure has binding name 'eml22__AreaPerTimeMeasure' for type 'eml22:AreaPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerTimeMeasure (-544)

#endif

/* eml22__AreaPerMassMeasureExt has binding name 'eml22__AreaPerMassMeasureExt' for type 'eml22:AreaPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasureExt (-543)

#endif

/* eml22__AreaPerMassMeasure has binding name 'eml22__AreaPerMassMeasure' for type 'eml22:AreaPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerMassMeasure (-542)

#endif

/* eml22__AreaPerCountMeasureExt has binding name 'eml22__AreaPerCountMeasureExt' for type 'eml22:AreaPerCountMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasureExt (-541)

#endif

/* eml22__AreaPerCountMeasure has binding name 'eml22__AreaPerCountMeasure' for type 'eml22:AreaPerCountMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerCountMeasure (-540)

#endif

/* eml22__AreaPerAreaMeasureExt has binding name 'eml22__AreaPerAreaMeasureExt' for type 'eml22:AreaPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasureExt (-539)

#endif

/* eml22__AreaPerAreaMeasure has binding name 'eml22__AreaPerAreaMeasure' for type 'eml22:AreaPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAreaMeasure (-538)

#endif

/* eml22__AreaPerAmountOfSubstanceMeasureExt has binding name 'eml22__AreaPerAmountOfSubstanceMeasureExt' for type 'eml22:AreaPerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasureExt (-537)

#endif

/* eml22__AreaPerAmountOfSubstanceMeasure has binding name 'eml22__AreaPerAmountOfSubstanceMeasure' for type 'eml22:AreaPerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaPerAmountOfSubstanceMeasure (-536)

#endif

/* eml22__AreaMeasureExt has binding name 'eml22__AreaMeasureExt' for type 'eml22:AreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasureExt (-535)

#endif

/* eml22__AreaMeasure has binding name 'eml22__AreaMeasure' for type 'eml22:AreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AreaMeasure (-534)

#endif

/* eml22__APINeutronMeasureExt has binding name 'eml22__APINeutronMeasureExt' for type 'eml22:APINeutronMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasureExt (-533)

#endif

/* eml22__APINeutronMeasure has binding name 'eml22__APINeutronMeasure' for type 'eml22:APINeutronMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APINeutronMeasure (-532)

#endif

/* eml22__APIGravityMeasureExt has binding name 'eml22__APIGravityMeasureExt' for type 'eml22:APIGravityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasureExt (-531)

#endif

/* eml22__APIGravityMeasure has binding name 'eml22__APIGravityMeasure' for type 'eml22:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGravityMeasure (-530)

#endif

/* eml22__APIGammaRayMeasureExt has binding name 'eml22__APIGammaRayMeasureExt' for type 'eml22:APIGammaRayMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasureExt (-529)

#endif

/* eml22__APIGammaRayMeasure has binding name 'eml22__APIGammaRayMeasure' for type 'eml22:APIGammaRayMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__APIGammaRayMeasure (-528)

#endif

/* eml22__AngularVelocityMeasureExt has binding name 'eml22__AngularVelocityMeasureExt' for type 'eml22:AngularVelocityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasureExt (-527)

#endif

/* eml22__AngularVelocityMeasure has binding name 'eml22__AngularVelocityMeasure' for type 'eml22:AngularVelocityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularVelocityMeasure (-526)

#endif

/* eml22__AngularAccelerationMeasureExt has binding name 'eml22__AngularAccelerationMeasureExt' for type 'eml22:AngularAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasureExt (-525)

#endif

/* eml22__AngularAccelerationMeasure has binding name 'eml22__AngularAccelerationMeasure' for type 'eml22:AngularAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AngularAccelerationMeasure (-524)

#endif

/* eml22__AnglePerVolumeMeasureExt has binding name 'eml22__AnglePerVolumeMeasureExt' for type 'eml22:AnglePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasureExt (-523)

#endif

/* eml22__AnglePerVolumeMeasure has binding name 'eml22__AnglePerVolumeMeasure' for type 'eml22:AnglePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerVolumeMeasure (-522)

#endif

/* eml22__AnglePerLengthMeasureExt has binding name 'eml22__AnglePerLengthMeasureExt' for type 'eml22:AnglePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasureExt (-521)

#endif

/* eml22__AnglePerLengthMeasure has binding name 'eml22__AnglePerLengthMeasure' for type 'eml22:AnglePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AnglePerLengthMeasure (-520)

#endif

/* eml22__AmountOfSubstancePerVolumeMeasureExt has binding name 'eml22__AmountOfSubstancePerVolumeMeasureExt' for type 'eml22:AmountOfSubstancePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasureExt (-519)

#endif

/* eml22__AmountOfSubstancePerVolumeMeasure has binding name 'eml22__AmountOfSubstancePerVolumeMeasure' for type 'eml22:AmountOfSubstancePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerVolumeMeasure (-518)

#endif

/* eml22__AmountOfSubstancePerTimePerAreaMeasureExt has binding name 'eml22__AmountOfSubstancePerTimePerAreaMeasureExt' for type 'eml22:AmountOfSubstancePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasureExt (-517)

#endif

/* eml22__AmountOfSubstancePerTimePerAreaMeasure has binding name 'eml22__AmountOfSubstancePerTimePerAreaMeasure' for type 'eml22:AmountOfSubstancePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimePerAreaMeasure (-516)

#endif

/* eml22__AmountOfSubstancePerTimeMeasureExt has binding name 'eml22__AmountOfSubstancePerTimeMeasureExt' for type 'eml22:AmountOfSubstancePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasureExt (-515)

#endif

/* eml22__AmountOfSubstancePerTimeMeasure has binding name 'eml22__AmountOfSubstancePerTimeMeasure' for type 'eml22:AmountOfSubstancePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerTimeMeasure (-514)

#endif

/* eml22__AmountOfSubstancePerAreaMeasureExt has binding name 'eml22__AmountOfSubstancePerAreaMeasureExt' for type 'eml22:AmountOfSubstancePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasureExt (-513)

#endif

/* eml22__AmountOfSubstancePerAreaMeasure has binding name 'eml22__AmountOfSubstancePerAreaMeasure' for type 'eml22:AmountOfSubstancePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAreaMeasure (-512)

#endif

/* eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt has binding name 'eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt' for type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasureExt (-511)

#endif

/* eml22__AmountOfSubstancePerAmountOfSubstanceMeasure has binding name 'eml22__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstancePerAmountOfSubstanceMeasure (-510)

#endif

/* eml22__AmountOfSubstanceMeasureExt has binding name 'eml22__AmountOfSubstanceMeasureExt' for type 'eml22:AmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasureExt (-509)

#endif

/* eml22__AmountOfSubstanceMeasure has binding name 'eml22__AmountOfSubstanceMeasure' for type 'eml22:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AmountOfSubstanceMeasure (-508)

#endif

/* eml22__ActivityOfRadioactivityMeasureExt has binding name 'eml22__ActivityOfRadioactivityMeasureExt' for type 'eml22:ActivityOfRadioactivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasureExt (-507)

#endif

/* eml22__ActivityOfRadioactivityMeasure has binding name 'eml22__ActivityOfRadioactivityMeasure' for type 'eml22:ActivityOfRadioactivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__ActivityOfRadioactivityMeasure (-506)

#endif

/* eml22__AbsorbedDoseMeasureExt has binding name 'eml22__AbsorbedDoseMeasureExt' for type 'eml22:AbsorbedDoseMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasureExt (-505)

#endif

/* eml22__AbsorbedDoseMeasure has binding name 'eml22__AbsorbedDoseMeasure' for type 'eml22:AbsorbedDoseMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbsorbedDoseMeasure (-504)

#endif

/* eml22__WellVerticalDepthCoord has binding name 'eml22__WellVerticalDepthCoord' for type 'eml22:WellVerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_eml22__WellVerticalDepthCoord (-503)

#endif

/* eml22__TvdInterval has binding name 'eml22__TvdInterval' for type 'eml22:TvdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__TvdInterval (-502)

#endif

/* eml22__StringMeasure has binding name 'eml22__StringMeasure' for type 'eml22:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringMeasure (-501)

#endif

/* eml22__StringExternalArray has binding name 'eml22__StringExternalArray' for type 'eml22:StringExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringExternalArray (-500)

#endif

/* eml22__StringConstantArray has binding name 'eml22__StringConstantArray' for type 'eml22:StringConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__StringConstantArray (-499)

#endif

/* eml22__MeasuredDepthCoord has binding name 'eml22__MeasuredDepthCoord' for type 'eml22:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_eml22__MeasuredDepthCoord (-498)

#endif

/* eml22__MdInterval has binding name 'eml22__MdInterval' for type 'eml22:MdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__MdInterval (-497)

#endif

/* eml22__JaggedArray has binding name 'eml22__JaggedArray' for type 'eml22:JaggedArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__JaggedArray (-496)

#endif

/* eml22__IntegerRangeArray has binding name 'eml22__IntegerRangeArray' for type 'eml22:IntegerRangeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerRangeArray (-495)

#endif

/* eml22__IntegerLatticeArray has binding name 'eml22__IntegerLatticeArray' for type 'eml22:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerLatticeArray (-494)

#endif

/* eml22__IntegerExternalArray has binding name 'eml22__IntegerExternalArray' for type 'eml22:IntegerExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerExternalArray (-493)

#endif

/* eml22__IntegerConstantArray has binding name 'eml22__IntegerConstantArray' for type 'eml22:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerConstantArray (-492)

#endif

/* eml22__IntegerArrayFromBooleanMaskArray has binding name 'eml22__IntegerArrayFromBooleanMaskArray' for type 'eml22:IntegerArrayFromBooleanMaskArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__IntegerArrayFromBooleanMaskArray (-491)

#endif

/* eml22__GenericMeasure has binding name 'eml22__GenericMeasure' for type 'eml22:GenericMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_2_eml22__GenericMeasure (-490)

#endif

/* eml22__FloatingPointLatticeArray has binding name 'eml22__FloatingPointLatticeArray' for type 'eml22:FloatingPointLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointLatticeArray (-489)

#endif

/* eml22__FloatingPointExternalArray has binding name 'eml22__FloatingPointExternalArray' for type 'eml22:FloatingPointExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointExternalArray (-488)

#endif

/* eml22__FloatingPointConstantArray has binding name 'eml22__FloatingPointConstantArray' for type 'eml22:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatingPointConstantArray (-487)

#endif

/* eml22__FloatExternalArray has binding name 'eml22__FloatExternalArray' for type 'eml22:FloatExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__FloatExternalArray (-486)

#endif

/* eml22__DummyType has binding name 'eml22__DummyType' for type 'eml22:DummyType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DummyType
#define SOAP_TYPE_gsoap_eml2_2_eml22__DummyType (-485)

#endif

/* eml22__DoubleExternalArray has binding name 'eml22__DoubleExternalArray' for type 'eml22:DoubleExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__DoubleExternalArray (-484)

#endif

/* eml22__Cost has binding name 'eml22__Cost' for type 'eml22:Cost' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Cost
#define SOAP_TYPE_gsoap_eml2_2_eml22__Cost (-483)

#endif

/* eml22__BooleanExternalArray has binding name 'eml22__BooleanExternalArray' for type 'eml22:BooleanExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanExternalArray (-482)

#endif

/* eml22__BooleanConstantArray has binding name 'eml22__BooleanConstantArray' for type 'eml22:BooleanConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanConstantArray (-481)

#endif

/* eml22__BooleanArrayFromIndexArray has binding name 'eml22__BooleanArrayFromIndexArray' for type 'eml22:BooleanArrayFromIndexArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__BooleanArrayFromIndexArray (-480)

#endif

/* eml22__AuthorityQualifiedName has binding name 'eml22__AuthorityQualifiedName' for type 'eml22:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_2_eml22__AuthorityQualifiedName (-479)

#endif

/* eml22__AbstractValueArray has binding name 'eml22__AbstractValueArray' for type 'eml22:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractValueArray (-478)

#endif

/* eml22__AbstractStringArray has binding name 'eml22__AbstractStringArray' for type 'eml22:AbstractStringArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractStringArray (-477)

#endif

/* eml22__AbstractNumericArray has binding name 'eml22__AbstractNumericArray' for type 'eml22:AbstractNumericArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractNumericArray (-476)

#endif

/* eml22__AbstractIntegerArray has binding name 'eml22__AbstractIntegerArray' for type 'eml22:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractIntegerArray (-475)

#endif

/* eml22__AbstractFloatingPointArray has binding name 'eml22__AbstractFloatingPointArray' for type 'eml22:AbstractFloatingPointArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractFloatingPointArray (-474)

#endif

/* eml22__AbstractBooleanArray has binding name 'eml22__AbstractBooleanArray' for type 'eml22:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractBooleanArray (-473)

#endif

/* eml22__TimeSeriesParentage has binding name 'eml22__TimeSeriesParentage' for type 'eml22:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeriesParentage (-472)

#endif

/* eml22__TimeSeries has binding name 'eml22__TimeSeries' for type 'eml22:TimeSeries' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeSeries (-471)

#endif

/* eml22__TimeIndices has binding name 'eml22__TimeIndices' for type 'eml22:TimeIndices' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndices (-470)

#endif

/* eml22__TimeIndex has binding name 'eml22__TimeIndex' for type 'eml22:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex
#define SOAP_TYPE_gsoap_eml2_2_eml22__TimeIndex (-469)

#endif

/* eml22__PropertyKindFacet has binding name 'eml22__PropertyKindFacet' for type 'eml22:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindFacet (-468)

#endif

/* eml22__PropertyKindDictionary has binding name 'eml22__PropertyKindDictionary' for type 'eml22:PropertyKindDictionary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKindDictionary (-467)

#endif

/* eml22__PropertyKind has binding name 'eml22__PropertyKind' for type 'eml22:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2_eml22__PropertyKind (-466)

#endif

/* eml22__GeologicTime has binding name 'eml22__GeologicTime' for type 'eml22:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime
#define SOAP_TYPE_gsoap_eml2_2_eml22__GeologicTime (-465)

#endif

/* eml22__DateTimeInterval has binding name 'eml22__DateTimeInterval' for type 'eml22:DateTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_2_eml22__DateTimeInterval (-464)

#endif

/* eml22__ObjectAlias has binding name 'eml22__ObjectAlias' for type 'eml22:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_2_eml22__ObjectAlias (-463)

#endif

/* eml22__ExtensionNameValue has binding name 'eml22__ExtensionNameValue' for type 'eml22:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_2_eml22__ExtensionNameValue (-462)

#endif

/* eml22__CustomData has binding name 'eml22__CustomData' for type 'eml22:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__CustomData
#define SOAP_TYPE_gsoap_eml2_2_eml22__CustomData (-461)

#endif

/* eml22__Citation has binding name 'eml22__Citation' for type 'eml22:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__Citation
#define SOAP_TYPE_gsoap_eml2_2_eml22__Citation (-460)

#endif

/* eml22__AbstractTimeIntervalGrowingPart has binding name 'eml22__AbstractTimeIntervalGrowingPart' for type 'eml22:AbstractTimeIntervalGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeIntervalGrowingPart (-459)

#endif

/* eml22__AbstractTimeGrowingPart has binding name 'eml22__AbstractTimeGrowingPart' for type 'eml22:AbstractTimeGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractTimeGrowingPart (-458)

#endif

/* eml22__AbstractObject has binding name 'eml22__AbstractObject' for type 'eml22:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractObject (-457)

#endif

/* eml22__AbstractMdIntervalGrowingPart has binding name 'eml22__AbstractMdIntervalGrowingPart' for type 'eml22:AbstractMdIntervalGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdIntervalGrowingPart (-456)

#endif

/* eml22__AbstractMdGrowingPart has binding name 'eml22__AbstractMdGrowingPart' for type 'eml22:AbstractMdGrowingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractMdGrowingPart (-455)

#endif

/* eml22__AbstractGrowingObjectPart has binding name 'eml22__AbstractGrowingObjectPart' for type 'eml22:AbstractGrowingObjectPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObjectPart (-454)

#endif

/* eml22__AbstractGrowingObject has binding name 'eml22__AbstractGrowingObject' for type 'eml22:AbstractGrowingObject' */
#ifndef SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject
#define SOAP_TYPE_gsoap_eml2_2_eml22__AbstractGrowingObject (-453)

#endif

/* prodml21__TimeSeriesStringSample has binding name 'prodml21__TimeSeriesStringSample' for type 'prodml21:TimeSeriesStringSample' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesStringSample (-452)

#endif

/* prodml21__TimeSeriesDoubleSample has binding name 'prodml21__TimeSeriesDoubleSample' for type 'prodml21:TimeSeriesDoubleSample' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesDoubleSample (-451)

#endif

/* prodml21__TimeSeriesData has binding name 'prodml21__TimeSeriesData' for type 'prodml21:TimeSeriesData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TimeSeriesData (-450)

#endif

/* prodml21__StringValue has binding name 'prodml21__StringValue' for type 'prodml21:StringValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StringValue (-449)

#endif

/* prodml21__DoubleValue has binding name 'prodml21__DoubleValue' for type 'prodml21:DoubleValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DoubleValue (-448)

#endif

/* prodml21__AbstractValue has binding name 'prodml21__AbstractValue' for type 'prodml21:AbstractValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractValue (-447)

#endif

/* prodml21__ReportingHierarchyNode has binding name 'prodml21__ReportingHierarchyNode' for type 'prodml21:ReportingHierarchyNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchyNode (-446)

#endif

/* prodml21__ReportingHierarchy has binding name 'prodml21__ReportingHierarchy' for type 'prodml21:ReportingHierarchy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingHierarchy (-445)

#endif

/* prodml21__ReportingEntity has binding name 'prodml21__ReportingEntity' for type 'prodml21:ReportingEntity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntity (-444)

#endif

/* prodml21__Facility has binding name 'prodml21__Facility' for type 'prodml21:Facility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Facility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Facility (-443)

#endif

/* prodml21__WellboreVolume has binding name 'prodml21__WellboreVolume' for type 'prodml21:WellboreVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreVolume (-442)

#endif

/* prodml21__WellboreStorageCoefficient has binding name 'prodml21__WellboreStorageCoefficient' for type 'prodml21:WellboreStorageCoefficient' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreStorageCoefficient (-441)

#endif

/* prodml21__WellboreRadius has binding name 'prodml21__WellboreRadius' for type 'prodml21:WellboreRadius' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreRadius (-440)

#endif

/* prodml21__WellboreFluidCompressibility has binding name 'prodml21__WellboreFluidCompressibility' for type 'prodml21:WellboreFluidCompressibility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreFluidCompressibility (-439)

#endif

/* prodml21__WellboreDeviationAngle has binding name 'prodml21__WellboreDeviationAngle' for type 'prodml21:WellboreDeviationAngle' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreDeviationAngle (-438)

#endif

/* prodml21__VerticalAnisotropyKvToKr has binding name 'prodml21__VerticalAnisotropyKvToKr' for type 'prodml21:VerticalAnisotropyKvToKr' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalAnisotropyKvToKr (-437)

#endif

/* prodml21__TubingInteralDiameter has binding name 'prodml21__TubingInteralDiameter' for type 'prodml21:TubingInteralDiameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TubingInteralDiameter (-436)

#endif

/* prodml21__TransmissibilityReductionFactorOfLinearFront has binding name 'prodml21__TransmissibilityReductionFactorOfLinearFront' for type 'prodml21:TransmissibilityReductionFactorOfLinearFront' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransmissibilityReductionFactorOfLinearFront (-435)

#endif

/* prodml21__TotalThickness has binding name 'prodml21__TotalThickness' for type 'prodml21:TotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TotalThickness (-434)

#endif

/* prodml21__StorativityRatio has binding name 'prodml21__StorativityRatio' for type 'prodml21:StorativityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StorativityRatio (-433)

#endif

/* prodml21__SkinRelativeToTotalThickness has binding name 'prodml21__SkinRelativeToTotalThickness' for type 'prodml21:SkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SkinRelativeToTotalThickness (-432)

#endif

/* prodml21__SkinLayer2RelativeToTotalThickness has binding name 'prodml21__SkinLayer2RelativeToTotalThickness' for type 'prodml21:SkinLayer2RelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SkinLayer2RelativeToTotalThickness (-431)

#endif

/* prodml21__Region2Thickness has binding name 'prodml21__Region2Thickness' for type 'prodml21:Region2Thickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Region2Thickness (-430)

#endif

/* prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct has binding name 'prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct' for type 'prodml21:RatioLayer1ToTotalPermeabilityThicknessProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct (-429)

#endif

/* prodml21__RatioInitialToFinalWellboreStorage has binding name 'prodml21__RatioInitialToFinalWellboreStorage' for type 'prodml21:RatioInitialToFinalWellboreStorage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioInitialToFinalWellboreStorage (-428)

#endif

/* prodml21__RatioDpSkinToTotalDrawdown has binding name 'prodml21__RatioDpSkinToTotalDrawdown' for type 'prodml21:RatioDpSkinToTotalDrawdown' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RatioDpSkinToTotalDrawdown (-427)

#endif

/* prodml21__RateDependentSkinFactor has binding name 'prodml21__RateDependentSkinFactor' for type 'prodml21:RateDependentSkinFactor' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RateDependentSkinFactor (-426)

#endif

/* prodml21__RadiusOfInvestigation has binding name 'prodml21__RadiusOfInvestigation' for type 'prodml21:RadiusOfInvestigation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RadiusOfInvestigation (-425)

#endif

/* prodml21__PressureDatumTVD has binding name 'prodml21__PressureDatumTVD' for type 'prodml21:PressureDatumTVD' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureDatumTVD (-424)

#endif

/* prodml21__Porosity has binding name 'prodml21__Porosity' for type 'prodml21:Porosity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Porosity (-423)

#endif

/* prodml21__PoreVolumeOfInvestigation has binding name 'prodml21__PoreVolumeOfInvestigation' for type 'prodml21:PoreVolumeOfInvestigation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeOfInvestigation (-422)

#endif

/* prodml21__PoreVolumeMeasured has binding name 'prodml21__PoreVolumeMeasured' for type 'prodml21:PoreVolumeMeasured' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PoreVolumeMeasured (-421)

#endif

/* prodml21__PermeabilityThicknessProduct has binding name 'prodml21__PermeabilityThicknessProduct' for type 'prodml21:PermeabilityThicknessProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PermeabilityThicknessProduct (-420)

#endif

/* prodml21__PerforatedLength has binding name 'prodml21__PerforatedLength' for type 'prodml21:PerforatedLength' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PerforatedLength (-419)

#endif

/* prodml21__OrientationWellTrajectory has binding name 'prodml21__OrientationWellTrajectory' for type 'prodml21:OrientationWellTrajectory' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationWellTrajectory (-418)

#endif

/* prodml21__OrientationOfNormalToBoundary1 has binding name 'prodml21__OrientationOfNormalToBoundary1' for type 'prodml21:OrientationOfNormalToBoundary1' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfNormalToBoundary1 (-417)

#endif

/* prodml21__OrientationOfLinearFront has binding name 'prodml21__OrientationOfLinearFront' for type 'prodml21:OrientationOfLinearFront' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfLinearFront (-416)

#endif

/* prodml21__OrientationOfFracturePlane has binding name 'prodml21__OrientationOfFracturePlane' for type 'prodml21:OrientationOfFracturePlane' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfFracturePlane (-415)

#endif

/* prodml21__OrientationOfAnisotropyXDirection has binding name 'prodml21__OrientationOfAnisotropyXDirection' for type 'prodml21:OrientationOfAnisotropyXDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OrientationOfAnisotropyXDirection (-414)

#endif

/* prodml21__NumberOfFractures has binding name 'prodml21__NumberOfFractures' for type 'prodml21:NumberOfFractures' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumberOfFractures (-413)

#endif

/* prodml21__ModelName has binding name 'prodml21__ModelName' for type 'prodml21:ModelName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ModelName (-412)

#endif

/* prodml21__MechanicalSkinRelativeToTotalThickness has binding name 'prodml21__MechanicalSkinRelativeToTotalThickness' for type 'prodml21:MechanicalSkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MechanicalSkinRelativeToTotalThickness (-411)

#endif

/* prodml21__LengthHorizontalWellboreFlowing has binding name 'prodml21__LengthHorizontalWellboreFlowing' for type 'prodml21:LengthHorizontalWellboreFlowing' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LengthHorizontalWellboreFlowing (-410)

#endif

/* prodml21__LeakSkin has binding name 'prodml21__LeakSkin' for type 'prodml21:LeakSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LeakSkin (-409)

#endif

/* prodml21__Layer2Thickness has binding name 'prodml21__Layer2Thickness' for type 'prodml21:Layer2Thickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Layer2Thickness (-408)

#endif

/* prodml21__InterporosityFlowParameter has binding name 'prodml21__InterporosityFlowParameter' for type 'prodml21:InterporosityFlowParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterporosityFlowParameter (-407)

#endif

/* prodml21__InnerToOuterZoneMobilityRatio has binding name 'prodml21__InnerToOuterZoneMobilityRatio' for type 'prodml21:InnerToOuterZoneMobilityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneMobilityRatio (-406)

#endif

/* prodml21__InnerToOuterZoneDiffusivityRatio has binding name 'prodml21__InnerToOuterZoneDiffusivityRatio' for type 'prodml21:InnerToOuterZoneDiffusivityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InnerToOuterZoneDiffusivityRatio (-405)

#endif

/* prodml21__InitialPressure has binding name 'prodml21__InitialPressure' for type 'prodml21:InitialPressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InitialPressure (-404)

#endif

/* prodml21__HorizontalRadialPermeability has binding name 'prodml21__HorizontalRadialPermeability' for type 'prodml21:HorizontalRadialPermeability' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalRadialPermeability (-403)

#endif

/* prodml21__HorizontalAnisotropyKxToKy has binding name 'prodml21__HorizontalAnisotropyKxToKy' for type 'prodml21:HorizontalAnisotropyKxToKy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalAnisotropyKxToKy (-402)

#endif

/* prodml21__FractureStorativityRatio has binding name 'prodml21__FractureStorativityRatio' for type 'prodml21:FractureStorativityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureStorativityRatio (-401)

#endif

/* prodml21__FractureRadius has binding name 'prodml21__FractureRadius' for type 'prodml21:FractureRadius' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureRadius (-400)

#endif

/* prodml21__FractureHeight has binding name 'prodml21__FractureHeight' for type 'prodml21:FractureHeight' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHeight (-399)

#endif

/* prodml21__FractureHalfLength has binding name 'prodml21__FractureHalfLength' for type 'prodml21:FractureHalfLength' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureHalfLength (-398)

#endif

/* prodml21__FractureFaceSkin has binding name 'prodml21__FractureFaceSkin' for type 'prodml21:FractureFaceSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureFaceSkin (-397)

#endif

/* prodml21__FractureConductivity has binding name 'prodml21__FractureConductivity' for type 'prodml21:FractureConductivity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureConductivity (-396)

#endif

/* prodml21__FractureAngleToWellbore has binding name 'prodml21__FractureAngleToWellbore' for type 'prodml21:FractureAngleToWellbore' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FractureAngleToWellbore (-395)

#endif

/* prodml21__FluidDensity has binding name 'prodml21__FluidDensity' for type 'prodml21:FluidDensity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDensity (-394)

#endif

/* prodml21__FaultConductivity has binding name 'prodml21__FaultConductivity' for type 'prodml21:FaultConductivity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FaultConductivity (-393)

#endif

/* prodml21__DrainageAreaMeasured has binding name 'prodml21__DrainageAreaMeasured' for type 'prodml21:DrainageAreaMeasured' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DrainageAreaMeasured (-392)

#endif

/* prodml21__DistanceWellboreToBottomBoundary has binding name 'prodml21__DistanceWellboreToBottomBoundary' for type 'prodml21:DistanceWellboreToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceWellboreToBottomBoundary (-391)

#endif

/* prodml21__DistanceToPinchOut has binding name 'prodml21__DistanceToPinchOut' for type 'prodml21:DistanceToPinchOut' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToPinchOut (-390)

#endif

/* prodml21__DistanceToMobilityInterface has binding name 'prodml21__DistanceToMobilityInterface' for type 'prodml21:DistanceToMobilityInterface' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToMobilityInterface (-389)

#endif

/* prodml21__DistanceToBoundary4 has binding name 'prodml21__DistanceToBoundary4' for type 'prodml21:DistanceToBoundary4' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary4 (-388)

#endif

/* prodml21__DistanceToBoundary3 has binding name 'prodml21__DistanceToBoundary3' for type 'prodml21:DistanceToBoundary3' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary3 (-387)

#endif

/* prodml21__DistanceToBoundary2 has binding name 'prodml21__DistanceToBoundary2' for type 'prodml21:DistanceToBoundary2' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary2 (-386)

#endif

/* prodml21__DistanceToBoundary1 has binding name 'prodml21__DistanceToBoundary1' for type 'prodml21:DistanceToBoundary1' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceToBoundary1 (-385)

#endif

/* prodml21__DistanceMidPerforationsToBottomBoundary has binding name 'prodml21__DistanceMidPerforationsToBottomBoundary' for type 'prodml21:DistanceMidPerforationsToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidPerforationsToBottomBoundary (-384)

#endif

/* prodml21__DistanceMidFractureHeightToBottomBoundary has binding name 'prodml21__DistanceMidFractureHeightToBottomBoundary' for type 'prodml21:DistanceMidFractureHeightToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceMidFractureHeightToBottomBoundary (-383)

#endif

/* prodml21__DistanceFractureToBottomBoundary has binding name 'prodml21__DistanceFractureToBottomBoundary' for type 'prodml21:DistanceFractureToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistanceFractureToBottomBoundary (-382)

#endif

/* prodml21__DeltaTimeStorageChanges has binding name 'prodml21__DeltaTimeStorageChanges' for type 'prodml21:DeltaTimeStorageChanges' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaTimeStorageChanges (-381)

#endif

/* prodml21__DeltaPressureTotalSkin has binding name 'prodml21__DeltaPressureTotalSkin' for type 'prodml21:DeltaPressureTotalSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeltaPressureTotalSkin (-380)

#endif

/* prodml21__CustomParameter has binding name 'prodml21__CustomParameter' for type 'prodml21:CustomParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomParameter (-379)

#endif

/* prodml21__ConvergenceSkinRelativeToTotalThickness has binding name 'prodml21__ConvergenceSkinRelativeToTotalThickness' for type 'prodml21:ConvergenceSkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConvergenceSkinRelativeToTotalThickness (-378)

#endif

/* prodml21__AveragePressure has binding name 'prodml21__AveragePressure' for type 'prodml21:AveragePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AveragePressure (-377)

#endif

/* prodml21__AngleBetweenBoundaries has binding name 'prodml21__AngleBetweenBoundaries' for type 'prodml21:AngleBetweenBoundaries' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AngleBetweenBoundaries (-376)

#endif

/* prodml21__AbstractParameter has binding name 'prodml21__AbstractParameter' for type 'prodml21:AbstractParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractParameter (-375)

#endif

/* prodml21__WellboreBaseModel has binding name 'prodml21__WellboreBaseModel' for type 'prodml21:WellboreBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellboreBaseModel (-374)

#endif

/* prodml21__UShapedFaultsModel has binding name 'prodml21__UShapedFaultsModel' for type 'prodml21:UShapedFaultsModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__UShapedFaultsModel (-373)

#endif

/* prodml21__TwoParallelFaultsModel has binding name 'prodml21__TwoParallelFaultsModel' for type 'prodml21:TwoParallelFaultsModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TwoParallelFaultsModel (-372)

#endif

/* prodml21__TwoIntersectingFaultsModel has binding name 'prodml21__TwoIntersectingFaultsModel' for type 'prodml21:TwoIntersectingFaultsModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TwoIntersectingFaultsModel (-371)

#endif

/* prodml21__SlantedPartiallyPenetratingModel has binding name 'prodml21__SlantedPartiallyPenetratingModel' for type 'prodml21:SlantedPartiallyPenetratingModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedPartiallyPenetratingModel (-370)

#endif

/* prodml21__SlantedFullyPenetratingModel has binding name 'prodml21__SlantedFullyPenetratingModel' for type 'prodml21:SlantedFullyPenetratingModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlantedFullyPenetratingModel (-369)

#endif

/* prodml21__SingleFaultModel has binding name 'prodml21__SingleFaultModel' for type 'prodml21:SingleFaultModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFaultModel (-368)

#endif

/* prodml21__ReservoirBaseModel has binding name 'prodml21__ReservoirBaseModel' for type 'prodml21:ReservoirBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirBaseModel (-367)

#endif

/* prodml21__RadialCompositeModel has binding name 'prodml21__RadialCompositeModel' for type 'prodml21:RadialCompositeModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RadialCompositeModel (-366)

#endif

/* prodml21__PinchOutModel has binding name 'prodml21__PinchOutModel' for type 'prodml21:PinchOutModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PinchOutModel (-365)

#endif

/* prodml21__PartiallyPenetratingModel has binding name 'prodml21__PartiallyPenetratingModel' for type 'prodml21:PartiallyPenetratingModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PartiallyPenetratingModel (-364)

#endif

/* prodml21__NumericalHomogeneousReservoirModel has binding name 'prodml21__NumericalHomogeneousReservoirModel' for type 'prodml21:NumericalHomogeneousReservoirModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalHomogeneousReservoirModel (-363)

#endif

/* prodml21__NumericalDualPorosityReservoirModel has binding name 'prodml21__NumericalDualPorosityReservoirModel' for type 'prodml21:NumericalDualPorosityReservoirModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalDualPorosityReservoirModel (-362)

#endif

/* prodml21__NumericalBoundaryModel has binding name 'prodml21__NumericalBoundaryModel' for type 'prodml21:NumericalBoundaryModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NumericalBoundaryModel (-361)

#endif

/* prodml21__NearWellboreBaseModel has binding name 'prodml21__NearWellboreBaseModel' for type 'prodml21:NearWellboreBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NearWellboreBaseModel (-360)

#endif

/* prodml21__LinearCompositeWithLeakyFaultModel has binding name 'prodml21__LinearCompositeWithLeakyFaultModel' for type 'prodml21:LinearCompositeWithLeakyFaultModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithLeakyFaultModel (-359)

#endif

/* prodml21__LinearCompositeWithConductiveFaultModel has binding name 'prodml21__LinearCompositeWithConductiveFaultModel' for type 'prodml21:LinearCompositeWithConductiveFaultModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithConductiveFaultModel (-358)

#endif

/* prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel has binding name 'prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel' for type 'prodml21:LinearCompositeWithChangingThicknessAcrossLeakyFaultModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeWithChangingThicknessAcrossLeakyFaultModel (-357)

#endif

/* prodml21__LinearCompositeModel has binding name 'prodml21__LinearCompositeModel' for type 'prodml21:LinearCompositeModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LinearCompositeModel (-356)

#endif

/* prodml21__InfiniteBoundaryModel has binding name 'prodml21__InfiniteBoundaryModel' for type 'prodml21:InfiniteBoundaryModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InfiniteBoundaryModel (-355)

#endif

/* prodml21__HorizontalWellboreMultipleVariableFracturedModel has binding name 'prodml21__HorizontalWellboreMultipleVariableFracturedModel' for type 'prodml21:HorizontalWellboreMultipleVariableFracturedModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleVariableFracturedModel (-354)

#endif

/* prodml21__HorizontalWellboreMultipleEqualFracturedModel has binding name 'prodml21__HorizontalWellboreMultipleEqualFracturedModel' for type 'prodml21:HorizontalWellboreMultipleEqualFracturedModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreMultipleEqualFracturedModel (-353)

#endif

/* prodml21__HorizontalWellboreModel has binding name 'prodml21__HorizontalWellboreModel' for type 'prodml21:HorizontalWellboreModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellboreModel (-352)

#endif

/* prodml21__HorizontalWellbore2LayerModel has binding name 'prodml21__HorizontalWellbore2LayerModel' for type 'prodml21:HorizontalWellbore2LayerModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HorizontalWellbore2LayerModel (-351)

#endif

/* prodml21__HomogeneousModel has binding name 'prodml21__HomogeneousModel' for type 'prodml21:HomogeneousModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HomogeneousModel (-350)

#endif

/* prodml21__FracturedUniformFluxModel has binding name 'prodml21__FracturedUniformFluxModel' for type 'prodml21:FracturedUniformFluxModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedUniformFluxModel (-349)

#endif

/* prodml21__FracturedInfiniteConductivityModel has binding name 'prodml21__FracturedInfiniteConductivityModel' for type 'prodml21:FracturedInfiniteConductivityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedInfiniteConductivityModel (-348)

#endif

/* prodml21__FracturedHorizontalUniformFluxModel has binding name 'prodml21__FracturedHorizontalUniformFluxModel' for type 'prodml21:FracturedHorizontalUniformFluxModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalUniformFluxModel (-347)

#endif

/* prodml21__FracturedHorizontalInfiniteConductivityModel has binding name 'prodml21__FracturedHorizontalInfiniteConductivityModel' for type 'prodml21:FracturedHorizontalInfiniteConductivityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalInfiniteConductivityModel (-346)

#endif

/* prodml21__FracturedHorizontalFiniteConductivityModel has binding name 'prodml21__FracturedHorizontalFiniteConductivityModel' for type 'prodml21:FracturedHorizontalFiniteConductivityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedHorizontalFiniteConductivityModel (-345)

#endif

/* prodml21__FracturedFiniteConductivityModel has binding name 'prodml21__FracturedFiniteConductivityModel' for type 'prodml21:FracturedFiniteConductivityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FracturedFiniteConductivityModel (-344)

#endif

/* prodml21__FiniteRadiusModel has binding name 'prodml21__FiniteRadiusModel' for type 'prodml21:FiniteRadiusModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FiniteRadiusModel (-343)

#endif

/* prodml21__DualPorosityTransientSpheresModel has binding name 'prodml21__DualPorosityTransientSpheresModel' for type 'prodml21:DualPorosityTransientSpheresModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSpheresModel (-342)

#endif

/* prodml21__DualPorosityTransientSlabsModel has binding name 'prodml21__DualPorosityTransientSlabsModel' for type 'prodml21:DualPorosityTransientSlabsModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityTransientSlabsModel (-341)

#endif

/* prodml21__DualPorosityPseudoSteadyStateModel has binding name 'prodml21__DualPorosityPseudoSteadyStateModel' for type 'prodml21:DualPorosityPseudoSteadyStateModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPorosityPseudoSteadyStateModel (-340)

#endif

/* prodml21__DualPermeabilityWithCrossflowModel has binding name 'prodml21__DualPermeabilityWithCrossflowModel' for type 'prodml21:DualPermeabilityWithCrossflowModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DualPermeabilityWithCrossflowModel (-339)

#endif

/* prodml21__CustomWellboreModel has binding name 'prodml21__CustomWellboreModel' for type 'prodml21:CustomWellboreModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomWellboreModel (-338)

#endif

/* prodml21__CustomReservoirModel has binding name 'prodml21__CustomReservoirModel' for type 'prodml21:CustomReservoirModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomReservoirModel (-337)

#endif

/* prodml21__CustomNearWellboreModel has binding name 'prodml21__CustomNearWellboreModel' for type 'prodml21:CustomNearWellboreModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomNearWellboreModel (-336)

#endif

/* prodml21__CustomBoundaryModel has binding name 'prodml21__CustomBoundaryModel' for type 'prodml21:CustomBoundaryModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomBoundaryModel (-335)

#endif

/* prodml21__ConstantStorageModel has binding name 'prodml21__ConstantStorageModel' for type 'prodml21:ConstantStorageModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantStorageModel (-334)

#endif

/* prodml21__ClosedRectangleModel has binding name 'prodml21__ClosedRectangleModel' for type 'prodml21:ClosedRectangleModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedRectangleModel (-333)

#endif

/* prodml21__ClosedCircleModel has binding name 'prodml21__ClosedCircleModel' for type 'prodml21:ClosedCircleModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ClosedCircleModel (-332)

#endif

/* prodml21__ChangingStorageSpiveyPackerModel has binding name 'prodml21__ChangingStorageSpiveyPackerModel' for type 'prodml21:ChangingStorageSpiveyPackerModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyPackerModel (-331)

#endif

/* prodml21__ChangingStorageSpiveyFissuresModel has binding name 'prodml21__ChangingStorageSpiveyFissuresModel' for type 'prodml21:ChangingStorageSpiveyFissuresModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageSpiveyFissuresModel (-330)

#endif

/* prodml21__ChangingStorageHegemanModel has binding name 'prodml21__ChangingStorageHegemanModel' for type 'prodml21:ChangingStorageHegemanModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageHegemanModel (-329)

#endif

/* prodml21__ChangingStorageFairModel has binding name 'prodml21__ChangingStorageFairModel' for type 'prodml21:ChangingStorageFairModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChangingStorageFairModel (-328)

#endif

/* prodml21__BoundaryBaseModel has binding name 'prodml21__BoundaryBaseModel' for type 'prodml21:BoundaryBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BoundaryBaseModel (-327)

#endif

/* prodml21__AbstractModelSection has binding name 'prodml21__AbstractModelSection' for type 'prodml21:AbstractModelSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractModelSection (-326)

#endif

/* prodml21__TestPeriodsFlowrateData has binding name 'prodml21__TestPeriodsFlowrateData' for type 'prodml21:TestPeriodsFlowrateData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriodsFlowrateData (-325)

#endif

/* prodml21__SpecializedAnalysis has binding name 'prodml21__SpecializedAnalysis' for type 'prodml21:SpecializedAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SpecializedAnalysis (-324)

#endif

/* prodml21__SingleFractureSubModel has binding name 'prodml21__SingleFractureSubModel' for type 'prodml21:SingleFractureSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFractureSubModel (-323)

#endif

/* prodml21__SingleFlowrateData has binding name 'prodml21__SingleFlowrateData' for type 'prodml21:SingleFlowrateData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleFlowrateData (-322)

#endif

/* prodml21__SingleBoundarySubModel has binding name 'prodml21__SingleBoundarySubModel' for type 'prodml21:SingleBoundarySubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SingleBoundarySubModel (-321)

#endif

/* prodml21__RtaAnalysis has binding name 'prodml21__RtaAnalysis' for type 'prodml21:RtaAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RtaAnalysis (-320)

#endif

/* prodml21__ResqmlModelRef has binding name 'prodml21__ResqmlModelRef' for type 'prodml21:ResqmlModelRef' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ResqmlModelRef (-319)

#endif

/* prodml21__ReservoirZoneSubModel has binding name 'prodml21__ReservoirZoneSubModel' for type 'prodml21:ReservoirZoneSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReservoirZoneSubModel (-318)

#endif

/* prodml21__PtaDeconvolution has binding name 'prodml21__PtaDeconvolution' for type 'prodml21:PtaDeconvolution' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDeconvolution (-317)

#endif

/* prodml21__PtaDataPreProcess has binding name 'prodml21__PtaDataPreProcess' for type 'prodml21:PtaDataPreProcess' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaDataPreProcess (-316)

#endif

/* prodml21__PtaAnalysis has binding name 'prodml21__PtaAnalysis' for type 'prodml21:PtaAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PtaAnalysis (-315)

#endif

/* prodml21__PressureTransientAnalysis has binding name 'prodml21__PressureTransientAnalysis' for type 'prodml21:PressureTransientAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressureTransientAnalysis (-314)

#endif

/* prodml21__PreProcessedPressureData has binding name 'prodml21__PreProcessedPressureData' for type 'prodml21:PreProcessedPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedPressureData (-313)

#endif

/* prodml21__PreProcessedFlowData has binding name 'prodml21__PreProcessedFlowData' for type 'prodml21:PreProcessedFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PreProcessedFlowData (-312)

#endif

/* prodml21__OutputPressureData has binding name 'prodml21__OutputPressureData' for type 'prodml21:OutputPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputPressureData (-311)

#endif

/* prodml21__OutputFlowData has binding name 'prodml21__OutputFlowData' for type 'prodml21:OutputFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OutputFlowData (-310)

#endif

/* prodml21__MeasuredPressureData has binding name 'prodml21__MeasuredPressureData' for type 'prodml21:MeasuredPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredPressureData (-309)

#endif

/* prodml21__MeasuredFlowData has binding name 'prodml21__MeasuredFlowData' for type 'prodml21:MeasuredFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredFlowData (-308)

#endif

/* prodml21__LogLogAnalysis has binding name 'prodml21__LogLogAnalysis' for type 'prodml21:LogLogAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LogLogAnalysis (-307)

#endif

/* prodml21__LocationIn2D has binding name 'prodml21__LocationIn2D' for type 'prodml21:LocationIn2D' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LocationIn2D (-306)

#endif

/* prodml21__LayerToLayerConnection has binding name 'prodml21__LayerToLayerConnection' for type 'prodml21:LayerToLayerConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LayerToLayerConnection (-305)

#endif

/* prodml21__LayerModel has binding name 'prodml21__LayerModel' for type 'prodml21:LayerModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LayerModel (-304)

#endif

/* prodml21__InternalFaultSubModel has binding name 'prodml21__InternalFaultSubModel' for type 'prodml21:InternalFaultSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InternalFaultSubModel (-303)

#endif

/* prodml21__InterferingFlowTestInterval has binding name 'prodml21__InterferingFlowTestInterval' for type 'prodml21:InterferingFlowTestInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterferingFlowTestInterval (-302)

#endif

/* prodml21__DistributedParametersSubModel has binding name 'prodml21__DistributedParametersSubModel' for type 'prodml21:DistributedParametersSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DistributedParametersSubModel (-301)

#endif

/* prodml21__DeconvolvedPressureData has binding name 'prodml21__DeconvolvedPressureData' for type 'prodml21:DeconvolvedPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedPressureData (-300)

#endif

/* prodml21__DeconvolvedFlowData has binding name 'prodml21__DeconvolvedFlowData' for type 'prodml21:DeconvolvedFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolvedFlowData (-299)

#endif

/* prodml21__DeconvolutionSingleOutput has binding name 'prodml21__DeconvolutionSingleOutput' for type 'prodml21:DeconvolutionSingleOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionSingleOutput (-298)

#endif

/* prodml21__DeconvolutionOutput has binding name 'prodml21__DeconvolutionOutput' for type 'prodml21:DeconvolutionOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionOutput (-297)

#endif

/* prodml21__DeconvolutionMultipleOutput has binding name 'prodml21__DeconvolutionMultipleOutput' for type 'prodml21:DeconvolutionMultipleOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeconvolutionMultipleOutput (-296)

#endif

/* prodml21__CompressibilityParameters has binding name 'prodml21__CompressibilityParameters' for type 'prodml21:CompressibilityParameters' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompressibilityParameters (-295)

#endif

/* prodml21__ChannelFlowrateData has binding name 'prodml21__ChannelFlowrateData' for type 'prodml21:ChannelFlowrateData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelFlowrateData (-294)

#endif

/* prodml21__AnalysisLine has binding name 'prodml21__AnalysisLine' for type 'prodml21:AnalysisLine' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AnalysisLine (-293)

#endif

/* prodml21__AbstractRateHistory has binding name 'prodml21__AbstractRateHistory' for type 'prodml21:AbstractRateHistory' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRateHistory (-292)

#endif

/* prodml21__AbstractPtaPressureData has binding name 'prodml21__AbstractPtaPressureData' for type 'prodml21:AbstractPtaPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaPressureData (-291)

#endif

/* prodml21__AbstractDeconvolutionOutput has binding name 'prodml21__AbstractDeconvolutionOutput' for type 'prodml21:AbstractDeconvolutionOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDeconvolutionOutput (-290)

#endif

/* prodml21__AbstractAnalysis has binding name 'prodml21__AbstractAnalysis' for type 'prodml21:AbstractAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractAnalysis (-289)

#endif

/* prodml21__VerticalInterferenceTest has binding name 'prodml21__VerticalInterferenceTest' for type 'prodml21:VerticalInterferenceTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VerticalInterferenceTest (-288)

#endif

/* prodml21__ProductionTransientTest has binding name 'prodml21__ProductionTransientTest' for type 'prodml21:ProductionTransientTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionTransientTest (-287)

#endif

/* prodml21__ProductionFlowTest has binding name 'prodml21__ProductionFlowTest' for type 'prodml21:ProductionFlowTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionFlowTest (-286)

#endif

/* prodml21__OtherData has binding name 'prodml21__OtherData' for type 'prodml21:OtherData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherData (-285)

#endif

/* prodml21__InterwellTest has binding name 'prodml21__InterwellTest' for type 'prodml21:InterwellTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterwellTest (-284)

#endif

/* prodml21__FormationTesterStation has binding name 'prodml21__FormationTesterStation' for type 'prodml21:FormationTesterStation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FormationTesterStation (-283)

#endif

/* prodml21__FlowTestMeasurementSet has binding name 'prodml21__FlowTestMeasurementSet' for type 'prodml21:FlowTestMeasurementSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestMeasurementSet (-282)

#endif

/* prodml21__FlowTestLocation has binding name 'prodml21__FlowTestLocation' for type 'prodml21:FlowTestLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestLocation (-281)

#endif

/* prodml21__FlowTestActivity has binding name 'prodml21__FlowTestActivity' for type 'prodml21:FlowTestActivity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlowTestActivity (-280)

#endif

/* prodml21__DrillStemTest has binding name 'prodml21__DrillStemTest' for type 'prodml21:DrillStemTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DrillStemTest (-279)

#endif

/* prodml21__ChannelSet has binding name 'prodml21__ChannelSet' for type 'prodml21:ChannelSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ChannelSet (-278)

#endif

/* prodml21__Channel has binding name 'prodml21__Channel' for type 'prodml21:Channel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Channel (-277)

#endif

/* prodml21__AbstractPtaFlowData has binding name 'prodml21__AbstractPtaFlowData' for type 'prodml21:AbstractPtaFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPtaFlowData (-276)

#endif

/* prodml21__AbstractFlowTestData has binding name 'prodml21__AbstractFlowTestData' for type 'prodml21:AbstractFlowTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFlowTestData (-275)

#endif

/* prodml21__WellProductionParameters has binding name 'prodml21__WellProductionParameters' for type 'prodml21:WellProductionParameters' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellProductionParameters (-274)

#endif

/* prodml21__WellFlowingCondition has binding name 'prodml21__WellFlowingCondition' for type 'prodml21:WellFlowingCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellFlowingCondition (-273)

#endif

/* prodml21__TransferDisposition has binding name 'prodml21__TransferDisposition' for type 'prodml21:TransferDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TransferDisposition (-272)

#endif

/* prodml21__Transfer has binding name 'prodml21__Transfer' for type 'prodml21:Transfer' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Transfer (-271)

#endif

/* prodml21__TestPeriod has binding name 'prodml21__TestPeriod' for type 'prodml21:TestPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TestPeriod (-270)

#endif

/* prodml21__TerminalLiftingDisposition has binding name 'prodml21__TerminalLiftingDisposition' for type 'prodml21:TerminalLiftingDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLiftingDisposition (-269)

#endif

/* prodml21__TerminalLifting has binding name 'prodml21__TerminalLifting' for type 'prodml21:TerminalLifting' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TerminalLifting (-268)

#endif

/* prodml21__ServiceFluid has binding name 'prodml21__ServiceFluid' for type 'prodml21:ServiceFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ServiceFluid (-267)

#endif

/* prodml21__ReportingEntityVolumes has binding name 'prodml21__ReportingEntityVolumes' for type 'prodml21:ReportingEntityVolumes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportingEntityVolumes (-266)

#endif

/* prodml21__ProductRate has binding name 'prodml21__ProductRate' for type 'prodml21:ProductRate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductRate (-265)

#endif

/* prodml21__ProductionWellTests has binding name 'prodml21__ProductionWellTests' for type 'prodml21:ProductionWellTests' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTests (-264)

#endif

/* prodml21__ProductionWellTest has binding name 'prodml21__ProductionWellTest' for type 'prodml21:ProductionWellTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellTest (-263)

#endif

/* prodml21__ProductionWellPeriod has binding name 'prodml21__ProductionWellPeriod' for type 'prodml21:ProductionWellPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductionWellPeriod (-262)

#endif

/* prodml21__Production has binding name 'prodml21__Production' for type 'prodml21:Production' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Production
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Production (-261)

#endif

/* prodml21__ProductFluid has binding name 'prodml21__ProductFluid' for type 'prodml21:ProductFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFluid (-260)

#endif

/* prodml21__ProductDisposition has binding name 'prodml21__ProductDisposition' for type 'prodml21:ProductDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductDisposition (-259)

#endif

/* prodml21__Injection has binding name 'prodml21__Injection' for type 'prodml21:Injection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Injection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Injection (-258)

#endif

/* prodml21__DowntimeReasonCode has binding name 'prodml21__DowntimeReasonCode' for type 'prodml21:DowntimeReasonCode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DowntimeReasonCode (-257)

#endif

/* prodml21__DeferredProductionVolume has binding name 'prodml21__DeferredProductionVolume' for type 'prodml21:DeferredProductionVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionVolume (-256)

#endif

/* prodml21__DeferredProductionEvent has binding name 'prodml21__DeferredProductionEvent' for type 'prodml21:DeferredProductionEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeferredProductionEvent (-255)

#endif

/* prodml21__AssetProductionVolumes has binding name 'prodml21__AssetProductionVolumes' for type 'prodml21:AssetProductionVolumes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AssetProductionVolumes (-254)

#endif

/* prodml21__AbstractSimpleProductVolume has binding name 'prodml21__AbstractSimpleProductVolume' for type 'prodml21:AbstractSimpleProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractSimpleProductVolume (-253)

#endif

/* prodml21__AbstractProductQuantity has binding name 'prodml21__AbstractProductQuantity' for type 'prodml21:AbstractProductQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractProductQuantity (-252)

#endif

/* prodml21__AbstractDisposition has binding name 'prodml21__AbstractDisposition' for type 'prodml21:AbstractDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDisposition (-251)

#endif

/* prodml21__WftTestResult has binding name 'prodml21__WftTestResult' for type 'prodml21:WftTestResult' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestResult (-250)

#endif

/* prodml21__WftTestData has binding name 'prodml21__WftTestData' for type 'prodml21:WftTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTestData (-249)

#endif

/* prodml21__WftTest has binding name 'prodml21__WftTest' for type 'prodml21:WftTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftTest (-248)

#endif

/* prodml21__WftStation has binding name 'prodml21__WftStation' for type 'prodml21:WftStation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftStation (-247)

#endif

/* prodml21__WftSampleAcquisition has binding name 'prodml21__WftSampleAcquisition' for type 'prodml21:WftSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisition (-246)

#endif

/* prodml21__WftRun has binding name 'prodml21__WftRun' for type 'prodml21:WftRun' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftRun (-245)

#endif

/* prodml21__WftResultReference has binding name 'prodml21__WftResultReference' for type 'prodml21:WftResultReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftResultReference (-244)

#endif

/* prodml21__WftInOutParameter has binding name 'prodml21__WftInOutParameter' for type 'prodml21:WftInOutParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftInOutParameter (-243)

#endif

/* prodml21__WftEvent has binding name 'prodml21__WftEvent' for type 'prodml21:WftEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftEvent (-242)

#endif

/* prodml21__WftCurveSection has binding name 'prodml21__WftCurveSection' for type 'prodml21:WftCurveSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftCurveSection (-241)

#endif

/* prodml21__WftSampleAcquisitionJob has binding name 'prodml21__WftSampleAcquisitionJob' for type 'prodml21:WftSampleAcquisitionJob' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WftSampleAcquisitionJob (-240)

#endif

/* prodml21__WellheadSampleAcquisition has binding name 'prodml21__WellheadSampleAcquisition' for type 'prodml21:WellheadSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellheadSampleAcquisition (-239)

#endif

/* prodml21__SeparatorSampleAcquisition has binding name 'prodml21__SeparatorSampleAcquisition' for type 'prodml21:SeparatorSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorSampleAcquisition (-238)

#endif

/* prodml21__FluidSampleAcquisitionJob has binding name 'prodml21__FluidSampleAcquisitionJob' for type 'prodml21:FluidSampleAcquisitionJob' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJob (-237)

#endif

/* prodml21__FluidSampleAcquisition has binding name 'prodml21__FluidSampleAcquisition' for type 'prodml21:FluidSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisition (-236)

#endif

/* prodml21__FacilitySampleAcquisition has binding name 'prodml21__FacilitySampleAcquisition' for type 'prodml21:FacilitySampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilitySampleAcquisition (-235)

#endif

/* prodml21__DownholeSampleAcquisition has binding name 'prodml21__DownholeSampleAcquisition' for type 'prodml21:DownholeSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DownholeSampleAcquisition (-234)

#endif

/* prodml21__FluidSampleContainer has binding name 'prodml21__FluidSampleContainer' for type 'prodml21:FluidSampleContainer' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleContainer (-233)

#endif

/* prodml21__SampleRecombinationRequirement has binding name 'prodml21__SampleRecombinationRequirement' for type 'prodml21:SampleRecombinationRequirement' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRecombinationRequirement (-232)

#endif

/* prodml21__FluidSampleComposition has binding name 'prodml21__FluidSampleComposition' for type 'prodml21:FluidSampleComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleComposition (-231)

#endif

/* prodml21__FluidSampleChainofCustodyEvent has binding name 'prodml21__FluidSampleChainofCustodyEvent' for type 'prodml21:FluidSampleChainofCustodyEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleChainofCustodyEvent (-230)

#endif

/* prodml21__FluidSampleAcquisitionJobSource has binding name 'prodml21__FluidSampleAcquisitionJobSource' for type 'prodml21:FluidSampleAcquisitionJobSource' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSampleAcquisitionJobSource (-229)

#endif

/* prodml21__FluidSample has binding name 'prodml21__FluidSample' for type 'prodml21:FluidSample' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSample (-228)

#endif

/* prodml21__WaterSampleComponent has binding name 'prodml21__WaterSampleComponent' for type 'prodml21:WaterSampleComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterSampleComponent (-227)

#endif

/* prodml21__WaterAnalysisTestStep has binding name 'prodml21__WaterAnalysisTestStep' for type 'prodml21:WaterAnalysisTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTestStep (-226)

#endif

/* prodml21__WaterAnalysisTest has binding name 'prodml21__WaterAnalysisTest' for type 'prodml21:WaterAnalysisTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysisTest (-225)

#endif

/* prodml21__WaterAnalysis has binding name 'prodml21__WaterAnalysis' for type 'prodml21:WaterAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WaterAnalysis (-224)

#endif

/* prodml21__ViscosityAtTemperature has binding name 'prodml21__ViscosityAtTemperature' for type 'prodml21:ViscosityAtTemperature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ViscosityAtTemperature (-223)

#endif

/* prodml21__VaporLiquidEquilibriumTest has binding name 'prodml21__VaporLiquidEquilibriumTest' for type 'prodml21:VaporLiquidEquilibriumTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VaporLiquidEquilibriumTest (-222)

#endif

/* prodml21__SwellingTestStep has binding name 'prodml21__SwellingTestStep' for type 'prodml21:SwellingTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTestStep (-221)

#endif

/* prodml21__SwellingTest has binding name 'prodml21__SwellingTest' for type 'prodml21:SwellingTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SwellingTest (-220)

#endif

/* prodml21__STOFlashedLiquid has binding name 'prodml21__STOFlashedLiquid' for type 'prodml21:STOFlashedLiquid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__STOFlashedLiquid (-219)

#endif

/* prodml21__STOAnalysis has binding name 'prodml21__STOAnalysis' for type 'prodml21:STOAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__STOAnalysis (-218)

#endif

/* prodml21__SlimTubeTestVolumeStep has binding name 'prodml21__SlimTubeTestVolumeStep' for type 'prodml21:SlimTubeTestVolumeStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestVolumeStep (-217)

#endif

/* prodml21__SlimTubeTestStep has binding name 'prodml21__SlimTubeTestStep' for type 'prodml21:SlimTubeTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTestStep (-216)

#endif

/* prodml21__SlimTubeTest has binding name 'prodml21__SlimTubeTest' for type 'prodml21:SlimTubeTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeTest (-215)

#endif

/* prodml21__SlimTubeSpecification has binding name 'prodml21__SlimTubeSpecification' for type 'prodml21:SlimTubeSpecification' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SlimTubeSpecification (-214)

#endif

/* prodml21__SeparatorConditions has binding name 'prodml21__SeparatorConditions' for type 'prodml21:SeparatorConditions' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SeparatorConditions (-213)

#endif

/* prodml21__SaturationTest has binding name 'prodml21__SaturationTest' for type 'prodml21:SaturationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTest (-212)

#endif

/* prodml21__SaturationTemperature has binding name 'prodml21__SaturationTemperature' for type 'prodml21:SaturationTemperature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationTemperature (-211)

#endif

/* prodml21__SaturationPressure has binding name 'prodml21__SaturationPressure' for type 'prodml21:SaturationPressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SaturationPressure (-210)

#endif

/* prodml21__Sara has binding name 'prodml21__Sara' for type 'prodml21:Sara' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Sara
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Sara (-209)

#endif

/* prodml21__SampleRestoration has binding name 'prodml21__SampleRestoration' for type 'prodml21:SampleRestoration' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleRestoration (-208)

#endif

/* prodml21__SampleIntegrityAndPreparation has binding name 'prodml21__SampleIntegrityAndPreparation' for type 'prodml21:SampleIntegrityAndPreparation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleIntegrityAndPreparation (-207)

#endif

/* prodml21__SampleContaminant has binding name 'prodml21__SampleContaminant' for type 'prodml21:SampleContaminant' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant
#define SOAP_TYPE_gsoap_eml2_2_prodml21__SampleContaminant (-206)

#endif

/* prodml21__ReportLocation has binding name 'prodml21__ReportLocation' for type 'prodml21:ReportLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReportLocation (-205)

#endif

/* prodml21__RelativeVolumeRatio has binding name 'prodml21__RelativeVolumeRatio' for type 'prodml21:RelativeVolumeRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeVolumeRatio (-204)

#endif

/* prodml21__RefInjectedGasAdded has binding name 'prodml21__RefInjectedGasAdded' for type 'prodml21:RefInjectedGasAdded' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RefInjectedGasAdded (-203)

#endif

/* prodml21__ProducedOilProperties has binding name 'prodml21__ProducedOilProperties' for type 'prodml21:ProducedOilProperties' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedOilProperties (-202)

#endif

/* prodml21__ProducedGasProperties has binding name 'prodml21__ProducedGasProperties' for type 'prodml21:ProducedGasProperties' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProducedGasProperties (-201)

#endif

/* prodml21__PhaseViscosity has binding name 'prodml21__PhaseViscosity' for type 'prodml21:PhaseViscosity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseViscosity (-200)

#endif

/* prodml21__PhaseDensity has binding name 'prodml21__PhaseDensity' for type 'prodml21:PhaseDensity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhaseDensity (-199)

#endif

/* prodml21__OtherMeasurementTestStep has binding name 'prodml21__OtherMeasurementTestStep' for type 'prodml21:OtherMeasurementTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTestStep (-198)

#endif

/* prodml21__OtherMeasurementTest has binding name 'prodml21__OtherMeasurementTest' for type 'prodml21:OtherMeasurementTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OtherMeasurementTest (-197)

#endif

/* prodml21__OilVolume has binding name 'prodml21__OilVolume' for type 'prodml21:OilVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilVolume (-196)

#endif

/* prodml21__OilShrinkageFactor has binding name 'prodml21__OilShrinkageFactor' for type 'prodml21:OilShrinkageFactor' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilShrinkageFactor (-195)

#endif

/* prodml21__OilCompressibility has binding name 'prodml21__OilCompressibility' for type 'prodml21:OilCompressibility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OilCompressibility (-194)

#endif

/* prodml21__MultipleContactMiscibilityTest has binding name 'prodml21__MultipleContactMiscibilityTest' for type 'prodml21:MultipleContactMiscibilityTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MultipleContactMiscibilityTest (-193)

#endif

/* prodml21__MassOut has binding name 'prodml21__MassOut' for type 'prodml21:MassOut' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassOut (-192)

#endif

/* prodml21__MassIn has binding name 'prodml21__MassIn' for type 'prodml21:MassIn' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassIn (-191)

#endif

/* prodml21__MassBalance has binding name 'prodml21__MassBalance' for type 'prodml21:MassBalance' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MassBalance (-190)

#endif

/* prodml21__LiquidVolume has binding name 'prodml21__LiquidVolume' for type 'prodml21:LiquidVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidVolume (-189)

#endif

/* prodml21__LiquidDropoutFraction has binding name 'prodml21__LiquidDropoutFraction' for type 'prodml21:LiquidDropoutFraction' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidDropoutFraction (-188)

#endif

/* prodml21__InterfacialTensionTestStep has binding name 'prodml21__InterfacialTensionTestStep' for type 'prodml21:InterfacialTensionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTestStep (-187)

#endif

/* prodml21__InterfacialTensionTest has binding name 'prodml21__InterfacialTensionTest' for type 'prodml21:InterfacialTensionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InterfacialTensionTest (-186)

#endif

/* prodml21__InjectedGas has binding name 'prodml21__InjectedGas' for type 'prodml21:InjectedGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__InjectedGas (-185)

#endif

/* prodml21__HydrocarbonAnalysis has binding name 'prodml21__HydrocarbonAnalysis' for type 'prodml21:HydrocarbonAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__HydrocarbonAnalysis (-184)

#endif

/* prodml21__FluidVolumeReference has binding name 'prodml21__FluidVolumeReference' for type 'prodml21:FluidVolumeReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidVolumeReference (-183)

#endif

/* prodml21__FluidSeparatorTestStep has binding name 'prodml21__FluidSeparatorTestStep' for type 'prodml21:FluidSeparatorTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTestStep (-182)

#endif

/* prodml21__FluidSeparatorTest has binding name 'prodml21__FluidSeparatorTest' for type 'prodml21:FluidSeparatorTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSeparatorTest (-181)

#endif

/* prodml21__FluidDifferentialLiberationTestStep has binding name 'prodml21__FluidDifferentialLiberationTestStep' for type 'prodml21:FluidDifferentialLiberationTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidDifferentialLiberationTestStep (-180)

#endif

/* prodml21__FluidCvdTestStep has binding name 'prodml21__FluidCvdTestStep' for type 'prodml21:FluidCvdTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCvdTestStep (-179)

#endif

/* prodml21__FluidAnalysisReport has binding name 'prodml21__FluidAnalysisReport' for type 'prodml21:FluidAnalysisReport' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysisReport (-178)

#endif

/* prodml21__FluidAnalysis has binding name 'prodml21__FluidAnalysis' for type 'prodml21:FluidAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidAnalysis (-177)

#endif

/* prodml21__FlashedLiquid has binding name 'prodml21__FlashedLiquid' for type 'prodml21:FlashedLiquid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedLiquid (-176)

#endif

/* prodml21__FlashedGas has binding name 'prodml21__FlashedGas' for type 'prodml21:FlashedGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FlashedGas (-175)

#endif

/* prodml21__DifferentialLiberationTest has binding name 'prodml21__DifferentialLiberationTest' for type 'prodml21:DifferentialLiberationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DifferentialLiberationTest (-174)

#endif

/* prodml21__CumulativeGasProducedVol has binding name 'prodml21__CumulativeGasProducedVol' for type 'prodml21:CumulativeGasProducedVol' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedVol (-173)

#endif

/* prodml21__CumulativeGasProducedRatioStd has binding name 'prodml21__CumulativeGasProducedRatioStd' for type 'prodml21:CumulativeGasProducedRatioStd' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CumulativeGasProducedRatioStd (-172)

#endif

/* prodml21__ConstantVolumeDepletionTest has binding name 'prodml21__ConstantVolumeDepletionTest' for type 'prodml21:ConstantVolumeDepletionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantVolumeDepletionTest (-171)

#endif

/* prodml21__ConstantCompositionExpansionTestStep has binding name 'prodml21__ConstantCompositionExpansionTestStep' for type 'prodml21:ConstantCompositionExpansionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTestStep (-170)

#endif

/* prodml21__ConstantCompositionExpansionTest has binding name 'prodml21__ConstantCompositionExpansionTest' for type 'prodml21:ConstantCompositionExpansionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConstantCompositionExpansionTest (-169)

#endif

/* prodml21__AtmosphericFlashTestAndCompositionalAnalysis has binding name 'prodml21__AtmosphericFlashTestAndCompositionalAnalysis' for type 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AtmosphericFlashTestAndCompositionalAnalysis (-168)

#endif

/* prodml21__AbstractOilVolShrinkage has binding name 'prodml21__AbstractOilVolShrinkage' for type 'prodml21:AbstractOilVolShrinkage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractOilVolShrinkage (-167)

#endif

/* prodml21__AbstractLiquidDropoutPercVolume has binding name 'prodml21__AbstractLiquidDropoutPercVolume' for type 'prodml21:AbstractLiquidDropoutPercVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractLiquidDropoutPercVolume (-166)

#endif

/* prodml21__AbstractGasProducedRatioVolume has binding name 'prodml21__AbstractGasProducedRatioVolume' for type 'prodml21:AbstractGasProducedRatioVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractGasProducedRatioVolume (-165)

#endif

/* prodml21__FluidSystem has binding name 'prodml21__FluidSystem' for type 'prodml21:FluidSystem' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidSystem (-164)

#endif

/* prodml21__RelativeCoordinate has binding name 'prodml21__RelativeCoordinate' for type 'prodml21:RelativeCoordinate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__RelativeCoordinate (-163)

#endif

/* prodml21__Qualifier has binding name 'prodml21__Qualifier' for type 'prodml21:Qualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Qualifier (-162)

#endif

/* prodml21__ProductFlowUnit has binding name 'prodml21__ProductFlowUnit' for type 'prodml21:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowUnit (-161)

#endif

/* prodml21__ProductFlowQualifierExpected has binding name 'prodml21__ProductFlowQualifierExpected' for type 'prodml21:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowQualifierExpected (-160)

#endif

/* prodml21__ProductFlowPort has binding name 'prodml21__ProductFlowPort' for type 'prodml21:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowPort (-159)

#endif

/* prodml21__ProductFlowNetworkPlan has binding name 'prodml21__ProductFlowNetworkPlan' for type 'prodml21:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetworkPlan (-158)

#endif

/* prodml21__ProductFlowModel has binding name 'prodml21__ProductFlowModel' for type 'prodml21:ProductFlowModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowModel (-157)

#endif

/* prodml21__ProductFlowExternalPort has binding name 'prodml21__ProductFlowExternalPort' for type 'prodml21:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalPort (-156)

#endif

/* prodml21__ProductFlowExpectedUnitProperty has binding name 'prodml21__ProductFlowExpectedUnitProperty' for type 'prodml21:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExpectedUnitProperty (-155)

#endif

/* prodml21__ProductFlowChangeLog has binding name 'prodml21__ProductFlowChangeLog' for type 'prodml21:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowChangeLog (-154)

#endif

/* prodml21__ExpectedFlowQualifier has binding name 'prodml21__ExpectedFlowQualifier' for type 'prodml21:ExpectedFlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ExpectedFlowQualifier (-153)

#endif

/* prodml21__ConnectedNode has binding name 'prodml21__ConnectedNode' for type 'prodml21:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ConnectedNode (-152)

#endif

/* prodml21__StringData has binding name 'prodml21__StringData' for type 'prodml21:StringData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StringData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StringData (-151)

#endif

/* prodml21__ReferenceFlow has binding name 'prodml21__ReferenceFlow' for type 'prodml21:ReferenceFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceFlow (-150)

#endif

/* prodml21__ProductVolumeRelatedFacility has binding name 'prodml21__ProductVolumeRelatedFacility' for type 'prodml21:ProductVolumeRelatedFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeRelatedFacility (-149)

#endif

/* prodml21__ProductVolumeProduct has binding name 'prodml21__ProductVolumeProduct' for type 'prodml21:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeProduct (-148)

#endif

/* prodml21__ProductVolumePortDifference has binding name 'prodml21__ProductVolumePortDifference' for type 'prodml21:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePortDifference (-147)

#endif

/* prodml21__ProductVolumePeriod has binding name 'prodml21__ProductVolumePeriod' for type 'prodml21:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumePeriod (-146)

#endif

/* prodml21__ProductVolumeParameterValue has binding name 'prodml21__ProductVolumeParameterValue' for type 'prodml21:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterValue (-145)

#endif

/* prodml21__ProductVolumeParameterSet has binding name 'prodml21__ProductVolumeParameterSet' for type 'prodml21:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeParameterSet (-144)

#endif

/* prodml21__ProductVolumeFlow has binding name 'prodml21__ProductVolumeFlow' for type 'prodml21:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFlow (-143)

#endif

/* prodml21__ProductVolumeFacility has binding name 'prodml21__ProductVolumeFacility' for type 'prodml21:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeFacility (-142)

#endif

/* prodml21__ProductVolumeDestination has binding name 'prodml21__ProductVolumeDestination' for type 'prodml21:ProductVolumeDestination' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeDestination (-141)

#endif

/* prodml21__ProductVolumeComponentContent has binding name 'prodml21__ProductVolumeComponentContent' for type 'prodml21:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeComponentContent (-140)

#endif

/* prodml21__ProductVolumeBusinessUnit has binding name 'prodml21__ProductVolumeBusinessUnit' for type 'prodml21:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessUnit (-139)

#endif

/* prodml21__ProductVolumeBusinessSubUnit has binding name 'prodml21__ProductVolumeBusinessSubUnit' for type 'prodml21:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBusinessSubUnit (-138)

#endif

/* prodml21__ProductVolumeBalanceSet has binding name 'prodml21__ProductVolumeBalanceSet' for type 'prodml21:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceSet (-137)

#endif

/* prodml21__ProductVolumeBalanceEvent has binding name 'prodml21__ProductVolumeBalanceEvent' for type 'prodml21:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceEvent (-136)

#endif

/* prodml21__ProductVolumeBalanceDetail has binding name 'prodml21__ProductVolumeBalanceDetail' for type 'prodml21:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeBalanceDetail (-135)

#endif

/* prodml21__ProductVolumeAlert has binding name 'prodml21__ProductVolumeAlert' for type 'prodml21:ProductVolumeAlert' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolumeAlert (-134)

#endif

/* prodml21__ProductVolume has binding name 'prodml21__ProductVolume' for type 'prodml21:ProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductVolume (-133)

#endif

/* prodml21__Parentfacility has binding name 'prodml21__Parentfacility' for type 'prodml21:Parentfacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Parentfacility (-132)

#endif

/* prodml21__OwnershipBusinessAcct has binding name 'prodml21__OwnershipBusinessAcct' for type 'prodml21:OwnershipBusinessAcct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OwnershipBusinessAcct (-131)

#endif

/* prodml21__IntegerData has binding name 'prodml21__IntegerData' for type 'prodml21:IntegerData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerData (-130)

#endif

/* prodml21__FacilityUnitPort has binding name 'prodml21__FacilityUnitPort' for type 'prodml21:FacilityUnitPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityUnitPort (-129)

#endif

/* prodml21__FacilityParent has binding name 'prodml21__FacilityParent' for type 'prodml21:FacilityParent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityParent (-128)

#endif

/* prodml21__CurveDefinition has binding name 'prodml21__CurveDefinition' for type 'prodml21:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CurveDefinition (-127)

#endif

/* prodml21__CurveData has binding name 'prodml21__CurveData' for type 'prodml21:CurveData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CurveData (-126)

#endif

/* prodml21__AbstractRelatedFacilityObject has binding name 'prodml21__AbstractRelatedFacilityObject' for type 'prodml21:AbstractRelatedFacilityObject' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRelatedFacilityObject (-125)

#endif

/* prodml21__AbstractRefProductFlow has binding name 'prodml21__AbstractRefProductFlow' for type 'prodml21:AbstractRefProductFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractRefProductFlow (-124)

#endif

/* prodml21__AbstractMeasureData has binding name 'prodml21__AbstractMeasureData' for type 'prodml21:AbstractMeasureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractMeasureData (-123)

#endif

/* prodml21__CommonPropertiesProductVolume has binding name 'prodml21__CommonPropertiesProductVolume' for type 'prodml21:CommonPropertiesProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CommonPropertiesProductVolume (-122)

#endif

/* prodml21__WellVerticalDepthCoord has binding name 'prodml21__WellVerticalDepthCoord' for type 'prodml21:WellVerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellVerticalDepthCoord (-121)

#endif

/* prodml21__WellElevationCoord has binding name 'prodml21__WellElevationCoord' for type 'prodml21:WellElevationCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__WellElevationCoord (-120)

#endif

/* prodml21__VolumeQualifiedMeasure has binding name 'prodml21__VolumeQualifiedMeasure' for type 'prodml21:VolumeQualifiedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VolumeQualifiedMeasure (-119)

#endif

/* prodml21__VaporComposition has binding name 'prodml21__VaporComposition' for type 'prodml21:VaporComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__VaporComposition (-118)

#endif

/* prodml21__StockTankOil has binding name 'prodml21__StockTankOil' for type 'prodml21:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StockTankOil (-117)

#endif

/* prodml21__StartEndTime has binding name 'prodml21__StartEndTime' for type 'prodml21:StartEndTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndTime (-116)

#endif

/* prodml21__StartEndDate has binding name 'prodml21__StartEndDate' for type 'prodml21:StartEndDate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__StartEndDate (-115)

#endif

/* prodml21__PureFluidComponent has binding name 'prodml21__PureFluidComponent' for type 'prodml21:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PureFluidComponent (-114)

#endif

/* prodml21__PseudoFluidComponent has binding name 'prodml21__PseudoFluidComponent' for type 'prodml21:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PseudoFluidComponent (-113)

#endif

/* prodml21__ProductFlowNetwork has binding name 'prodml21__ProductFlowNetwork' for type 'prodml21:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowNetwork (-112)

#endif

/* prodml21__ProductFlowExternalReference has binding name 'prodml21__ProductFlowExternalReference' for type 'prodml21:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ProductFlowExternalReference (-111)

#endif

/* prodml21__PressurePerFlowrateSquaredMeasure has binding name 'prodml21__PressurePerFlowrateSquaredMeasure' for type 'prodml21:PressurePerFlowrateSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateSquaredMeasure (-110)

#endif

/* prodml21__PressurePerFlowrateMeasure has binding name 'prodml21__PressurePerFlowrateMeasure' for type 'prodml21:PressurePerFlowrateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PressurePerFlowrateMeasure (-109)

#endif

/* prodml21__PlusFluidComponent has binding name 'prodml21__PlusFluidComponent' for type 'prodml21:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PlusFluidComponent (-108)

#endif

/* prodml21__PhoneNumberStruct has binding name 'prodml21__PhoneNumberStruct' for type 'prodml21:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PhoneNumberStruct (-107)

#endif

/* prodml21__PersonName has binding name 'prodml21__PersonName' for type 'prodml21:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PersonName (-106)

#endif

/* prodml21__OverallComposition has binding name 'prodml21__OverallComposition' for type 'prodml21:OverallComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OverallComposition (-105)

#endif

/* prodml21__OffshoreLocation has binding name 'prodml21__OffshoreLocation' for type 'prodml21:OffshoreLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__OffshoreLocation (-104)

#endif

/* prodml21__NorthSeaOffshore has binding name 'prodml21__NorthSeaOffshore' for type 'prodml21:NorthSeaOffshore' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NorthSeaOffshore (-103)

#endif

/* prodml21__NaturalGas has binding name 'prodml21__NaturalGas' for type 'prodml21:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NaturalGas (-102)

#endif

/* prodml21__NameStruct has binding name 'prodml21__NameStruct' for type 'prodml21:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__NameStruct (-101)

#endif

/* prodml21__MeasureOrQuantity has binding name 'prodml21__MeasureOrQuantity' for type 'prodml21:MeasureOrQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasureOrQuantity (-100)

#endif

/* prodml21__MeasuredDepthCoord has binding name 'prodml21__MeasuredDepthCoord' for type 'prodml21:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_prodml21__MeasuredDepthCoord (-99)

#endif

/* prodml21__LiquidComposition has binding name 'prodml21__LiquidComposition' for type 'prodml21:LiquidComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LiquidComposition (-98)

#endif

/* prodml21__KindQualifiedString has binding name 'prodml21__KindQualifiedString' for type 'prodml21:KindQualifiedString' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_2_prodml21__KindQualifiedString (-97)

#endif

/* prodml21__KeywordValueStruct has binding name 'prodml21__KeywordValueStruct' for type 'prodml21:KeywordValueStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__KeywordValueStruct (-96)

#endif

/* prodml21__IntegerQualifiedCount has binding name 'prodml21__IntegerQualifiedCount' for type 'prodml21:IntegerQualifiedCount' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_2_prodml21__IntegerQualifiedCount (-95)

#endif

/* prodml21__GeologyFeature has binding name 'prodml21__GeologyFeature' for type 'prodml21:GeologyFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeologyFeature (-94)

#endif

/* prodml21__GeographicContext has binding name 'prodml21__GeographicContext' for type 'prodml21:GeographicContext' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeographicContext (-93)

#endif

/* prodml21__GeneralQualifiedMeasure has binding name 'prodml21__GeneralQualifiedMeasure' for type 'prodml21:GeneralQualifiedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralQualifiedMeasure (-92)

#endif

/* prodml21__GeneralMeasureType has binding name 'prodml21__GeneralMeasureType' for type 'prodml21:GeneralMeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralMeasureType (-91)

#endif

/* prodml21__GeneralAddress has binding name 'prodml21__GeneralAddress' for type 'prodml21:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_2_prodml21__GeneralAddress (-90)

#endif

/* prodml21__FormationWater has binding name 'prodml21__FormationWater' for type 'prodml21:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FormationWater (-89)

#endif

/* prodml21__FluidComponentCatalog has binding name 'prodml21__FluidComponentCatalog' for type 'prodml21:FluidComponentCatalog' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentCatalog (-88)

#endif

/* prodml21__FluidComponent has binding name 'prodml21__FluidComponent' for type 'prodml21:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponent (-87)

#endif

/* prodml21__FacilityIdentifierStruct has binding name 'prodml21__FacilityIdentifierStruct' for type 'prodml21:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifierStruct (-86)

#endif

/* prodml21__FacilityIdentifier has binding name 'prodml21__FacilityIdentifier' for type 'prodml21:FacilityIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FacilityIdentifier (-85)

#endif

/* prodml21__EndpointQualifiedDateTime has binding name 'prodml21__EndpointQualifiedDateTime' for type 'prodml21:EndpointQualifiedDateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDateTime (-84)

#endif

/* prodml21__EndpointQualifiedDate has binding name 'prodml21__EndpointQualifiedDate' for type 'prodml21:EndpointQualifiedDate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EndpointQualifiedDate (-83)

#endif

/* prodml21__EmailQualifierStruct has binding name 'prodml21__EmailQualifierStruct' for type 'prodml21:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_2_prodml21__EmailQualifierStruct (-82)

#endif

/* prodml21__DatedComment has binding name 'prodml21__DatedComment' for type 'prodml21:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DatedComment (-81)

#endif

/* prodml21__CalibrationParameter has binding name 'prodml21__CalibrationParameter' for type 'prodml21:CalibrationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CalibrationParameter (-80)

#endif

/* prodml21__BusinessAssociate has binding name 'prodml21__BusinessAssociate' for type 'prodml21:BusinessAssociate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BusinessAssociate (-79)

#endif

/* prodml21__AbstractFluidComponent has binding name 'prodml21__AbstractFluidComponent' for type 'prodml21:AbstractFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractFluidComponent (-78)

#endif

/* prodml21__AbstractDateTimeClass has binding name 'prodml21__AbstractDateTimeClass' for type 'prodml21:AbstractDateTimeClass' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractDateTimeClass (-77)

#endif

/* prodml21__TableDelimiter has binding name 'prodml21__TableDelimiter' for type 'prodml21:TableDelimiter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__TableDelimiter (-76)

#endif

/* prodml21__Standing_Undersaturated has binding name 'prodml21__Standing_Undersaturated' for type 'prodml21:Standing-Undersaturated' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Undersaturated (-75)

#endif

/* prodml21__Standing_Dead has binding name 'prodml21__Standing_Dead' for type 'prodml21:Standing-Dead' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_Dead (-74)

#endif

/* prodml21__Standing_BubblePoint has binding name 'prodml21__Standing_BubblePoint' for type 'prodml21:Standing-BubblePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Standing_BubblePoint (-73)

#endif

/* prodml21__Srk_USCOREEOS has binding name 'prodml21__Srk_USCOREEOS' for type 'prodml21:Srk_EOS' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Srk_USCOREEOS (-72)

#endif

/* prodml21__ReferenceSeparatorStage has binding name 'prodml21__ReferenceSeparatorStage' for type 'prodml21:ReferenceSeparatorStage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ReferenceSeparatorStage (-71)

#endif

/* prodml21__PvtModelParameterSet has binding name 'prodml21__PvtModelParameterSet' for type 'prodml21:PvtModelParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameterSet (-70)

#endif

/* prodml21__PvtModelParameter has binding name 'prodml21__PvtModelParameter' for type 'prodml21:PvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PvtModelParameter (-69)

#endif

/* prodml21__PrsvParameter has binding name 'prodml21__PrsvParameter' for type 'prodml21:PrsvParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PrsvParameter (-68)

#endif

/* prodml21__PetroskyFarshad_Undersaturated has binding name 'prodml21__PetroskyFarshad_Undersaturated' for type 'prodml21:PetroskyFarshad-Undersaturated' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Undersaturated (-67)

#endif

/* prodml21__PetroskyFarshad_Dead has binding name 'prodml21__PetroskyFarshad_Dead' for type 'prodml21:PetroskyFarshad-Dead' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_Dead (-66)

#endif

/* prodml21__PetroskyFarshad_BubblePoint has binding name 'prodml21__PetroskyFarshad_BubblePoint' for type 'prodml21:PetroskyFarshad-BubblePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PetroskyFarshad_BubblePoint (-65)

#endif

/* prodml21__PengRobinson78_USCOREEOS has binding name 'prodml21__PengRobinson78_USCOREEOS' for type 'prodml21:PengRobinson78_EOS' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson78_USCOREEOS (-64)

#endif

/* prodml21__PengRobinson76_USCOREEOS has binding name 'prodml21__PengRobinson76_USCOREEOS' for type 'prodml21:PengRobinson76_EOS' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS
#define SOAP_TYPE_gsoap_eml2_2_prodml21__PengRobinson76_USCOREEOS (-63)

#endif

/* prodml21__Lucas has binding name 'prodml21__Lucas' for type 'prodml21:Lucas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Lucas (-62)

#endif

/* prodml21__LondonoArcherBlasinggame has binding name 'prodml21__LondonoArcherBlasinggame' for type 'prodml21:LondonoArcherBlasinggame' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LondonoArcherBlasinggame (-61)

#endif

/* prodml21__Lohrenz_Bray_ClarkCorrelation has binding name 'prodml21__Lohrenz_Bray_ClarkCorrelation' for type 'prodml21:Lohrenz-Bray-ClarkCorrelation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation
#define SOAP_TYPE_gsoap_eml2_2_prodml21__Lohrenz_Bray_ClarkCorrelation (-60)

#endif

/* prodml21__LeeGonzalez has binding name 'prodml21__LeeGonzalez' for type 'prodml21:LeeGonzalez' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez
#define SOAP_TYPE_gsoap_eml2_2_prodml21__LeeGonzalez (-59)

#endif

/* prodml21__FrictionTheory has binding name 'prodml21__FrictionTheory' for type 'prodml21:FrictionTheory' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FrictionTheory (-58)

#endif

/* prodml21__FluidComponentProperty has binding name 'prodml21__FluidComponentProperty' for type 'prodml21:FluidComponentProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidComponentProperty (-57)

#endif

/* prodml21__FluidCharacterizationTableFormatSet has binding name 'prodml21__FluidCharacterizationTableFormatSet' for type 'prodml21:FluidCharacterizationTableFormatSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormatSet (-56)

#endif

/* prodml21__FluidCharacterizationTableFormat has binding name 'prodml21__FluidCharacterizationTableFormat' for type 'prodml21:FluidCharacterizationTableFormat' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableFormat (-55)

#endif

/* prodml21__FluidCharacterizationTableColumn has binding name 'prodml21__FluidCharacterizationTableColumn' for type 'prodml21:FluidCharacterizationTableColumn' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableColumn (-54)

#endif

/* prodml21__FluidCharacterizationTable has binding name 'prodml21__FluidCharacterizationTable' for type 'prodml21:FluidCharacterizationTable' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTable (-53)

#endif

/* prodml21__FluidCharacterizationSource has binding name 'prodml21__FluidCharacterizationSource' for type 'prodml21:FluidCharacterizationSource' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationSource (-52)

#endif

/* prodml21__FluidCharacterizationParameterSet has binding name 'prodml21__FluidCharacterizationParameterSet' for type 'prodml21:FluidCharacterizationParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameterSet (-51)

#endif

/* prodml21__FluidCharacterizationParameter has binding name 'prodml21__FluidCharacterizationParameter' for type 'prodml21:FluidCharacterizationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationParameter (-50)

#endif

/* prodml21__FluidCharacterizationModel has binding name 'prodml21__FluidCharacterizationModel' for type 'prodml21:FluidCharacterizationModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationModel (-49)

#endif

/* prodml21__FluidCharacterization has binding name 'prodml21__FluidCharacterization' for type 'prodml21:FluidCharacterization' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterization (-48)

#endif

/* prodml21__DindorukChristman_Undersaturated has binding name 'prodml21__DindorukChristman_Undersaturated' for type 'prodml21:DindorukChristman-Undersaturated' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Undersaturated (-47)

#endif

/* prodml21__DindorukChristman_Dead has binding name 'prodml21__DindorukChristman_Dead' for type 'prodml21:DindorukChristman-Dead' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_Dead (-46)

#endif

/* prodml21__DindorukChristman_BubblePoint has binding name 'prodml21__DindorukChristman_BubblePoint' for type 'prodml21:DindorukChristman-BubblePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DindorukChristman_BubblePoint (-45)

#endif

/* prodml21__DeGhetto_Undersaturated has binding name 'prodml21__DeGhetto_Undersaturated' for type 'prodml21:DeGhetto-Undersaturated' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Undersaturated (-44)

#endif

/* prodml21__DeGhetto_Dead has binding name 'prodml21__DeGhetto_Dead' for type 'prodml21:DeGhetto-Dead' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_Dead (-43)

#endif

/* prodml21__DeGhetto_BubblePoint has binding name 'prodml21__DeGhetto_BubblePoint' for type 'prodml21:DeGhetto-BubblePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__DeGhetto_BubblePoint (-42)

#endif

/* prodml21__CustomPvtModelParameter has binding name 'prodml21__CustomPvtModelParameter' for type 'prodml21:CustomPvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelParameter (-41)

#endif

/* prodml21__CustomPvtModelExtension has binding name 'prodml21__CustomPvtModelExtension' for type 'prodml21:CustomPvtModelExtension' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CustomPvtModelExtension (-40)

#endif

/* prodml21__CSPedersen87 has binding name 'prodml21__CSPedersen87' for type 'prodml21:CSPedersen87' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen87 (-39)

#endif

/* prodml21__CSPedersen84 has binding name 'prodml21__CSPedersen84' for type 'prodml21:CSPedersen84' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CSPedersen84 (-38)

#endif

/* prodml21__CorrelationThermalModel has binding name 'prodml21__CorrelationThermalModel' for type 'prodml21:CorrelationThermalModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CorrelationThermalModel (-37)

#endif

/* prodml21__CompositionalThermalModel has binding name 'prodml21__CompositionalThermalModel' for type 'prodml21:CompositionalThermalModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CompositionalThermalModel (-36)

#endif

/* prodml21__ComponentPropertySet has binding name 'prodml21__ComponentPropertySet' for type 'prodml21:ComponentPropertySet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ComponentPropertySet (-35)

#endif

/* prodml21__CarrDempsey has binding name 'prodml21__CarrDempsey' for type 'prodml21:CarrDempsey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey
#define SOAP_TYPE_gsoap_eml2_2_prodml21__CarrDempsey (-34)

#endif

/* prodml21__BinaryInteractionCoefficientSet has binding name 'prodml21__BinaryInteractionCoefficientSet' for type 'prodml21:BinaryInteractionCoefficientSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficientSet (-33)

#endif

/* prodml21__BinaryInteractionCoefficient has binding name 'prodml21__BinaryInteractionCoefficient' for type 'prodml21:BinaryInteractionCoefficient' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BinaryInteractionCoefficient (-32)

#endif

/* prodml21__BergmanSutton_BubblePoint has binding name 'prodml21__BergmanSutton_BubblePoint' for type 'prodml21:BergmanSutton-BubblePoint' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BergmanSutton_BubblePoint (-31)

#endif

/* prodml21__BerganSutton_Dead has binding name 'prodml21__BerganSutton_Dead' for type 'prodml21:BerganSutton-Dead' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BerganSutton_Dead (-30)

#endif

/* prodml21__BerganAndSutton_Undersaturated has binding name 'prodml21__BerganAndSutton_Undersaturated' for type 'prodml21:BerganAndSutton-Undersaturated' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated
#define SOAP_TYPE_gsoap_eml2_2_prodml21__BerganAndSutton_Undersaturated (-29)

#endif

/* prodml21__ApplicationInfo has binding name 'prodml21__ApplicationInfo' for type 'prodml21:ApplicationInfo' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo
#define SOAP_TYPE_gsoap_eml2_2_prodml21__ApplicationInfo (-28)

#endif

/* prodml21__AbstractPvtModel has binding name 'prodml21__AbstractPvtModel' for type 'prodml21:AbstractPvtModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractPvtModel (-27)

#endif

/* prodml21__AbstractCorrelationViscosityUndersaturatedModel has binding name 'prodml21__AbstractCorrelationViscosityUndersaturatedModel' for type 'prodml21:AbstractCorrelationViscosityUndersaturatedModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityUndersaturatedModel (-26)

#endif

/* prodml21__AbstractCorrelationViscosityModel has binding name 'prodml21__AbstractCorrelationViscosityModel' for type 'prodml21:AbstractCorrelationViscosityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityModel (-25)

#endif

/* prodml21__AbstractCorrelationViscosityBubblePointModel has binding name 'prodml21__AbstractCorrelationViscosityBubblePointModel' for type 'prodml21:AbstractCorrelationViscosityBubblePointModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityBubblePointModel (-24)

#endif

/* prodml21__AbstractCorrelationGasViscosityModel has binding name 'prodml21__AbstractCorrelationGasViscosityModel' for type 'prodml21:AbstractCorrelationGasViscosityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationGasViscosityModel (-23)

#endif

/* prodml21__AbstractCompositionalViscosityModel has binding name 'prodml21__AbstractCompositionalViscosityModel' for type 'prodml21:AbstractCompositionalViscosityModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalViscosityModel (-22)

#endif

/* prodml21__AbstractCompositionalEoSModel has binding name 'prodml21__AbstractCompositionalEoSModel' for type 'prodml21:AbstractCompositionalEoSModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalEoSModel (-21)

#endif

/* prodml21__FluidCharacterizationTableRow has binding name 'prodml21__FluidCharacterizationTableRow' for type 'prodml21:FluidCharacterizationTableRow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow
#define SOAP_TYPE_gsoap_eml2_2_prodml21__FluidCharacterizationTableRow (-20)

#endif

/* prodml21__AbstractCorrelationViscosityDeadModel has binding name 'prodml21__AbstractCorrelationViscosityDeadModel' for type 'prodml21:AbstractCorrelationViscosityDeadModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationViscosityDeadModel (-19)

#endif

/* prodml21__AbstractCorrelationModel has binding name 'prodml21__AbstractCorrelationModel' for type 'prodml21:AbstractCorrelationModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCorrelationModel (-18)

#endif

/* prodml21__AbstractCompositionalModel has binding name 'prodml21__AbstractCompositionalModel' for type 'prodml21:AbstractCompositionalModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel
#define SOAP_TYPE_gsoap_eml2_2_prodml21__AbstractCompositionalModel (-17)

#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__date
#define SOAP_TYPE_gsoap_eml2_2_xsd__date (-16)

#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_2_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_2_xsd__anyURI (-15)

#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__string
#define SOAP_TYPE_gsoap_eml2_2_std__string (-14)

#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Fault (-845619207)

#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Reason (-845619206)

#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Detail (-845619203)

#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Code (-845619201)

#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_2_SOAP_ENV__Header (-845619200)

#endif

/* eml22__TimeStamp has binding name 'eml22__TimeStamp' for type 'eml22:TimeStamp' */
#ifndef SOAP_TYPE_eml22__TimeStamp
#define SOAP_TYPE_eml22__TimeStamp (-1154)

#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (-9)

#endif

/* struct tm has binding name 'tm' for type 'tm' */
#ifndef SOAP_TYPE_gsoap_eml2_2_tm
#define SOAP_TYPE_gsoap_eml2_2_tm (-8)

#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Reason (-845619209)

#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Detail (-845619208)

#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_2_PointerToSOAP_ENV__Code (-845619202)

#endif

/* eml22__PressurePerPressureMeasure * has binding name 'PointerToeml22__PressurePerPressureMeasure' for type 'eml22:PressurePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressurePerPressureMeasure (-2070)

#endif

/* eml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure * has binding name 'PointerToeml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' for type 'eml22:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (-2069)

#endif

/* std::string * has binding name 'PointerToeml22__UnitOfMeasureExt' for type 'eml22:UnitOfMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__UnitOfMeasureExt (-2068)

#endif

/* eml22__IntegerConstantArray * has binding name 'PointerToeml22__IntegerConstantArray' for type 'eml22:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IntegerConstantArray (-2066)

#endif

/* eml22__AbstractBooleanArray * has binding name 'PointerToeml22__AbstractBooleanArray' for type 'eml22:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractBooleanArray (-2065)

#endif

/* eml22__FloatingPointConstantArray * has binding name 'PointerToeml22__FloatingPointConstantArray' for type 'eml22:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FloatingPointConstantArray (-2063)

#endif

/* prodml21__PrsvParameter * has binding name 'PointerToprodml21__PrsvParameter' for type 'prodml21:PrsvParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PrsvParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PrsvParameter (-2061)

#endif

/* eml22__ReferencePressureKind * has binding name 'PointerToeml22__ReferencePressureKind' for type 'eml22:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferencePressureKind (-2060)

#endif

/* eml22__ExternalDataset * has binding name 'PointerToeml22__ExternalDataset' for type 'eml22:ExternalDataset' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExternalDataset (-2059)

#endif

/* prodml21__AngleBetweenBoundaries * has binding name 'PointerToprodml21__AngleBetweenBoundaries' for type 'prodml21:AngleBetweenBoundaries' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AngleBetweenBoundaries
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AngleBetweenBoundaries (-2058)

#endif

/* prodml21__DistanceToPinchOut * has binding name 'PointerToprodml21__DistanceToPinchOut' for type 'prodml21:DistanceToPinchOut' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToPinchOut
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToPinchOut (-2057)

#endif

/* prodml21__DistanceMidPerforationsToBottomBoundary * has binding name 'PointerToprodml21__DistanceMidPerforationsToBottomBoundary' for type 'prodml21:DistanceMidPerforationsToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceMidPerforationsToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceMidPerforationsToBottomBoundary (-2056)

#endif

/* prodml21__PerforatedLength * has binding name 'PointerToprodml21__PerforatedLength' for type 'prodml21:PerforatedLength' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PerforatedLength
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PerforatedLength (-2055)

#endif

/* prodml21__ReservoirZoneSubModel * has binding name 'PointerToprodml21__ReservoirZoneSubModel' for type 'prodml21:ReservoirZoneSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirZoneSubModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirZoneSubModel (-2053)

#endif

/* prodml21__DistributedParametersSubModel * has binding name 'PointerToprodml21__DistributedParametersSubModel' for type 'prodml21:DistributedParametersSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistributedParametersSubModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistributedParametersSubModel (-2052)

#endif

/* prodml21__InternalFaultSubModel * has binding name 'PointerToprodml21__InternalFaultSubModel' for type 'prodml21:InternalFaultSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InternalFaultSubModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InternalFaultSubModel (-2050)

#endif

/* prodml21__SingleBoundarySubModel * has binding name 'PointerToprodml21__SingleBoundarySubModel' for type 'prodml21:SingleBoundarySubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SingleBoundarySubModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SingleBoundarySubModel (-2048)

#endif

/* prodml21__FaultConductivity * has binding name 'PointerToprodml21__FaultConductivity' for type 'prodml21:FaultConductivity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FaultConductivity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FaultConductivity (-2047)

#endif

/* prodml21__Region2Thickness * has binding name 'PointerToprodml21__Region2Thickness' for type 'prodml21:Region2Thickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Region2Thickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Region2Thickness (-2046)

#endif

/* prodml21__OrientationOfLinearFront * has binding name 'PointerToprodml21__OrientationOfLinearFront' for type 'prodml21:OrientationOfLinearFront' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfLinearFront (-2045)

#endif

/* prodml21__DistanceToMobilityInterface * has binding name 'PointerToprodml21__DistanceToMobilityInterface' for type 'prodml21:DistanceToMobilityInterface' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToMobilityInterface
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToMobilityInterface (-2044)

#endif

/* prodml21__InnerToOuterZoneDiffusivityRatio * has binding name 'PointerToprodml21__InnerToOuterZoneDiffusivityRatio' for type 'prodml21:InnerToOuterZoneDiffusivityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InnerToOuterZoneDiffusivityRatio
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InnerToOuterZoneDiffusivityRatio (-2043)

#endif

/* prodml21__InnerToOuterZoneMobilityRatio * has binding name 'PointerToprodml21__InnerToOuterZoneMobilityRatio' for type 'prodml21:InnerToOuterZoneMobilityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InnerToOuterZoneMobilityRatio
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InnerToOuterZoneMobilityRatio (-2042)

#endif

/* prodml21__SingleFractureSubModel * has binding name 'PointerToprodml21__SingleFractureSubModel' for type 'prodml21:SingleFractureSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SingleFractureSubModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SingleFractureSubModel (-2040)

#endif

/* prodml21__FractureAngleToWellbore * has binding name 'PointerToprodml21__FractureAngleToWellbore' for type 'prodml21:FractureAngleToWellbore' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureAngleToWellbore
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureAngleToWellbore (-2039)

#endif

/* prodml21__NumberOfFractures * has binding name 'PointerToprodml21__NumberOfFractures' for type 'prodml21:NumberOfFractures' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NumberOfFractures
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NumberOfFractures (-2038)

#endif

/* prodml21__DistanceWellboreToBottomBoundary * has binding name 'PointerToprodml21__DistanceWellboreToBottomBoundary' for type 'prodml21:DistanceWellboreToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceWellboreToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceWellboreToBottomBoundary (-2037)

#endif

/* prodml21__LengthHorizontalWellboreFlowing * has binding name 'PointerToprodml21__LengthHorizontalWellboreFlowing' for type 'prodml21:LengthHorizontalWellboreFlowing' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LengthHorizontalWellboreFlowing
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LengthHorizontalWellboreFlowing (-2036)

#endif

/* prodml21__OrientationWellTrajectory * has binding name 'PointerToprodml21__OrientationWellTrajectory' for type 'prodml21:OrientationWellTrajectory' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationWellTrajectory
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationWellTrajectory (-2035)

#endif

/* prodml21__MechanicalSkinRelativeToTotalThickness * has binding name 'PointerToprodml21__MechanicalSkinRelativeToTotalThickness' for type 'prodml21:MechanicalSkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MechanicalSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MechanicalSkinRelativeToTotalThickness (-2034)

#endif

/* prodml21__ConvergenceSkinRelativeToTotalThickness * has binding name 'PointerToprodml21__ConvergenceSkinRelativeToTotalThickness' for type 'prodml21:ConvergenceSkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConvergenceSkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConvergenceSkinRelativeToTotalThickness (-2033)

#endif

/* prodml21__DistanceFractureToBottomBoundary * has binding name 'PointerToprodml21__DistanceFractureToBottomBoundary' for type 'prodml21:DistanceFractureToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceFractureToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceFractureToBottomBoundary (-2032)

#endif

/* prodml21__FractureRadius * has binding name 'PointerToprodml21__FractureRadius' for type 'prodml21:FractureRadius' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureRadius
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureRadius (-2031)

#endif

/* prodml21__OrientationOfFracturePlane * has binding name 'PointerToprodml21__OrientationOfFracturePlane' for type 'prodml21:OrientationOfFracturePlane' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfFracturePlane
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfFracturePlane (-2030)

#endif

/* prodml21__FractureHalfLength * has binding name 'PointerToprodml21__FractureHalfLength' for type 'prodml21:FractureHalfLength' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureHalfLength
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureHalfLength (-2029)

#endif

/* prodml21__SkinLayer2RelativeToTotalThickness * has binding name 'PointerToprodml21__SkinLayer2RelativeToTotalThickness' for type 'prodml21:SkinLayer2RelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SkinLayer2RelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SkinLayer2RelativeToTotalThickness (-2028)

#endif

/* prodml21__Layer2Thickness * has binding name 'PointerToprodml21__Layer2Thickness' for type 'prodml21:Layer2Thickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Layer2Thickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Layer2Thickness (-2027)

#endif

/* prodml21__RatioLayer1ToTotalPermeabilityThicknessProduct * has binding name 'PointerToprodml21__RatioLayer1ToTotalPermeabilityThicknessProduct' for type 'prodml21:RatioLayer1ToTotalPermeabilityThicknessProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioLayer1ToTotalPermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioLayer1ToTotalPermeabilityThicknessProduct (-2026)

#endif

/* prodml21__StorativityRatio * has binding name 'PointerToprodml21__StorativityRatio' for type 'prodml21:StorativityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__StorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__StorativityRatio (-2025)

#endif

/* prodml21__ModelName * has binding name 'PointerToprodml21__ModelName' for type 'prodml21:ModelName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ModelName
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ModelName (-2024)

#endif

/* prodml21__OrientationOfNormalToBoundary1 * has binding name 'PointerToprodml21__OrientationOfNormalToBoundary1' for type 'prodml21:OrientationOfNormalToBoundary1' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfNormalToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfNormalToBoundary1 (-2023)

#endif

/* prodml21__DistanceToBoundary4 * has binding name 'PointerToprodml21__DistanceToBoundary4' for type 'prodml21:DistanceToBoundary4' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary4
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary4 (-2022)

#endif

/* prodml21__DistanceToBoundary3 * has binding name 'PointerToprodml21__DistanceToBoundary3' for type 'prodml21:DistanceToBoundary3' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary3
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary3 (-2021)

#endif

/* prodml21__DistanceToBoundary2 * has binding name 'PointerToprodml21__DistanceToBoundary2' for type 'prodml21:DistanceToBoundary2' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary2
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary2 (-2020)

#endif

/* prodml21__DistanceToBoundary1 * has binding name 'PointerToprodml21__DistanceToBoundary1' for type 'prodml21:DistanceToBoundary1' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary1
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceToBoundary1 (-2019)

#endif

/* prodml21__PoreVolumeMeasured * has binding name 'PointerToprodml21__PoreVolumeMeasured' for type 'prodml21:PoreVolumeMeasured' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PoreVolumeMeasured
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PoreVolumeMeasured (-2018)

#endif

/* prodml21__DrainageAreaMeasured * has binding name 'PointerToprodml21__DrainageAreaMeasured' for type 'prodml21:DrainageAreaMeasured' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DrainageAreaMeasured
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DrainageAreaMeasured (-2017)

#endif

/* prodml21__LeakSkin * has binding name 'PointerToprodml21__LeakSkin' for type 'prodml21:LeakSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LeakSkin
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LeakSkin (-2016)

#endif

/* prodml21__DeltaTimeStorageChanges * has binding name 'PointerToprodml21__DeltaTimeStorageChanges' for type 'prodml21:DeltaTimeStorageChanges' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeltaTimeStorageChanges
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeltaTimeStorageChanges (-2015)

#endif

/* prodml21__RatioInitialToFinalWellboreStorage * has binding name 'PointerToprodml21__RatioInitialToFinalWellboreStorage' for type 'prodml21:RatioInitialToFinalWellboreStorage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioInitialToFinalWellboreStorage
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioInitialToFinalWellboreStorage (-2014)

#endif

/* prodml21__FlowTestMeasurementSet * has binding name 'PointerToprodml21__FlowTestMeasurementSet' for type 'prodml21:FlowTestMeasurementSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowTestMeasurementSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowTestMeasurementSet (-2012)

#endif

/* prodml21__ProductionWellPeriod * has binding name 'PointerToprodml21__ProductionWellPeriod' for type 'prodml21:ProductionWellPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductionWellPeriod
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductionWellPeriod (-2010)

#endif

/* std::string * has binding name 'PointerToprodml21__ReportingDurationKindExt' for type 'prodml21:ReportingDurationKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingDurationKindExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingDurationKindExt (-2009)

#endif

/* prodml21__ProductFluid * has binding name 'PointerToprodml21__ProductFluid' for type 'prodml21:ProductFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFluid
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFluid (-2007)

#endif

/* prodml21__ReportingEntityVolumes * has binding name 'PointerToprodml21__ReportingEntityVolumes' for type 'prodml21:ReportingEntityVolumes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingEntityVolumes
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingEntityVolumes (-2004)

#endif

/* prodml21__WaterSampleComponent * has binding name 'PointerToprodml21__WaterSampleComponent' for type 'prodml21:WaterSampleComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterSampleComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterSampleComponent (-2002)

#endif

/* prodml21__WaterAnalysisTest * has binding name 'PointerToprodml21__WaterAnalysisTest' for type 'prodml21:WaterAnalysisTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterAnalysisTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterAnalysisTest (-2000)

#endif

/* prodml21__InterfacialTensionTest * has binding name 'PointerToprodml21__InterfacialTensionTest' for type 'prodml21:InterfacialTensionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterfacialTensionTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterfacialTensionTest (-1998)

#endif

/* prodml21__STOAnalysis * has binding name 'PointerToprodml21__STOAnalysis' for type 'prodml21:STOAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__STOAnalysis
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__STOAnalysis (-1996)

#endif

/* prodml21__MultipleContactMiscibilityTest * has binding name 'PointerToprodml21__MultipleContactMiscibilityTest' for type 'prodml21:MultipleContactMiscibilityTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MultipleContactMiscibilityTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MultipleContactMiscibilityTest (-1994)

#endif

/* prodml21__SlimTubeTest * has binding name 'PointerToprodml21__SlimTubeTest' for type 'prodml21:SlimTubeTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTest (-1992)

#endif

/* prodml21__SwellingTest * has binding name 'PointerToprodml21__SwellingTest' for type 'prodml21:SwellingTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SwellingTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SwellingTest (-1990)

#endif

/* prodml21__VaporLiquidEquilibriumTest * has binding name 'PointerToprodml21__VaporLiquidEquilibriumTest' for type 'prodml21:VaporLiquidEquilibriumTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VaporLiquidEquilibriumTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VaporLiquidEquilibriumTest (-1988)

#endif

/* prodml21__OtherMeasurementTest * has binding name 'PointerToprodml21__OtherMeasurementTest' for type 'prodml21:OtherMeasurementTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherMeasurementTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherMeasurementTest (-1986)

#endif

/* prodml21__FluidSeparatorTest * has binding name 'PointerToprodml21__FluidSeparatorTest' for type 'prodml21:FluidSeparatorTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSeparatorTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSeparatorTest (-1984)

#endif

/* prodml21__ConstantVolumeDepletionTest * has binding name 'PointerToprodml21__ConstantVolumeDepletionTest' for type 'prodml21:ConstantVolumeDepletionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantVolumeDepletionTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantVolumeDepletionTest (-1982)

#endif

/* prodml21__DifferentialLiberationTest * has binding name 'PointerToprodml21__DifferentialLiberationTest' for type 'prodml21:DifferentialLiberationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DifferentialLiberationTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DifferentialLiberationTest (-1980)

#endif

/* prodml21__SaturationTest * has binding name 'PointerToprodml21__SaturationTest' for type 'prodml21:SaturationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationTest (-1978)

#endif

/* prodml21__ConstantCompositionExpansionTest * has binding name 'PointerToprodml21__ConstantCompositionExpansionTest' for type 'prodml21:ConstantCompositionExpansionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantCompositionExpansionTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantCompositionExpansionTest (-1976)

#endif

/* prodml21__AtmosphericFlashTestAndCompositionalAnalysis * has binding name 'PointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis' for type 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis (-1974)

#endif

/* prodml21__SampleIntegrityAndPreparation * has binding name 'PointerToprodml21__SampleIntegrityAndPreparation' for type 'prodml21:SampleIntegrityAndPreparation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleIntegrityAndPreparation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleIntegrityAndPreparation (-1973)

#endif

/* prodml21__saturationKind * has binding name 'PointerToprodml21__saturationKind' for type 'prodml21:saturationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__saturationKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__saturationKind (-1972)

#endif

/* eml22__AbstractGraphicalInformation * has binding name 'PointerToeml22__AbstractGraphicalInformation' for type 'eml22:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractGraphicalInformation (-1970)

#endif

/* eml22__FailingRule * has binding name 'PointerToeml22__FailingRule' for type 'eml22:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FailingRule
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FailingRule (-1968)

#endif

/* eml22__IndexRange * has binding name 'PointerToeml22__IndexRange' for type 'eml22:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IndexRange
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IndexRange (-1967)

#endif

/* eml22__AbstractVerticalCrs * has binding name 'PointerToeml22__AbstractVerticalCrs' for type 'eml22:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractVerticalCrs (-1966)

#endif

/* std::string * has binding name 'PointerToeml22__LengthUomExt' for type 'eml22:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthUomExt (-1965)

#endif

/* eml22__AbstractProjectedCrs * has binding name 'PointerToeml22__AbstractProjectedCrs' for type 'eml22:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractProjectedCrs (-1964)

#endif

/* eml22__ProjectedCrs * has binding name 'PointerToeml22__ProjectedCrs' for type 'eml22:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ProjectedCrs (-1963)

#endif

/* eml22__Vector * has binding name 'PointerToeml22__Vector' for type 'eml22:Vector' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__Vector
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__Vector (-1962)

#endif

/* eml22__VerticalCrs * has binding name 'PointerToeml22__VerticalCrs' for type 'eml22:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VerticalCrs (-1961)

#endif

/* eml22__HorizontalAxes * has binding name 'PointerToeml22__HorizontalAxes' for type 'eml22:HorizontalAxes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__HorizontalAxes
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__HorizontalAxes (-1960)

#endif

/* eml22__VerticalAxis * has binding name 'PointerToeml22__VerticalAxis' for type 'eml22:VerticalAxis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VerticalAxis
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VerticalAxis (-1959)

#endif

/* eml22__PlaneAngleMeasureExt * has binding name 'PointerToeml22__PlaneAngleMeasureExt' for type 'eml22:PlaneAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PlaneAngleMeasureExt (-1958)

#endif

/* eml22__AbstractGeodeticCrs * has binding name 'PointerToeml22__AbstractGeodeticCrs' for type 'eml22:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractGeodeticCrs (-1957)

#endif

/* std::string * has binding name 'PointerToeml22__ReferenceConditionExt' for type 'eml22:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferenceConditionExt (-1956)

#endif

/* eml22__ReferencePressure * has binding name 'PointerToeml22__ReferencePressure' for type 'eml22:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferencePressure (-1954)

#endif

/* eml22__PressureMeasureExt * has binding name 'PointerToeml22__PressureMeasureExt' for type 'eml22:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressureMeasureExt (-1953)

#endif

/* eml22__ParameterTemplate * has binding name 'PointerToeml22__ParameterTemplate' for type 'eml22:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ParameterTemplate (-1951)

#endif

/* eml22__TimeSeriesParentage * has binding name 'PointerToeml22__TimeSeriesParentage' for type 'eml22:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeSeriesParentage (-1950)

#endif

/* eml22__GeologicTime * has binding name 'PointerToeml22__GeologicTime' for type 'eml22:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__GeologicTime
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__GeologicTime (-1948)

#endif

/* eml22__PropertyKind * has binding name 'PointerToeml22__PropertyKind' for type 'eml22:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PropertyKind (-1946)

#endif

/* eml22__DateTimeInterval * has binding name 'PointerToeml22__DateTimeInterval' for type 'eml22:DateTimeInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DateTimeInterval
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DateTimeInterval (-1945)

#endif

/* eml22__MeasuredDepthCoord * has binding name 'PointerToeml22__MeasuredDepthCoord' for type 'eml22:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MeasuredDepthCoord (-1944)

#endif

/* prodml21__AbstractValue * has binding name 'PointerToprodml21__AbstractValue' for type 'prodml21:AbstractValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractValue (-1942)

#endif

/* prodml21__KeywordValueStruct * has binding name 'PointerToprodml21__KeywordValueStruct' for type 'prodml21:KeywordValueStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__KeywordValueStruct (-1940)

#endif

/* prodml21__TimeSeriesStringSample * has binding name 'PointerToprodml21__TimeSeriesStringSample' for type 'prodml21:TimeSeriesStringSample' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesStringSample
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesStringSample (-1939)

#endif

/* prodml21__TimeSeriesDoubleSample * has binding name 'PointerToprodml21__TimeSeriesDoubleSample' for type 'prodml21:TimeSeriesDoubleSample' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesDoubleSample
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesDoubleSample (-1938)

#endif

/* eml22__VolumePerPressureMeasureExt * has binding name 'PointerToeml22__VolumePerPressureMeasureExt' for type 'eml22:VolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerPressureMeasureExt (-1937)

#endif

/* eml22__TimePerVolumeMeasureExt * has binding name 'PointerToeml22__TimePerVolumeMeasureExt' for type 'eml22:TimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimePerVolumeMeasureExt (-1936)

#endif

/* eml22__PermeabilityRockMeasureExt * has binding name 'PointerToeml22__PermeabilityRockMeasureExt' for type 'eml22:PermeabilityRockMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityRockMeasureExt (-1935)

#endif

/* eml22__PermeabilityLengthMeasureExt * has binding name 'PointerToeml22__PermeabilityLengthMeasureExt' for type 'eml22:PermeabilityLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityLengthMeasureExt (-1934)

#endif

/* eml22__PlaneAngleMeasure * has binding name 'PointerToeml22__PlaneAngleMeasure' for type 'eml22:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PlaneAngleMeasure (-1933)

#endif

/* prodml21__WellboreStorageMechanismType * has binding name 'PointerToprodml21__WellboreStorageMechanismType' for type 'prodml21:WellboreStorageMechanismType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreStorageMechanismType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreStorageMechanismType (-1932)

#endif

/* prodml21__WellboreDeviationAngle * has binding name 'PointerToprodml21__WellboreDeviationAngle' for type 'prodml21:WellboreDeviationAngle' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreDeviationAngle
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreDeviationAngle (-1931)

#endif

/* prodml21__FluidDensity * has binding name 'PointerToprodml21__FluidDensity' for type 'prodml21:FluidDensity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidDensity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidDensity (-1930)

#endif

/* prodml21__TubingInteralDiameter * has binding name 'PointerToprodml21__TubingInteralDiameter' for type 'prodml21:TubingInteralDiameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TubingInteralDiameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TubingInteralDiameter (-1929)

#endif

/* prodml21__WellboreFluidCompressibility * has binding name 'PointerToprodml21__WellboreFluidCompressibility' for type 'prodml21:WellboreFluidCompressibility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreFluidCompressibility
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreFluidCompressibility (-1928)

#endif

/* prodml21__WellboreVolume * has binding name 'PointerToprodml21__WellboreVolume' for type 'prodml21:WellboreVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreVolume
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreVolume (-1927)

#endif

/* prodml21__WellboreStorageCoefficient * has binding name 'PointerToprodml21__WellboreStorageCoefficient' for type 'prodml21:WellboreStorageCoefficient' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreStorageCoefficient
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreStorageCoefficient (-1926)

#endif

/* prodml21__WellboreRadius * has binding name 'PointerToprodml21__WellboreRadius' for type 'prodml21:WellboreRadius' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreRadius
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreRadius (-1925)

#endif

/* prodml21__LowerBoundaryType * has binding name 'PointerToprodml21__LowerBoundaryType' for type 'prodml21:LowerBoundaryType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LowerBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LowerBoundaryType (-1924)

#endif

/* prodml21__UpperBoundaryType * has binding name 'PointerToprodml21__UpperBoundaryType' for type 'prodml21:UpperBoundaryType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__UpperBoundaryType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__UpperBoundaryType (-1923)

#endif

/* prodml21__OrientationOfAnisotropyXDirection * has binding name 'PointerToprodml21__OrientationOfAnisotropyXDirection' for type 'prodml21:OrientationOfAnisotropyXDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfAnisotropyXDirection
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OrientationOfAnisotropyXDirection (-1922)

#endif

/* prodml21__HorizontalAnisotropyKxToKy * has binding name 'PointerToprodml21__HorizontalAnisotropyKxToKy' for type 'prodml21:HorizontalAnisotropyKxToKy' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__HorizontalAnisotropyKxToKy
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__HorizontalAnisotropyKxToKy (-1921)

#endif

/* prodml21__VerticalAnisotropyKvToKr * has binding name 'PointerToprodml21__VerticalAnisotropyKvToKr' for type 'prodml21:VerticalAnisotropyKvToKr' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VerticalAnisotropyKvToKr
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VerticalAnisotropyKvToKr (-1920)

#endif

/* prodml21__AveragePressure * has binding name 'PointerToprodml21__AveragePressure' for type 'prodml21:AveragePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AveragePressure
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AveragePressure (-1919)

#endif

/* prodml21__PressureDatumTVD * has binding name 'PointerToprodml21__PressureDatumTVD' for type 'prodml21:PressureDatumTVD' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressureDatumTVD
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressureDatumTVD (-1918)

#endif

/* prodml21__InitialPressure * has binding name 'PointerToprodml21__InitialPressure' for type 'prodml21:InitialPressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InitialPressure
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InitialPressure (-1917)

#endif

/* prodml21__PermeabilityThicknessProduct * has binding name 'PointerToprodml21__PermeabilityThicknessProduct' for type 'prodml21:PermeabilityThicknessProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PermeabilityThicknessProduct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PermeabilityThicknessProduct (-1916)

#endif

/* prodml21__RatioDpSkinToTotalDrawdown * has binding name 'PointerToprodml21__RatioDpSkinToTotalDrawdown' for type 'prodml21:RatioDpSkinToTotalDrawdown' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioDpSkinToTotalDrawdown
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RatioDpSkinToTotalDrawdown (-1915)

#endif

/* prodml21__DeltaPressureTotalSkin * has binding name 'PointerToprodml21__DeltaPressureTotalSkin' for type 'prodml21:DeltaPressureTotalSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeltaPressureTotalSkin
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeltaPressureTotalSkin (-1914)

#endif

/* prodml21__RateDependentSkinFactor * has binding name 'PointerToprodml21__RateDependentSkinFactor' for type 'prodml21:RateDependentSkinFactor' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RateDependentSkinFactor
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RateDependentSkinFactor (-1913)

#endif

/* prodml21__SkinRelativeToTotalThickness * has binding name 'PointerToprodml21__SkinRelativeToTotalThickness' for type 'prodml21:SkinRelativeToTotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SkinRelativeToTotalThickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SkinRelativeToTotalThickness (-1912)

#endif

/* prodml21__PoreVolumeOfInvestigation * has binding name 'PointerToprodml21__PoreVolumeOfInvestigation' for type 'prodml21:PoreVolumeOfInvestigation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PoreVolumeOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PoreVolumeOfInvestigation (-1911)

#endif

/* prodml21__RadiusOfInvestigation * has binding name 'PointerToprodml21__RadiusOfInvestigation' for type 'prodml21:RadiusOfInvestigation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RadiusOfInvestigation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RadiusOfInvestigation (-1910)

#endif

/* prodml21__OutputFlowData * has binding name 'PointerToprodml21__OutputFlowData' for type 'prodml21:OutputFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OutputFlowData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OutputFlowData (-1909)

#endif

/* prodml21__AbstractDeconvolutionOutput * has binding name 'PointerToprodml21__AbstractDeconvolutionOutput' for type 'prodml21:AbstractDeconvolutionOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDeconvolutionOutput (-1907)

#endif

/* prodml21__DeconvolvedFlowData * has binding name 'PointerToprodml21__DeconvolvedFlowData' for type 'prodml21:DeconvolvedFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolvedFlowData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolvedFlowData (-1906)

#endif

/* prodml21__AbstractRateHistory * has binding name 'PointerToprodml21__AbstractRateHistory' for type 'prodml21:AbstractRateHistory' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRateHistory
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRateHistory (-1904)

#endif

/* prodml21__SpecializedAnalysis * has binding name 'PointerToprodml21__SpecializedAnalysis' for type 'prodml21:SpecializedAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SpecializedAnalysis
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SpecializedAnalysis (-1902)

#endif

/* prodml21__LogLogAnalysis * has binding name 'PointerToprodml21__LogLogAnalysis' for type 'prodml21:LogLogAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LogLogAnalysis
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LogLogAnalysis (-1901)

#endif

/* eml22__PressurePerTimeMeasure * has binding name 'PointerToeml22__PressurePerTimeMeasure' for type 'eml22:PressurePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressurePerTimeMeasure (-1900)

#endif

/* prodml21__CompressibilityParameters * has binding name 'PointerToprodml21__CompressibilityParameters' for type 'prodml21:CompressibilityParameters' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CompressibilityParameters
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CompressibilityParameters (-1899)

#endif

/* prodml21__InterferingFlowTestInterval * has binding name 'PointerToprodml21__InterferingFlowTestInterval' for type 'prodml21:InterferingFlowTestInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterferingFlowTestInterval
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterferingFlowTestInterval (-1897)

#endif

/* prodml21__AbstractAnalysis * has binding name 'PointerToprodml21__AbstractAnalysis' for type 'prodml21:AbstractAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractAnalysis
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractAnalysis (-1896)

#endif

/* prodml21__PseudoPressureEffectApplied * has binding name 'PointerToprodml21__PseudoPressureEffectApplied' for type 'prodml21:PseudoPressureEffectApplied' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PseudoPressureEffectApplied
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PseudoPressureEffectApplied (-1895)

#endif

/* prodml21__LayerModel * has binding name 'PointerToprodml21__LayerModel' for type 'prodml21:LayerModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LayerModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LayerModel (-1893)

#endif

/* prodml21__WellboreBaseModel * has binding name 'PointerToprodml21__WellboreBaseModel' for type 'prodml21:WellboreBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellboreBaseModel (-1892)

#endif

/* prodml21__DeconvolutionOutput * has binding name 'PointerToprodml21__DeconvolutionOutput' for type 'prodml21:DeconvolutionOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolutionOutput (-1891)

#endif

/* prodml21__Channel * has binding name 'PointerToprodml21__Channel' for type 'prodml21:Channel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Channel (-1889)

#endif

/* prodml21__FluidPhaseKind * has binding name 'PointerToprodml21__FluidPhaseKind' for type 'prodml21:FluidPhaseKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidPhaseKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidPhaseKind (-1887)

#endif

/* prodml21__Transfer * has binding name 'PointerToprodml21__Transfer' for type 'prodml21:Transfer' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Transfer
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Transfer (-1886)

#endif

/* prodml21__TerminalLifting * has binding name 'PointerToprodml21__TerminalLifting' for type 'prodml21:TerminalLifting' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TerminalLifting
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TerminalLifting (-1885)

#endif

/* prodml21__WftStation * has binding name 'PointerToprodml21__WftStation' for type 'prodml21:WftStation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftStation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftStation (-1883)

#endif

/* prodml21__FluidSampleAcquisition * has binding name 'PointerToprodml21__FluidSampleAcquisition' for type 'prodml21:FluidSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleAcquisition (-1881)

#endif

/* prodml21__ProductionWellTest * has binding name 'PointerToprodml21__ProductionWellTest' for type 'prodml21:ProductionWellTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductionWellTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductionWellTest (-1880)

#endif

/* prodml21__SampleRecombinationRequirement * has binding name 'PointerToprodml21__SampleRecombinationRequirement' for type 'prodml21:SampleRecombinationRequirement' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleRecombinationRequirement
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleRecombinationRequirement (-1879)

#endif

/* prodml21__FluidSampleComposition * has binding name 'PointerToprodml21__FluidSampleComposition' for type 'prodml21:FluidSampleComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleComposition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleComposition (-1877)

#endif

/* prodml21__FluidSampleChainofCustodyEvent * has binding name 'PointerToprodml21__FluidSampleChainofCustodyEvent' for type 'prodml21:FluidSampleChainofCustodyEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleChainofCustodyEvent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleChainofCustodyEvent (-1875)

#endif

/* prodml21__FluidSampleAcquisitionJobSource * has binding name 'PointerToprodml21__FluidSampleAcquisitionJobSource' for type 'prodml21:FluidSampleAcquisitionJobSource' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleAcquisitionJobSource
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleAcquisitionJobSource (-1874)

#endif

/* prodml21__FluidSampleKind * has binding name 'PointerToprodml21__FluidSampleKind' for type 'prodml21:FluidSampleKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSampleKind (-1873)

#endif

/* prodml21__FluidAnalysisReport * has binding name 'PointerToprodml21__FluidAnalysisReport' for type 'prodml21:FluidAnalysisReport' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidAnalysisReport
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidAnalysisReport (-1871)

#endif

/* prodml21__SampleContaminant * has binding name 'PointerToprodml21__SampleContaminant' for type 'prodml21:SampleContaminant' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleContaminant
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleContaminant (-1869)

#endif

/* prodml21__ReservoirLifeCycleState * has binding name 'PointerToprodml21__ReservoirLifeCycleState' for type 'prodml21:ReservoirLifeCycleState' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirLifeCycleState
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirLifeCycleState (-1868)

#endif

/* prodml21__ProductFlowExternalReference * has binding name 'PointerToprodml21__ProductFlowExternalReference' for type 'prodml21:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExternalReference (-1865)

#endif

/* prodml21__ProductFlowNetwork * has binding name 'PointerToprodml21__ProductFlowNetwork' for type 'prodml21:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowNetwork (-1863)

#endif

/* prodml21__KindQualifiedString * has binding name 'PointerToprodml21__KindQualifiedString' for type 'prodml21:KindQualifiedString' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__KindQualifiedString (-1862)

#endif

/* prodml21__ProductVolumeFacility * has binding name 'PointerToprodml21__ProductVolumeFacility' for type 'prodml21:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeFacility (-1859)

#endif

/* eml22__ReferenceCondition * has binding name 'PointerToeml22__ReferenceCondition' for type 'eml22:ReferenceCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReferenceCondition (-1858)

#endif

/* prodml21__CalculationMethod * has binding name 'PointerToprodml21__CalculationMethod' for type 'prodml21:CalculationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CalculationMethod (-1857)

#endif

/* prodml21__EndpointQualifiedDateTime * has binding name 'PointerToprodml21__EndpointQualifiedDateTime' for type 'prodml21:EndpointQualifiedDateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EndpointQualifiedDateTime (-1856)

#endif

/* prodml21__IntegerQualifiedCount * has binding name 'PointerToprodml21__IntegerQualifiedCount' for type 'prodml21:IntegerQualifiedCount' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__IntegerQualifiedCount (-1855)

#endif

/* eml22__EnergyPerMassMeasure * has binding name 'PointerToeml22__EnergyPerMassMeasure' for type 'eml22:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyPerMassMeasure (-1852)

#endif

/* prodml21__FluidCharacterizationModel * has binding name 'PointerToprodml21__FluidCharacterizationModel' for type 'prodml21:FluidCharacterizationModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationModel (-1850)

#endif

/* prodml21__FluidCharacterizationSource * has binding name 'PointerToprodml21__FluidCharacterizationSource' for type 'prodml21:FluidCharacterizationSource' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationSource
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationSource (-1848)

#endif

/* prodml21__ApplicationInfo * has binding name 'PointerToprodml21__ApplicationInfo' for type 'prodml21:ApplicationInfo' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ApplicationInfo
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ApplicationInfo (-1846)

#endif

/* prodml21__ComponentPropertySet * has binding name 'PointerToprodml21__ComponentPropertySet' for type 'prodml21:ComponentPropertySet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ComponentPropertySet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ComponentPropertySet (-1845)

#endif

/* prodml21__BinaryInteractionCoefficientSet * has binding name 'PointerToprodml21__BinaryInteractionCoefficientSet' for type 'prodml21:BinaryInteractionCoefficientSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BinaryInteractionCoefficientSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BinaryInteractionCoefficientSet (-1844)

#endif

/* prodml21__MixingRule * has binding name 'PointerToprodml21__MixingRule' for type 'prodml21:MixingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MixingRule
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MixingRule (-1843)

#endif

/* eml22__DistanceNorthSouth * has binding name 'PointerToeml22__DistanceNorthSouth' for type 'eml22:DistanceNorthSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DistanceNorthSouth
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DistanceNorthSouth (-1842)

#endif

/* eml22__DistanceEastWest * has binding name 'PointerToeml22__DistanceEastWest' for type 'eml22:DistanceEastWest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DistanceEastWest
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DistanceEastWest (-1841)

#endif

/* std::string * has binding name 'PointerToeml22__PublicLandSurveySystemQuarterTownship' for type 'eml22:PublicLandSurveySystemQuarterTownship' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PublicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PublicLandSurveySystemQuarterTownship (-1840)

#endif

/* std::string * has binding name 'PointerToeml22__PublicLandSurveySystemQuarterSection' for type 'eml22:PublicLandSurveySystemQuarterSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PublicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PublicLandSurveySystemQuarterSection (-1839)

#endif

/* std::string * has binding name 'PointerToeml22__SectionNumber' for type 'eml22:SectionNumber' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__SectionNumber
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__SectionNumber (-1838)

#endif

/* eml22__NorthOrSouth * has binding name 'PointerToeml22__NorthOrSouth' for type 'eml22:NorthOrSouth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__NorthOrSouth
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__NorthOrSouth (-1837)

#endif

/* eml22__EastOrWest * has binding name 'PointerToeml22__EastOrWest' for type 'eml22:EastOrWest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EastOrWest
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EastOrWest (-1836)

#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToint
#define SOAP_TYPE_gsoap_eml2_2_PointerToint (-1835)

#endif

/* eml22__PrincipalMeridian * has binding name 'PointerToeml22__PrincipalMeridian' for type 'eml22:PrincipalMeridian' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PrincipalMeridian
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PrincipalMeridian (-1834)

#endif

/* eml22__LengthMeasureExt * has binding name 'PointerToeml22__LengthMeasureExt' for type 'eml22:LengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthMeasureExt (-1833)

#endif

/* eml22__AbstractTemperaturePressure * has binding name 'PointerToeml22__AbstractTemperaturePressure' for type 'eml22:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractTemperaturePressure (-1832)

#endif

/* eml22__AbstractActivityParameter * has binding name 'PointerToeml22__AbstractActivityParameter' for type 'eml22:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractActivityParameter (-1829)

#endif

/* eml22__AbstractParameterKey * has binding name 'PointerToeml22__AbstractParameterKey' for type 'eml22:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractParameterKey (-1825)

#endif

/* eml22__ExternalDatasetPart * has binding name 'PointerToeml22__ExternalDatasetPart' for type 'eml22:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExternalDatasetPart (-1823)

#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToxsd__anyURI
#define SOAP_TYPE_gsoap_eml2_2_PointerToxsd__anyURI (-1822)

#endif

/* eml22__AbstractValueArray * has binding name 'PointerToeml22__AbstractValueArray' for type 'eml22:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractValueArray (-1821)

#endif

/* eml22__TimeIndex * has binding name 'PointerToeml22__TimeIndex' for type 'eml22:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeIndex
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeIndex (-1820)

#endif

/* eml22__AbstractIntegerArray * has binding name 'PointerToeml22__AbstractIntegerArray' for type 'eml22:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractIntegerArray (-1819)

#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToLONG64
#define SOAP_TYPE_gsoap_eml2_2_PointerToLONG64 (-1818)

#endif

/* eml22__StringMeasure * has binding name 'PointerToeml22__StringMeasure' for type 'eml22:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__StringMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__StringMeasure (-1817)

#endif

/* eml22__ExistenceKind * has binding name 'PointerToeml22__ExistenceKind' for type 'eml22:ExistenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExistenceKind (-1815)

#endif

/* eml22__CustomData * has binding name 'PointerToeml22__CustomData' for type 'eml22:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__CustomData
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__CustomData (-1813)

#endif

/* eml22__Citation * has binding name 'PointerToeml22__Citation' for type 'eml22:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__Citation
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__Citation (-1812)

#endif

/* prodml21__ReportingHierarchyNode * has binding name 'PointerToprodml21__ReportingHierarchyNode' for type 'prodml21:ReportingHierarchyNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingHierarchyNode
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingHierarchyNode (-1810)

#endif

/* prodml21__CustomParameter * has binding name 'PointerToprodml21__CustomParameter' for type 'prodml21:CustomParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomParameter (-1808)

#endif

/* prodml21__AbstractParameter * has binding name 'PointerToprodml21__AbstractParameter' for type 'prodml21:AbstractParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractParameter (-1806)

#endif

/* prodml21__FractureStorativityRatio * has binding name 'PointerToprodml21__FractureStorativityRatio' for type 'prodml21:FractureStorativityRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureStorativityRatio
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureStorativityRatio (-1804)

#endif

/* prodml21__FractureFaceSkin * has binding name 'PointerToprodml21__FractureFaceSkin' for type 'prodml21:FractureFaceSkin' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureFaceSkin
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureFaceSkin (-1803)

#endif

/* prodml21__DistanceMidFractureHeightToBottomBoundary * has binding name 'PointerToprodml21__DistanceMidFractureHeightToBottomBoundary' for type 'prodml21:DistanceMidFractureHeightToBottomBoundary' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceMidFractureHeightToBottomBoundary
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DistanceMidFractureHeightToBottomBoundary (-1802)

#endif

/* prodml21__FractureHeight * has binding name 'PointerToprodml21__FractureHeight' for type 'prodml21:FractureHeight' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureHeight
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureHeight (-1801)

#endif

/* prodml21__TotalThickness * has binding name 'PointerToprodml21__TotalThickness' for type 'prodml21:TotalThickness' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TotalThickness
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TotalThickness (-1797)

#endif

/* prodml21__Porosity * has binding name 'PointerToprodml21__Porosity' for type 'prodml21:Porosity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Porosity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Porosity (-1796)

#endif

/* prodml21__HorizontalRadialPermeability * has binding name 'PointerToprodml21__HorizontalRadialPermeability' for type 'prodml21:HorizontalRadialPermeability' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__HorizontalRadialPermeability
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__HorizontalRadialPermeability (-1795)

#endif

/* prodml21__LocationIn2D * has binding name 'PointerToprodml21__LocationIn2D' for type 'prodml21:LocationIn2D' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LocationIn2D
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LocationIn2D (-1793)

#endif

/* prodml21__AnalysisLine * has binding name 'PointerToprodml21__AnalysisLine' for type 'prodml21:AnalysisLine' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AnalysisLine
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AnalysisLine (-1790)

#endif

/* prodml21__AbstractPtaPressureData * has binding name 'PointerToprodml21__AbstractPtaPressureData' for type 'prodml21:AbstractPtaPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPtaPressureData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPtaPressureData (-1789)

#endif

/* prodml21__InterporosityFlowParameter * has binding name 'PointerToprodml21__InterporosityFlowParameter' for type 'prodml21:InterporosityFlowParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterporosityFlowParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterporosityFlowParameter (-1787)

#endif

/* prodml21__LayerToLayerConnection * has binding name 'PointerToprodml21__LayerToLayerConnection' for type 'prodml21:LayerToLayerConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LayerToLayerConnection
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LayerToLayerConnection (-1785)

#endif

/* prodml21__BoundaryBaseModel * has binding name 'PointerToprodml21__BoundaryBaseModel' for type 'prodml21:BoundaryBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BoundaryBaseModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BoundaryBaseModel (-1784)

#endif

/* prodml21__ReservoirBaseModel * has binding name 'PointerToprodml21__ReservoirBaseModel' for type 'prodml21:ReservoirBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirBaseModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReservoirBaseModel (-1783)

#endif

/* prodml21__NearWellboreBaseModel * has binding name 'PointerToprodml21__NearWellboreBaseModel' for type 'prodml21:NearWellboreBaseModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NearWellboreBaseModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NearWellboreBaseModel (-1782)

#endif

/* prodml21__PressurePerFlowrateMeasure * has binding name 'PointerToprodml21__PressurePerFlowrateMeasure' for type 'prodml21:PressurePerFlowrateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressurePerFlowrateMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressurePerFlowrateMeasure (-1781)

#endif

/* prodml21__PressurePerFlowrateSquaredMeasure * has binding name 'PointerToprodml21__PressurePerFlowrateSquaredMeasure' for type 'prodml21:PressurePerFlowrateSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressurePerFlowrateSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PressurePerFlowrateSquaredMeasure (-1780)

#endif

/* eml22__VolumePerTimePerPressureMeasure * has binding name 'PointerToeml22__VolumePerTimePerPressureMeasure' for type 'eml22:VolumePerTimePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerTimePerPressureMeasure (-1779)

#endif

/* prodml21__FractureConductivity * has binding name 'PointerToprodml21__FractureConductivity' for type 'prodml21:FractureConductivity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureConductivity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FractureConductivity (-1777)

#endif

/* prodml21__TransmissibilityReductionFactorOfLinearFront * has binding name 'PointerToprodml21__TransmissibilityReductionFactorOfLinearFront' for type 'prodml21:TransmissibilityReductionFactorOfLinearFront' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TransmissibilityReductionFactorOfLinearFront
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TransmissibilityReductionFactorOfLinearFront (-1776)

#endif

/* prodml21__OutputPressureData * has binding name 'PointerToprodml21__OutputPressureData' for type 'prodml21:OutputPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OutputPressureData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OutputPressureData (-1774)

#endif

/* prodml21__ResqmlModelRef * has binding name 'PointerToprodml21__ResqmlModelRef' for type 'prodml21:ResqmlModelRef' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ResqmlModelRef
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ResqmlModelRef (-1773)

#endif

/* eml22__VolumePerTimeMeasure * has binding name 'PointerToeml22__VolumePerTimeMeasure' for type 'eml22:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerTimeMeasure (-1772)

#endif

/* prodml21__DeconvolvedPressureData * has binding name 'PointerToprodml21__DeconvolvedPressureData' for type 'prodml21:DeconvolvedPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolvedPressureData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeconvolvedPressureData (-1771)

#endif

/* eml22__ReciprocalPressureMeasureExt * has binding name 'PointerToeml22__ReciprocalPressureMeasureExt' for type 'eml22:ReciprocalPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReciprocalPressureMeasureExt (-1770)

#endif

/* prodml21__MeasuredPressureData * has binding name 'PointerToprodml21__MeasuredPressureData' for type 'prodml21:MeasuredPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasuredPressureData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasuredPressureData (-1768)

#endif

/* prodml21__AbstractPtaFlowData * has binding name 'PointerToprodml21__AbstractPtaFlowData' for type 'prodml21:AbstractPtaFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPtaFlowData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPtaFlowData (-1766)

#endif

/* prodml21__OtherData * has binding name 'PointerToprodml21__OtherData' for type 'prodml21:OtherData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherData (-1764)

#endif

/* prodml21__AbstractFlowTestData * has binding name 'PointerToprodml21__AbstractFlowTestData' for type 'prodml21:AbstractFlowTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractFlowTestData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractFlowTestData (-1762)

#endif

/* prodml21__FlowTestLocation * has binding name 'PointerToprodml21__FlowTestLocation' for type 'prodml21:FlowTestLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowTestLocation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowTestLocation (-1761)

#endif

/* prodml21__FluidComponentCatalog * has binding name 'PointerToprodml21__FluidComponentCatalog' for type 'prodml21:FluidComponentCatalog' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponentCatalog
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponentCatalog (-1760)

#endif

/* eml22__WellboreDatumReference * has binding name 'PointerToeml22__WellboreDatumReference' for type 'eml22:WellboreDatumReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__WellboreDatumReference (-1759)

#endif

/* eml22__MdInterval * has binding name 'PointerToeml22__MdInterval' for type 'eml22:MdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MdInterval
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MdInterval (-1758)

#endif

/* prodml21__TimeSeriesPointRepresentation * has binding name 'PointerToprodml21__TimeSeriesPointRepresentation' for type 'prodml21:TimeSeriesPointRepresentation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesPointRepresentation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TimeSeriesPointRepresentation (-1757)

#endif

/* prodml21__TestPeriodKind * has binding name 'PointerToprodml21__TestPeriodKind' for type 'prodml21:TestPeriodKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TestPeriodKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TestPeriodKind (-1756)

#endif

/* prodml21__DeferredProductionEvent * has binding name 'PointerToprodml21__DeferredProductionEvent' for type 'prodml21:DeferredProductionEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredProductionEvent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredProductionEvent (-1754)

#endif

/* prodml21__AbstractDisposition * has binding name 'PointerToprodml21__AbstractDisposition' for type 'prodml21:AbstractDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDisposition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDisposition (-1752)

#endif

/* prodml21__Injection * has binding name 'PointerToprodml21__Injection' for type 'prodml21:Injection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Injection
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Injection (-1750)

#endif

/* prodml21__Production * has binding name 'PointerToprodml21__Production' for type 'prodml21:Production' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Production
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Production (-1748)

#endif

/* prodml21__TestPeriod * has binding name 'PointerToprodml21__TestPeriod' for type 'prodml21:TestPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TestPeriod
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TestPeriod (-1746)

#endif

/* prodml21__ProductRate * has binding name 'PointerToprodml21__ProductRate' for type 'prodml21:ProductRate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductRate
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductRate (-1744)

#endif

/* prodml21__WellFlowingCondition * has binding name 'PointerToprodml21__WellFlowingCondition' for type 'prodml21:WellFlowingCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellFlowingCondition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellFlowingCondition (-1743)

#endif

/* prodml21__DeferredProductionVolume * has binding name 'PointerToprodml21__DeferredProductionVolume' for type 'prodml21:DeferredProductionVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredProductionVolume
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredProductionVolume (-1741)

#endif

/* prodml21__DeferredKind * has binding name 'PointerToprodml21__DeferredKind' for type 'prodml21:DeferredKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DeferredKind (-1740)

#endif

/* prodml21__DowntimeReasonCode * has binding name 'PointerToprodml21__DowntimeReasonCode' for type 'prodml21:DowntimeReasonCode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DowntimeReasonCode
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DowntimeReasonCode (-1739)

#endif

/* prodml21__AbstractProductQuantity * has binding name 'PointerToprodml21__AbstractProductQuantity' for type 'prodml21:AbstractProductQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractProductQuantity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractProductQuantity (-1737)

#endif

/* eml22__AuthorityQualifiedName * has binding name 'PointerToeml22__AuthorityQualifiedName' for type 'eml22:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AuthorityQualifiedName (-1736)

#endif

/* prodml21__WftResultReference * has binding name 'PointerToprodml21__WftResultReference' for type 'prodml21:WftResultReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftResultReference
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftResultReference (-1734)

#endif

/* prodml21__WftCurveSection * has binding name 'PointerToprodml21__WftCurveSection' for type 'prodml21:WftCurveSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftCurveSection
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftCurveSection (-1732)

#endif

/* prodml21__WftInOutParameter * has binding name 'PointerToprodml21__WftInOutParameter' for type 'prodml21:WftInOutParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftInOutParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftInOutParameter (-1730)

#endif

/* prodml21__WftTest * has binding name 'PointerToprodml21__WftTest' for type 'prodml21:WftTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTest
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTest (-1728)

#endif

/* prodml21__WftSampleAcquisition * has binding name 'PointerToprodml21__WftSampleAcquisition' for type 'prodml21:WftSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftSampleAcquisition (-1726)

#endif

/* prodml21__WftEvent * has binding name 'PointerToprodml21__WftEvent' for type 'prodml21:WftEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftEvent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftEvent (-1724)

#endif

/* prodml21__WftTestData * has binding name 'PointerToprodml21__WftTestData' for type 'prodml21:WftTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTestData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTestData (-1721)

#endif

/* prodml21__WftTestResult * has binding name 'PointerToprodml21__WftTestResult' for type 'prodml21:WftTestResult' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTestResult
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WftTestResult (-1719)

#endif

/* prodml21__MeasureOrQuantity * has binding name 'PointerToprodml21__MeasureOrQuantity' for type 'prodml21:MeasureOrQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasureOrQuantity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasureOrQuantity (-1718)

#endif

/* prodml21__SampleAction * has binding name 'PointerToprodml21__SampleAction' for type 'prodml21:SampleAction' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleAction
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleAction (-1717)

#endif

/* eml22__EnergyLengthPerTimeAreaTemperatureMeasure * has binding name 'PointerToeml22__EnergyLengthPerTimeAreaTemperatureMeasure' for type 'eml22:EnergyLengthPerTimeAreaTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyLengthPerTimeAreaTemperatureMeasure (-1716)

#endif

/* eml22__MolarEnergyMeasure * has binding name 'PointerToeml22__MolarEnergyMeasure' for type 'eml22:MolarEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolarEnergyMeasure (-1715)

#endif

/* eml22__VolumetricThermalExpansionMeasure * has binding name 'PointerToeml22__VolumetricThermalExpansionMeasure' for type 'eml22:VolumetricThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumetricThermalExpansionMeasure (-1714)

#endif

/* eml22__ElectricConductivityMeasure * has binding name 'PointerToeml22__ElectricConductivityMeasure' for type 'eml22:ElectricConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ElectricConductivityMeasure (-1713)

#endif

/* eml22__MassPerVolumePerTemperatureMeasureExt * has binding name 'PointerToeml22__MassPerVolumePerTemperatureMeasureExt' for type 'eml22:MassPerVolumePerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumePerTemperatureMeasureExt (-1712)

#endif

/* eml22__MassPerVolumePerPressureMeasureExt * has binding name 'PointerToeml22__MassPerVolumePerPressureMeasureExt' for type 'eml22:MassPerVolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumePerPressureMeasureExt (-1711)

#endif

/* eml22__VolumePerMassMeasure * has binding name 'PointerToeml22__VolumePerMassMeasure' for type 'eml22:VolumePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerMassMeasure (-1710)

#endif

/* prodml21__WaterAnalysisTestStep * has binding name 'PointerToprodml21__WaterAnalysisTestStep' for type 'prodml21:WaterAnalysisTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterAnalysisTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WaterAnalysisTestStep (-1708)

#endif

/* eml22__ElectricalResistivityMeasure * has binding name 'PointerToeml22__ElectricalResistivityMeasure' for type 'eml22:ElectricalResistivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ElectricalResistivityMeasure (-1707)

#endif

/* prodml21__PhaseDensity * has binding name 'PointerToprodml21__PhaseDensity' for type 'prodml21:PhaseDensity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhaseDensity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhaseDensity (-1704)

#endif

/* prodml21__PhaseViscosity * has binding name 'PointerToprodml21__PhaseViscosity' for type 'prodml21:PhaseViscosity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhaseViscosity
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhaseViscosity (-1703)

#endif

/* prodml21__RefInjectedGasAdded * has binding name 'PointerToprodml21__RefInjectedGasAdded' for type 'prodml21:RefInjectedGasAdded' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RefInjectedGasAdded
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RefInjectedGasAdded (-1701)

#endif

/* prodml21__SwellingTestStep * has binding name 'PointerToprodml21__SwellingTestStep' for type 'prodml21:SwellingTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SwellingTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SwellingTestStep (-1699)

#endif

/* prodml21__Sara * has binding name 'PointerToprodml21__Sara' for type 'prodml21:Sara' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Sara
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__Sara (-1697)

#endif

/* prodml21__ViscosityAtTemperature * has binding name 'PointerToprodml21__ViscosityAtTemperature' for type 'prodml21:ViscosityAtTemperature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ViscosityAtTemperature
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ViscosityAtTemperature (-1695)

#endif

/* prodml21__STOFlashedLiquid * has binding name 'PointerToprodml21__STOFlashedLiquid' for type 'prodml21:STOFlashedLiquid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__STOFlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__STOFlashedLiquid (-1694)

#endif

/* prodml21__MassBalance * has binding name 'PointerToprodml21__MassBalance' for type 'prodml21:MassBalance' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassBalance
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassBalance (-1693)

#endif

/* prodml21__ProducedOilProperties * has binding name 'PointerToprodml21__ProducedOilProperties' for type 'prodml21:ProducedOilProperties' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProducedOilProperties
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProducedOilProperties (-1692)

#endif

/* prodml21__ProducedGasProperties * has binding name 'PointerToprodml21__ProducedGasProperties' for type 'prodml21:ProducedGasProperties' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProducedGasProperties
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProducedGasProperties (-1691)

#endif

/* eml22__LengthPerTimeMeasure * has binding name 'PointerToeml22__LengthPerTimeMeasure' for type 'eml22:LengthPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthPerTimeMeasure (-1690)

#endif

/* prodml21__SlimTubeTestVolumeStep * has binding name 'PointerToprodml21__SlimTubeTestVolumeStep' for type 'prodml21:SlimTubeTestVolumeStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTestVolumeStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTestVolumeStep (-1688)

#endif

/* prodml21__SlimTubeTestStep * has binding name 'PointerToprodml21__SlimTubeTestStep' for type 'prodml21:SlimTubeTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeTestStep (-1686)

#endif

/* prodml21__SlimTubeSpecification * has binding name 'PointerToprodml21__SlimTubeSpecification' for type 'prodml21:SlimTubeSpecification' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeSpecification
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SlimTubeSpecification (-1684)

#endif

/* prodml21__InjectedGas * has binding name 'PointerToprodml21__InjectedGas' for type 'prodml21:InjectedGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InjectedGas
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InjectedGas (-1682)

#endif

/* eml22__PermeabilityRockMeasure * has binding name 'PointerToeml22__PermeabilityRockMeasure' for type 'eml22:PermeabilityRockMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PermeabilityRockMeasure (-1681)

#endif

/* eml22__AreaMeasure * has binding name 'PointerToeml22__AreaMeasure' for type 'eml22:AreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AreaMeasure (-1680)

#endif

/* prodml21__SampleRestoration * has binding name 'PointerToprodml21__SampleRestoration' for type 'prodml21:SampleRestoration' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleRestoration
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SampleRestoration (-1678)

#endif

/* prodml21__SaturationTemperature * has binding name 'PointerToprodml21__SaturationTemperature' for type 'prodml21:SaturationTemperature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationTemperature
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationTemperature (-1677)

#endif

/* prodml21__OtherMeasurementTestStep * has binding name 'PointerToprodml21__OtherMeasurementTestStep' for type 'prodml21:OtherMeasurementTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherMeasurementTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OtherMeasurementTestStep (-1675)

#endif

/* prodml21__FluidCharacterizationTableFormatSet * has binding name 'PointerToprodml21__FluidCharacterizationTableFormatSet' for type 'prodml21:FluidCharacterizationTableFormatSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableFormatSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableFormatSet (-1674)

#endif

/* prodml21__MassIn * has binding name 'PointerToprodml21__MassIn' for type 'prodml21:MassIn' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassIn
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassIn (-1673)

#endif

/* prodml21__MassOut * has binding name 'PointerToprodml21__MassOut' for type 'prodml21:MassOut' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassOut
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MassOut (-1672)

#endif

/* eml22__ForcePerLengthMeasure * has binding name 'PointerToeml22__ForcePerLengthMeasure' for type 'eml22:ForcePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ForcePerLengthMeasure (-1671)

#endif

/* prodml21__InterfacialTensionTestStep * has binding name 'PointerToprodml21__InterfacialTensionTestStep' for type 'prodml21:InterfacialTensionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterfacialTensionTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__InterfacialTensionTestStep (-1669)

#endif

/* prodml21__AbstractFluidComponent * has binding name 'PointerToprodml21__AbstractFluidComponent' for type 'prodml21:AbstractFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractFluidComponent (-1668)

#endif

/* prodml21__FluidSeparatorTestStep * has binding name 'PointerToprodml21__FluidSeparatorTestStep' for type 'prodml21:FluidSeparatorTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSeparatorTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidSeparatorTestStep (-1665)

#endif

/* prodml21__ReportLocation * has binding name 'PointerToprodml21__ReportLocation' for type 'prodml21:ReportLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportLocation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportLocation (-1663)

#endif

/* prodml21__FluidDifferentialLiberationTestStep * has binding name 'PointerToprodml21__FluidDifferentialLiberationTestStep' for type 'prodml21:FluidDifferentialLiberationTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidDifferentialLiberationTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidDifferentialLiberationTestStep (-1661)

#endif

/* prodml21__SeparatorConditions * has binding name 'PointerToprodml21__SeparatorConditions' for type 'prodml21:SeparatorConditions' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SeparatorConditions
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SeparatorConditions (-1660)

#endif

/* prodml21__FluidCvdTestStep * has binding name 'PointerToprodml21__FluidCvdTestStep' for type 'prodml21:FluidCvdTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCvdTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCvdTestStep (-1658)

#endif

/* prodml21__LiquidComposition * has binding name 'PointerToprodml21__LiquidComposition' for type 'prodml21:LiquidComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__LiquidComposition (-1657)

#endif

/* prodml21__VaporComposition * has binding name 'PointerToprodml21__VaporComposition' for type 'prodml21:VaporComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VaporComposition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__VaporComposition (-1656)

#endif

/* prodml21__PhasePresent * has binding name 'PointerToprodml21__PhasePresent' for type 'prodml21:PhasePresent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhasePresent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhasePresent (-1655)

#endif

/* prodml21__FluidAnalysisStepCondition * has binding name 'PointerToprodml21__FluidAnalysisStepCondition' for type 'prodml21:FluidAnalysisStepCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidAnalysisStepCondition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidAnalysisStepCondition (-1654)

#endif

/* prodml21__OilCompressibility * has binding name 'PointerToprodml21__OilCompressibility' for type 'prodml21:OilCompressibility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OilCompressibility
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OilCompressibility (-1653)

#endif

/* prodml21__RelativeVolumeRatio * has binding name 'PointerToprodml21__RelativeVolumeRatio' for type 'prodml21:RelativeVolumeRatio' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RelativeVolumeRatio
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RelativeVolumeRatio (-1652)

#endif

/* prodml21__ConstantCompositionExpansionTestStep * has binding name 'PointerToprodml21__ConstantCompositionExpansionTestStep' for type 'prodml21:ConstantCompositionExpansionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantCompositionExpansionTestStep
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConstantCompositionExpansionTestStep (-1650)

#endif

/* prodml21__FluidVolumeReference * has binding name 'PointerToprodml21__FluidVolumeReference' for type 'prodml21:FluidVolumeReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidVolumeReference
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidVolumeReference (-1648)

#endif

/* prodml21__SaturationPressure * has binding name 'PointerToprodml21__SaturationPressure' for type 'prodml21:SaturationPressure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationPressure
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__SaturationPressure (-1647)

#endif

/* prodml21__FlashedLiquid * has binding name 'PointerToprodml21__FlashedLiquid' for type 'prodml21:FlashedLiquid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlashedLiquid
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlashedLiquid (-1646)

#endif

/* prodml21__FlashedGas * has binding name 'PointerToprodml21__FlashedGas' for type 'prodml21:FlashedGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlashedGas
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlashedGas (-1645)

#endif

/* prodml21__OverallComposition * has binding name 'PointerToprodml21__OverallComposition' for type 'prodml21:OverallComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OverallComposition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OverallComposition (-1644)

#endif

/* prodml21__ProductFlowPort * has binding name 'PointerToprodml21__ProductFlowPort' for type 'prodml21:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowPort (-1641)

#endif

/* prodml21__RelativeCoordinate * has binding name 'PointerToprodml21__RelativeCoordinate' for type 'prodml21:RelativeCoordinate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__RelativeCoordinate (-1640)

#endif

/* prodml21__ProductFlowExpectedUnitProperty * has binding name 'PointerToprodml21__ProductFlowExpectedUnitProperty' for type 'prodml21:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExpectedUnitProperty (-1637)

#endif

/* prodml21__ConnectedNode * has binding name 'PointerToprodml21__ConnectedNode' for type 'prodml21:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ConnectedNode (-1635)

#endif

/* prodml21__ProductFlowQualifierExpected * has binding name 'PointerToprodml21__ProductFlowQualifierExpected' for type 'prodml21:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowQualifierExpected (-1633)

#endif

/* prodml21__ExpectedFlowQualifier * has binding name 'PointerToprodml21__ExpectedFlowQualifier' for type 'prodml21:ExpectedFlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ExpectedFlowQualifier (-1632)

#endif

/* prodml21__GeneralMeasureType * has binding name 'PointerToprodml21__GeneralMeasureType' for type 'prodml21:GeneralMeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeneralMeasureType (-1631)

#endif

/* prodml21__AbstractRelatedFacilityObject * has binding name 'PointerToprodml21__AbstractRelatedFacilityObject' for type 'prodml21:AbstractRelatedFacilityObject' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRelatedFacilityObject (-1630)

#endif

/* prodml21__AbstractRefProductFlow * has binding name 'PointerToprodml21__AbstractRefProductFlow' for type 'prodml21:AbstractRefProductFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractRefProductFlow (-1629)

#endif

/* prodml21__ProductVolumePeriod * has binding name 'PointerToprodml21__ProductVolumePeriod' for type 'prodml21:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumePeriod (-1627)

#endif

/* float * has binding name 'PointerToprodml21__NonNegativeFraction' for type 'prodml21:NonNegativeFraction' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NonNegativeFraction (-1626)

#endif

/* eml22__LengthPerLengthMeasure * has binding name 'PointerToeml22__LengthPerLengthMeasure' for type 'eml22:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthPerLengthMeasure (-1625)

#endif

/* eml22__LengthMeasure * has binding name 'PointerToeml22__LengthMeasure' for type 'eml22:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__LengthMeasure (-1624)

#endif

/* prodml21__AbstractDateTimeClass * has binding name 'PointerToprodml21__AbstractDateTimeClass' for type 'prodml21:AbstractDateTimeClass' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractDateTimeClass (-1623)

#endif

/* prodml21__ProductVolumeBalanceSet * has binding name 'PointerToprodml21__ProductVolumeBalanceSet' for type 'prodml21:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceSet (-1621)

#endif

/* prodml21__ProductVolumeAlert * has binding name 'PointerToprodml21__ProductVolumeAlert' for type 'prodml21:ProductVolumeAlert' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeAlert (-1620)

#endif

/* prodml21__AbstractMeasureData * has binding name 'PointerToprodml21__AbstractMeasureData' for type 'prodml21:AbstractMeasureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractMeasureData
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractMeasureData (-1618)

#endif

/* prodml21__CurveDefinition * has binding name 'PointerToprodml21__CurveDefinition' for type 'prodml21:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CurveDefinition (-1616)

#endif

/* prodml21__ProductVolumeParameterValue * has binding name 'PointerToprodml21__ProductVolumeParameterValue' for type 'prodml21:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeParameterValue (-1614)

#endif

/* prodml21__ReportingDurationKind * has binding name 'PointerToprodml21__ReportingDurationKind' for type 'prodml21:ReportingDurationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingDurationKind (-1613)

#endif

/* eml22__MeasureClass * has binding name 'PointerToeml22__MeasureClass' for type 'eml22:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MeasureClass
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MeasureClass (-1612)

#endif

/* std::string * has binding name 'PointerToprodml21__ProdmlRelativeIdentifier' for type 'prodml21:ProdmlRelativeIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProdmlRelativeIdentifier (-1611)

#endif

/* prodml21__ProductVolumeRelatedFacility * has binding name 'PointerToprodml21__ProductVolumeRelatedFacility' for type 'prodml21:ProductVolumeRelatedFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeRelatedFacility (-1610)

#endif

/* prodml21__ProductVolumeProduct * has binding name 'PointerToprodml21__ProductVolumeProduct' for type 'prodml21:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeProduct (-1608)

#endif

/* prodml21__FlowSubQualifier * has binding name 'PointerToprodml21__FlowSubQualifier' for type 'prodml21:FlowSubQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowSubQualifier (-1607)

#endif

/* prodml21__FlowQualifier * has binding name 'PointerToprodml21__FlowQualifier' for type 'prodml21:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FlowQualifier (-1606)

#endif

/* prodml21__ProductFlowPortType * has binding name 'PointerToprodml21__ProductFlowPortType' for type 'prodml21:ProductFlowPortType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowPortType (-1605)

#endif

/* prodml21__DatedComment * has binding name 'PointerToprodml21__DatedComment' for type 'prodml21:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DatedComment
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__DatedComment (-1603)

#endif

/* prodml21__ProductVolumeParameterSet * has binding name 'PointerToprodml21__ProductVolumeParameterSet' for type 'prodml21:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeParameterSet (-1601)

#endif

/* prodml21__ProductVolumeFlow * has binding name 'PointerToprodml21__ProductVolumeFlow' for type 'prodml21:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeFlow (-1599)

#endif

/* eml22__TimeMeasure * has binding name 'PointerToeml22__TimeMeasure' for type 'eml22:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeMeasure (-1598)

#endif

/* prodml21__WellOperationMethod * has binding name 'PointerToprodml21__WellOperationMethod' for type 'prodml21:WellOperationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellOperationMethod (-1597)

#endif

/* prodml21__WellFluid * has binding name 'PointerToprodml21__WellFluid' for type 'prodml21:WellFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellFluid
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellFluid (-1596)

#endif

/* eml22__WellStatus * has binding name 'PointerToeml22__WellStatus' for type 'eml22:WellStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__WellStatus
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__WellStatus (-1595)

#endif

/* prodml21__BalanceDestinationType * has binding name 'PointerToprodml21__BalanceDestinationType' for type 'prodml21:BalanceDestinationType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BalanceDestinationType (-1594)

#endif

/* prodml21__CommonPropertiesProductVolume * has binding name 'PointerToprodml21__CommonPropertiesProductVolume' for type 'prodml21:CommonPropertiesProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CommonPropertiesProductVolume (-1593)

#endif

/* prodml21__ReportingProduct * has binding name 'PointerToprodml21__ReportingProduct' for type 'prodml21:ReportingProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingProduct (-1592)

#endif

/* prodml21__ProductVolumeBusinessSubUnit * has binding name 'PointerToprodml21__ProductVolumeBusinessSubUnit' for type 'prodml21:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBusinessSubUnit (-1590)

#endif

/* prodml21__OwnershipBusinessAcct * has binding name 'PointerToprodml21__OwnershipBusinessAcct' for type 'prodml21:OwnershipBusinessAcct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OwnershipBusinessAcct (-1589)

#endif

/* prodml21__ProductVolumeBalanceDetail * has binding name 'PointerToprodml21__ProductVolumeBalanceDetail' for type 'prodml21:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceDetail (-1587)

#endif

/* prodml21__ProductVolumeDestination * has binding name 'PointerToprodml21__ProductVolumeDestination' for type 'prodml21:ProductVolumeDestination' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeDestination (-1586)

#endif

/* prodml21__BalanceFlowPart * has binding name 'PointerToprodml21__BalanceFlowPart' for type 'prodml21:BalanceFlowPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BalanceFlowPart (-1585)

#endif

/* prodml21__ProductVolumeComponentContent * has binding name 'PointerToprodml21__ProductVolumeComponentContent' for type 'prodml21:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeComponentContent (-1583)

#endif

/* prodml21__ProductVolumeBalanceEvent * has binding name 'PointerToprodml21__ProductVolumeBalanceEvent' for type 'prodml21:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBalanceEvent (-1581)

#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerTobool
#define SOAP_TYPE_gsoap_eml2_2_PointerTobool (-1579)

#endif

/* prodml21__FacilityParent * has binding name 'PointerToprodml21__FacilityParent' for type 'prodml21:FacilityParent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FacilityParent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FacilityParent (-1577)

#endif

/* eml22__FlowRateValue * has binding name 'PointerToeml22__FlowRateValue' for type 'eml22:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__FlowRateValue (-1574)

#endif

/* eml22__DensityValue * has binding name 'PointerToeml22__DensityValue' for type 'eml22:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DensityValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DensityValue (-1572)

#endif

/* prodml21__ProductVolumePortDifference * has binding name 'PointerToprodml21__ProductVolumePortDifference' for type 'prodml21:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumePortDifference (-1570)

#endif

/* eml22__VolumeValue * has binding name 'PointerToeml22__VolumeValue' for type 'eml22:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumeValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumeValue (-1568)

#endif

/* eml22__EnergyPerVolumeMeasure * has binding name 'PointerToeml22__EnergyPerVolumeMeasure' for type 'eml22:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyPerVolumeMeasure (-1567)

#endif

/* eml22__IsothermalCompressibilityMeasure * has binding name 'PointerToeml22__IsothermalCompressibilityMeasure' for type 'eml22:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__IsothermalCompressibilityMeasure (-1566)

#endif

/* eml22__DimensionlessMeasure * has binding name 'PointerToeml22__DimensionlessMeasure' for type 'eml22:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DimensionlessMeasure (-1565)

#endif

/* eml22__AmountOfSubstanceMeasure * has binding name 'PointerToeml22__AmountOfSubstanceMeasure' for type 'eml22:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AmountOfSubstanceMeasure (-1564)

#endif

/* eml22__MolecularWeightMeasure * has binding name 'PointerToeml22__MolecularWeightMeasure' for type 'eml22:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolecularWeightMeasure (-1563)

#endif

/* eml22__MassPerTimeMeasure * has binding name 'PointerToeml22__MassPerTimeMeasure' for type 'eml22:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerTimeMeasure (-1562)

#endif

/* eml22__EnergyMeasure * has binding name 'PointerToeml22__EnergyMeasure' for type 'eml22:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__EnergyMeasure (-1561)

#endif

/* eml22__MassMeasure * has binding name 'PointerToeml22__MassMeasure' for type 'eml22:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassMeasure (-1560)

#endif

/* eml22__VolumePerVolumeMeasure * has binding name 'PointerToeml22__VolumePerVolumeMeasure' for type 'eml22:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumePerVolumeMeasure (-1559)

#endif

/* prodml21__ValueStatus * has binding name 'PointerToprodml21__ValueStatus' for type 'prodml21:ValueStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ValueStatus
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ValueStatus (-1558)

#endif

/* prodml21__ProductFlowNetworkPlan * has binding name 'PointerToprodml21__ProductFlowNetworkPlan' for type 'prodml21:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowNetworkPlan (-1556)

#endif

/* prodml21__ProductFlowExternalPort * has binding name 'PointerToprodml21__ProductFlowExternalPort' for type 'prodml21:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowExternalPort (-1554)

#endif

/* prodml21__ProductFlowUnit * has binding name 'PointerToprodml21__ProductFlowUnit' for type 'prodml21:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowUnit (-1552)

#endif

/* prodml21__ProductFlowChangeLog * has binding name 'PointerToprodml21__ProductFlowChangeLog' for type 'prodml21:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductFlowChangeLog (-1550)

#endif

/* prodml21__AddressQualifier * has binding name 'PointerToprodml21__AddressQualifier' for type 'prodml21:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AddressQualifier (-1549)

#endif

/* prodml21__NorthSeaOffshore * has binding name 'PointerToprodml21__NorthSeaOffshore' for type 'prodml21:NorthSeaOffshore' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NorthSeaOffshore (-1548)

#endif

/* prodml21__FluidComponent * has binding name 'PointerToprodml21__FluidComponent' for type 'prodml21:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponent (-1546)

#endif

/* prodml21__WellVerticalDepthCoord * has binding name 'PointerToprodml21__WellVerticalDepthCoord' for type 'prodml21:WellVerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__WellVerticalDepthCoord (-1545)

#endif

/* prodml21__MeasuredDepthCoord * has binding name 'PointerToprodml21__MeasuredDepthCoord' for type 'prodml21:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__MeasuredDepthCoord (-1544)

#endif

/* prodml21__GeologyType * has binding name 'PointerToprodml21__GeologyType' for type 'prodml21:GeologyType' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeologyType
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeologyType (-1543)

#endif

/* prodml21__OffshoreLocation * has binding name 'PointerToprodml21__OffshoreLocation' for type 'prodml21:OffshoreLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__OffshoreLocation (-1542)

#endif

/* prodml21__AddressKindEnum * has binding name 'PointerToprodml21__AddressKindEnum' for type 'prodml21:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AddressKindEnum (-1541)

#endif

/* prodml21__PlusFluidComponent * has binding name 'PointerToprodml21__PlusFluidComponent' for type 'prodml21:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PlusFluidComponent (-1539)

#endif

/* prodml21__PseudoFluidComponent * has binding name 'PointerToprodml21__PseudoFluidComponent' for type 'prodml21:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PseudoFluidComponent (-1537)

#endif

/* prodml21__PureFluidComponent * has binding name 'PointerToprodml21__PureFluidComponent' for type 'prodml21:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PureFluidComponent (-1535)

#endif

/* prodml21__FormationWater * has binding name 'PointerToprodml21__FormationWater' for type 'prodml21:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FormationWater
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FormationWater (-1533)

#endif

/* prodml21__NaturalGas * has binding name 'PointerToprodml21__NaturalGas' for type 'prodml21:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NaturalGas
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NaturalGas (-1531)

#endif

/* prodml21__StockTankOil * has binding name 'PointerToprodml21__StockTankOil' for type 'prodml21:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__StockTankOil
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__StockTankOil (-1529)

#endif

/* prodml21__ReportingFacility * has binding name 'PointerToprodml21__ReportingFacility' for type 'prodml21:ReportingFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReportingFacility (-1528)

#endif

/* prodml21__ProductVolumeBusinessUnit * has binding name 'PointerToprodml21__ProductVolumeBusinessUnit' for type 'prodml21:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ProductVolumeBusinessUnit (-1527)

#endif

/* prodml21__GeographicContext * has binding name 'PointerToprodml21__GeographicContext' for type 'prodml21:GeographicContext' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeographicContext
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeographicContext (-1526)

#endif

/* prodml21__BusinessAssociate * has binding name 'PointerToprodml21__BusinessAssociate' for type 'prodml21:BusinessAssociate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BusinessAssociate (-1525)

#endif

/* prodml21__FacilityIdentifierStruct * has binding name 'PointerToprodml21__FacilityIdentifierStruct' for type 'prodml21:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FacilityIdentifierStruct (-1524)

#endif

/* prodml21__EndpointQualifier * has binding name 'PointerToprodml21__EndpointQualifier' for type 'prodml21:EndpointQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EndpointQualifier (-1523)

#endif

/* std::string * has binding name 'PointerToeml22__UomEnum' for type 'eml22:UomEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__UomEnum
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__UomEnum (-1522)

#endif

/* prodml21__PersonName * has binding name 'PointerToprodml21__PersonName' for type 'prodml21:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PersonName
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PersonName (-1521)

#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_2_PointerToxsd__nonNegativeInteger (-1520)

#endif

/* prodml21__EmailQualifierStruct * has binding name 'PointerToprodml21__EmailQualifierStruct' for type 'prodml21:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__EmailQualifierStruct (-1518)

#endif

/* prodml21__PhoneNumberStruct * has binding name 'PointerToprodml21__PhoneNumberStruct' for type 'prodml21:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PhoneNumberStruct (-1516)

#endif

/* prodml21__GeneralAddress * has binding name 'PointerToprodml21__GeneralAddress' for type 'prodml21:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__GeneralAddress (-1515)

#endif

/* prodml21__NameStruct * has binding name 'PointerToprodml21__NameStruct' for type 'prodml21:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NameStruct
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__NameStruct (-1513)

#endif

/* eml22__AmountOfSubstancePerAmountOfSubstanceMeasure * has binding name 'PointerToeml22__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml22:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AmountOfSubstancePerAmountOfSubstanceMeasure (-1512)

#endif

/* eml22__MassPerMassMeasure * has binding name 'PointerToeml22__MassPerMassMeasure' for type 'eml22:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerMassMeasure (-1511)

#endif

/* std::string * has binding name 'PointerToprodml21__CalendarMonth' for type 'prodml21:CalendarMonth' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CalendarMonth (-1510)

#endif

/* std::string * has binding name 'PointerToxsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToxsd__date
#define SOAP_TYPE_gsoap_eml2_2_PointerToxsd__date (-1509)

#endif

/* struct tm * has binding name 'PointerToeml22__TimeStamp' for type 'eml22:TimeStamp' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeStamp
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__TimeStamp (-1508)

#endif

/* eml22__ThermodynamicTemperatureMeasureExt * has binding name 'PointerToeml22__ThermodynamicTemperatureMeasureExt' for type 'eml22:ThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperatureMeasureExt (-1507)

#endif

/* prodml21__PvtModelParameter * has binding name 'PointerToprodml21__PvtModelParameter' for type 'prodml21:PvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PvtModelParameter (-1505)

#endif

/* eml22__ReciprocalPressureMeasure * has binding name 'PointerToeml22__ReciprocalPressureMeasure' for type 'eml22:ReciprocalPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ReciprocalPressureMeasure (-1504)

#endif

/* eml22__APIGravityMeasure * has binding name 'PointerToeml22__APIGravityMeasure' for type 'eml22:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__APIGravityMeasure (-1503)

#endif

/* eml22__MassPerVolumeMeasure * has binding name 'PointerToeml22__MassPerVolumeMeasure' for type 'eml22:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MassPerVolumeMeasure (-1502)

#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerTodouble
#define SOAP_TYPE_gsoap_eml2_2_PointerTodouble (-1501)

#endif

/* eml22__MolarVolumeMeasure * has binding name 'PointerToeml22__MolarVolumeMeasure' for type 'eml22:MolarVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__MolarVolumeMeasure (-1500)

#endif

/* eml22__VolumeMeasure * has binding name 'PointerToeml22__VolumeMeasure' for type 'eml22:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__VolumeMeasure (-1499)

#endif

/* eml22__DynamicViscosityMeasure * has binding name 'PointerToeml22__DynamicViscosityMeasure' for type 'eml22:DynamicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DynamicViscosityMeasure (-1498)

#endif

/* eml22__PressureMeasure * has binding name 'PointerToeml22__PressureMeasure' for type 'eml22:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__PressureMeasure (-1497)

#endif

/* prodml21__FluidCharacterizationTableFormat * has binding name 'PointerToprodml21__FluidCharacterizationTableFormat' for type 'prodml21:FluidCharacterizationTableFormat' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableFormat
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableFormat (-1495)

#endif

/* prodml21__FluidCharacterizationTableColumn * has binding name 'PointerToprodml21__FluidCharacterizationTableColumn' for type 'prodml21:FluidCharacterizationTableColumn' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableColumn
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableColumn (-1493)

#endif

/* prodml21__TableDelimiter * has binding name 'PointerToprodml21__TableDelimiter' for type 'prodml21:TableDelimiter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TableDelimiter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__TableDelimiter (-1492)

#endif

/* LONG64 * has binding name 'PointerToeml22__NonNegativeLong' for type 'eml22:NonNegativeLong' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__NonNegativeLong
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__NonNegativeLong (-1491)

#endif

/* prodml21__FluidCharacterizationTableRow * has binding name 'PointerToprodml21__FluidCharacterizationTableRow' for type 'prodml21:FluidCharacterizationTableRow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableRow
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTableRow (-1489)

#endif

/* eml22__DataObjectReference * has binding name 'PointerToeml22__DataObjectReference' for type 'eml22:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__DataObjectReference (-1488)

#endif

/* prodml21__FluidCharacterizationParameter * has binding name 'PointerToprodml21__FluidCharacterizationParameter' for type 'prodml21:FluidCharacterizationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationParameter (-1486)

#endif

/* prodml21__ThermodynamicPhase * has binding name 'PointerToprodml21__ThermodynamicPhase' for type 'prodml21:ThermodynamicPhase' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ThermodynamicPhase
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ThermodynamicPhase (-1485)

#endif

/* eml22__ObjectAlias * has binding name 'PointerToeml22__ObjectAlias' for type 'eml22:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ObjectAlias (-1483)

#endif

/* prodml21__FluidCharacterizationParameterSet * has binding name 'PointerToprodml21__FluidCharacterizationParameterSet' for type 'prodml21:FluidCharacterizationParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationParameterSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationParameterSet (-1482)

#endif

/* prodml21__ReferenceSeparatorStage * has binding name 'PointerToprodml21__ReferenceSeparatorStage' for type 'prodml21:ReferenceSeparatorStage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReferenceSeparatorStage
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__ReferenceSeparatorStage (-1480)

#endif

/* prodml21__FluidCharacterizationTable * has binding name 'PointerToprodml21__FluidCharacterizationTable' for type 'prodml21:FluidCharacterizationTable' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTable
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidCharacterizationTable (-1478)

#endif

/* prodml21__AbstractPvtModel * has binding name 'PointerToprodml21__AbstractPvtModel' for type 'prodml21:AbstractPvtModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPvtModel
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__AbstractPvtModel (-1477)

#endif

/* eml22__ThermodynamicTemperatureMeasure * has binding name 'PointerToeml22__ThermodynamicTemperatureMeasure' for type 'eml22:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ThermodynamicTemperatureMeasure (-1476)

#endif

/* eml22__AbstractPressureValue * has binding name 'PointerToeml22__AbstractPressureValue' for type 'eml22:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__AbstractPressureValue (-1475)

#endif

/* eml22__ExtensionNameValue * has binding name 'PointerToeml22__ExtensionNameValue' for type 'eml22:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__ExtensionNameValue (-1474)

#endif

/* prodml21__CustomPvtModelParameter * has binding name 'PointerToprodml21__CustomPvtModelParameter' for type 'prodml21:CustomPvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomPvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomPvtModelParameter (-1472)

#endif

/* std::string * has binding name 'PointerToeml22__String2000' for type 'eml22:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__String2000
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__String2000 (-1471)

#endif

/* prodml21__FluidComponentProperty * has binding name 'PointerToprodml21__FluidComponentProperty' for type 'prodml21:FluidComponentProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponentProperty
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__FluidComponentProperty (-1469)

#endif

/* prodml21__BinaryInteractionCoefficient * has binding name 'PointerToprodml21__BinaryInteractionCoefficient' for type 'prodml21:BinaryInteractionCoefficient' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BinaryInteractionCoefficient
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__BinaryInteractionCoefficient (-1467)

#endif

/* std::string * has binding name 'PointerToeml22__String64' for type 'eml22:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToeml22__String64
#define SOAP_TYPE_gsoap_eml2_2_PointerToeml22__String64 (-1466)

#endif

/* prodml21__PvtModelParameterSet * has binding name 'PointerToprodml21__PvtModelParameterSet' for type 'prodml21:PvtModelParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PvtModelParameterSet
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__PvtModelParameterSet (-1463)

#endif

/* prodml21__CustomPvtModelExtension * has binding name 'PointerToprodml21__CustomPvtModelExtension' for type 'prodml21:CustomPvtModelExtension' */
#ifndef SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomPvtModelExtension
#define SOAP_TYPE_gsoap_eml2_2_PointerToprodml21__CustomPvtModelExtension (-1462)

#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_gsoap_eml2_2__QName
#define SOAP_TYPE_gsoap_eml2_2__QName (-6)

#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2__XML
#define SOAP_TYPE_gsoap_eml2_2__XML (-5)

#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_2_string
#define SOAP_TYPE_gsoap_eml2_2_string (-4)

#endif

/* std::vector<eml22__IntegerConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml22__IntegerConstantArray' for type 'eml22:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__IntegerConstantArray (-2067)

#endif

/* std::vector<eml22__FloatingPointConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml22__FloatingPointConstantArray' for type 'eml22:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FloatingPointConstantArray (-2064)

#endif

/* std::vector<prodml21__PrsvParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PrsvParameter' for type 'prodml21:PrsvParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PrsvParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PrsvParameter (-2062)

#endif

/* std::vector<prodml21__ReservoirZoneSubModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ReservoirZoneSubModel' for type 'prodml21:ReservoirZoneSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReservoirZoneSubModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReservoirZoneSubModel (-2054)

#endif

/* std::vector<prodml21__InternalFaultSubModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__InternalFaultSubModel' for type 'prodml21:InternalFaultSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InternalFaultSubModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InternalFaultSubModel (-2051)

#endif

/* std::vector<prodml21__SingleBoundarySubModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SingleBoundarySubModel' for type 'prodml21:SingleBoundarySubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SingleBoundarySubModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SingleBoundarySubModel (-2049)

#endif

/* std::vector<prodml21__SingleFractureSubModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SingleFractureSubModel' for type 'prodml21:SingleFractureSubModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SingleFractureSubModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SingleFractureSubModel (-2041)

#endif

/* std::vector<prodml21__FlowTestMeasurementSet *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FlowTestMeasurementSet' for type 'prodml21:FlowTestMeasurementSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FlowTestMeasurementSet
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FlowTestMeasurementSet (-2013)

#endif

/* std::vector<prodml21__ProductionWellPeriod *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductionWellPeriod' for type 'prodml21:ProductionWellPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductionWellPeriod
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductionWellPeriod (-2011)

#endif

/* std::vector<prodml21__ProductFluid *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFluid' for type 'prodml21:ProductFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFluid
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFluid (-2008)

#endif

/* std::vector<prodml21__ProductionWellTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductionWellTest' for type 'prodml21:ProductionWellTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductionWellTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductionWellTest (-2006)

#endif

/* std::vector<prodml21__ReportingEntityVolumes *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ReportingEntityVolumes' for type 'prodml21:ReportingEntityVolumes' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportingEntityVolumes
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportingEntityVolumes (-2005)

#endif

/* std::vector<prodml21__WaterSampleComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WaterSampleComponent' for type 'prodml21:WaterSampleComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterSampleComponent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterSampleComponent (-2003)

#endif

/* std::vector<prodml21__WaterAnalysisTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WaterAnalysisTest' for type 'prodml21:WaterAnalysisTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterAnalysisTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterAnalysisTest (-2001)

#endif

/* std::vector<prodml21__InterfacialTensionTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__InterfacialTensionTest' for type 'prodml21:InterfacialTensionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterfacialTensionTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterfacialTensionTest (-1999)

#endif

/* std::vector<prodml21__STOAnalysis *>  has binding name 'std__vectorTemplateOfPointerToprodml21__STOAnalysis' for type 'prodml21:STOAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__STOAnalysis
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__STOAnalysis (-1997)

#endif

/* std::vector<prodml21__MultipleContactMiscibilityTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__MultipleContactMiscibilityTest' for type 'prodml21:MultipleContactMiscibilityTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__MultipleContactMiscibilityTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__MultipleContactMiscibilityTest (-1995)

#endif

/* std::vector<prodml21__SlimTubeTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SlimTubeTest' for type 'prodml21:SlimTubeTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTest (-1993)

#endif

/* std::vector<prodml21__SwellingTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SwellingTest' for type 'prodml21:SwellingTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SwellingTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SwellingTest (-1991)

#endif

/* std::vector<prodml21__VaporLiquidEquilibriumTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__VaporLiquidEquilibriumTest' for type 'prodml21:VaporLiquidEquilibriumTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__VaporLiquidEquilibriumTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__VaporLiquidEquilibriumTest (-1989)

#endif

/* std::vector<prodml21__OtherMeasurementTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__OtherMeasurementTest' for type 'prodml21:OtherMeasurementTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherMeasurementTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherMeasurementTest (-1987)

#endif

/* std::vector<prodml21__FluidSeparatorTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidSeparatorTest' for type 'prodml21:FluidSeparatorTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSeparatorTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSeparatorTest (-1985)

#endif

/* std::vector<prodml21__ConstantVolumeDepletionTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ConstantVolumeDepletionTest' for type 'prodml21:ConstantVolumeDepletionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantVolumeDepletionTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantVolumeDepletionTest (-1983)

#endif

/* std::vector<prodml21__DifferentialLiberationTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__DifferentialLiberationTest' for type 'prodml21:DifferentialLiberationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DifferentialLiberationTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DifferentialLiberationTest (-1981)

#endif

/* std::vector<prodml21__SaturationTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SaturationTest' for type 'prodml21:SaturationTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SaturationTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SaturationTest (-1979)

#endif

/* std::vector<prodml21__ConstantCompositionExpansionTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTest' for type 'prodml21:ConstantCompositionExpansionTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTest (-1977)

#endif

/* std::vector<prodml21__AtmosphericFlashTestAndCompositionalAnalysis *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis' for type 'prodml21:AtmosphericFlashTestAndCompositionalAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AtmosphericFlashTestAndCompositionalAnalysis (-1975)

#endif

/* std::vector<eml22__AbstractGraphicalInformation *>  has binding name 'std__vectorTemplateOfPointerToeml22__AbstractGraphicalInformation' for type 'eml22:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractGraphicalInformation (-1971)

#endif

/* std::vector<eml22__FailingRule *>  has binding name 'std__vectorTemplateOfPointerToeml22__FailingRule' for type 'eml22:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FailingRule
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FailingRule (-1969)

#endif

/* std::vector<eml22__ParameterTemplate *>  has binding name 'std__vectorTemplateOfPointerToeml22__ParameterTemplate' for type 'eml22:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ParameterTemplate (-1952)

#endif

/* std::vector<eml22__GeologicTime *>  has binding name 'std__vectorTemplateOfPointerToeml22__GeologicTime' for type 'eml22:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__GeologicTime
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__GeologicTime (-1949)

#endif

/* std::vector<eml22__PropertyKind *>  has binding name 'std__vectorTemplateOfPointerToeml22__PropertyKind' for type 'eml22:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__PropertyKind
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__PropertyKind (-1947)

#endif

/* std::vector<prodml21__AbstractValue *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractValue' for type 'prodml21:AbstractValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractValue (-1943)

#endif

/* std::vector<prodml21__KeywordValueStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__KeywordValueStruct' for type 'prodml21:KeywordValueStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__KeywordValueStruct (-1941)

#endif

/* std::vector<prodml21__AbstractDeconvolutionOutput *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractDeconvolutionOutput' for type 'prodml21:AbstractDeconvolutionOutput' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractDeconvolutionOutput
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractDeconvolutionOutput (-1908)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfprodml21__DataConditioningExt' for type 'prodml21:DataConditioningExt' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfprodml21__DataConditioningExt
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfprodml21__DataConditioningExt (-1905)

#endif

/* std::vector<prodml21__SpecializedAnalysis *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SpecializedAnalysis' for type 'prodml21:SpecializedAnalysis' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SpecializedAnalysis
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SpecializedAnalysis (-1903)

#endif

/* std::vector<prodml21__InterferingFlowTestInterval *>  has binding name 'std__vectorTemplateOfPointerToprodml21__InterferingFlowTestInterval' for type 'prodml21:InterferingFlowTestInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterferingFlowTestInterval
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterferingFlowTestInterval (-1898)

#endif

/* std::vector<prodml21__LayerModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__LayerModel' for type 'prodml21:LayerModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LayerModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LayerModel (-1894)

#endif

/* std::vector<prodml21__Channel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__Channel' for type 'prodml21:Channel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Channel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Channel (-1890)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfstd__string
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfstd__string (-1888)

#endif

/* std::vector<prodml21__WftStation *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftStation' for type 'prodml21:WftStation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftStation
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftStation (-1884)

#endif

/* std::vector<prodml21__FluidSampleAcquisition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidSampleAcquisition' for type 'prodml21:FluidSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleAcquisition (-1882)

#endif

/* std::vector<prodml21__FluidSampleComposition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidSampleComposition' for type 'prodml21:FluidSampleComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleComposition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleComposition (-1878)

#endif

/* std::vector<prodml21__FluidSampleChainofCustodyEvent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidSampleChainofCustodyEvent' for type 'prodml21:FluidSampleChainofCustodyEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleChainofCustodyEvent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSampleChainofCustodyEvent (-1876)

#endif

/* std::vector<prodml21__FluidAnalysisReport *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidAnalysisReport' for type 'prodml21:FluidAnalysisReport' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidAnalysisReport
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidAnalysisReport (-1872)

#endif

/* std::vector<prodml21__SampleContaminant *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SampleContaminant' for type 'prodml21:SampleContaminant' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SampleContaminant
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SampleContaminant (-1870)

#endif

/* std::vector<prodml21__FlowQualifier>  has binding name 'std__vectorTemplateOfprodml21__FlowQualifier' for type 'prodml21:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfprodml21__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfprodml21__FlowQualifier (-1867)

#endif

/* std::vector<prodml21__ProductFlowExternalReference *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowExternalReference' for type 'prodml21:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExternalReference (-1866)

#endif

/* std::vector<prodml21__ProductFlowNetwork *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowNetwork' for type 'prodml21:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowNetwork (-1864)

#endif

/* std::vector<prodml21__ProductVolumeBusinessUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessUnit' for type 'prodml21:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessUnit (-1861)

#endif

/* std::vector<prodml21__ProductVolumeFacility *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeFacility' for type 'prodml21:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeFacility (-1860)

#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfdouble
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfdouble (-1854)

#endif

/* std::vector<LONG64>  has binding name 'std__vectorTemplateOfeml22__PositiveLong' for type 'eml22:PositiveLong' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__PositiveLong
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__PositiveLong (-1853)

#endif

/* std::vector<prodml21__FluidCharacterizationModel *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationModel' for type 'prodml21:FluidCharacterizationModel' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationModel
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationModel (-1851)

#endif

/* std::vector<prodml21__FluidCharacterizationSource *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationSource' for type 'prodml21:FluidCharacterizationSource' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationSource
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationSource (-1849)

#endif

/* std::vector<prodml21__ApplicationInfo *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ApplicationInfo' for type 'prodml21:ApplicationInfo' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ApplicationInfo
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ApplicationInfo (-1847)

#endif

/* std::vector<eml22__AbstractActivityParameter *>  has binding name 'std__vectorTemplateOfPointerToeml22__AbstractActivityParameter' for type 'eml22:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractActivityParameter (-1830)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml22__String2000' for type 'eml22:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__String2000
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__String2000 (-1828)

#endif

/* std::vector<eml22__ActivityParameterKind>  has binding name 'std__vectorTemplateOfeml22__ActivityParameterKind' for type 'eml22:ActivityParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__ActivityParameterKind
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__ActivityParameterKind (-1827)

#endif

/* std::vector<eml22__AbstractParameterKey *>  has binding name 'std__vectorTemplateOfPointerToeml22__AbstractParameterKey' for type 'eml22:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__AbstractParameterKey (-1826)

#endif

/* std::vector<eml22__ExternalDatasetPart *>  has binding name 'std__vectorTemplateOfPointerToeml22__ExternalDatasetPart' for type 'eml22:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ExternalDatasetPart (-1824)

#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf_XML
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf_XML (-1816)

#endif

/* std::vector<eml22__ExtensionNameValue *>  has binding name 'std__vectorTemplateOfPointerToeml22__ExtensionNameValue' for type 'eml22:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ExtensionNameValue (-1814)

#endif

/* std::vector<prodml21__ReportingHierarchyNode *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ReportingHierarchyNode' for type 'prodml21:ReportingHierarchyNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportingHierarchyNode
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportingHierarchyNode (-1811)

#endif

/* std::vector<prodml21__CustomParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__CustomParameter' for type 'prodml21:CustomParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CustomParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CustomParameter (-1809)

#endif

/* std::vector<prodml21__AbstractParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractParameter' for type 'prodml21:AbstractParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractParameter (-1807)

#endif

/* std::vector<struct __prodml21__SingleFractureSubModel_sequence>  has binding name 'std__vectorTemplateOf__prodml21__SingleFractureSubModel_sequence' for type '-prodml21:SingleFractureSubModel-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__SingleFractureSubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__SingleFractureSubModel_sequence (-1805)

#endif

/* std::vector<struct __prodml21__SingleBoundarySubModel_sequence>  has binding name 'std__vectorTemplateOf__prodml21__SingleBoundarySubModel_sequence' for type '-prodml21:SingleBoundarySubModel-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__SingleBoundarySubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__SingleBoundarySubModel_sequence (-1799)

#endif

/* std::vector<prodml21__LocationIn2D *>  has binding name 'std__vectorTemplateOfPointerToprodml21__LocationIn2D' for type 'prodml21:LocationIn2D' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LocationIn2D
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LocationIn2D (-1794)

#endif

/* std::vector<struct __prodml21__LogLogAnalysis_sequence>  has binding name 'std__vectorTemplateOf__prodml21__LogLogAnalysis_sequence' for type '-prodml21:LogLogAnalysis-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__LogLogAnalysis_sequence
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__LogLogAnalysis_sequence (-1792)

#endif

/* std::vector<prodml21__AnalysisLine *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AnalysisLine' for type 'prodml21:AnalysisLine' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AnalysisLine
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AnalysisLine (-1791)

#endif

/* std::vector<prodml21__LayerToLayerConnection *>  has binding name 'std__vectorTemplateOfPointerToprodml21__LayerToLayerConnection' for type 'prodml21:LayerToLayerConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LayerToLayerConnection
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LayerToLayerConnection (-1786)

#endif

/* std::vector<struct __prodml21__InternalFaultSubModel_sequence>  has binding name 'std__vectorTemplateOf__prodml21__InternalFaultSubModel_sequence' for type '-prodml21:InternalFaultSubModel-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__InternalFaultSubModel_sequence
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOf__prodml21__InternalFaultSubModel_sequence (-1778)

#endif

/* std::vector<prodml21__MeasuredPressureData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__MeasuredPressureData' for type 'prodml21:MeasuredPressureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__MeasuredPressureData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__MeasuredPressureData (-1769)

#endif

/* std::vector<prodml21__AbstractPtaFlowData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractPtaFlowData' for type 'prodml21:AbstractPtaFlowData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractPtaFlowData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractPtaFlowData (-1767)

#endif

/* std::vector<prodml21__OtherData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__OtherData' for type 'prodml21:OtherData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherData (-1765)

#endif

/* std::vector<prodml21__AbstractFlowTestData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractFlowTestData' for type 'prodml21:AbstractFlowTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractFlowTestData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractFlowTestData (-1763)

#endif

/* std::vector<prodml21__DeferredProductionEvent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__DeferredProductionEvent' for type 'prodml21:DeferredProductionEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DeferredProductionEvent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DeferredProductionEvent (-1755)

#endif

/* std::vector<prodml21__AbstractDisposition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractDisposition' for type 'prodml21:AbstractDisposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractDisposition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractDisposition (-1753)

#endif

/* std::vector<prodml21__Injection *>  has binding name 'std__vectorTemplateOfPointerToprodml21__Injection' for type 'prodml21:Injection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Injection
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Injection (-1751)

#endif

/* std::vector<prodml21__Production *>  has binding name 'std__vectorTemplateOfPointerToprodml21__Production' for type 'prodml21:Production' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Production
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Production (-1749)

#endif

/* std::vector<prodml21__TestPeriod *>  has binding name 'std__vectorTemplateOfPointerToprodml21__TestPeriod' for type 'prodml21:TestPeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__TestPeriod
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__TestPeriod (-1747)

#endif

/* std::vector<prodml21__ProductRate *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductRate' for type 'prodml21:ProductRate' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductRate
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductRate (-1745)

#endif

/* std::vector<prodml21__DeferredProductionVolume *>  has binding name 'std__vectorTemplateOfPointerToprodml21__DeferredProductionVolume' for type 'prodml21:DeferredProductionVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DeferredProductionVolume
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DeferredProductionVolume (-1742)

#endif

/* std::vector<prodml21__AbstractProductQuantity *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractProductQuantity' for type 'prodml21:AbstractProductQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractProductQuantity
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractProductQuantity (-1738)

#endif

/* std::vector<prodml21__WftResultReference *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftResultReference' for type 'prodml21:WftResultReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftResultReference
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftResultReference (-1735)

#endif

/* std::vector<prodml21__WftCurveSection *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftCurveSection' for type 'prodml21:WftCurveSection' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftCurveSection
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftCurveSection (-1733)

#endif

/* std::vector<prodml21__WftInOutParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftInOutParameter' for type 'prodml21:WftInOutParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftInOutParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftInOutParameter (-1731)

#endif

/* std::vector<prodml21__WftTest *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftTest' for type 'prodml21:WftTest' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTest
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTest (-1729)

#endif

/* std::vector<prodml21__WftSampleAcquisition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftSampleAcquisition' for type 'prodml21:WftSampleAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftSampleAcquisition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftSampleAcquisition (-1727)

#endif

/* std::vector<prodml21__WftEvent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftEvent' for type 'prodml21:WftEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftEvent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftEvent (-1725)

#endif

/* std::vector<eml22__DataObjectReference *>  has binding name 'std__vectorTemplateOfPointerToeml22__DataObjectReference' for type 'eml22:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__DataObjectReference (-1723)

#endif

/* std::vector<prodml21__WftTestData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftTestData' for type 'prodml21:WftTestData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTestData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTestData (-1722)

#endif

/* std::vector<prodml21__WftTestResult *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WftTestResult' for type 'prodml21:WftTestResult' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTestResult
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WftTestResult (-1720)

#endif

/* std::vector<prodml21__WaterAnalysisTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__WaterAnalysisTestStep' for type 'prodml21:WaterAnalysisTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterAnalysisTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__WaterAnalysisTestStep (-1709)

#endif

/* std::vector<prodml21__LiquidComposition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__LiquidComposition' for type 'prodml21:LiquidComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__LiquidComposition (-1706)

#endif

/* std::vector<prodml21__PhaseDensity *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PhaseDensity' for type 'prodml21:PhaseDensity' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PhaseDensity
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PhaseDensity (-1705)

#endif

/* std::vector<prodml21__RefInjectedGasAdded *>  has binding name 'std__vectorTemplateOfPointerToprodml21__RefInjectedGasAdded' for type 'prodml21:RefInjectedGasAdded' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__RefInjectedGasAdded
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__RefInjectedGasAdded (-1702)

#endif

/* std::vector<prodml21__SwellingTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SwellingTestStep' for type 'prodml21:SwellingTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SwellingTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SwellingTestStep (-1700)

#endif

/* std::vector<prodml21__Sara *>  has binding name 'std__vectorTemplateOfPointerToprodml21__Sara' for type 'prodml21:Sara' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Sara
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__Sara (-1698)

#endif

/* std::vector<prodml21__ViscosityAtTemperature *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ViscosityAtTemperature' for type 'prodml21:ViscosityAtTemperature' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ViscosityAtTemperature
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ViscosityAtTemperature (-1696)

#endif

/* std::vector<prodml21__SlimTubeTestVolumeStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SlimTubeTestVolumeStep' for type 'prodml21:SlimTubeTestVolumeStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTestVolumeStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTestVolumeStep (-1689)

#endif

/* std::vector<prodml21__SlimTubeTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SlimTubeTestStep' for type 'prodml21:SlimTubeTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeTestStep (-1687)

#endif

/* std::vector<prodml21__SlimTubeSpecification *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SlimTubeSpecification' for type 'prodml21:SlimTubeSpecification' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeSpecification
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SlimTubeSpecification (-1685)

#endif

/* std::vector<prodml21__InjectedGas *>  has binding name 'std__vectorTemplateOfPointerToprodml21__InjectedGas' for type 'prodml21:InjectedGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InjectedGas
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InjectedGas (-1683)

#endif

/* std::vector<prodml21__SampleRestoration *>  has binding name 'std__vectorTemplateOfPointerToprodml21__SampleRestoration' for type 'prodml21:SampleRestoration' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SampleRestoration
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__SampleRestoration (-1679)

#endif

/* std::vector<prodml21__OtherMeasurementTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__OtherMeasurementTestStep' for type 'prodml21:OtherMeasurementTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherMeasurementTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__OtherMeasurementTestStep (-1676)

#endif

/* std::vector<prodml21__InterfacialTensionTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__InterfacialTensionTestStep' for type 'prodml21:InterfacialTensionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterfacialTensionTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__InterfacialTensionTestStep (-1670)

#endif

/* std::vector<prodml21__VaporComposition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__VaporComposition' for type 'prodml21:VaporComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__VaporComposition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__VaporComposition (-1667)

#endif

/* std::vector<prodml21__FluidSeparatorTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidSeparatorTestStep' for type 'prodml21:FluidSeparatorTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSeparatorTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidSeparatorTestStep (-1666)

#endif

/* std::vector<prodml21__ReportLocation *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ReportLocation' for type 'prodml21:ReportLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportLocation
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReportLocation (-1664)

#endif

/* std::vector<prodml21__FluidDifferentialLiberationTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidDifferentialLiberationTestStep' for type 'prodml21:FluidDifferentialLiberationTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidDifferentialLiberationTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidDifferentialLiberationTestStep (-1662)

#endif

/* std::vector<prodml21__FluidCvdTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCvdTestStep' for type 'prodml21:FluidCvdTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCvdTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCvdTestStep (-1659)

#endif

/* std::vector<prodml21__ConstantCompositionExpansionTestStep *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTestStep' for type 'prodml21:ConstantCompositionExpansionTestStep' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTestStep
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConstantCompositionExpansionTestStep (-1651)

#endif

/* std::vector<prodml21__FluidVolumeReference *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidVolumeReference' for type 'prodml21:FluidVolumeReference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidVolumeReference
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidVolumeReference (-1649)

#endif

/* std::vector<prodml21__ProductFlowPort *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowPort' for type 'prodml21:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowPort (-1642)

#endif

/* std::vector<prodml21__FacilityIdentifierStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FacilityIdentifierStruct' for type 'prodml21:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FacilityIdentifierStruct (-1639)

#endif

/* std::vector<prodml21__ProductFlowExpectedUnitProperty *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowExpectedUnitProperty' for type 'prodml21:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExpectedUnitProperty (-1638)

#endif

/* std::vector<prodml21__ConnectedNode *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ConnectedNode' for type 'prodml21:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ConnectedNode (-1636)

#endif

/* std::vector<prodml21__ProductFlowQualifierExpected *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowQualifierExpected' for type 'prodml21:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowQualifierExpected (-1634)

#endif

/* std::vector<prodml21__ProductVolumePeriod *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumePeriod' for type 'prodml21:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumePeriod (-1628)

#endif

/* std::vector<prodml21__ProductVolumeBalanceSet *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceSet' for type 'prodml21:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceSet (-1622)

#endif

/* std::vector<prodml21__AbstractMeasureData *>  has binding name 'std__vectorTemplateOfPointerToprodml21__AbstractMeasureData' for type 'prodml21:AbstractMeasureData' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractMeasureData
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__AbstractMeasureData (-1619)

#endif

/* std::vector<prodml21__CurveDefinition *>  has binding name 'std__vectorTemplateOfPointerToprodml21__CurveDefinition' for type 'prodml21:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CurveDefinition (-1617)

#endif

/* std::vector<prodml21__ProductVolumeParameterValue *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterValue' for type 'prodml21:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterValue (-1615)

#endif

/* std::vector<prodml21__ProductVolumeProduct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeProduct' for type 'prodml21:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeProduct (-1609)

#endif

/* std::vector<prodml21__DatedComment *>  has binding name 'std__vectorTemplateOfPointerToprodml21__DatedComment' for type 'prodml21:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DatedComment
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__DatedComment (-1604)

#endif

/* std::vector<prodml21__ProductVolumeParameterSet *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterSet' for type 'prodml21:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeParameterSet (-1602)

#endif

/* std::vector<prodml21__ProductVolumeFlow *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeFlow' for type 'prodml21:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeFlow (-1600)

#endif

/* std::vector<prodml21__ProductVolumeBusinessSubUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessSubUnit' for type 'prodml21:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBusinessSubUnit (-1591)

#endif

/* std::vector<prodml21__ProductVolumeBalanceDetail *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceDetail' for type 'prodml21:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceDetail (-1588)

#endif

/* std::vector<prodml21__ProductVolumeComponentContent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeComponentContent' for type 'prodml21:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeComponentContent (-1584)

#endif

/* std::vector<prodml21__ProductVolumeBalanceEvent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceEvent' for type 'prodml21:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumeBalanceEvent (-1582)

#endif

/* std::vector<eml22__FlowRateValue *>  has binding name 'std__vectorTemplateOfPointerToeml22__FlowRateValue' for type 'eml22:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__FlowRateValue (-1575)

#endif

/* std::vector<eml22__DensityValue *>  has binding name 'std__vectorTemplateOfPointerToeml22__DensityValue' for type 'eml22:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__DensityValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__DensityValue (-1573)

#endif

/* std::vector<prodml21__ProductVolumePortDifference *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductVolumePortDifference' for type 'prodml21:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductVolumePortDifference (-1571)

#endif

/* std::vector<eml22__VolumeValue *>  has binding name 'std__vectorTemplateOfPointerToeml22__VolumeValue' for type 'eml22:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__VolumeValue
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__VolumeValue (-1569)

#endif

/* std::vector<prodml21__ProductFlowNetworkPlan *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowNetworkPlan' for type 'prodml21:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowNetworkPlan (-1557)

#endif

/* std::vector<prodml21__ProductFlowExternalPort *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowExternalPort' for type 'prodml21:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowExternalPort (-1555)

#endif

/* std::vector<prodml21__ProductFlowUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowUnit' for type 'prodml21:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowUnit (-1553)

#endif

/* std::vector<prodml21__ProductFlowChangeLog *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ProductFlowChangeLog' for type 'prodml21:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ProductFlowChangeLog (-1551)

#endif

/* std::vector<prodml21__FluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidComponent' for type 'prodml21:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidComponent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidComponent (-1547)

#endif

/* std::vector<prodml21__PlusFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PlusFluidComponent' for type 'prodml21:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PlusFluidComponent (-1540)

#endif

/* std::vector<prodml21__PseudoFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PseudoFluidComponent' for type 'prodml21:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PseudoFluidComponent (-1538)

#endif

/* std::vector<prodml21__PureFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PureFluidComponent' for type 'prodml21:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PureFluidComponent (-1536)

#endif

/* std::vector<prodml21__FormationWater *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FormationWater' for type 'prodml21:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FormationWater
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FormationWater (-1534)

#endif

/* std::vector<prodml21__NaturalGas *>  has binding name 'std__vectorTemplateOfPointerToprodml21__NaturalGas' for type 'prodml21:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__NaturalGas
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__NaturalGas (-1532)

#endif

/* std::vector<prodml21__StockTankOil *>  has binding name 'std__vectorTemplateOfPointerToprodml21__StockTankOil' for type 'prodml21:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__StockTankOil
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__StockTankOil (-1530)

#endif

/* std::vector<prodml21__EmailQualifierStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__EmailQualifierStruct' for type 'prodml21:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__EmailQualifierStruct (-1519)

#endif

/* std::vector<prodml21__PhoneNumberStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PhoneNumberStruct' for type 'prodml21:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PhoneNumberStruct (-1517)

#endif

/* std::vector<prodml21__NameStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml21__NameStruct' for type 'prodml21:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__NameStruct
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__NameStruct (-1514)

#endif

/* std::vector<prodml21__PvtModelParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__PvtModelParameter' for type 'prodml21:PvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__PvtModelParameter (-1506)

#endif

/* std::vector<prodml21__FluidCharacterizationTableFormat *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableFormat' for type 'prodml21:FluidCharacterizationTableFormat' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableFormat
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableFormat (-1496)

#endif

/* std::vector<prodml21__FluidCharacterizationTableColumn *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableColumn' for type 'prodml21:FluidCharacterizationTableColumn' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableColumn
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableColumn (-1494)

#endif

/* std::vector<prodml21__FluidCharacterizationTableRow *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableRow' for type 'prodml21:FluidCharacterizationTableRow' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableRow
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTableRow (-1490)

#endif

/* std::vector<prodml21__FluidCharacterizationParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationParameter' for type 'prodml21:FluidCharacterizationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationParameter (-1487)

#endif

/* std::vector<eml22__ObjectAlias *>  has binding name 'std__vectorTemplateOfPointerToeml22__ObjectAlias' for type 'eml22:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToeml22__ObjectAlias (-1484)

#endif

/* std::vector<prodml21__ReferenceSeparatorStage *>  has binding name 'std__vectorTemplateOfPointerToprodml21__ReferenceSeparatorStage' for type 'prodml21:ReferenceSeparatorStage' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReferenceSeparatorStage
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__ReferenceSeparatorStage (-1481)

#endif

/* std::vector<prodml21__FluidCharacterizationTable *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTable' for type 'prodml21:FluidCharacterizationTable' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTable
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidCharacterizationTable (-1479)

#endif

/* std::vector<prodml21__CustomPvtModelParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml21__CustomPvtModelParameter' for type 'prodml21:CustomPvtModelParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CustomPvtModelParameter
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__CustomPvtModelParameter (-1473)

#endif

/* std::vector<prodml21__FluidComponentProperty *>  has binding name 'std__vectorTemplateOfPointerToprodml21__FluidComponentProperty' for type 'prodml21:FluidComponentProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidComponentProperty
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__FluidComponentProperty (-1470)

#endif

/* std::vector<prodml21__BinaryInteractionCoefficient *>  has binding name 'std__vectorTemplateOfPointerToprodml21__BinaryInteractionCoefficient' for type 'prodml21:BinaryInteractionCoefficient' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__BinaryInteractionCoefficient
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfPointerToprodml21__BinaryInteractionCoefficient (-1468)

#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml22__String64' for type 'eml22:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__String64
#define SOAP_TYPE_gsoap_eml2_2_std__vectorTemplateOfeml22__String64 (-1465)

#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_eml2_2


#endif

/* End of gsoap_eml2_2Stub.h */
