/* gsoap_uom1_0C.cpp
   Generated by gSOAP 2.8.127E for uom1_0ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use and protected by law.
**  REDISTRIBUTION, RESALE OR ANY OTHER FORM OF SHARING IS STRICTLY PROHIBITED.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "gsoap_uom1_0H.h"

#if defined(__clang__)
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic ignored "-Wcast-qual"
#elif defined(_MSC_VER)
#pragma warning(disable : 4706) /* assignment within conditional expression */
#pragma warning(disable : 4458) /* declaration hides class member */
#endif

namespace gsoap_uom1_0 {

SOAP_SOURCE_STAMP("@(#) gsoap_uom1_0C.cpp ver 2.8.127E 2024-08-15 16:42:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_gsoap_uom1_0_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_gsoap_uom1_0_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, tag, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_gsoap_uom1_0_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_gsoap_uom1_0_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_gsoap_uom1_0_uom10__zero:
		return soap_in_uom10__zero(soap, tag, NULL, "uom10:zero");
	case SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum:
		return soap_in_uom10__stateEnum(soap, tag, NULL, "uom10:stateEnum");
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		return soap_in_uom10__commentString(soap, tag, NULL, "uom10:commentString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		return soap_in_uom10__descriptionString(soap, tag, NULL, "uom10:descriptionString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		return soap_in_uom10__nameString(soap, tag, NULL, "uom10:nameString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		return soap_in_uom10__symbolString(soap, tag, NULL, "uom10:symbolString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		return soap_in_uom10__collapsedNonEmptyString(soap, tag, NULL, "uom10:collapsedNonEmptyString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		return soap_in_uom10__quantityDimension(soap, tag, NULL, "uom10:quantityDimension");
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		return soap_in_uom10__dimemsionalSymbolString(soap, tag, NULL, "uom10:dimemsionalSymbolString");
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		return soap_in_uom10__unitCodeStruct(soap, tag, NULL, "uom10:unitCodeStruct");
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		return soap_in_uom10__emptyElement(soap, tag, NULL, "uom10:emptyElement");
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		return soap_in_uom10__mapFromToClass(soap, tag, NULL, "uom10:mapFromToClass");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		return soap_in_uom10__classMappingSet(soap, tag, NULL, "uom10:classMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		return soap_in_uom10__mapFromToUnit(soap, tag, NULL, "uom10:mapFromToUnit");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		return soap_in_uom10__unitMappingSet(soap, tag, NULL, "uom10:unitMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		return soap_in_uom10__unitCode(soap, tag, NULL, "uom10:unitCode");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		return soap_in_uom10__classCode(soap, tag, NULL, "uom10:classCode");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		return soap_in_uom10__unitCodeSet(soap, tag, NULL, "uom10:unitCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		return soap_in_uom10__classCodeSet(soap, tag, NULL, "uom10:classCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		return soap_in_uom10__integerCodeSet(soap, tag, NULL, "uom10:integerCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		return soap_in_uom10__prefix(soap, tag, NULL, "uom10:prefix");
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		return soap_in_uom10__prefixSet(soap, tag, NULL, "uom10:prefixSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		return soap_in_uom10__reference(soap, tag, NULL, "uom10:reference");
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		return soap_in_uom10__referenceSet(soap, tag, NULL, "uom10:referenceSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		return soap_in_uom10__unit(soap, tag, NULL, "uom10:unit");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		return soap_in_uom10__unitSet(soap, tag, NULL, "uom10:unitSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		return soap_in_uom10__quantityClass(soap, tag, NULL, "uom10:quantityClass");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		return soap_in_uom10__quantityClassSet(soap, tag, NULL, "uom10:quantityClassSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		return soap_in_uom10__unitDimension(soap, tag, NULL, "uom10:unitDimension");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		return soap_in_uom10__unitDimensionSet(soap, tag, NULL, "uom10:unitDimensionSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		return soap_in_uom10__uomDictionary(soap, tag, NULL, "uom10:uomDictionary");
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		return soap_in_uom10__uomAggregate(soap, tag, NULL, "uom10:uomAggregate");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToClass:
		return soap_in_PointerTouom10__mapFromToClass(soap, tag, NULL, "uom10:mapFromToClass");
	case SOAP_TYPE_gsoap_uom1_0_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToUnit:
		return soap_in_PointerTouom10__mapFromToUnit(soap, tag, NULL, "uom10:mapFromToUnit");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeStruct:
		return soap_in_PointerTouom10__unitCodeStruct(soap, tag, NULL, "uom10:unitCodeStruct");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCode:
		return soap_in_PointerTouom10__unitCode(soap, tag, NULL, "uom10:unitCode");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCode:
		return soap_in_PointerTouom10__classCode(soap, tag, NULL, "uom10:classCode");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeSet:
		return soap_in_PointerTouom10__unitCodeSet(soap, tag, NULL, "uom10:unitCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCodeSet:
		return soap_in_PointerTouom10__classCodeSet(soap, tag, NULL, "uom10:classCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__nameString:
		return soap_in_PointerTouom10__nameString(soap, tag, NULL, "uom10:nameString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefix:
		return soap_in_PointerTouom10__prefix(soap, tag, NULL, "uom10:prefix");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__reference:
		return soap_in_PointerTouom10__reference(soap, tag, NULL, "uom10:reference");
	case SOAP_TYPE_gsoap_uom1_0_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__emptyElement:
		return soap_in_PointerTouom10__emptyElement(soap, tag, NULL, "uom10:emptyElement");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unit:
		return soap_in_PointerTouom10__unit(soap, tag, NULL, "uom10:unit");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__symbolString:
		return soap_in_PointerTouom10__symbolString(soap, tag, NULL, "uom10:symbolString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClass:
		return soap_in_PointerTouom10__quantityClass(soap, tag, NULL, "uom10:quantityClass");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__collapsedNonEmptyString:
		return soap_in_PointerTouom10__collapsedNonEmptyString(soap, tag, NULL, "uom10:collapsedNonEmptyString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimension:
		return soap_in_PointerTouom10__unitDimension(soap, tag, NULL, "uom10:unitDimension");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefixSet:
		return soap_in_PointerTouom10__prefixSet(soap, tag, NULL, "uom10:prefixSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__referenceSet:
		return soap_in_PointerTouom10__referenceSet(soap, tag, NULL, "uom10:referenceSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitSet:
		return soap_in_PointerTouom10__unitSet(soap, tag, NULL, "uom10:unitSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClassSet:
		return soap_in_PointerTouom10__quantityClassSet(soap, tag, NULL, "uom10:quantityClassSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimensionSet:
		return soap_in_PointerTouom10__unitDimensionSet(soap, tag, NULL, "uom10:unitDimensionSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitMappingSet:
		return soap_in_PointerTouom10__unitMappingSet(soap, tag, NULL, "uom10:unitMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classMappingSet:
		return soap_in_PointerTouom10__classMappingSet(soap, tag, NULL, "uom10:classMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__integerCodeSet:
		return soap_in_PointerTouom10__integerCodeSet(soap, tag, NULL, "uom10:integerCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__uomDictionary:
		return soap_in_PointerTouom10__uomDictionary(soap, tag, NULL, "uom10:uomDictionary");
	case SOAP_TYPE_gsoap_uom1_0__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_gsoap_uom1_0_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "uom10:commentString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__commentString;
			return soap_in_uom10__commentString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:descriptionString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString;
			return soap_in_uom10__descriptionString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:nameString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__nameString;
			return soap_in_uom10__nameString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:symbolString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__symbolString;
			return soap_in_uom10__symbolString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:collapsedNonEmptyString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString;
			return soap_in_uom10__collapsedNonEmptyString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:quantityDimension"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension;
			return soap_in_uom10__quantityDimension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:dimemsionalSymbolString"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString;
			return soap_in_uom10__dimemsionalSymbolString(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitCodeStruct"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct;
			return soap_in_uom10__unitCodeStruct(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:emptyElement"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement;
			return soap_in_uom10__emptyElement(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:mapFromToClass"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass;
			return soap_in_uom10__mapFromToClass(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:classMappingSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet;
			return soap_in_uom10__classMappingSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:mapFromToUnit"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit;
			return soap_in_uom10__mapFromToUnit(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitMappingSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet;
			return soap_in_uom10__unitMappingSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitCode"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitCode;
			return soap_in_uom10__unitCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:classCode"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__classCode;
			return soap_in_uom10__classCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitCodeSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet;
			return soap_in_uom10__unitCodeSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:classCodeSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet;
			return soap_in_uom10__classCodeSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:integerCodeSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet;
			return soap_in_uom10__integerCodeSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:prefix"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__prefix;
			return soap_in_uom10__prefix(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:prefixSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet;
			return soap_in_uom10__prefixSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:reference"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__reference;
			return soap_in_uom10__reference(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:referenceSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet;
			return soap_in_uom10__referenceSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unit"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unit;
			return soap_in_uom10__unit(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitSet;
			return soap_in_uom10__unitSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:quantityClass"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass;
			return soap_in_uom10__quantityClass(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:quantityClassSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet;
			return soap_in_uom10__quantityClassSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitDimension"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension;
			return soap_in_uom10__unitDimension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitDimensionSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet;
			return soap_in_uom10__unitDimensionSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:uomDictionary"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary;
			return soap_in_uom10__uomDictionary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:uomAggregate"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate;
			return soap_in_uom10__uomAggregate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:zero"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__zero;
			return soap_in_uom10__zero(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:stateEnum"))
		{	*type = SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum;
			return soap_in_uom10__stateEnum(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_gsoap_uom1_0__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_gsoap_uom1_0_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "uom10:classMappingSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet;
			return soap_in__uom10__classMappingSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitMappingSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet;
			return soap_in__uom10__unitMappingSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:integerCodeSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet;
			return soap_in__uom10__integerCodeSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:prefixSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet;
			return soap_in__uom10__prefixSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:referenceSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet;
			return soap_in__uom10__referenceSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__unitSet;
			return soap_in__uom10__unitSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:quantityClassSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet;
			return soap_in__uom10__quantityClassSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:unitDimensionSet"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet;
			return soap_in__uom10__unitDimensionSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:uomDictionary"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary;
			return soap_in__uom10__uomDictionary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "uom10:uomAggregate"))
		{	*type = SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate;
			return soap_in__uom10__uomAggregate(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if ((!soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_gsoap_uom1_0_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_gsoap_uom1_0_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const ULONG64 *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_gsoap_uom1_0_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_gsoap_uom1_0_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_gsoap_uom1_0_uom10__zero:
		return soap_out_uom10__zero(soap, tag, id, (const uom10__zero *)ptr, "uom10:zero");
	case SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum:
		return soap_out_uom10__stateEnum(soap, tag, id, (const uom10__stateEnum *)ptr, "uom10:stateEnum");
	case SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet:
		return soap_out__uom10__classMappingSet(soap, "uom10:classMappingSet", id, (const uom10__classMappingSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet:
		return soap_out__uom10__unitMappingSet(soap, "uom10:unitMappingSet", id, (const uom10__unitMappingSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet:
		return soap_out__uom10__integerCodeSet(soap, "uom10:integerCodeSet", id, (const uom10__integerCodeSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet:
		return soap_out__uom10__prefixSet(soap, "uom10:prefixSet", id, (const uom10__prefixSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet:
		return soap_out__uom10__referenceSet(soap, "uom10:referenceSet", id, (const uom10__referenceSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitSet:
		return soap_out__uom10__unitSet(soap, "uom10:unitSet", id, (const uom10__unitSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet:
		return soap_out__uom10__quantityClassSet(soap, "uom10:quantityClassSet", id, (const uom10__quantityClassSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet:
		return soap_out__uom10__unitDimensionSet(soap, "uom10:unitDimensionSet", id, (const uom10__unitDimensionSet *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary:
		return soap_out__uom10__uomDictionary(soap, "uom10:uomDictionary", id, (const uom10__uomDictionary *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate:
		return soap_out__uom10__uomAggregate(soap, "uom10:uomAggregate", id, (const uom10__uomAggregate *)ptr, "");
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		return soap_out_uom10__commentString(soap, tag, id, (const std::string *)ptr, "uom10:commentString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		return soap_out_uom10__descriptionString(soap, tag, id, (const std::string *)ptr, "uom10:descriptionString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		return soap_out_uom10__nameString(soap, tag, id, (const std::string *)ptr, "uom10:nameString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		return soap_out_uom10__symbolString(soap, tag, id, (const std::string *)ptr, "uom10:symbolString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		return soap_out_uom10__collapsedNonEmptyString(soap, tag, id, (const std::string *)ptr, "uom10:collapsedNonEmptyString");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		return soap_out_uom10__quantityDimension(soap, tag, id, (const std::string *)ptr, "uom10:quantityDimension");
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		return soap_out_uom10__dimemsionalSymbolString(soap, tag, id, (const std::string *)ptr, "uom10:dimemsionalSymbolString");
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		return ((uom10__unitCodeStruct *)ptr)->soap_out(soap, tag, id, "uom10:unitCodeStruct");
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		return ((uom10__emptyElement *)ptr)->soap_out(soap, tag, id, "uom10:emptyElement");
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		return ((uom10__mapFromToClass *)ptr)->soap_out(soap, tag, id, "uom10:mapFromToClass");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		return ((uom10__classMappingSet *)ptr)->soap_out(soap, tag, id, "uom10:classMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		return ((uom10__mapFromToUnit *)ptr)->soap_out(soap, tag, id, "uom10:mapFromToUnit");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		return ((uom10__unitMappingSet *)ptr)->soap_out(soap, tag, id, "uom10:unitMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		return ((uom10__unitCode *)ptr)->soap_out(soap, tag, id, "uom10:unitCode");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		return ((uom10__classCode *)ptr)->soap_out(soap, tag, id, "uom10:classCode");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		return ((uom10__unitCodeSet *)ptr)->soap_out(soap, tag, id, "uom10:unitCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		return ((uom10__classCodeSet *)ptr)->soap_out(soap, tag, id, "uom10:classCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		return ((uom10__integerCodeSet *)ptr)->soap_out(soap, tag, id, "uom10:integerCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		return ((uom10__prefix *)ptr)->soap_out(soap, tag, id, "uom10:prefix");
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		return ((uom10__prefixSet *)ptr)->soap_out(soap, tag, id, "uom10:prefixSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		return ((uom10__reference *)ptr)->soap_out(soap, tag, id, "uom10:reference");
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		return ((uom10__referenceSet *)ptr)->soap_out(soap, tag, id, "uom10:referenceSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		return ((uom10__unit *)ptr)->soap_out(soap, tag, id, "uom10:unit");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		return ((uom10__unitSet *)ptr)->soap_out(soap, tag, id, "uom10:unitSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		return ((uom10__quantityClass *)ptr)->soap_out(soap, tag, id, "uom10:quantityClass");
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		return ((uom10__quantityClassSet *)ptr)->soap_out(soap, tag, id, "uom10:quantityClassSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		return ((uom10__unitDimension *)ptr)->soap_out(soap, tag, id, "uom10:unitDimension");
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		return ((uom10__unitDimensionSet *)ptr)->soap_out(soap, tag, id, "uom10:unitDimensionSet");
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		return ((uom10__uomDictionary *)ptr)->soap_out(soap, tag, id, "uom10:uomDictionary");
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		return ((uom10__uomAggregate *)ptr)->soap_out(soap, tag, id, "uom10:uomAggregate");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToClass:
		return soap_out_PointerTouom10__mapFromToClass(soap, tag, id, (uom10__mapFromToClass *const*)ptr, "uom10:mapFromToClass");
	case SOAP_TYPE_gsoap_uom1_0_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToUnit:
		return soap_out_PointerTouom10__mapFromToUnit(soap, tag, id, (uom10__mapFromToUnit *const*)ptr, "uom10:mapFromToUnit");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeStruct:
		return soap_out_PointerTouom10__unitCodeStruct(soap, tag, id, (uom10__unitCodeStruct *const*)ptr, "uom10:unitCodeStruct");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCode:
		return soap_out_PointerTouom10__unitCode(soap, tag, id, (uom10__unitCode *const*)ptr, "uom10:unitCode");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCode:
		return soap_out_PointerTouom10__classCode(soap, tag, id, (uom10__classCode *const*)ptr, "uom10:classCode");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeSet:
		return soap_out_PointerTouom10__unitCodeSet(soap, tag, id, (uom10__unitCodeSet *const*)ptr, "uom10:unitCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCodeSet:
		return soap_out_PointerTouom10__classCodeSet(soap, tag, id, (uom10__classCodeSet *const*)ptr, "uom10:classCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__nameString:
		return soap_out_PointerTouom10__nameString(soap, tag, id, (std::string *const*)ptr, "uom10:nameString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefix:
		return soap_out_PointerTouom10__prefix(soap, tag, id, (uom10__prefix *const*)ptr, "uom10:prefix");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__reference:
		return soap_out_PointerTouom10__reference(soap, tag, id, (uom10__reference *const*)ptr, "uom10:reference");
	case SOAP_TYPE_gsoap_uom1_0_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__emptyElement:
		return soap_out_PointerTouom10__emptyElement(soap, tag, id, (uom10__emptyElement *const*)ptr, "uom10:emptyElement");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unit:
		return soap_out_PointerTouom10__unit(soap, tag, id, (uom10__unit *const*)ptr, "uom10:unit");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__symbolString:
		return soap_out_PointerTouom10__symbolString(soap, tag, id, (std::string *const*)ptr, "uom10:symbolString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClass:
		return soap_out_PointerTouom10__quantityClass(soap, tag, id, (uom10__quantityClass *const*)ptr, "uom10:quantityClass");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__collapsedNonEmptyString:
		return soap_out_PointerTouom10__collapsedNonEmptyString(soap, tag, id, (std::string *const*)ptr, "uom10:collapsedNonEmptyString");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimension:
		return soap_out_PointerTouom10__unitDimension(soap, tag, id, (uom10__unitDimension *const*)ptr, "uom10:unitDimension");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefixSet:
		return soap_out_PointerTouom10__prefixSet(soap, tag, id, (uom10__prefixSet *const*)ptr, "uom10:prefixSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__referenceSet:
		return soap_out_PointerTouom10__referenceSet(soap, tag, id, (uom10__referenceSet *const*)ptr, "uom10:referenceSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitSet:
		return soap_out_PointerTouom10__unitSet(soap, tag, id, (uom10__unitSet *const*)ptr, "uom10:unitSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClassSet:
		return soap_out_PointerTouom10__quantityClassSet(soap, tag, id, (uom10__quantityClassSet *const*)ptr, "uom10:quantityClassSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimensionSet:
		return soap_out_PointerTouom10__unitDimensionSet(soap, tag, id, (uom10__unitDimensionSet *const*)ptr, "uom10:unitDimensionSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitMappingSet:
		return soap_out_PointerTouom10__unitMappingSet(soap, tag, id, (uom10__unitMappingSet *const*)ptr, "uom10:unitMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classMappingSet:
		return soap_out_PointerTouom10__classMappingSet(soap, tag, id, (uom10__classMappingSet *const*)ptr, "uom10:classMappingSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__integerCodeSet:
		return soap_out_PointerTouom10__integerCodeSet(soap, tag, id, (uom10__integerCodeSet *const*)ptr, "uom10:integerCodeSet");
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__uomDictionary:
		return soap_out_PointerTouom10__uomDictionary(soap, tag, id, (uom10__uomDictionary *const*)ptr, "uom10:uomDictionary");
	case SOAP_TYPE_gsoap_uom1_0__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_gsoap_uom1_0_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in gsoap_uom1_0C.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet:
		soap_serialize__uom10__classMappingSet(soap, (const uom10__classMappingSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet:
		soap_serialize__uom10__unitMappingSet(soap, (const uom10__unitMappingSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet:
		soap_serialize__uom10__integerCodeSet(soap, (const uom10__integerCodeSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet:
		soap_serialize__uom10__prefixSet(soap, (const uom10__prefixSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet:
		soap_serialize__uom10__referenceSet(soap, (const uom10__referenceSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitSet:
		soap_serialize__uom10__unitSet(soap, (const uom10__unitSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet:
		soap_serialize__uom10__quantityClassSet(soap, (const uom10__quantityClassSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet:
		soap_serialize__uom10__unitDimensionSet(soap, (const uom10__unitDimensionSet *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary:
		soap_serialize__uom10__uomDictionary(soap, (const uom10__uomDictionary *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate:
		soap_serialize__uom10__uomAggregate(soap, (const uom10__uomAggregate *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		soap_serialize_uom10__commentString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		soap_serialize_uom10__descriptionString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		soap_serialize_uom10__nameString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		soap_serialize_uom10__symbolString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		soap_serialize_uom10__collapsedNonEmptyString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		soap_serialize_uom10__quantityDimension(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		soap_serialize_uom10__dimemsionalSymbolString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		((uom10__unitCodeStruct *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		((uom10__emptyElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		((uom10__mapFromToClass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		((uom10__classMappingSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		((uom10__mapFromToUnit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		((uom10__unitMappingSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		((uom10__unitCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		((uom10__classCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		((uom10__unitCodeSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		((uom10__classCodeSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		((uom10__integerCodeSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		((uom10__prefix *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		((uom10__prefixSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		((uom10__reference *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		((uom10__referenceSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		((uom10__unit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		((uom10__unitSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		((uom10__quantityClass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		((uom10__quantityClassSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		((uom10__unitDimension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		((uom10__unitDimensionSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		((uom10__uomDictionary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		((uom10__uomAggregate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToClass:
		soap_serialize_PointerTouom10__mapFromToClass(soap, (uom10__mapFromToClass *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__mapFromToUnit:
		soap_serialize_PointerTouom10__mapFromToUnit(soap, (uom10__mapFromToUnit *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeStruct:
		soap_serialize_PointerTouom10__unitCodeStruct(soap, (uom10__unitCodeStruct *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCode:
		soap_serialize_PointerTouom10__unitCode(soap, (uom10__unitCode *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCode:
		soap_serialize_PointerTouom10__classCode(soap, (uom10__classCode *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitCodeSet:
		soap_serialize_PointerTouom10__unitCodeSet(soap, (uom10__unitCodeSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classCodeSet:
		soap_serialize_PointerTouom10__classCodeSet(soap, (uom10__classCodeSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__nameString:
		soap_serialize_PointerTouom10__nameString(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefix:
		soap_serialize_PointerTouom10__prefix(soap, (uom10__prefix *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__reference:
		soap_serialize_PointerTouom10__reference(soap, (uom10__reference *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__emptyElement:
		soap_serialize_PointerTouom10__emptyElement(soap, (uom10__emptyElement *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unit:
		soap_serialize_PointerTouom10__unit(soap, (uom10__unit *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__symbolString:
		soap_serialize_PointerTouom10__symbolString(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClass:
		soap_serialize_PointerTouom10__quantityClass(soap, (uom10__quantityClass *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__collapsedNonEmptyString:
		soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimension:
		soap_serialize_PointerTouom10__unitDimension(soap, (uom10__unitDimension *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__prefixSet:
		soap_serialize_PointerTouom10__prefixSet(soap, (uom10__prefixSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__referenceSet:
		soap_serialize_PointerTouom10__referenceSet(soap, (uom10__referenceSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitSet:
		soap_serialize_PointerTouom10__unitSet(soap, (uom10__unitSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__quantityClassSet:
		soap_serialize_PointerTouom10__quantityClassSet(soap, (uom10__quantityClassSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitDimensionSet:
		soap_serialize_PointerTouom10__unitDimensionSet(soap, (uom10__unitDimensionSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__unitMappingSet:
		soap_serialize_PointerTouom10__unitMappingSet(soap, (uom10__unitMappingSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__classMappingSet:
		soap_serialize_PointerTouom10__classMappingSet(soap, (uom10__classMappingSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__integerCodeSet:
		soap_serialize_PointerTouom10__integerCodeSet(soap, (uom10__integerCodeSet *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_PointerTouom10__uomDictionary:
		soap_serialize_PointerTouom10__uomDictionary(soap, (uom10__uomDictionary *const*)ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_gsoap_uom1_0_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 void * SOAP_FMAC4 gsoap_uom1_0_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		return (void*)soap_instantiate_uom10__uomAggregate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		return (void*)soap_instantiate_uom10__uomDictionary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		return (void*)soap_instantiate_uom10__unitDimensionSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		return (void*)soap_instantiate_uom10__unitDimension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		return (void*)soap_instantiate_uom10__quantityClassSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		return (void*)soap_instantiate_uom10__quantityClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		return (void*)soap_instantiate_uom10__unitSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		return (void*)soap_instantiate_uom10__unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		return (void*)soap_instantiate_uom10__referenceSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		return (void*)soap_instantiate_uom10__reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		return (void*)soap_instantiate_uom10__prefixSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		return (void*)soap_instantiate_uom10__prefix(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		return (void*)soap_instantiate_uom10__integerCodeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		return (void*)soap_instantiate_uom10__classCodeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		return (void*)soap_instantiate_uom10__unitCodeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		return (void*)soap_instantiate_uom10__classCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		return (void*)soap_instantiate_uom10__unitCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		return (void*)soap_instantiate_uom10__unitMappingSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		return (void*)soap_instantiate_uom10__mapFromToUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		return (void*)soap_instantiate_uom10__classMappingSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		return (void*)soap_instantiate_uom10__mapFromToClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		return (void*)soap_instantiate_uom10__emptyElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		return (void*)soap_instantiate_uom10__unitCodeStruct(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		return (void*)soap_instantiate_uom10__dimemsionalSymbolString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		return (void*)soap_instantiate_uom10__quantityDimension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		return (void*)soap_instantiate_uom10__collapsedNonEmptyString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		return (void*)soap_instantiate_uom10__symbolString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		return (void*)soap_instantiate_uom10__nameString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		return (void*)soap_instantiate_uom10__descriptionString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		return (void*)soap_instantiate_uom10__commentString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate:
		return (void*)soap_instantiate__uom10__uomAggregate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary:
		return (void*)soap_instantiate__uom10__uomDictionary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet:
		return (void*)soap_instantiate__uom10__unitDimensionSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet:
		return (void*)soap_instantiate__uom10__quantityClassSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitSet:
		return (void*)soap_instantiate__uom10__unitSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet:
		return (void*)soap_instantiate__uom10__referenceSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet:
		return (void*)soap_instantiate__uom10__prefixSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet:
		return (void*)soap_instantiate__uom10__integerCodeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet:
		return (void*)soap_instantiate__uom10__unitMappingSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet:
		return (void*)soap_instantiate__uom10__classMappingSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__unitCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__classCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__prefix(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__unit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString:
		return (void*)soap_instantiate_std__vectorTemplateOfuom10__symbolString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__quantityClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__unitDimension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTouom10__classMappingSet(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 gsoap_uom1_0_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__uomAggregate*>(p->ptr), uom10__uomAggregate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__uomAggregate*>(p->ptr), uom10__uomAggregate);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__uomDictionary*>(p->ptr), uom10__uomDictionary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__uomDictionary*>(p->ptr), uom10__uomDictionary);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitDimensionSet*>(p->ptr), uom10__unitDimensionSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitDimensionSet*>(p->ptr), uom10__unitDimensionSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitDimension*>(p->ptr), uom10__unitDimension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitDimension*>(p->ptr), uom10__unitDimension);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__quantityClassSet*>(p->ptr), uom10__quantityClassSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__quantityClassSet*>(p->ptr), uom10__quantityClassSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__quantityClass*>(p->ptr), uom10__quantityClass);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__quantityClass*>(p->ptr), uom10__quantityClass);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitSet*>(p->ptr), uom10__unitSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitSet*>(p->ptr), uom10__unitSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unit*>(p->ptr), uom10__unit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unit*>(p->ptr), uom10__unit);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__referenceSet*>(p->ptr), uom10__referenceSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__referenceSet*>(p->ptr), uom10__referenceSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__reference*>(p->ptr), uom10__reference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__reference*>(p->ptr), uom10__reference);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__prefixSet*>(p->ptr), uom10__prefixSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__prefixSet*>(p->ptr), uom10__prefixSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__prefix*>(p->ptr), uom10__prefix);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__prefix*>(p->ptr), uom10__prefix);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__integerCodeSet*>(p->ptr), uom10__integerCodeSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__integerCodeSet*>(p->ptr), uom10__integerCodeSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__classCodeSet*>(p->ptr), uom10__classCodeSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__classCodeSet*>(p->ptr), uom10__classCodeSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitCodeSet*>(p->ptr), uom10__unitCodeSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitCodeSet*>(p->ptr), uom10__unitCodeSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__classCode*>(p->ptr), uom10__classCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__classCode*>(p->ptr), uom10__classCode);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitCode*>(p->ptr), uom10__unitCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitCode*>(p->ptr), uom10__unitCode);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitMappingSet*>(p->ptr), uom10__unitMappingSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitMappingSet*>(p->ptr), uom10__unitMappingSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__mapFromToUnit*>(p->ptr), uom10__mapFromToUnit);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__mapFromToUnit*>(p->ptr), uom10__mapFromToUnit);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__classMappingSet*>(p->ptr), uom10__classMappingSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__classMappingSet*>(p->ptr), uom10__classMappingSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__mapFromToClass*>(p->ptr), uom10__mapFromToClass);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__mapFromToClass*>(p->ptr), uom10__mapFromToClass);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__emptyElement*>(p->ptr), uom10__emptyElement);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__emptyElement*>(p->ptr), uom10__emptyElement);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitCodeStruct*>(p->ptr), uom10__unitCodeStruct);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitCodeStruct*>(p->ptr), uom10__unitCodeStruct);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__uomAggregate*>(p->ptr), uom10__uomAggregate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__uomAggregate*>(p->ptr), uom10__uomAggregate);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__uomDictionary*>(p->ptr), uom10__uomDictionary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__uomDictionary*>(p->ptr), uom10__uomDictionary);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitDimensionSet*>(p->ptr), uom10__unitDimensionSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitDimensionSet*>(p->ptr), uom10__unitDimensionSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__quantityClassSet*>(p->ptr), uom10__quantityClassSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__quantityClassSet*>(p->ptr), uom10__quantityClassSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitSet*>(p->ptr), uom10__unitSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitSet*>(p->ptr), uom10__unitSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__referenceSet*>(p->ptr), uom10__referenceSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__referenceSet*>(p->ptr), uom10__referenceSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__prefixSet*>(p->ptr), uom10__prefixSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__prefixSet*>(p->ptr), uom10__prefixSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__integerCodeSet*>(p->ptr), uom10__integerCodeSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__integerCodeSet*>(p->ptr), uom10__integerCodeSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__unitMappingSet*>(p->ptr), uom10__unitMappingSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__unitMappingSet*>(p->ptr), uom10__unitMappingSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<uom10__classMappingSet*>(p->ptr), uom10__classMappingSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<uom10__classMappingSet*>(p->ptr), uom10__classMappingSet);
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__mapFromToClass *> *>(p->ptr), std::vector<uom10__mapFromToClass *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__mapFromToClass *> *>(p->ptr), std::vector<uom10__mapFromToClass *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__mapFromToUnit *> *>(p->ptr), std::vector<uom10__mapFromToUnit *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__mapFromToUnit *> *>(p->ptr), std::vector<uom10__mapFromToUnit *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__unitCode *> *>(p->ptr), std::vector<uom10__unitCode *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__unitCode *> *>(p->ptr), std::vector<uom10__unitCode *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__classCode *> *>(p->ptr), std::vector<uom10__classCode *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__classCode *> *>(p->ptr), std::vector<uom10__classCode *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__prefix *> *>(p->ptr), std::vector<uom10__prefix *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__prefix *> *>(p->ptr), std::vector<uom10__prefix *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__reference *> *>(p->ptr), std::vector<uom10__reference *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__reference *> *>(p->ptr), std::vector<uom10__reference *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__unit *> *>(p->ptr), std::vector<uom10__unit *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__unit *> *>(p->ptr), std::vector<uom10__unit *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__quantityClass *> *>(p->ptr), std::vector<uom10__quantityClass *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__quantityClass *> *>(p->ptr), std::vector<uom10__quantityClass *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__unitDimension *> *>(p->ptr), std::vector<uom10__unitDimension *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__unitDimension *> *>(p->ptr), std::vector<uom10__unitDimension *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__unitMappingSet *> *>(p->ptr), std::vector<uom10__unitMappingSet *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__unitMappingSet *> *>(p->ptr), std::vector<uom10__unitMappingSet *> );
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<uom10__classMappingSet *> *>(p->ptr), std::vector<uom10__classMappingSet *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<uom10__classMappingSet *> *>(p->ptr), std::vector<uom10__classMappingSet *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 gsoap_uom1_0_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 gsoap_uom1_0_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__mapFromToClass *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__mapFromToClass *> *)p)[index] = *(uom10__mapFromToClass **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__mapFromToUnit *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__mapFromToUnit *> *)p)[index] = *(uom10__mapFromToUnit **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__unitCode || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__unitCode *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__unitCode *> *)p)[index] = *(uom10__unitCode **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__classCode || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__classCode))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__classCode *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__classCode *> *)p)[index] = *(uom10__classCode **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__prefix || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__prefix))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__prefix *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__prefix *> *)p)[index] = *(uom10__prefix **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__reference || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__reference))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__reference *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__reference *> *)p)[index] = *(uom10__reference **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__unit || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__unit))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__unit *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__unit *> *)p)[index] = *(uom10__unit **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__symbolString)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__quantityClass *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__quantityClass *> *)p)[index] = *(uom10__quantityClass **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__unitDimension *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__unitDimension *> *)p)[index] = *(uom10__unitDimension **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__unitMappingSet *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__unitMappingSet *> *)p)[index] = *(uom10__unitMappingSet **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet:
		if (t == SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet || gsoap_uom1_0_fbase(t, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<uom10__classMappingSet *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<uom10__classMappingSet *> *)p)[index] = *(uom10__classMappingSet **)q;
		}
		break;
	case SOAP_TYPE_gsoap_uom1_0_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__uomAggregate type=%d location=%p object=%p\n", t, p, q));
		*(uom10__uomAggregate*)p = *(uom10__uomAggregate*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__uomDictionary type=%d location=%p object=%p\n", t, p, q));
		*(uom10__uomDictionary*)p = *(uom10__uomDictionary*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitDimensionSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitDimensionSet*)p = *(uom10__unitDimensionSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitDimension type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitDimension*)p = *(uom10__unitDimension*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__quantityClassSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__quantityClassSet*)p = *(uom10__quantityClassSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__quantityClass type=%d location=%p object=%p\n", t, p, q));
		*(uom10__quantityClass*)p = *(uom10__quantityClass*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitSet*)p = *(uom10__unitSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unit type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unit*)p = *(uom10__unit*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__referenceSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__referenceSet*)p = *(uom10__referenceSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__reference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__reference type=%d location=%p object=%p\n", t, p, q));
		*(uom10__reference*)p = *(uom10__reference*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__prefixSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__prefixSet*)p = *(uom10__prefixSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__prefix:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__prefix type=%d location=%p object=%p\n", t, p, q));
		*(uom10__prefix*)p = *(uom10__prefix*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__integerCodeSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__integerCodeSet*)p = *(uom10__integerCodeSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__classCodeSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__classCodeSet*)p = *(uom10__classCodeSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitCodeSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitCodeSet*)p = *(uom10__unitCodeSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__classCode type=%d location=%p object=%p\n", t, p, q));
		*(uom10__classCode*)p = *(uom10__classCode*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitCode type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitCode*)p = *(uom10__unitCode*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitMappingSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitMappingSet*)p = *(uom10__unitMappingSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__mapFromToUnit type=%d location=%p object=%p\n", t, p, q));
		*(uom10__mapFromToUnit*)p = *(uom10__mapFromToUnit*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__classMappingSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__classMappingSet*)p = *(uom10__classMappingSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__mapFromToClass type=%d location=%p object=%p\n", t, p, q));
		*(uom10__mapFromToClass*)p = *(uom10__mapFromToClass*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__emptyElement type=%d location=%p object=%p\n", t, p, q));
		*(uom10__emptyElement*)p = *(uom10__emptyElement*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitCodeStruct type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitCodeStruct*)p = *(uom10__unitCodeStruct*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__symbolString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__nameString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0_uom10__commentString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomAggregate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__uomAggregate type=%d location=%p object=%p\n", t, p, q));
		*(uom10__uomAggregate*)p = *(uom10__uomAggregate*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__uomDictionary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__uomDictionary type=%d location=%p object=%p\n", t, p, q));
		*(uom10__uomDictionary*)p = *(uom10__uomDictionary*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitDimensionSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitDimensionSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitDimensionSet*)p = *(uom10__unitDimensionSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__quantityClassSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__quantityClassSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__quantityClassSet*)p = *(uom10__quantityClassSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitSet*)p = *(uom10__unitSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__referenceSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__referenceSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__referenceSet*)p = *(uom10__referenceSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__prefixSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__prefixSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__prefixSet*)p = *(uom10__prefixSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__integerCodeSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__integerCodeSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__integerCodeSet*)p = *(uom10__integerCodeSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__unitMappingSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__unitMappingSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__unitMappingSet*)p = *(uom10__unitMappingSet*)q;
		break;
	case SOAP_TYPE_gsoap_uom1_0__uom10__classMappingSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy uom10__classMappingSet type=%d location=%p object=%p\n", t, p, q));
		*(uom10__classMappingSet*)p = *(uom10__classMappingSet*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	if (!type)
		type = "xsd:byte";
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	if (!type)
		type = "xsd:int";
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	if (!type)
		type = "xsd:positiveInteger";
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__positiveInteger(struct soap *soap, const char *s, ULONG64 *a)
{
	int err = soap_s2ULONG64(soap, s, a);
	if (!err)
	{
	}
	return err;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0_xsd__positiveInteger);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__positiveInteger(soap, tag ? tag : "xsd:positiveInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	if (!type)
		type = "xsd:unsignedLong";
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (!type)
		type = "xsd:boolean";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_bool, SOAP_TYPE_gsoap_uom1_0_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_uom10__zero[] =
{	{ (LONG64)uom10__zero::_0, "0" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_uom10__zero2s(struct soap *soap, uom10__zero n)
{
	const char *s = soap_code_str(soap_codes_uom10__zero, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__zero(struct soap *soap, const char *tag, int id, const uom10__zero *a, const char *type)
{
	if (!type)
		type = "uom10:zero";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__zero), type) || soap_send(soap, soap_uom10__zero2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2uom10__zero(struct soap *soap, const char *s, uom10__zero *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_uom10__zero, s);
	if (map)
		*a = (uom10__zero)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 uom10__zero * SOAP_FMAC4 soap_in_uom10__zero(struct soap *soap, const char *tag, uom10__zero *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (uom10__zero*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__zero, sizeof(uom10__zero), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2uom10__zero(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (uom10__zero *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__zero, SOAP_TYPE_gsoap_uom1_0_uom10__zero, sizeof(uom10__zero), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 uom10__zero * SOAP_FMAC4 soap_new_uom10__zero(struct soap *soap, int n)
{
	uom10__zero *a = static_cast<uom10__zero *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(uom10__zero)));
	for (uom10__zero *p = a; p && n--; ++p)
		soap_default_uom10__zero(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__zero(struct soap *soap, const uom10__zero *a, const char *tag, const char *type)
{
	if (soap_out_uom10__zero(soap, tag ? tag : "uom10:zero", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__zero * SOAP_FMAC4 soap_get_uom10__zero(struct soap *soap, uom10__zero *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__zero(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_uom10__stateEnum[] =
{	{ (LONG64)uom10__stateEnum::identical, "identical" },
	{ (LONG64)uom10__stateEnum::precision, "precision" },
	{ (LONG64)uom10__stateEnum::corrected, "corrected" },
	{ (LONG64)uom10__stateEnum::conditional, "conditional" },
	{ (LONG64)uom10__stateEnum::conversion, "conversion" },
	{ (LONG64)uom10__stateEnum::unsupported, "unsupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_uom10__stateEnum2s(struct soap *soap, uom10__stateEnum n)
{
	const char *s = soap_code_str(soap_codes_uom10__stateEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__stateEnum(struct soap *soap, const char *tag, int id, const uom10__stateEnum *a, const char *type)
{
	if (!type)
		type = "uom10:stateEnum";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum), type) || soap_send(soap, soap_uom10__stateEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2uom10__stateEnum(struct soap *soap, const char *s, uom10__stateEnum *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_uom10__stateEnum, s);
	if (map)
		*a = (uom10__stateEnum)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 uom10__stateEnum * SOAP_FMAC4 soap_in_uom10__stateEnum(struct soap *soap, const char *tag, uom10__stateEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (uom10__stateEnum*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum, sizeof(uom10__stateEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2uom10__stateEnum(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (uom10__stateEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum, SOAP_TYPE_gsoap_uom1_0_uom10__stateEnum, sizeof(uom10__stateEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 uom10__stateEnum * SOAP_FMAC4 soap_new_uom10__stateEnum(struct soap *soap, int n)
{
	uom10__stateEnum *a = static_cast<uom10__stateEnum *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(uom10__stateEnum)));
	for (uom10__stateEnum *p = a; p && n--; ++p)
		soap_default_uom10__stateEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__stateEnum(struct soap *soap, const uom10__stateEnum *a, const char *tag, const char *type)
{
	if (soap_out_uom10__stateEnum(soap, tag ? tag : "uom10:stateEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__stateEnum * SOAP_FMAC4 soap_get_uom10__stateEnum(struct soap *soap, uom10__stateEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__stateEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__classMappingSet(struct soap *soap, const uom10__classMappingSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__classMappingSet(soap, tag ? tag : "uom10:classMappingSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__unitMappingSet(struct soap *soap, const uom10__unitMappingSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__unitMappingSet(soap, tag ? tag : "uom10:unitMappingSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__integerCodeSet(struct soap *soap, const uom10__integerCodeSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__integerCodeSet(soap, tag ? tag : "uom10:integerCodeSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__prefixSet(struct soap *soap, const uom10__prefixSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__prefixSet(soap, tag ? tag : "uom10:prefixSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__referenceSet(struct soap *soap, const uom10__referenceSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__referenceSet(soap, tag ? tag : "uom10:referenceSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__unitSet(struct soap *soap, const uom10__unitSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__unitSet(soap, tag ? tag : "uom10:unitSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__quantityClassSet(struct soap *soap, const uom10__quantityClassSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__quantityClassSet(soap, tag ? tag : "uom10:quantityClassSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__unitDimensionSet(struct soap *soap, const uom10__unitDimensionSet *a, const char *tag, const char *type)
{
	if (soap_out__uom10__unitDimensionSet(soap, tag ? tag : "uom10:unitDimensionSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__uomDictionary(struct soap *soap, const uom10__uomDictionary *a, const char *tag, const char *type)
{
	if (soap_out__uom10__uomDictionary(soap, tag ? tag : "uom10:uomDictionary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__uom10__uomAggregate(struct soap *soap, const uom10__uomAggregate *a, const char *tag, const char *type)
{
	if (soap_out__uom10__uomAggregate(soap, tag ? tag : "uom10:uomAggregate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__commentString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__commentString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__commentString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__commentString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 4000, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__commentString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__commentString, SOAP_TYPE_gsoap_uom1_0_uom10__commentString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__commentString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__commentString(soap, tag ? tag : "uom10:commentString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__commentString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__commentString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__descriptionString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__descriptionString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 256, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString, SOAP_TYPE_gsoap_uom1_0_uom10__descriptionString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__descriptionString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__descriptionString(soap, tag ? tag : "uom10:descriptionString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__descriptionString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__descriptionString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__nameString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__nameString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__nameString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__nameString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__nameString(soap, tag ? tag : "uom10:nameString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__nameString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__nameString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_uom10__symbolString(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__symbolString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__symbolString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, 40, "((1E((-)?([2-9]|[1-9][0-9]+))(/([2-9]|[1-9][0-9]+))?|1/([2-9]|[1-9][0-9]+)|(([2-9]|[1-9][0-9]+)|[1-9][0-9]*\\.[0-9]*[1-9]|0\\.[0-9]*[1-9])(E((-)?([2-9]|[1-9][0-9]+)))?(/([2-9]|[1-9][0-9]+))?) )?(((([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)|(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+))|(1|((([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)|(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+))|(\\(((([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)|(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+))/(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?|\\(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+\\))\\)))/((([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?|\\(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+\\))|(\\(((([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)|(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+))/(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?|\\(([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?(\\.([A-Za-z]+|%|inH2O|cmH2O)(\\[@?[A-Za-z0-9]+(,[A-Za-z0-9]+)*\\])?([2-9]|\\([1-9][0-9]*\\.[0-9]*[1-9]\\)|\\(0\\.[0-9]*[1-9]\\))?)+\\))\\))))")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__symbolString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__symbolString(soap, tag ? tag : "uom10:symbolString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__symbolString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__symbolString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_uom10__collapsedNonEmptyString(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__collapsedNonEmptyString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__collapsedNonEmptyString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__collapsedNonEmptyString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__collapsedNonEmptyString(soap, tag ? tag : "uom10:collapsedNonEmptyString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__collapsedNonEmptyString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__collapsedNonEmptyString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_uom10__quantityDimension(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__quantityDimension(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__quantityDimension(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 1, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension, SOAP_TYPE_gsoap_uom1_0_uom10__quantityDimension, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__quantityDimension(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__quantityDimension(soap, tag ? tag : "uom10:quantityDimension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__quantityDimension(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__quantityDimension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_uom10__dimemsionalSymbolString(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__dimemsionalSymbolString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_uom10__dimemsionalSymbolString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString, SOAP_TYPE_gsoap_uom1_0_uom10__dimemsionalSymbolString, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_uom10__dimemsionalSymbolString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_uom10__dimemsionalSymbolString(soap, tag ? tag : "uom10:dimemsionalSymbolString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_uom10__dimemsionalSymbolString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__dimemsionalSymbolString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_gsoap_uom1_0_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_std__string, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_gsoap_uom1_0_std__string, sizeof(std::string), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase), 0, SOAP_TYPE_gsoap_uom1_0_std__string, SOAP_TYPE_gsoap_uom1_0_std__string, sizeof(std::string), 0, gsoap_uom1_0_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__string, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitCodeStruct::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__symbolString(soap, &this->uom10__unitCodeStruct::__item);
	soap_default_xsd__positiveInteger(soap, &this->uom10__unitCodeStruct::code);
}

void uom10__unitCodeStruct::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__unitCodeStruct::__item, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString);
	soap_serialize_uom10__symbolString(soap, &this->uom10__unitCodeStruct::__item);
#endif
}

int uom10__unitCodeStruct::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitCodeStruct(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitCodeStruct(struct soap *soap, const char *tag, int id, const uom10__unitCodeStruct *a, const char *type)
{
	if (!type)
		type = "uom10:unitCodeStruct";
	soap_set_attr(soap, "code", soap_xsd__positiveInteger2s(soap, ((uom10__unitCodeStruct*)a)->code), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_uom10__symbolString(soap, tag, id, &a->uom10__unitCodeStruct::__item, "uom10:unitCodeStruct");
}

void *uom10__unitCodeStruct::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitCodeStruct(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitCodeStruct * SOAP_FMAC4 soap_in_uom10__unitCodeStruct(struct soap *soap, const char *tag, uom10__unitCodeStruct *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (uom10__unitCodeStruct*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct, sizeof(uom10__unitCodeStruct), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct)
		return (uom10__unitCodeStruct *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__positiveInteger(soap, soap_attr_value(soap, "code", 5, 3), &((uom10__unitCodeStruct*)a)->code))
		return NULL;
	if (!soap_in_uom10__symbolString(soap, tag, &a->uom10__unitCodeStruct::__item, "uom10:unitCodeStruct"))
		return NULL;
	return a;
}

SOAP_FMAC1 uom10__unitCodeStruct * SOAP_FMAC2 soap_instantiate_uom10__unitCodeStruct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitCodeStruct(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitCodeStruct *p;
	size_t k = sizeof(uom10__unitCodeStruct);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitCodeStruct);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitCodeStruct, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitCodeStruct location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitCodeStruct::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitCodeStruct(soap, tag ? tag : "uom10:unitCodeStruct", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitCodeStruct::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitCodeStruct(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitCodeStruct * SOAP_FMAC4 soap_get_uom10__unitCodeStruct(struct soap *soap, uom10__unitCodeStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitCodeStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__emptyElement::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void uom10__emptyElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int uom10__emptyElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__emptyElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__emptyElement(struct soap *soap, const char *tag, int id, const uom10__emptyElement *a, const char *type)
{
	if (!type)
		type = "uom10:emptyElement";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__emptyElement::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__emptyElement(soap, tag, this, type);
}

SOAP_FMAC3 uom10__emptyElement * SOAP_FMAC4 soap_in_uom10__emptyElement(struct soap *soap, const char *tag, uom10__emptyElement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__emptyElement*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, sizeof(uom10__emptyElement), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__emptyElement *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (uom10__emptyElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, sizeof(uom10__emptyElement), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__emptyElement * SOAP_FMAC2 soap_instantiate_uom10__emptyElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__emptyElement(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__emptyElement *p;
	size_t k = sizeof(uom10__emptyElement);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__emptyElement);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__emptyElement, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__emptyElement location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__emptyElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__emptyElement(soap, tag ? tag : "uom10:emptyElement", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__emptyElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__emptyElement(soap, this, tag, type);
}

SOAP_FMAC3 uom10__emptyElement * SOAP_FMAC4 soap_get_uom10__emptyElement(struct soap *soap, uom10__emptyElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__emptyElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__mapFromToClass::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__mapFromToClass::mapsFrom);
	soap_default_std__string(soap, &this->uom10__mapFromToClass::mapsTo);
}

void uom10__mapFromToClass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__mapFromToClass::mapsFrom, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__mapFromToClass::mapsFrom);
	soap_embedded(soap, &this->uom10__mapFromToClass::mapsTo, SOAP_TYPE_gsoap_uom1_0_std__string);
	soap_serialize_std__string(soap, &this->uom10__mapFromToClass::mapsTo);
#endif
}

int uom10__mapFromToClass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__mapFromToClass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__mapFromToClass(struct soap *soap, const char *tag, int id, const uom10__mapFromToClass *a, const char *type)
{
	if (!type)
		type = "uom10:mapFromToClass";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass), type))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:mapsFrom", -1, &a->uom10__mapFromToClass::mapsFrom, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_std__string(soap, "uom10:mapsTo", -1, &a->uom10__mapFromToClass::mapsTo, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__mapFromToClass::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__mapFromToClass(soap, tag, this, type);
}

SOAP_FMAC3 uom10__mapFromToClass * SOAP_FMAC4 soap_in_uom10__mapFromToClass(struct soap *soap, const char *tag, uom10__mapFromToClass *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__mapFromToClass*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, sizeof(uom10__mapFromToClass), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__mapFromToClass *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mapsFrom1 = 1;
	size_t soap_flag_mapsTo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mapsFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:mapsFrom", &a->uom10__mapFromToClass::mapsFrom, "uom10:collapsedNonEmptyString"))
				{	soap_flag_mapsFrom1--;
					continue;
				}
			}
			if (soap_flag_mapsTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "uom10:mapsTo", &a->uom10__mapFromToClass::mapsTo, "xsd:string"))
				{	soap_flag_mapsTo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_mapsFrom1 > 0 || soap_flag_mapsTo1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__mapFromToClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, sizeof(uom10__mapFromToClass), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__mapFromToClass * SOAP_FMAC2 soap_instantiate_uom10__mapFromToClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__mapFromToClass(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__mapFromToClass *p;
	size_t k = sizeof(uom10__mapFromToClass);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__mapFromToClass);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__mapFromToClass, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__mapFromToClass location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__mapFromToClass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__mapFromToClass(soap, tag ? tag : "uom10:mapFromToClass", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__mapFromToClass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__mapFromToClass(soap, this, tag, type);
}

SOAP_FMAC3 uom10__mapFromToClass * SOAP_FMAC4 soap_get_uom10__mapFromToClass(struct soap *soap, uom10__mapFromToClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__mapFromToClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__classMappingSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__descriptionString(soap, &this->uom10__classMappingSet::title);
	soap_default_uom10__nameString(soap, &this->uom10__classMappingSet::originator);
	soap_default_uom10__commentString(soap, &this->uom10__classMappingSet::description);
	soap_default_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap, &this->uom10__classMappingSet::classMap);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__classMappingSet::version);
}

void uom10__classMappingSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_uom10__descriptionString(soap, &this->uom10__classMappingSet::title);
	soap_embedded(soap, &this->uom10__classMappingSet::originator, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__classMappingSet::originator);
	soap_serialize_uom10__commentString(soap, &this->uom10__classMappingSet::description);
	soap_serialize_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap, &this->uom10__classMappingSet::classMap);
#endif
}

int uom10__classMappingSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__classMappingSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__classMappingSet(struct soap *soap, const char *tag, int id, const uom10__classMappingSet *a, const char *type)
{
	if (!type)
		type = "uom10:classMappingSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__classMappingSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet), type))
		return soap->error;
	if (soap_out_uom10__descriptionString(soap, "uom10:title", -1, &a->uom10__classMappingSet::title, "uom10:descriptionString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:originator", -1, &a->uom10__classMappingSet::originator, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__commentString(soap, "uom10:description", -1, &a->uom10__classMappingSet::description, "uom10:commentString"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap, "uom10:classMap", -1, &a->uom10__classMappingSet::classMap, "uom10:mapFromToClass"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__classMappingSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__classMappingSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__classMappingSet * SOAP_FMAC4 soap_in_uom10__classMappingSet(struct soap *soap, const char *tag, uom10__classMappingSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__classMappingSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, sizeof(uom10__classMappingSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__classMappingSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__classMappingSet*)a)->version))
		return NULL;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_originator1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__descriptionString(soap, "uom10:title", &a->uom10__classMappingSet::title, "uom10:descriptionString"))
				{	soap_flag_title1--;
					continue;
				}
			}
			if (soap_flag_originator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:originator", &a->uom10__classMappingSet::originator, "uom10:nameString"))
				{	soap_flag_originator1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__commentString(soap, "uom10:description", &a->uom10__classMappingSet::description, "uom10:commentString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap, "uom10:classMap", &a->uom10__classMappingSet::classMap, "uom10:mapFromToClass"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_title1 > 0 || soap_flag_originator1 > 0 || soap_flag_description1 > 0 || a->uom10__classMappingSet::classMap.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__classMappingSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, sizeof(uom10__classMappingSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__classMappingSet * SOAP_FMAC2 soap_instantiate_uom10__classMappingSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__classMappingSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__classMappingSet *p;
	size_t k = sizeof(uom10__classMappingSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__classMappingSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__classMappingSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__classMappingSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__classMappingSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__classMappingSet(soap, tag ? tag : "uom10:classMappingSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__classMappingSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__classMappingSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__classMappingSet * SOAP_FMAC4 soap_get_uom10__classMappingSet(struct soap *soap, uom10__classMappingSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__classMappingSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__mapFromToUnit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__mapFromToUnit::mapsFrom);
	soap_default_std__string(soap, &this->uom10__mapFromToUnit::mapsTo);
	soap_default_uom10__stateEnum(soap, &this->uom10__mapFromToUnit::state);
	this->uom10__mapFromToUnit::note = NULL;
}

void uom10__mapFromToUnit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__mapFromToUnit::mapsFrom, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__mapFromToUnit::mapsFrom);
	soap_embedded(soap, &this->uom10__mapFromToUnit::mapsTo, SOAP_TYPE_gsoap_uom1_0_std__string);
	soap_serialize_std__string(soap, &this->uom10__mapFromToUnit::mapsTo);
	soap_serialize_PointerTostd__string(soap, &this->uom10__mapFromToUnit::note);
#endif
}

int uom10__mapFromToUnit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__mapFromToUnit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__mapFromToUnit(struct soap *soap, const char *tag, int id, const uom10__mapFromToUnit *a, const char *type)
{
	if (!type)
		type = "uom10:mapFromToUnit";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit), type))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:mapsFrom", -1, &a->uom10__mapFromToUnit::mapsFrom, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_std__string(soap, "uom10:mapsTo", -1, &a->uom10__mapFromToUnit::mapsTo, "xsd:string"))
		return soap->error;
	if (soap_out_uom10__stateEnum(soap, "uom10:state", -1, &a->uom10__mapFromToUnit::state, "uom10:stateEnum"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uom10:note", -1, &a->uom10__mapFromToUnit::note, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__mapFromToUnit::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__mapFromToUnit(soap, tag, this, type);
}

SOAP_FMAC3 uom10__mapFromToUnit * SOAP_FMAC4 soap_in_uom10__mapFromToUnit(struct soap *soap, const char *tag, uom10__mapFromToUnit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__mapFromToUnit*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, sizeof(uom10__mapFromToUnit), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__mapFromToUnit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mapsFrom1 = 1;
	size_t soap_flag_mapsTo1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_note1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mapsFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:mapsFrom", &a->uom10__mapFromToUnit::mapsFrom, "uom10:collapsedNonEmptyString"))
				{	soap_flag_mapsFrom1--;
					continue;
				}
			}
			if (soap_flag_mapsTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "uom10:mapsTo", &a->uom10__mapFromToUnit::mapsTo, "xsd:string"))
				{	soap_flag_mapsTo1--;
					continue;
				}
			}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_uom10__stateEnum(soap, "uom10:state", &a->uom10__mapFromToUnit::state, "uom10:stateEnum"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "uom10:note", &a->uom10__mapFromToUnit::note, "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_mapsFrom1 > 0 || soap_flag_mapsTo1 > 0 || soap_flag_state1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__mapFromToUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, sizeof(uom10__mapFromToUnit), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__mapFromToUnit * SOAP_FMAC2 soap_instantiate_uom10__mapFromToUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__mapFromToUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__mapFromToUnit *p;
	size_t k = sizeof(uom10__mapFromToUnit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__mapFromToUnit);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__mapFromToUnit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__mapFromToUnit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__mapFromToUnit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__mapFromToUnit(soap, tag ? tag : "uom10:mapFromToUnit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__mapFromToUnit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__mapFromToUnit(soap, this, tag, type);
}

SOAP_FMAC3 uom10__mapFromToUnit * SOAP_FMAC4 soap_get_uom10__mapFromToUnit(struct soap *soap, uom10__mapFromToUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__mapFromToUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitMappingSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__descriptionString(soap, &this->uom10__unitMappingSet::title);
	soap_default_uom10__nameString(soap, &this->uom10__unitMappingSet::originator);
	soap_default_uom10__commentString(soap, &this->uom10__unitMappingSet::description);
	soap_default_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap, &this->uom10__unitMappingSet::unitMap);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__unitMappingSet::version);
}

void uom10__unitMappingSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_uom10__descriptionString(soap, &this->uom10__unitMappingSet::title);
	soap_embedded(soap, &this->uom10__unitMappingSet::originator, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__unitMappingSet::originator);
	soap_serialize_uom10__commentString(soap, &this->uom10__unitMappingSet::description);
	soap_serialize_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap, &this->uom10__unitMappingSet::unitMap);
#endif
}

int uom10__unitMappingSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitMappingSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitMappingSet(struct soap *soap, const char *tag, int id, const uom10__unitMappingSet *a, const char *type)
{
	if (!type)
		type = "uom10:unitMappingSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__unitMappingSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet), type))
		return soap->error;
	if (soap_out_uom10__descriptionString(soap, "uom10:title", -1, &a->uom10__unitMappingSet::title, "uom10:descriptionString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:originator", -1, &a->uom10__unitMappingSet::originator, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__commentString(soap, "uom10:description", -1, &a->uom10__unitMappingSet::description, "uom10:commentString"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap, "uom10:unitMap", -1, &a->uom10__unitMappingSet::unitMap, "uom10:mapFromToUnit"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitMappingSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitMappingSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitMappingSet * SOAP_FMAC4 soap_in_uom10__unitMappingSet(struct soap *soap, const char *tag, uom10__unitMappingSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitMappingSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, sizeof(uom10__unitMappingSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitMappingSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__unitMappingSet*)a)->version))
		return NULL;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_originator1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__descriptionString(soap, "uom10:title", &a->uom10__unitMappingSet::title, "uom10:descriptionString"))
				{	soap_flag_title1--;
					continue;
				}
			}
			if (soap_flag_originator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:originator", &a->uom10__unitMappingSet::originator, "uom10:nameString"))
				{	soap_flag_originator1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__commentString(soap, "uom10:description", &a->uom10__unitMappingSet::description, "uom10:commentString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap, "uom10:unitMap", &a->uom10__unitMappingSet::unitMap, "uom10:mapFromToUnit"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_title1 > 0 || soap_flag_originator1 > 0 || soap_flag_description1 > 0 || a->uom10__unitMappingSet::unitMap.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitMappingSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, sizeof(uom10__unitMappingSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitMappingSet * SOAP_FMAC2 soap_instantiate_uom10__unitMappingSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitMappingSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitMappingSet *p;
	size_t k = sizeof(uom10__unitMappingSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitMappingSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitMappingSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitMappingSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitMappingSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitMappingSet(soap, tag ? tag : "uom10:unitMappingSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitMappingSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitMappingSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitMappingSet * SOAP_FMAC4 soap_get_uom10__unitMappingSet(struct soap *soap, uom10__unitMappingSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitMappingSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__unitCode::term);
	soap_default_xsd__positiveInteger(soap, &this->uom10__unitCode::code);
	this->uom10__unitCode::deprecated = NULL;
}

void uom10__unitCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__unitCode::term, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__unitCode::term);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unitCode::deprecated);
#endif
}

int uom10__unitCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitCode(struct soap *soap, const char *tag, int id, const uom10__unitCode *a, const char *type)
{
	if (!type)
		type = "uom10:unitCode";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode), type))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:term", -1, &a->uom10__unitCode::term, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "uom10:code", -1, &a->uom10__unitCode::code, "xsd:positiveInteger"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:deprecated", -1, &a->uom10__unitCode::deprecated, "uom10:collapsedNonEmptyString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitCode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitCode(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitCode * SOAP_FMAC4 soap_in_uom10__unitCode(struct soap *soap, const char *tag, uom10__unitCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, sizeof(uom10__unitCode), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_term1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_deprecated1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:term", &a->uom10__unitCode::term, "uom10:collapsedNonEmptyString"))
				{	soap_flag_term1--;
					continue;
				}
			}
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__positiveInteger(soap, "uom10:code", &a->uom10__unitCode::code, "xsd:positiveInteger"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_deprecated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:deprecated", &a->uom10__unitCode::deprecated, "uom10:collapsedNonEmptyString"))
				{	soap_flag_deprecated1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_term1 > 0 || soap_flag_code1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, sizeof(uom10__unitCode), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitCode * SOAP_FMAC2 soap_instantiate_uom10__unitCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitCode *p;
	size_t k = sizeof(uom10__unitCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitCode(soap, tag ? tag : "uom10:unitCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitCode(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitCode * SOAP_FMAC4 soap_get_uom10__unitCode(struct soap *soap, uom10__unitCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__classCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__classCode::term);
	soap_default_xsd__positiveInteger(soap, &this->uom10__classCode::code);
	this->uom10__classCode::deprecated = NULL;
	this->uom10__classCode::unit = NULL;
}

void uom10__classCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__classCode::term, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__classCode::term);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__classCode::deprecated);
	soap_serialize_PointerTouom10__unitCodeStruct(soap, &this->uom10__classCode::unit);
#endif
}

int uom10__classCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__classCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__classCode(struct soap *soap, const char *tag, int id, const uom10__classCode *a, const char *type)
{
	if (!type)
		type = "uom10:classCode";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classCode), type))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:term", -1, &a->uom10__classCode::term, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "uom10:code", -1, &a->uom10__classCode::code, "xsd:positiveInteger"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:deprecated", -1, &a->uom10__classCode::deprecated, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (!a->uom10__classCode::unit)
	{	if (soap_element_empty(soap, "uom10:unit", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__unitCodeStruct(soap, "uom10:unit", -1, &a->uom10__classCode::unit, "uom10:unitCodeStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__classCode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__classCode(soap, tag, this, type);
}

SOAP_FMAC3 uom10__classCode * SOAP_FMAC4 soap_in_uom10__classCode(struct soap *soap, const char *tag, uom10__classCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__classCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, sizeof(uom10__classCode), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__classCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__classCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_term1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_deprecated1 = 1;
	size_t soap_flag_unit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_term1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:term", &a->uom10__classCode::term, "uom10:collapsedNonEmptyString"))
				{	soap_flag_term1--;
					continue;
				}
			}
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__positiveInteger(soap, "uom10:code", &a->uom10__classCode::code, "xsd:positiveInteger"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_deprecated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:deprecated", &a->uom10__classCode::deprecated, "uom10:collapsedNonEmptyString"))
				{	soap_flag_deprecated1--;
					continue;
				}
			}
			if (soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__unitCodeStruct(soap, "uom10:unit", &a->uom10__classCode::unit, "uom10:unitCodeStruct"))
				{	soap_flag_unit1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_term1 > 0 || soap_flag_code1 > 0 || !a->uom10__classCode::unit))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__classCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, sizeof(uom10__classCode), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__classCode * SOAP_FMAC2 soap_instantiate_uom10__classCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__classCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__classCode *p;
	size_t k = sizeof(uom10__classCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__classCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__classCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__classCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__classCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__classCode(soap, tag ? tag : "uom10:classCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__classCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__classCode(soap, this, tag, type);
}

SOAP_FMAC3 uom10__classCode * SOAP_FMAC4 soap_get_uom10__classCode(struct soap *soap, uom10__classCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__classCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitCodeSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__unitCode(soap, &this->uom10__unitCodeSet::unitCode);
}

void uom10__unitCodeSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__unitCode(soap, &this->uom10__unitCodeSet::unitCode);
#endif
}

int uom10__unitCodeSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitCodeSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitCodeSet(struct soap *soap, const char *tag, int id, const uom10__unitCodeSet *a, const char *type)
{
	if (!type)
		type = "uom10:unitCodeSet";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__unitCode(soap, "uom10:unitCode", -1, &a->uom10__unitCodeSet::unitCode, "uom10:unitCode"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitCodeSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitCodeSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitCodeSet * SOAP_FMAC4 soap_in_uom10__unitCodeSet(struct soap *soap, const char *tag, uom10__unitCodeSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitCodeSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, sizeof(uom10__unitCodeSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitCodeSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__unitCode(soap, "uom10:unitCode", &a->uom10__unitCodeSet::unitCode, "uom10:unitCode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__unitCodeSet::unitCode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitCodeSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, sizeof(uom10__unitCodeSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitCodeSet * SOAP_FMAC2 soap_instantiate_uom10__unitCodeSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitCodeSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitCodeSet *p;
	size_t k = sizeof(uom10__unitCodeSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitCodeSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitCodeSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitCodeSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitCodeSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitCodeSet(soap, tag ? tag : "uom10:unitCodeSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitCodeSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitCodeSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitCodeSet * SOAP_FMAC4 soap_get_uom10__unitCodeSet(struct soap *soap, uom10__unitCodeSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__classCodeSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__classCode(soap, &this->uom10__classCodeSet::classCode);
}

void uom10__classCodeSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__classCode(soap, &this->uom10__classCodeSet::classCode);
#endif
}

int uom10__classCodeSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__classCodeSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__classCodeSet(struct soap *soap, const char *tag, int id, const uom10__classCodeSet *a, const char *type)
{
	if (!type)
		type = "uom10:classCodeSet";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__classCode(soap, "uom10:classCode", -1, &a->uom10__classCodeSet::classCode, "uom10:classCode"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__classCodeSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__classCodeSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__classCodeSet * SOAP_FMAC4 soap_in_uom10__classCodeSet(struct soap *soap, const char *tag, uom10__classCodeSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__classCodeSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, sizeof(uom10__classCodeSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__classCodeSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__classCode(soap, "uom10:classCode", &a->uom10__classCodeSet::classCode, "uom10:classCode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__classCodeSet::classCode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__classCodeSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, sizeof(uom10__classCodeSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__classCodeSet * SOAP_FMAC2 soap_instantiate_uom10__classCodeSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__classCodeSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__classCodeSet *p;
	size_t k = sizeof(uom10__classCodeSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__classCodeSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__classCodeSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__classCodeSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__classCodeSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__classCodeSet(soap, tag ? tag : "uom10:classCodeSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__classCodeSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__classCodeSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__classCodeSet * SOAP_FMAC4 soap_get_uom10__classCodeSet(struct soap *soap, uom10__classCodeSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__classCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__integerCodeSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__descriptionString(soap, &this->uom10__integerCodeSet::title);
	soap_default_uom10__nameString(soap, &this->uom10__integerCodeSet::originator);
	soap_default_uom10__commentString(soap, &this->uom10__integerCodeSet::description);
	this->uom10__integerCodeSet::classCodeSet = NULL;
	this->uom10__integerCodeSet::unitCodeSet = NULL;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__integerCodeSet::version);
}

void uom10__integerCodeSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_uom10__descriptionString(soap, &this->uom10__integerCodeSet::title);
	soap_embedded(soap, &this->uom10__integerCodeSet::originator, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__integerCodeSet::originator);
	soap_serialize_uom10__commentString(soap, &this->uom10__integerCodeSet::description);
	soap_serialize_PointerTouom10__classCodeSet(soap, &this->uom10__integerCodeSet::classCodeSet);
	soap_serialize_PointerTouom10__unitCodeSet(soap, &this->uom10__integerCodeSet::unitCodeSet);
#endif
}

int uom10__integerCodeSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__integerCodeSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__integerCodeSet(struct soap *soap, const char *tag, int id, const uom10__integerCodeSet *a, const char *type)
{
	if (!type)
		type = "uom10:integerCodeSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__integerCodeSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet), type))
		return soap->error;
	if (soap_out_uom10__descriptionString(soap, "uom10:title", -1, &a->uom10__integerCodeSet::title, "uom10:descriptionString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:originator", -1, &a->uom10__integerCodeSet::originator, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__commentString(soap, "uom10:description", -1, &a->uom10__integerCodeSet::description, "uom10:commentString"))
		return soap->error;
	if (!a->uom10__integerCodeSet::classCodeSet)
	{	if (soap_element_empty(soap, "uom10:classCodeSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__classCodeSet(soap, "uom10:classCodeSet", -1, &a->uom10__integerCodeSet::classCodeSet, "uom10:classCodeSet"))
		return soap->error;
	if (!a->uom10__integerCodeSet::unitCodeSet)
	{	if (soap_element_empty(soap, "uom10:unitCodeSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__unitCodeSet(soap, "uom10:unitCodeSet", -1, &a->uom10__integerCodeSet::unitCodeSet, "uom10:unitCodeSet"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__integerCodeSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__integerCodeSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__integerCodeSet * SOAP_FMAC4 soap_in_uom10__integerCodeSet(struct soap *soap, const char *tag, uom10__integerCodeSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__integerCodeSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, sizeof(uom10__integerCodeSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__integerCodeSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__integerCodeSet*)a)->version))
		return NULL;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_originator1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_classCodeSet1 = 1;
	size_t soap_flag_unitCodeSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__descriptionString(soap, "uom10:title", &a->uom10__integerCodeSet::title, "uom10:descriptionString"))
				{	soap_flag_title1--;
					continue;
				}
			}
			if (soap_flag_originator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:originator", &a->uom10__integerCodeSet::originator, "uom10:nameString"))
				{	soap_flag_originator1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__commentString(soap, "uom10:description", &a->uom10__integerCodeSet::description, "uom10:commentString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap_flag_classCodeSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__classCodeSet(soap, "uom10:classCodeSet", &a->uom10__integerCodeSet::classCodeSet, "uom10:classCodeSet"))
				{	soap_flag_classCodeSet1--;
					continue;
				}
			}
			if (soap_flag_unitCodeSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__unitCodeSet(soap, "uom10:unitCodeSet", &a->uom10__integerCodeSet::unitCodeSet, "uom10:unitCodeSet"))
				{	soap_flag_unitCodeSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_title1 > 0 || soap_flag_originator1 > 0 || soap_flag_description1 > 0 || !a->uom10__integerCodeSet::classCodeSet || !a->uom10__integerCodeSet::unitCodeSet))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__integerCodeSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, sizeof(uom10__integerCodeSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__integerCodeSet * SOAP_FMAC2 soap_instantiate_uom10__integerCodeSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__integerCodeSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__integerCodeSet *p;
	size_t k = sizeof(uom10__integerCodeSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__integerCodeSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__integerCodeSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__integerCodeSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__integerCodeSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__integerCodeSet(soap, tag ? tag : "uom10:integerCodeSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__integerCodeSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__integerCodeSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__integerCodeSet * SOAP_FMAC4 soap_get_uom10__integerCodeSet(struct soap *soap, uom10__integerCodeSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__integerCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__prefix::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__symbolString(soap, &this->uom10__prefix::symbol);
	soap_default_uom10__nameString(soap, &this->uom10__prefix::name);
	soap_default_uom10__nameString(soap, &this->uom10__prefix::multiplier);
	this->uom10__prefix::commonName = NULL;
}

void uom10__prefix::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__prefix::symbol, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString);
	soap_serialize_uom10__symbolString(soap, &this->uom10__prefix::symbol);
	soap_embedded(soap, &this->uom10__prefix::name, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__prefix::name);
	soap_embedded(soap, &this->uom10__prefix::multiplier, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__prefix::multiplier);
	soap_serialize_PointerTouom10__nameString(soap, &this->uom10__prefix::commonName);
#endif
}

int uom10__prefix::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__prefix(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__prefix(struct soap *soap, const char *tag, int id, const uom10__prefix *a, const char *type)
{
	if (!type)
		type = "uom10:prefix";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__prefix), type))
		return soap->error;
	if (soap_out_uom10__symbolString(soap, "uom10:symbol", -1, &a->uom10__prefix::symbol, "uom10:symbolString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:name", -1, &a->uom10__prefix::name, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:multiplier", -1, &a->uom10__prefix::multiplier, "uom10:nameString"))
		return soap->error;
	if (soap_out_PointerTouom10__nameString(soap, "uom10:commonName", -1, &a->uom10__prefix::commonName, "uom10:nameString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__prefix::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__prefix(soap, tag, this, type);
}

SOAP_FMAC3 uom10__prefix * SOAP_FMAC4 soap_in_uom10__prefix(struct soap *soap, const char *tag, uom10__prefix *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__prefix*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, sizeof(uom10__prefix), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__prefix)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__prefix *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_symbol1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_multiplier1 = 1;
	size_t soap_flag_commonName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__symbolString(soap, "uom10:symbol", &a->uom10__prefix::symbol, "uom10:symbolString"))
				{	soap_flag_symbol1--;
					continue;
				}
			}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:name", &a->uom10__prefix::name, "uom10:nameString"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_multiplier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:multiplier", &a->uom10__prefix::multiplier, "uom10:nameString"))
				{	soap_flag_multiplier1--;
					continue;
				}
			}
			if (soap_flag_commonName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__nameString(soap, "uom10:commonName", &a->uom10__prefix::commonName, "uom10:nameString"))
				{	soap_flag_commonName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_symbol1 > 0 || soap_flag_name1 > 0 || soap_flag_multiplier1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__prefix *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, sizeof(uom10__prefix), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__prefix * SOAP_FMAC2 soap_instantiate_uom10__prefix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__prefix(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__prefix *p;
	size_t k = sizeof(uom10__prefix);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__prefix);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__prefix, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__prefix location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__prefix::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__prefix(soap, tag ? tag : "uom10:prefix", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__prefix::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__prefix(soap, this, tag, type);
}

SOAP_FMAC3 uom10__prefix * SOAP_FMAC4 soap_get_uom10__prefix(struct soap *soap, uom10__prefix *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__prefix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__prefixSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__prefix(soap, &this->uom10__prefixSet::prefix);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__prefixSet::version);
}

void uom10__prefixSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__prefix(soap, &this->uom10__prefixSet::prefix);
#endif
}

int uom10__prefixSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__prefixSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__prefixSet(struct soap *soap, const char *tag, int id, const uom10__prefixSet *a, const char *type)
{
	if (!type)
		type = "uom10:prefixSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__prefixSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__prefix(soap, "uom10:prefix", -1, &a->uom10__prefixSet::prefix, "uom10:prefix"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__prefixSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__prefixSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__prefixSet * SOAP_FMAC4 soap_in_uom10__prefixSet(struct soap *soap, const char *tag, uom10__prefixSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__prefixSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, sizeof(uom10__prefixSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__prefixSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__prefixSet*)a)->version))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__prefix(soap, "uom10:prefix", &a->uom10__prefixSet::prefix, "uom10:prefix"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__prefixSet::prefix.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__prefixSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, sizeof(uom10__prefixSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__prefixSet * SOAP_FMAC2 soap_instantiate_uom10__prefixSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__prefixSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__prefixSet *p;
	size_t k = sizeof(uom10__prefixSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__prefixSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__prefixSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__prefixSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__prefixSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__prefixSet(soap, tag ? tag : "uom10:prefixSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__prefixSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__prefixSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__prefixSet * SOAP_FMAC4 soap_get_uom10__prefixSet(struct soap *soap, uom10__prefixSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__prefixSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__reference::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__reference::ID);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__reference::description);
}

void uom10__reference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__reference::ID, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__reference::ID);
	soap_embedded(soap, &this->uom10__reference::description, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__reference::description);
#endif
}

int uom10__reference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__reference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__reference(struct soap *soap, const char *tag, int id, const uom10__reference *a, const char *type)
{
	if (!type)
		type = "uom10:reference";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__reference), type))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:ID", -1, &a->uom10__reference::ID, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:description", -1, &a->uom10__reference::description, "uom10:collapsedNonEmptyString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__reference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__reference(soap, tag, this, type);
}

SOAP_FMAC3 uom10__reference * SOAP_FMAC4 soap_in_uom10__reference(struct soap *soap, const char *tag, uom10__reference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__reference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__reference, sizeof(uom10__reference), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__reference)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__reference *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:ID", &a->uom10__reference::ID, "uom10:collapsedNonEmptyString"))
				{	soap_flag_ID1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:description", &a->uom10__reference::description, "uom10:collapsedNonEmptyString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_ID1 > 0 || soap_flag_description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__reference, SOAP_TYPE_gsoap_uom1_0_uom10__reference, sizeof(uom10__reference), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__reference * SOAP_FMAC2 soap_instantiate_uom10__reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__reference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__reference *p;
	size_t k = sizeof(uom10__reference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__reference, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__reference);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__reference, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__reference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__reference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__reference(soap, tag ? tag : "uom10:reference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__reference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__reference(soap, this, tag, type);
}

SOAP_FMAC3 uom10__reference * SOAP_FMAC4 soap_get_uom10__reference(struct soap *soap, uom10__reference *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__referenceSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__reference(soap, &this->uom10__referenceSet::reference);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__referenceSet::version);
}

void uom10__referenceSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__reference(soap, &this->uom10__referenceSet::reference);
#endif
}

int uom10__referenceSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__referenceSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__referenceSet(struct soap *soap, const char *tag, int id, const uom10__referenceSet *a, const char *type)
{
	if (!type)
		type = "uom10:referenceSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__referenceSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__reference(soap, "uom10:reference", -1, &a->uom10__referenceSet::reference, "uom10:reference"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__referenceSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__referenceSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__referenceSet * SOAP_FMAC4 soap_in_uom10__referenceSet(struct soap *soap, const char *tag, uom10__referenceSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__referenceSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, sizeof(uom10__referenceSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__referenceSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__referenceSet*)a)->version))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__reference(soap, "uom10:reference", &a->uom10__referenceSet::reference, "uom10:reference"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__referenceSet::reference.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__referenceSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, sizeof(uom10__referenceSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__referenceSet * SOAP_FMAC2 soap_instantiate_uom10__referenceSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__referenceSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__referenceSet *p;
	size_t k = sizeof(uom10__referenceSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__referenceSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__referenceSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__referenceSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__referenceSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__referenceSet(soap, tag ? tag : "uom10:referenceSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__referenceSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__referenceSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__referenceSet * SOAP_FMAC4 soap_get_uom10__referenceSet(struct soap *soap, uom10__referenceSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__referenceSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unit::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__symbolString(soap, &this->uom10__unit::symbol);
	soap_default_uom10__nameString(soap, &this->uom10__unit::name);
	soap_default_uom10__quantityDimension(soap, &this->uom10__unit::dimension);
	soap_default_bool(soap, &this->uom10__unit::isSI);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__unit::category);
	this->uom10__unit::isBase = NULL;
	this->uom10__unit::baseUnit = NULL;
	this->uom10__unit::conversionRef = NULL;
	this->uom10__unit::isExact = NULL;
	this->uom10__unit::A = NULL;
	this->uom10__unit::B = NULL;
	this->uom10__unit::C = NULL;
	this->uom10__unit::D = NULL;
	this->uom10__unit::underlyingDef = NULL;
	this->uom10__unit::description = NULL;
}

void uom10__unit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__unit::symbol, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString);
	soap_serialize_uom10__symbolString(soap, &this->uom10__unit::symbol);
	soap_embedded(soap, &this->uom10__unit::name, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__unit::name);
	soap_serialize_uom10__quantityDimension(soap, &this->uom10__unit::dimension);
	soap_embedded(soap, &this->uom10__unit::isSI, SOAP_TYPE_gsoap_uom1_0_bool);
	soap_embedded(soap, &this->uom10__unit::category, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString);
	soap_serialize_uom10__collapsedNonEmptyString(soap, &this->uom10__unit::category);
	soap_serialize_PointerTouom10__emptyElement(soap, &this->uom10__unit::isBase);
	soap_serialize_PointerTouom10__symbolString(soap, &this->uom10__unit::baseUnit);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::conversionRef);
	soap_serialize_PointerTobool(soap, &this->uom10__unit::isExact);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::A);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::B);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::C);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::D);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::underlyingDef);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unit::description);
#endif
}

int uom10__unit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unit(struct soap *soap, const char *tag, int id, const uom10__unit *a, const char *type)
{
	if (!type)
		type = "uom10:unit";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unit), type))
		return soap->error;
	if (soap_out_uom10__symbolString(soap, "uom10:symbol", -1, &a->uom10__unit::symbol, "uom10:symbolString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:name", -1, &a->uom10__unit::name, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__quantityDimension(soap, "uom10:dimension", -1, &a->uom10__unit::dimension, "uom10:quantityDimension"))
		return soap->error;
	if (soap_out_bool(soap, "uom10:isSI", -1, &a->uom10__unit::isSI, "xsd:boolean"))
		return soap->error;
	if (soap_out_uom10__collapsedNonEmptyString(soap, "uom10:category", -1, &a->uom10__unit::category, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__emptyElement(soap, "uom10:isBase", -1, &a->uom10__unit::isBase, "uom10:emptyElement"))
		return soap->error;
	if (soap_out_PointerTouom10__symbolString(soap, "uom10:baseUnit", -1, &a->uom10__unit::baseUnit, "uom10:symbolString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:conversionRef", -1, &a->uom10__unit::conversionRef, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "uom10:isExact", -1, &a->uom10__unit::isExact, "xsd:boolean"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:A", -1, &a->uom10__unit::A, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:B", -1, &a->uom10__unit::B, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:C", -1, &a->uom10__unit::C, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:D", -1, &a->uom10__unit::D, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:underlyingDef", -1, &a->uom10__unit::underlyingDef, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", -1, &a->uom10__unit::description, "uom10:collapsedNonEmptyString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unit::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unit(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unit * SOAP_FMAC4 soap_in_uom10__unit(struct soap *soap, const char *tag, uom10__unit *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unit*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unit, sizeof(uom10__unit), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unit)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unit *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_symbol1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_dimension1 = 1;
	size_t soap_flag_isSI1 = 1;
	size_t soap_flag_category1 = 1;
	size_t soap_flag_isBase1 = 1;
	size_t soap_flag_baseUnit1 = 1;
	size_t soap_flag_conversionRef1 = 1;
	size_t soap_flag_isExact1 = 1;
	size_t soap_flag_A1 = 1;
	size_t soap_flag_B1 = 1;
	size_t soap_flag_C1 = 1;
	size_t soap_flag_D1 = 1;
	size_t soap_flag_underlyingDef1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_symbol1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__symbolString(soap, "uom10:symbol", &a->uom10__unit::symbol, "uom10:symbolString"))
				{	soap_flag_symbol1--;
					continue;
				}
			}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:name", &a->uom10__unit::name, "uom10:nameString"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_dimension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__quantityDimension(soap, "uom10:dimension", &a->uom10__unit::dimension, "uom10:quantityDimension"))
				{	soap_flag_dimension1--;
					continue;
				}
			}
			if (soap_flag_isSI1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "uom10:isSI", &a->uom10__unit::isSI, "xsd:boolean"))
				{	soap_flag_isSI1--;
					continue;
				}
			}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__collapsedNonEmptyString(soap, "uom10:category", &a->uom10__unit::category, "uom10:collapsedNonEmptyString"))
				{	soap_flag_category1--;
					continue;
				}
			}
			if (soap_flag_isBase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__emptyElement(soap, "uom10:isBase", &a->uom10__unit::isBase, "uom10:emptyElement"))
				{	soap_flag_isBase1--;
					continue;
				}
			}
			if (soap_flag_baseUnit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__symbolString(soap, "uom10:baseUnit", &a->uom10__unit::baseUnit, "uom10:symbolString"))
				{	soap_flag_baseUnit1--;
					continue;
				}
			}
			if (soap_flag_conversionRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:conversionRef", &a->uom10__unit::conversionRef, "uom10:collapsedNonEmptyString"))
				{	soap_flag_conversionRef1--;
					continue;
				}
			}
			if (soap_flag_isExact1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "uom10:isExact", &a->uom10__unit::isExact, "xsd:boolean"))
				{	soap_flag_isExact1--;
					continue;
				}
			}
			if (soap_flag_A1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:A", &a->uom10__unit::A, "uom10:collapsedNonEmptyString"))
				{	soap_flag_A1--;
					continue;
				}
			}
			if (soap_flag_B1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:B", &a->uom10__unit::B, "uom10:collapsedNonEmptyString"))
				{	soap_flag_B1--;
					continue;
				}
			}
			if (soap_flag_C1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:C", &a->uom10__unit::C, "uom10:collapsedNonEmptyString"))
				{	soap_flag_C1--;
					continue;
				}
			}
			if (soap_flag_D1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:D", &a->uom10__unit::D, "uom10:collapsedNonEmptyString"))
				{	soap_flag_D1--;
					continue;
				}
			}
			if (soap_flag_underlyingDef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:underlyingDef", &a->uom10__unit::underlyingDef, "uom10:collapsedNonEmptyString"))
				{	soap_flag_underlyingDef1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", &a->uom10__unit::description, "uom10:collapsedNonEmptyString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_symbol1 > 0 || soap_flag_name1 > 0 || soap_flag_dimension1 > 0 || soap_flag_isSI1 > 0 || soap_flag_category1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unit, SOAP_TYPE_gsoap_uom1_0_uom10__unit, sizeof(uom10__unit), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unit * SOAP_FMAC2 soap_instantiate_uom10__unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unit *p;
	size_t k = sizeof(uom10__unit);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unit, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unit);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unit, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unit location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unit(soap, tag ? tag : "uom10:unit", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unit(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unit * SOAP_FMAC4 soap_get_uom10__unit(struct soap *soap, uom10__unit *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__unit(soap, &this->uom10__unitSet::unit);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__unitSet::version);
}

void uom10__unitSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__unit(soap, &this->uom10__unitSet::unit);
#endif
}

int uom10__unitSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitSet(struct soap *soap, const char *tag, int id, const uom10__unitSet *a, const char *type)
{
	if (!type)
		type = "uom10:unitSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__unitSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__unit(soap, "uom10:unit", -1, &a->uom10__unitSet::unit, "uom10:unit"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitSet * SOAP_FMAC4 soap_in_uom10__unitSet(struct soap *soap, const char *tag, uom10__unitSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, sizeof(uom10__unitSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__unitSet*)a)->version))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__unit(soap, "uom10:unit", &a->uom10__unitSet::unit, "uom10:unit"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__unitSet::unit.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, sizeof(uom10__unitSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitSet * SOAP_FMAC2 soap_instantiate_uom10__unitSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitSet *p;
	size_t k = sizeof(uom10__unitSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitSet(soap, tag ? tag : "uom10:unitSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitSet * SOAP_FMAC4 soap_get_uom10__unitSet(struct soap *soap, uom10__unitSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__quantityClass::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__nameString(soap, &this->uom10__quantityClass::name);
	soap_default_uom10__quantityDimension(soap, &this->uom10__quantityClass::dimension);
	soap_default_uom10__symbolString(soap, &this->uom10__quantityClass::baseForConversion);
	this->uom10__quantityClass::alternativeBase = NULL;
	this->uom10__quantityClass::description = NULL;
	soap_default_std__vectorTemplateOfuom10__symbolString(soap, &this->uom10__quantityClass::memberUnit);
}

void uom10__quantityClass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__quantityClass::name, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__quantityClass::name);
	soap_serialize_uom10__quantityDimension(soap, &this->uom10__quantityClass::dimension);
	soap_embedded(soap, &this->uom10__quantityClass::baseForConversion, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString);
	soap_serialize_uom10__symbolString(soap, &this->uom10__quantityClass::baseForConversion);
	soap_serialize_PointerTouom10__symbolString(soap, &this->uom10__quantityClass::alternativeBase);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__quantityClass::description);
	soap_serialize_std__vectorTemplateOfuom10__symbolString(soap, &this->uom10__quantityClass::memberUnit);
#endif
}

int uom10__quantityClass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__quantityClass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__quantityClass(struct soap *soap, const char *tag, int id, const uom10__quantityClass *a, const char *type)
{
	if (!type)
		type = "uom10:quantityClass";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass), type))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:name", -1, &a->uom10__quantityClass::name, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__quantityDimension(soap, "uom10:dimension", -1, &a->uom10__quantityClass::dimension, "uom10:quantityDimension"))
		return soap->error;
	if (soap_out_uom10__symbolString(soap, "uom10:baseForConversion", -1, &a->uom10__quantityClass::baseForConversion, "uom10:symbolString"))
		return soap->error;
	if (soap_out_PointerTouom10__symbolString(soap, "uom10:alternativeBase", -1, &a->uom10__quantityClass::alternativeBase, "uom10:symbolString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", -1, &a->uom10__quantityClass::description, "uom10:collapsedNonEmptyString"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfuom10__symbolString(soap, "uom10:memberUnit", -1, &a->uom10__quantityClass::memberUnit, "uom10:symbolString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__quantityClass::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__quantityClass(soap, tag, this, type);
}

SOAP_FMAC3 uom10__quantityClass * SOAP_FMAC4 soap_in_uom10__quantityClass(struct soap *soap, const char *tag, uom10__quantityClass *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__quantityClass*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, sizeof(uom10__quantityClass), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__quantityClass *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_dimension1 = 1;
	size_t soap_flag_baseForConversion1 = 1;
	size_t soap_flag_alternativeBase1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:name", &a->uom10__quantityClass::name, "uom10:nameString"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_dimension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__quantityDimension(soap, "uom10:dimension", &a->uom10__quantityClass::dimension, "uom10:quantityDimension"))
				{	soap_flag_dimension1--;
					continue;
				}
			}
			if (soap_flag_baseForConversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__symbolString(soap, "uom10:baseForConversion", &a->uom10__quantityClass::baseForConversion, "uom10:symbolString"))
				{	soap_flag_baseForConversion1--;
					continue;
				}
			}
			if (soap_flag_alternativeBase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__symbolString(soap, "uom10:alternativeBase", &a->uom10__quantityClass::alternativeBase, "uom10:symbolString"))
				{	soap_flag_alternativeBase1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", &a->uom10__quantityClass::description, "uom10:collapsedNonEmptyString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfuom10__symbolString(soap, "uom10:memberUnit", &a->uom10__quantityClass::memberUnit, "uom10:symbolString"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_name1 > 0 || soap_flag_dimension1 > 0 || soap_flag_baseForConversion1 > 0 || a->uom10__quantityClass::memberUnit.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__quantityClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, sizeof(uom10__quantityClass), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__quantityClass * SOAP_FMAC2 soap_instantiate_uom10__quantityClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__quantityClass(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__quantityClass *p;
	size_t k = sizeof(uom10__quantityClass);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__quantityClass);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__quantityClass, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__quantityClass location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__quantityClass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__quantityClass(soap, tag ? tag : "uom10:quantityClass", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__quantityClass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__quantityClass(soap, this, tag, type);
}

SOAP_FMAC3 uom10__quantityClass * SOAP_FMAC4 soap_get_uom10__quantityClass(struct soap *soap, uom10__quantityClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__quantityClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__quantityClassSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__quantityClass(soap, &this->uom10__quantityClassSet::quantityClass);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__quantityClassSet::version);
}

void uom10__quantityClassSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__quantityClass(soap, &this->uom10__quantityClassSet::quantityClass);
#endif
}

int uom10__quantityClassSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__quantityClassSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__quantityClassSet(struct soap *soap, const char *tag, int id, const uom10__quantityClassSet *a, const char *type)
{
	if (!type)
		type = "uom10:quantityClassSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__quantityClassSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__quantityClass(soap, "uom10:quantityClass", -1, &a->uom10__quantityClassSet::quantityClass, "uom10:quantityClass"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__quantityClassSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__quantityClassSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__quantityClassSet * SOAP_FMAC4 soap_in_uom10__quantityClassSet(struct soap *soap, const char *tag, uom10__quantityClassSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__quantityClassSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, sizeof(uom10__quantityClassSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__quantityClassSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__quantityClassSet*)a)->version))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__quantityClass(soap, "uom10:quantityClass", &a->uom10__quantityClassSet::quantityClass, "uom10:quantityClass"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__quantityClassSet::quantityClass.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__quantityClassSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, sizeof(uom10__quantityClassSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__quantityClassSet * SOAP_FMAC2 soap_instantiate_uom10__quantityClassSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__quantityClassSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__quantityClassSet *p;
	size_t k = sizeof(uom10__quantityClassSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__quantityClassSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__quantityClassSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__quantityClassSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__quantityClassSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__quantityClassSet(soap, tag ? tag : "uom10:quantityClassSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__quantityClassSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__quantityClassSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__quantityClassSet * SOAP_FMAC4 soap_get_uom10__quantityClassSet(struct soap *soap, uom10__quantityClassSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__quantityClassSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitDimension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__nameString(soap, &this->uom10__unitDimension::name);
	soap_default_uom10__quantityDimension(soap, &this->uom10__unitDimension::dimension);
	soap_default_uom10__dimemsionalSymbolString(soap, &this->uom10__unitDimension::baseForConversion);
	soap_default_uom10__dimemsionalSymbolString(soap, &this->uom10__unitDimension::canonicalUnit);
	this->uom10__unitDimension::description = NULL;
}

void uom10__unitDimension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->uom10__unitDimension::name, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__unitDimension::name);
	soap_serialize_uom10__quantityDimension(soap, &this->uom10__unitDimension::dimension);
	soap_serialize_uom10__dimemsionalSymbolString(soap, &this->uom10__unitDimension::baseForConversion);
	soap_serialize_uom10__dimemsionalSymbolString(soap, &this->uom10__unitDimension::canonicalUnit);
	soap_serialize_PointerTouom10__collapsedNonEmptyString(soap, &this->uom10__unitDimension::description);
#endif
}

int uom10__unitDimension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitDimension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitDimension(struct soap *soap, const char *tag, int id, const uom10__unitDimension *a, const char *type)
{
	if (!type)
		type = "uom10:unitDimension";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension), type))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:name", -1, &a->uom10__unitDimension::name, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__quantityDimension(soap, "uom10:dimension", -1, &a->uom10__unitDimension::dimension, "uom10:quantityDimension"))
		return soap->error;
	if (soap_out_uom10__dimemsionalSymbolString(soap, "uom10:baseForConversion", -1, &a->uom10__unitDimension::baseForConversion, "uom10:dimemsionalSymbolString"))
		return soap->error;
	if (soap_out_uom10__dimemsionalSymbolString(soap, "uom10:canonicalUnit", -1, &a->uom10__unitDimension::canonicalUnit, "uom10:dimemsionalSymbolString"))
		return soap->error;
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", -1, &a->uom10__unitDimension::description, "uom10:collapsedNonEmptyString"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitDimension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitDimension(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitDimension * SOAP_FMAC4 soap_in_uom10__unitDimension(struct soap *soap, const char *tag, uom10__unitDimension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitDimension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, sizeof(uom10__unitDimension), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitDimension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_dimension1 = 1;
	size_t soap_flag_baseForConversion1 = 1;
	size_t soap_flag_canonicalUnit1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:name", &a->uom10__unitDimension::name, "uom10:nameString"))
				{	soap_flag_name1--;
					continue;
				}
			}
			if (soap_flag_dimension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__quantityDimension(soap, "uom10:dimension", &a->uom10__unitDimension::dimension, "uom10:quantityDimension"))
				{	soap_flag_dimension1--;
					continue;
				}
			}
			if (soap_flag_baseForConversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__dimemsionalSymbolString(soap, "uom10:baseForConversion", &a->uom10__unitDimension::baseForConversion, "uom10:dimemsionalSymbolString"))
				{	soap_flag_baseForConversion1--;
					continue;
				}
			}
			if (soap_flag_canonicalUnit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__dimemsionalSymbolString(soap, "uom10:canonicalUnit", &a->uom10__unitDimension::canonicalUnit, "uom10:dimemsionalSymbolString"))
				{	soap_flag_canonicalUnit1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTouom10__collapsedNonEmptyString(soap, "uom10:description", &a->uom10__unitDimension::description, "uom10:collapsedNonEmptyString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_name1 > 0 || soap_flag_dimension1 > 0 || soap_flag_baseForConversion1 > 0 || soap_flag_canonicalUnit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitDimension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, sizeof(uom10__unitDimension), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitDimension * SOAP_FMAC2 soap_instantiate_uom10__unitDimension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitDimension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitDimension *p;
	size_t k = sizeof(uom10__unitDimension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitDimension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitDimension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitDimension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitDimension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitDimension(soap, tag ? tag : "uom10:unitDimension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitDimension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitDimension(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitDimension * SOAP_FMAC4 soap_get_uom10__unitDimension(struct soap *soap, uom10__unitDimension *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitDimension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__unitDimensionSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTouom10__unitDimension(soap, &this->uom10__unitDimensionSet::unitDimension);
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__unitDimensionSet::version);
}

void uom10__unitDimensionSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTouom10__unitDimension(soap, &this->uom10__unitDimensionSet::unitDimension);
#endif
}

int uom10__unitDimensionSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__unitDimensionSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__unitDimensionSet(struct soap *soap, const char *tag, int id, const uom10__unitDimensionSet *a, const char *type)
{
	if (!type)
		type = "uom10:unitDimensionSet";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__unitDimensionSet*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__unitDimension(soap, "uom10:unitDimension", -1, &a->uom10__unitDimensionSet::unitDimension, "uom10:unitDimension"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__unitDimensionSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__unitDimensionSet(soap, tag, this, type);
}

SOAP_FMAC3 uom10__unitDimensionSet * SOAP_FMAC4 soap_in_uom10__unitDimensionSet(struct soap *soap, const char *tag, uom10__unitDimensionSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__unitDimensionSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, sizeof(uom10__unitDimensionSet), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__unitDimensionSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__unitDimensionSet*)a)->version))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__unitDimension(soap, "uom10:unitDimension", &a->uom10__unitDimensionSet::unitDimension, "uom10:unitDimension"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->uom10__unitDimensionSet::unitDimension.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__unitDimensionSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, sizeof(uom10__unitDimensionSet), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__unitDimensionSet * SOAP_FMAC2 soap_instantiate_uom10__unitDimensionSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__unitDimensionSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__unitDimensionSet *p;
	size_t k = sizeof(uom10__unitDimensionSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__unitDimensionSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__unitDimensionSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__unitDimensionSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__unitDimensionSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__unitDimensionSet(soap, tag ? tag : "uom10:unitDimensionSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__unitDimensionSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__unitDimensionSet(soap, this, tag, type);
}

SOAP_FMAC3 uom10__unitDimensionSet * SOAP_FMAC4 soap_get_uom10__unitDimensionSet(struct soap *soap, uom10__unitDimensionSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__unitDimensionSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__uomDictionary::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_uom10__descriptionString(soap, &this->uom10__uomDictionary::title);
	soap_default_uom10__nameString(soap, &this->uom10__uomDictionary::originator);
	soap_default_uom10__commentString(soap, &this->uom10__uomDictionary::description);
	this->uom10__uomDictionary::unitDimensionSet = NULL;
	this->uom10__uomDictionary::quantityClassSet = NULL;
	this->uom10__uomDictionary::unitSet = NULL;
	this->uom10__uomDictionary::referenceSet = NULL;
	this->uom10__uomDictionary::prefixSet = NULL;
	soap_default_uom10__collapsedNonEmptyString(soap, &this->uom10__uomDictionary::version);
}

void uom10__uomDictionary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_uom10__descriptionString(soap, &this->uom10__uomDictionary::title);
	soap_embedded(soap, &this->uom10__uomDictionary::originator, SOAP_TYPE_gsoap_uom1_0_uom10__nameString);
	soap_serialize_uom10__nameString(soap, &this->uom10__uomDictionary::originator);
	soap_serialize_uom10__commentString(soap, &this->uom10__uomDictionary::description);
	soap_serialize_PointerTouom10__unitDimensionSet(soap, &this->uom10__uomDictionary::unitDimensionSet);
	soap_serialize_PointerTouom10__quantityClassSet(soap, &this->uom10__uomDictionary::quantityClassSet);
	soap_serialize_PointerTouom10__unitSet(soap, &this->uom10__uomDictionary::unitSet);
	soap_serialize_PointerTouom10__referenceSet(soap, &this->uom10__uomDictionary::referenceSet);
	soap_serialize_PointerTouom10__prefixSet(soap, &this->uom10__uomDictionary::prefixSet);
#endif
}

int uom10__uomDictionary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__uomDictionary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__uomDictionary(struct soap *soap, const char *tag, int id, const uom10__uomDictionary *a, const char *type)
{
	if (!type)
		type = "uom10:uomDictionary";
	soap_set_attr(soap, "version", soap_uom10__collapsedNonEmptyString2s(soap, ((uom10__uomDictionary*)a)->version), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary), type))
		return soap->error;
	if (soap_out_uom10__descriptionString(soap, "uom10:title", -1, &a->uom10__uomDictionary::title, "uom10:descriptionString"))
		return soap->error;
	if (soap_out_uom10__nameString(soap, "uom10:originator", -1, &a->uom10__uomDictionary::originator, "uom10:nameString"))
		return soap->error;
	if (soap_out_uom10__commentString(soap, "uom10:description", -1, &a->uom10__uomDictionary::description, "uom10:commentString"))
		return soap->error;
	if (!a->uom10__uomDictionary::unitDimensionSet)
	{	if (soap_element_empty(soap, "uom10:unitDimensionSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__unitDimensionSet(soap, "uom10:unitDimensionSet", -1, &a->uom10__uomDictionary::unitDimensionSet, "uom10:unitDimensionSet"))
		return soap->error;
	if (!a->uom10__uomDictionary::quantityClassSet)
	{	if (soap_element_empty(soap, "uom10:quantityClassSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__quantityClassSet(soap, "uom10:quantityClassSet", -1, &a->uom10__uomDictionary::quantityClassSet, "uom10:quantityClassSet"))
		return soap->error;
	if (!a->uom10__uomDictionary::unitSet)
	{	if (soap_element_empty(soap, "uom10:unitSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__unitSet(soap, "uom10:unitSet", -1, &a->uom10__uomDictionary::unitSet, "uom10:unitSet"))
		return soap->error;
	if (!a->uom10__uomDictionary::referenceSet)
	{	if (soap_element_empty(soap, "uom10:referenceSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__referenceSet(soap, "uom10:referenceSet", -1, &a->uom10__uomDictionary::referenceSet, "uom10:referenceSet"))
		return soap->error;
	if (!a->uom10__uomDictionary::prefixSet)
	{	if (soap_element_empty(soap, "uom10:prefixSet", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTouom10__prefixSet(soap, "uom10:prefixSet", -1, &a->uom10__uomDictionary::prefixSet, "uom10:prefixSet"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__uomDictionary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__uomDictionary(soap, tag, this, type);
}

SOAP_FMAC3 uom10__uomDictionary * SOAP_FMAC4 soap_in_uom10__uomDictionary(struct soap *soap, const char *tag, uom10__uomDictionary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__uomDictionary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, sizeof(uom10__uomDictionary), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__uomDictionary *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2uom10__collapsedNonEmptyString(soap, soap_attr_value(soap, "version", 1, 3), &((uom10__uomDictionary*)a)->version))
		return NULL;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_originator1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_unitDimensionSet1 = 1;
	size_t soap_flag_quantityClassSet1 = 1;
	size_t soap_flag_unitSet1 = 1;
	size_t soap_flag_referenceSet1 = 1;
	size_t soap_flag_prefixSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__descriptionString(soap, "uom10:title", &a->uom10__uomDictionary::title, "uom10:descriptionString"))
				{	soap_flag_title1--;
					continue;
				}
			}
			if (soap_flag_originator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__nameString(soap, "uom10:originator", &a->uom10__uomDictionary::originator, "uom10:nameString"))
				{	soap_flag_originator1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_uom10__commentString(soap, "uom10:description", &a->uom10__uomDictionary::description, "uom10:commentString"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap_flag_unitDimensionSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__unitDimensionSet(soap, "uom10:unitDimensionSet", &a->uom10__uomDictionary::unitDimensionSet, "uom10:unitDimensionSet"))
				{	soap_flag_unitDimensionSet1--;
					continue;
				}
			}
			if (soap_flag_quantityClassSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__quantityClassSet(soap, "uom10:quantityClassSet", &a->uom10__uomDictionary::quantityClassSet, "uom10:quantityClassSet"))
				{	soap_flag_quantityClassSet1--;
					continue;
				}
			}
			if (soap_flag_unitSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__unitSet(soap, "uom10:unitSet", &a->uom10__uomDictionary::unitSet, "uom10:unitSet"))
				{	soap_flag_unitSet1--;
					continue;
				}
			}
			if (soap_flag_referenceSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__referenceSet(soap, "uom10:referenceSet", &a->uom10__uomDictionary::referenceSet, "uom10:referenceSet"))
				{	soap_flag_referenceSet1--;
					continue;
				}
			}
			if (soap_flag_prefixSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__prefixSet(soap, "uom10:prefixSet", &a->uom10__uomDictionary::prefixSet, "uom10:prefixSet"))
				{	soap_flag_prefixSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_title1 > 0 || soap_flag_originator1 > 0 || soap_flag_description1 > 0 || !a->uom10__uomDictionary::unitDimensionSet || !a->uom10__uomDictionary::quantityClassSet || !a->uom10__uomDictionary::unitSet || !a->uom10__uomDictionary::referenceSet || !a->uom10__uomDictionary::prefixSet))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (uom10__uomDictionary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, sizeof(uom10__uomDictionary), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__uomDictionary * SOAP_FMAC2 soap_instantiate_uom10__uomDictionary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__uomDictionary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__uomDictionary *p;
	size_t k = sizeof(uom10__uomDictionary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__uomDictionary);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__uomDictionary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__uomDictionary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__uomDictionary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__uomDictionary(soap, tag ? tag : "uom10:uomDictionary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__uomDictionary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__uomDictionary(soap, this, tag, type);
}

SOAP_FMAC3 uom10__uomDictionary * SOAP_FMAC4 soap_get_uom10__uomDictionary(struct soap *soap, uom10__uomDictionary *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__uomDictionary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void uom10__uomAggregate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->uom10__uomAggregate::uomDictionary = NULL;
	this->uom10__uomAggregate::integerCodeSet = NULL;
	soap_default_std__vectorTemplateOfPointerTouom10__classMappingSet(soap, &this->uom10__uomAggregate::classMappingSet);
	soap_default_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap, &this->uom10__uomAggregate::unitMappingSet);
}

void uom10__uomAggregate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTouom10__uomDictionary(soap, &this->uom10__uomAggregate::uomDictionary);
	soap_serialize_PointerTouom10__integerCodeSet(soap, &this->uom10__uomAggregate::integerCodeSet);
	soap_serialize_std__vectorTemplateOfPointerTouom10__classMappingSet(soap, &this->uom10__uomAggregate::classMappingSet);
	soap_serialize_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap, &this->uom10__uomAggregate::unitMappingSet);
#endif
}

int uom10__uomAggregate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_uom10__uomAggregate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_uom10__uomAggregate(struct soap *soap, const char *tag, int id, const uom10__uomAggregate *a, const char *type)
{
	if (!type)
		type = "uom10:uomAggregate";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate), type))
		return soap->error;
	if (soap_out_PointerTouom10__uomDictionary(soap, "uom10:uomDictionary", -1, &a->uom10__uomAggregate::uomDictionary, "uom10:uomDictionary"))
		return soap->error;
	if (soap_out_PointerTouom10__integerCodeSet(soap, "uom10:integerCodeSet", -1, &a->uom10__uomAggregate::integerCodeSet, "uom10:integerCodeSet"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__classMappingSet(soap, "uom10:classMappingSet", -1, &a->uom10__uomAggregate::classMappingSet, "uom10:classMappingSet"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap, "uom10:unitMappingSet", -1, &a->uom10__uomAggregate::unitMappingSet, "uom10:unitMappingSet"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *uom10__uomAggregate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_uom10__uomAggregate(soap, tag, this, type);
}

SOAP_FMAC3 uom10__uomAggregate * SOAP_FMAC4 soap_in_uom10__uomAggregate(struct soap *soap, const char *tag, uom10__uomAggregate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (uom10__uomAggregate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate, sizeof(uom10__uomAggregate), soap->type, soap->arrayType, gsoap_uom1_0_instantiate, gsoap_uom1_0_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (uom10__uomAggregate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_uomDictionary1 = 1;
	size_t soap_flag_integerCodeSet1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uomDictionary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__uomDictionary(soap, "uom10:uomDictionary", &a->uom10__uomAggregate::uomDictionary, "uom10:uomDictionary"))
				{	soap_flag_uomDictionary1--;
					continue;
				}
			}
			if (soap_flag_integerCodeSet1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouom10__integerCodeSet(soap, "uom10:integerCodeSet", &a->uom10__uomAggregate::integerCodeSet, "uom10:integerCodeSet"))
				{	soap_flag_integerCodeSet1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__classMappingSet(soap, "uom10:classMappingSet", &a->uom10__uomAggregate::classMappingSet, "uom10:classMappingSet"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap, "uom10:unitMappingSet", &a->uom10__uomAggregate::unitMappingSet, "uom10:unitMappingSet"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (uom10__uomAggregate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate, SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate, sizeof(uom10__uomAggregate), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 uom10__uomAggregate * SOAP_FMAC2 soap_instantiate_uom10__uomAggregate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_uom10__uomAggregate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	uom10__uomAggregate *p;
	size_t k = sizeof(uom10__uomAggregate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_uom10__uomAggregate, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, uom10__uomAggregate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, uom10__uomAggregate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated uom10__uomAggregate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int uom10__uomAggregate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_uom10__uomAggregate(soap, tag ? tag : "uom10:uomAggregate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *uom10__uomAggregate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_uom10__uomAggregate(soap, this, tag, type);
}

SOAP_FMAC3 uom10__uomAggregate * SOAP_FMAC4 soap_get_uom10__uomAggregate(struct soap *soap, uom10__uomAggregate *p, const char *tag, const char *type)
{
	if ((p = soap_in_uom10__uomAggregate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, "xsd:QName"))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, gsoap_uom1_0_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Fault, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, gsoap_uom1_0_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, gsoap_uom1_0_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, "xsd:QName"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, gsoap_uom1_0_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, gsoap_uom1_0_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Header, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__mapFromToClass(struct soap *soap, uom10__mapFromToClass *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__mapFromToClass(struct soap *soap, const char *tag, int id, uom10__mapFromToClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass ? type : NULL);
}

SOAP_FMAC3 uom10__mapFromToClass ** SOAP_FMAC4 soap_in_PointerTouom10__mapFromToClass(struct soap *soap, const char *tag, uom10__mapFromToClass **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__mapFromToClass **)soap_malloc(soap, sizeof(uom10__mapFromToClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__mapFromToClass *)soap_instantiate_uom10__mapFromToClass(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__mapFromToClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, sizeof(uom10__mapFromToClass), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__mapFromToClass(struct soap *soap, uom10__mapFromToClass *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__mapFromToClass(soap, tag ? tag : "uom10:mapFromToClass", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__mapFromToClass ** SOAP_FMAC4 soap_get_PointerTouom10__mapFromToClass(struct soap *soap, uom10__mapFromToClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__mapFromToClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__mapFromToUnit(struct soap *soap, uom10__mapFromToUnit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__mapFromToUnit(struct soap *soap, const char *tag, int id, uom10__mapFromToUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit ? type : NULL);
}

SOAP_FMAC3 uom10__mapFromToUnit ** SOAP_FMAC4 soap_in_PointerTouom10__mapFromToUnit(struct soap *soap, const char *tag, uom10__mapFromToUnit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__mapFromToUnit **)soap_malloc(soap, sizeof(uom10__mapFromToUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__mapFromToUnit *)soap_instantiate_uom10__mapFromToUnit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__mapFromToUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, sizeof(uom10__mapFromToUnit), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__mapFromToUnit(struct soap *soap, uom10__mapFromToUnit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__mapFromToUnit(soap, tag ? tag : "uom10:mapFromToUnit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__mapFromToUnit ** SOAP_FMAC4 soap_get_PointerTouom10__mapFromToUnit(struct soap *soap, uom10__mapFromToUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__mapFromToUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitCodeStruct(struct soap *soap, uom10__unitCodeStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitCodeStruct(struct soap *soap, const char *tag, int id, uom10__unitCodeStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct ? type : NULL);
}

SOAP_FMAC3 uom10__unitCodeStruct ** SOAP_FMAC4 soap_in_PointerTouom10__unitCodeStruct(struct soap *soap, const char *tag, uom10__unitCodeStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitCodeStruct **)soap_malloc(soap, sizeof(uom10__unitCodeStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitCodeStruct *)soap_instantiate_uom10__unitCodeStruct(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitCodeStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeStruct, sizeof(uom10__unitCodeStruct), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitCodeStruct(struct soap *soap, uom10__unitCodeStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitCodeStruct(soap, tag ? tag : "uom10:unitCodeStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitCodeStruct ** SOAP_FMAC4 soap_get_PointerTouom10__unitCodeStruct(struct soap *soap, uom10__unitCodeStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitCodeStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitCode(struct soap *soap, uom10__unitCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitCode(struct soap *soap, const char *tag, int id, uom10__unitCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitCode ? type : NULL);
}

SOAP_FMAC3 uom10__unitCode ** SOAP_FMAC4 soap_in_PointerTouom10__unitCode(struct soap *soap, const char *tag, uom10__unitCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitCode **)soap_malloc(soap, sizeof(uom10__unitCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitCode *)soap_instantiate_uom10__unitCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, sizeof(uom10__unitCode), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitCode(struct soap *soap, uom10__unitCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitCode(soap, tag ? tag : "uom10:unitCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitCode ** SOAP_FMAC4 soap_get_PointerTouom10__unitCode(struct soap *soap, uom10__unitCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__classCode(struct soap *soap, uom10__classCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__classCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__classCode(struct soap *soap, const char *tag, int id, uom10__classCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__classCode ? type : NULL);
}

SOAP_FMAC3 uom10__classCode ** SOAP_FMAC4 soap_in_PointerTouom10__classCode(struct soap *soap, const char *tag, uom10__classCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__classCode **)soap_malloc(soap, sizeof(uom10__classCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__classCode *)soap_instantiate_uom10__classCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__classCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, sizeof(uom10__classCode), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__classCode(struct soap *soap, uom10__classCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__classCode(soap, tag ? tag : "uom10:classCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__classCode ** SOAP_FMAC4 soap_get_PointerTouom10__classCode(struct soap *soap, uom10__classCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__classCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitCodeSet(struct soap *soap, uom10__unitCodeSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitCodeSet(struct soap *soap, const char *tag, int id, uom10__unitCodeSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet ? type : NULL);
}

SOAP_FMAC3 uom10__unitCodeSet ** SOAP_FMAC4 soap_in_PointerTouom10__unitCodeSet(struct soap *soap, const char *tag, uom10__unitCodeSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitCodeSet **)soap_malloc(soap, sizeof(uom10__unitCodeSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitCodeSet *)soap_instantiate_uom10__unitCodeSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitCodeSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitCodeSet, sizeof(uom10__unitCodeSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitCodeSet(struct soap *soap, uom10__unitCodeSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitCodeSet(soap, tag ? tag : "uom10:unitCodeSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitCodeSet ** SOAP_FMAC4 soap_get_PointerTouom10__unitCodeSet(struct soap *soap, uom10__unitCodeSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__classCodeSet(struct soap *soap, uom10__classCodeSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__classCodeSet(struct soap *soap, const char *tag, int id, uom10__classCodeSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet ? type : NULL);
}

SOAP_FMAC3 uom10__classCodeSet ** SOAP_FMAC4 soap_in_PointerTouom10__classCodeSet(struct soap *soap, const char *tag, uom10__classCodeSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__classCodeSet **)soap_malloc(soap, sizeof(uom10__classCodeSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__classCodeSet *)soap_instantiate_uom10__classCodeSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__classCodeSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__classCodeSet, sizeof(uom10__classCodeSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__classCodeSet(struct soap *soap, uom10__classCodeSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__classCodeSet(soap, tag ? tag : "uom10:classCodeSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__classCodeSet ** SOAP_FMAC4 soap_get_PointerTouom10__classCodeSet(struct soap *soap, uom10__classCodeSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__classCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__nameString(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__nameString))
		soap_serialize_uom10__nameString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__nameString(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_uom10__nameString(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTouom10__nameString(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_uom10__nameString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__nameString, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__nameString(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__nameString(soap, tag ? tag : "uom10:nameString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTouom10__nameString(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__nameString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__prefix(struct soap *soap, uom10__prefix *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__prefix))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__prefix(struct soap *soap, const char *tag, int id, uom10__prefix *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__prefix ? type : NULL);
}

SOAP_FMAC3 uom10__prefix ** SOAP_FMAC4 soap_in_PointerTouom10__prefix(struct soap *soap, const char *tag, uom10__prefix **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__prefix **)soap_malloc(soap, sizeof(uom10__prefix *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__prefix *)soap_instantiate_uom10__prefix(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__prefix **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, sizeof(uom10__prefix), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__prefix(struct soap *soap, uom10__prefix *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__prefix(soap, tag ? tag : "uom10:prefix", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__prefix ** SOAP_FMAC4 soap_get_PointerTouom10__prefix(struct soap *soap, uom10__prefix **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__prefix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__reference(struct soap *soap, uom10__reference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__reference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__reference(struct soap *soap, const char *tag, int id, uom10__reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__reference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__reference ? type : NULL);
}

SOAP_FMAC3 uom10__reference ** SOAP_FMAC4 soap_in_PointerTouom10__reference(struct soap *soap, const char *tag, uom10__reference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__reference **)soap_malloc(soap, sizeof(uom10__reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__reference *)soap_instantiate_uom10__reference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__reference, sizeof(uom10__reference), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__reference(struct soap *soap, uom10__reference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__reference(soap, tag ? tag : "uom10:reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__reference ** SOAP_FMAC4 soap_get_PointerTouom10__reference(struct soap *soap, uom10__reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__emptyElement(struct soap *soap, uom10__emptyElement *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__emptyElement(struct soap *soap, const char *tag, int id, uom10__emptyElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement ? type : NULL);
}

SOAP_FMAC3 uom10__emptyElement ** SOAP_FMAC4 soap_in_PointerTouom10__emptyElement(struct soap *soap, const char *tag, uom10__emptyElement **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__emptyElement **)soap_malloc(soap, sizeof(uom10__emptyElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__emptyElement *)soap_instantiate_uom10__emptyElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__emptyElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__emptyElement, sizeof(uom10__emptyElement), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__emptyElement(struct soap *soap, uom10__emptyElement *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__emptyElement(soap, tag ? tag : "uom10:emptyElement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__emptyElement ** SOAP_FMAC4 soap_get_PointerTouom10__emptyElement(struct soap *soap, uom10__emptyElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__emptyElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unit(struct soap *soap, uom10__unit *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unit))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unit(struct soap *soap, const char *tag, int id, uom10__unit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unit, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unit ? type : NULL);
}

SOAP_FMAC3 uom10__unit ** SOAP_FMAC4 soap_in_PointerTouom10__unit(struct soap *soap, const char *tag, uom10__unit **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unit **)soap_malloc(soap, sizeof(uom10__unit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unit *)soap_instantiate_uom10__unit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unit, sizeof(uom10__unit), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unit(struct soap *soap, uom10__unit *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unit(soap, tag ? tag : "uom10:unit", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unit ** SOAP_FMAC4 soap_get_PointerTouom10__unit(struct soap *soap, uom10__unit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__symbolString(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString))
		soap_serialize_uom10__symbolString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__symbolString(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_uom10__symbolString(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTouom10__symbolString(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_uom10__symbolString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__symbolString(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__symbolString(soap, tag ? tag : "uom10:symbolString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTouom10__symbolString(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__symbolString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__quantityClass(struct soap *soap, uom10__quantityClass *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__quantityClass(struct soap *soap, const char *tag, int id, uom10__quantityClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass ? type : NULL);
}

SOAP_FMAC3 uom10__quantityClass ** SOAP_FMAC4 soap_in_PointerTouom10__quantityClass(struct soap *soap, const char *tag, uom10__quantityClass **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__quantityClass **)soap_malloc(soap, sizeof(uom10__quantityClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__quantityClass *)soap_instantiate_uom10__quantityClass(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__quantityClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, sizeof(uom10__quantityClass), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__quantityClass(struct soap *soap, uom10__quantityClass *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__quantityClass(soap, tag ? tag : "uom10:quantityClass", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__quantityClass ** SOAP_FMAC4 soap_get_PointerTouom10__quantityClass(struct soap *soap, uom10__quantityClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__quantityClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__collapsedNonEmptyString(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString))
		soap_serialize_uom10__collapsedNonEmptyString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__collapsedNonEmptyString(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_uom10__collapsedNonEmptyString(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTouom10__collapsedNonEmptyString(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_uom10__collapsedNonEmptyString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__collapsedNonEmptyString, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__collapsedNonEmptyString(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__collapsedNonEmptyString(soap, tag ? tag : "uom10:collapsedNonEmptyString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTouom10__collapsedNonEmptyString(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__collapsedNonEmptyString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitDimension(struct soap *soap, uom10__unitDimension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitDimension(struct soap *soap, const char *tag, int id, uom10__unitDimension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension ? type : NULL);
}

SOAP_FMAC3 uom10__unitDimension ** SOAP_FMAC4 soap_in_PointerTouom10__unitDimension(struct soap *soap, const char *tag, uom10__unitDimension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitDimension **)soap_malloc(soap, sizeof(uom10__unitDimension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitDimension *)soap_instantiate_uom10__unitDimension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitDimension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, sizeof(uom10__unitDimension), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitDimension(struct soap *soap, uom10__unitDimension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitDimension(soap, tag ? tag : "uom10:unitDimension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitDimension ** SOAP_FMAC4 soap_get_PointerTouom10__unitDimension(struct soap *soap, uom10__unitDimension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitDimension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__prefixSet(struct soap *soap, uom10__prefixSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__prefixSet(struct soap *soap, const char *tag, int id, uom10__prefixSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet ? type : NULL);
}

SOAP_FMAC3 uom10__prefixSet ** SOAP_FMAC4 soap_in_PointerTouom10__prefixSet(struct soap *soap, const char *tag, uom10__prefixSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__prefixSet **)soap_malloc(soap, sizeof(uom10__prefixSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__prefixSet *)soap_instantiate_uom10__prefixSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__prefixSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__prefixSet, sizeof(uom10__prefixSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__prefixSet(struct soap *soap, uom10__prefixSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__prefixSet(soap, tag ? tag : "uom10:prefixSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__prefixSet ** SOAP_FMAC4 soap_get_PointerTouom10__prefixSet(struct soap *soap, uom10__prefixSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__prefixSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__referenceSet(struct soap *soap, uom10__referenceSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__referenceSet(struct soap *soap, const char *tag, int id, uom10__referenceSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet ? type : NULL);
}

SOAP_FMAC3 uom10__referenceSet ** SOAP_FMAC4 soap_in_PointerTouom10__referenceSet(struct soap *soap, const char *tag, uom10__referenceSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__referenceSet **)soap_malloc(soap, sizeof(uom10__referenceSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__referenceSet *)soap_instantiate_uom10__referenceSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__referenceSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__referenceSet, sizeof(uom10__referenceSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__referenceSet(struct soap *soap, uom10__referenceSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__referenceSet(soap, tag ? tag : "uom10:referenceSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__referenceSet ** SOAP_FMAC4 soap_get_PointerTouom10__referenceSet(struct soap *soap, uom10__referenceSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__referenceSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitSet(struct soap *soap, uom10__unitSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitSet(struct soap *soap, const char *tag, int id, uom10__unitSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitSet ? type : NULL);
}

SOAP_FMAC3 uom10__unitSet ** SOAP_FMAC4 soap_in_PointerTouom10__unitSet(struct soap *soap, const char *tag, uom10__unitSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitSet **)soap_malloc(soap, sizeof(uom10__unitSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitSet *)soap_instantiate_uom10__unitSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitSet, sizeof(uom10__unitSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitSet(struct soap *soap, uom10__unitSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitSet(soap, tag ? tag : "uom10:unitSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitSet ** SOAP_FMAC4 soap_get_PointerTouom10__unitSet(struct soap *soap, uom10__unitSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__quantityClassSet(struct soap *soap, uom10__quantityClassSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__quantityClassSet(struct soap *soap, const char *tag, int id, uom10__quantityClassSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet ? type : NULL);
}

SOAP_FMAC3 uom10__quantityClassSet ** SOAP_FMAC4 soap_in_PointerTouom10__quantityClassSet(struct soap *soap, const char *tag, uom10__quantityClassSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__quantityClassSet **)soap_malloc(soap, sizeof(uom10__quantityClassSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__quantityClassSet *)soap_instantiate_uom10__quantityClassSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__quantityClassSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClassSet, sizeof(uom10__quantityClassSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__quantityClassSet(struct soap *soap, uom10__quantityClassSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__quantityClassSet(soap, tag ? tag : "uom10:quantityClassSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__quantityClassSet ** SOAP_FMAC4 soap_get_PointerTouom10__quantityClassSet(struct soap *soap, uom10__quantityClassSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__quantityClassSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitDimensionSet(struct soap *soap, uom10__unitDimensionSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitDimensionSet(struct soap *soap, const char *tag, int id, uom10__unitDimensionSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet ? type : NULL);
}

SOAP_FMAC3 uom10__unitDimensionSet ** SOAP_FMAC4 soap_in_PointerTouom10__unitDimensionSet(struct soap *soap, const char *tag, uom10__unitDimensionSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitDimensionSet **)soap_malloc(soap, sizeof(uom10__unitDimensionSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitDimensionSet *)soap_instantiate_uom10__unitDimensionSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitDimensionSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimensionSet, sizeof(uom10__unitDimensionSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitDimensionSet(struct soap *soap, uom10__unitDimensionSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitDimensionSet(soap, tag ? tag : "uom10:unitDimensionSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitDimensionSet ** SOAP_FMAC4 soap_get_PointerTouom10__unitDimensionSet(struct soap *soap, uom10__unitDimensionSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitDimensionSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__unitMappingSet(struct soap *soap, uom10__unitMappingSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__unitMappingSet(struct soap *soap, const char *tag, int id, uom10__unitMappingSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet ? type : NULL);
}

SOAP_FMAC3 uom10__unitMappingSet ** SOAP_FMAC4 soap_in_PointerTouom10__unitMappingSet(struct soap *soap, const char *tag, uom10__unitMappingSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__unitMappingSet **)soap_malloc(soap, sizeof(uom10__unitMappingSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__unitMappingSet *)soap_instantiate_uom10__unitMappingSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__unitMappingSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, sizeof(uom10__unitMappingSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__unitMappingSet(struct soap *soap, uom10__unitMappingSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__unitMappingSet(soap, tag ? tag : "uom10:unitMappingSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__unitMappingSet ** SOAP_FMAC4 soap_get_PointerTouom10__unitMappingSet(struct soap *soap, uom10__unitMappingSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__unitMappingSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__classMappingSet(struct soap *soap, uom10__classMappingSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__classMappingSet(struct soap *soap, const char *tag, int id, uom10__classMappingSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet ? type : NULL);
}

SOAP_FMAC3 uom10__classMappingSet ** SOAP_FMAC4 soap_in_PointerTouom10__classMappingSet(struct soap *soap, const char *tag, uom10__classMappingSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__classMappingSet **)soap_malloc(soap, sizeof(uom10__classMappingSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__classMappingSet *)soap_instantiate_uom10__classMappingSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__classMappingSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, sizeof(uom10__classMappingSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__classMappingSet(struct soap *soap, uom10__classMappingSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__classMappingSet(soap, tag ? tag : "uom10:classMappingSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__classMappingSet ** SOAP_FMAC4 soap_get_PointerTouom10__classMappingSet(struct soap *soap, uom10__classMappingSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__classMappingSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__integerCodeSet(struct soap *soap, uom10__integerCodeSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__integerCodeSet(struct soap *soap, const char *tag, int id, uom10__integerCodeSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet ? type : NULL);
}

SOAP_FMAC3 uom10__integerCodeSet ** SOAP_FMAC4 soap_in_PointerTouom10__integerCodeSet(struct soap *soap, const char *tag, uom10__integerCodeSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__integerCodeSet **)soap_malloc(soap, sizeof(uom10__integerCodeSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__integerCodeSet *)soap_instantiate_uom10__integerCodeSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__integerCodeSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__integerCodeSet, sizeof(uom10__integerCodeSet), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__integerCodeSet(struct soap *soap, uom10__integerCodeSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__integerCodeSet(soap, tag ? tag : "uom10:integerCodeSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__integerCodeSet ** SOAP_FMAC4 soap_get_PointerTouom10__integerCodeSet(struct soap *soap, uom10__integerCodeSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__integerCodeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouom10__uomDictionary(struct soap *soap, uom10__uomDictionary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouom10__uomDictionary(struct soap *soap, const char *tag, int id, uom10__uomDictionary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary ? type : NULL);
}

SOAP_FMAC3 uom10__uomDictionary ** SOAP_FMAC4 soap_in_PointerTouom10__uomDictionary(struct soap *soap, const char *tag, uom10__uomDictionary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (uom10__uomDictionary **)soap_malloc(soap, sizeof(uom10__uomDictionary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (uom10__uomDictionary *)soap_instantiate_uom10__uomDictionary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (uom10__uomDictionary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gsoap_uom1_0_uom10__uomDictionary, sizeof(uom10__uomDictionary), 0, gsoap_uom1_0_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouom10__uomDictionary(struct soap *soap, uom10__uomDictionary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouom10__uomDictionary(soap, tag ? tag : "uom10:uomDictionary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 uom10__uomDictionary ** SOAP_FMAC4 soap_get_PointerTouom10__uomDictionary(struct soap *soap, uom10__uomDictionary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouom10__uomDictionary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_gsoap_uom1_0_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_gsoap_uom1_0_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_gsoap_uom1_0_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__mapFromToClass(struct soap *soap, std::vector<uom10__mapFromToClass *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__mapFromToClass(struct soap *soap, const std::vector<uom10__mapFromToClass *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__mapFromToClass *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__mapFromToClass(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__mapFromToClass(struct soap *soap, const char *tag, int id, const std::vector<uom10__mapFromToClass *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__mapFromToClass *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__mapFromToClass(soap, tag, id, &(*i), "uom10:mapFromToClass"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__mapFromToClass *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__mapFromToClass(struct soap *soap, const char *tag, std::vector<uom10__mapFromToClass *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__mapFromToClass(soap)))
			return NULL;
		a->emplace_back();
		uom10__mapFromToClass * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToClass, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass, sizeof(uom10__mapFromToClass), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__mapFromToClass(soap, tag, NULL, "uom10:mapFromToClass"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__mapFromToClass(soap, tag, n, "uom10:mapFromToClass"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__mapFromToClass *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToClass(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__mapFromToClass *> *p;
	size_t k = sizeof(std::vector<uom10__mapFromToClass *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToClass, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__mapFromToClass *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__mapFromToClass *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__mapFromToClass *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__mapFromToUnit(struct soap *soap, std::vector<uom10__mapFromToUnit *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__mapFromToUnit(struct soap *soap, const std::vector<uom10__mapFromToUnit *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__mapFromToUnit *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__mapFromToUnit(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__mapFromToUnit(struct soap *soap, const char *tag, int id, const std::vector<uom10__mapFromToUnit *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__mapFromToUnit *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__mapFromToUnit(soap, tag, id, &(*i), "uom10:mapFromToUnit"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__mapFromToUnit *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__mapFromToUnit(struct soap *soap, const char *tag, std::vector<uom10__mapFromToUnit *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__mapFromToUnit(soap)))
			return NULL;
		a->emplace_back();
		uom10__mapFromToUnit * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__mapFromToUnit, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit, sizeof(uom10__mapFromToUnit), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__mapFromToUnit(soap, tag, NULL, "uom10:mapFromToUnit"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__mapFromToUnit(soap, tag, n, "uom10:mapFromToUnit"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__mapFromToUnit *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__mapFromToUnit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__mapFromToUnit *> *p;
	size_t k = sizeof(std::vector<uom10__mapFromToUnit *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__mapFromToUnit, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__mapFromToUnit *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__mapFromToUnit *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__mapFromToUnit *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__unitCode(struct soap *soap, std::vector<uom10__unitCode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__unitCode(struct soap *soap, const std::vector<uom10__unitCode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__unitCode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__unitCode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__unitCode(struct soap *soap, const char *tag, int id, const std::vector<uom10__unitCode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__unitCode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__unitCode(soap, tag, id, &(*i), "uom10:unitCode"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__unitCode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__unitCode(struct soap *soap, const char *tag, std::vector<uom10__unitCode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__unitCode(soap)))
			return NULL;
		a->emplace_back();
		uom10__unitCode * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__unitCode, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode, sizeof(uom10__unitCode), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__unitCode(soap, tag, NULL, "uom10:unitCode"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__unitCode(soap, tag, n, "uom10:unitCode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__unitCode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__unitCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__unitCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__unitCode *> *p;
	size_t k = sizeof(std::vector<uom10__unitCode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitCode, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__unitCode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__unitCode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__unitCode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__classCode(struct soap *soap, std::vector<uom10__classCode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__classCode(struct soap *soap, const std::vector<uom10__classCode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__classCode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__classCode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__classCode(struct soap *soap, const char *tag, int id, const std::vector<uom10__classCode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__classCode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__classCode(soap, tag, id, &(*i), "uom10:classCode"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__classCode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__classCode(struct soap *soap, const char *tag, std::vector<uom10__classCode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__classCode(soap)))
			return NULL;
		a->emplace_back();
		uom10__classCode * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__classCode, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode, sizeof(uom10__classCode), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__classCode(soap, tag, NULL, "uom10:classCode"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__classCode(soap, tag, n, "uom10:classCode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__classCode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__classCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__classCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__classCode *> *p;
	size_t k = sizeof(std::vector<uom10__classCode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classCode, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__classCode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__classCode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__classCode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__prefix(struct soap *soap, std::vector<uom10__prefix *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__prefix(struct soap *soap, const std::vector<uom10__prefix *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__prefix *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__prefix(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__prefix(struct soap *soap, const char *tag, int id, const std::vector<uom10__prefix *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__prefix *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__prefix(soap, tag, id, &(*i), "uom10:prefix"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__prefix *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__prefix(struct soap *soap, const char *tag, std::vector<uom10__prefix *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__prefix(soap)))
			return NULL;
		a->emplace_back();
		uom10__prefix * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__prefix, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix, sizeof(uom10__prefix), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__prefix(soap, tag, NULL, "uom10:prefix"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__prefix(soap, tag, n, "uom10:prefix"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__prefix *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__prefix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__prefix(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__prefix *> *p;
	size_t k = sizeof(std::vector<uom10__prefix *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__prefix, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__prefix *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__prefix *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__prefix *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__reference(struct soap *soap, std::vector<uom10__reference *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__reference(struct soap *soap, const std::vector<uom10__reference *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__reference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__reference(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__reference(struct soap *soap, const char *tag, int id, const std::vector<uom10__reference *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__reference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__reference(soap, tag, id, &(*i), "uom10:reference"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__reference *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__reference(struct soap *soap, const char *tag, std::vector<uom10__reference *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__reference(soap)))
			return NULL;
		a->emplace_back();
		uom10__reference * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__reference, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference, sizeof(uom10__reference), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__reference(soap, tag, NULL, "uom10:reference"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__reference(soap, tag, n, "uom10:reference"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__reference *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__reference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__reference *> *p;
	size_t k = sizeof(std::vector<uom10__reference *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__reference, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__reference *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__reference *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__reference *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__unit(struct soap *soap, std::vector<uom10__unit *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__unit(struct soap *soap, const std::vector<uom10__unit *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__unit *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__unit(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__unit(struct soap *soap, const char *tag, int id, const std::vector<uom10__unit *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__unit *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__unit(soap, tag, id, &(*i), "uom10:unit"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__unit *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__unit(struct soap *soap, const char *tag, std::vector<uom10__unit *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__unit(soap)))
			return NULL;
		a->emplace_back();
		uom10__unit * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__unit, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit, sizeof(uom10__unit), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__unit(soap, tag, NULL, "uom10:unit"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__unit(soap, tag, n, "uom10:unit"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__unit *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__unit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__unit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__unit *> *p;
	size_t k = sizeof(std::vector<uom10__unit *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unit, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__unit *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__unit *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__unit *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfuom10__symbolString(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfuom10__symbolString(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_uom10__symbolString(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfuom10__symbolString(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_uom10__symbolString(soap, tag, id, &(*i), "uom10:symbolString"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfuom10__symbolString(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfuom10__symbolString(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_uom10__symbolString(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__symbolString, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString, sizeof(std::string), 0, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_uom10__symbolString(soap, tag, NULL, "uom10:symbolString"))
				break;
		}
		else
		{	if (!soap_in_uom10__symbolString(soap, tag, n, "uom10:symbolString"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfuom10__symbolString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfuom10__symbolString(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfuom10__symbolString, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__quantityClass(struct soap *soap, std::vector<uom10__quantityClass *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__quantityClass(struct soap *soap, const std::vector<uom10__quantityClass *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__quantityClass *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__quantityClass(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__quantityClass(struct soap *soap, const char *tag, int id, const std::vector<uom10__quantityClass *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__quantityClass *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__quantityClass(soap, tag, id, &(*i), "uom10:quantityClass"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__quantityClass *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__quantityClass(struct soap *soap, const char *tag, std::vector<uom10__quantityClass *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__quantityClass(soap)))
			return NULL;
		a->emplace_back();
		uom10__quantityClass * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__quantityClass, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass, sizeof(uom10__quantityClass), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__quantityClass(soap, tag, NULL, "uom10:quantityClass"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__quantityClass(soap, tag, n, "uom10:quantityClass"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__quantityClass *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__quantityClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__quantityClass(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__quantityClass *> *p;
	size_t k = sizeof(std::vector<uom10__quantityClass *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__quantityClass, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__quantityClass *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__quantityClass *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__quantityClass *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__unitDimension(struct soap *soap, std::vector<uom10__unitDimension *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__unitDimension(struct soap *soap, const std::vector<uom10__unitDimension *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__unitDimension *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__unitDimension(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__unitDimension(struct soap *soap, const char *tag, int id, const std::vector<uom10__unitDimension *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__unitDimension *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__unitDimension(soap, tag, id, &(*i), "uom10:unitDimension"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__unitDimension *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__unitDimension(struct soap *soap, const char *tag, std::vector<uom10__unitDimension *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__unitDimension(soap)))
			return NULL;
		a->emplace_back();
		uom10__unitDimension * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__unitDimension, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension, sizeof(uom10__unitDimension), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__unitDimension(soap, tag, NULL, "uom10:unitDimension"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__unitDimension(soap, tag, n, "uom10:unitDimension"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__unitDimension *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__unitDimension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__unitDimension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__unitDimension *> *p;
	size_t k = sizeof(std::vector<uom10__unitDimension *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitDimension, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__unitDimension *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__unitDimension *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__unitDimension *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__unitMappingSet(struct soap *soap, std::vector<uom10__unitMappingSet *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__unitMappingSet(struct soap *soap, const std::vector<uom10__unitMappingSet *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__unitMappingSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__unitMappingSet(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__unitMappingSet(struct soap *soap, const char *tag, int id, const std::vector<uom10__unitMappingSet *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__unitMappingSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__unitMappingSet(soap, tag, id, &(*i), "uom10:unitMappingSet"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__unitMappingSet *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__unitMappingSet(struct soap *soap, const char *tag, std::vector<uom10__unitMappingSet *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__unitMappingSet(soap)))
			return NULL;
		a->emplace_back();
		uom10__unitMappingSet * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__unitMappingSet, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet, sizeof(uom10__unitMappingSet), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__unitMappingSet(soap, tag, NULL, "uom10:unitMappingSet"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__unitMappingSet(soap, tag, n, "uom10:unitMappingSet"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__unitMappingSet *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__unitMappingSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__unitMappingSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__unitMappingSet *> *p;
	size_t k = sizeof(std::vector<uom10__unitMappingSet *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__unitMappingSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__unitMappingSet *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__unitMappingSet *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__unitMappingSet *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTouom10__classMappingSet(struct soap *soap, std::vector<uom10__classMappingSet *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTouom10__classMappingSet(struct soap *soap, const std::vector<uom10__classMappingSet *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<uom10__classMappingSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTouom10__classMappingSet(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTouom10__classMappingSet(struct soap *soap, const char *tag, int id, const std::vector<uom10__classMappingSet *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<uom10__classMappingSet *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTouom10__classMappingSet(soap, tag, id, &(*i), "uom10:classMappingSet"))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<uom10__classMappingSet *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTouom10__classMappingSet(struct soap *soap, const char *tag, std::vector<uom10__classMappingSet *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTouom10__classMappingSet(soap)))
			return NULL;
		a->emplace_back();
		uom10__classMappingSet * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_gsoap_uom1_0_uom10__classMappingSet, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet, sizeof(uom10__classMappingSet), 1, gsoap_uom1_0_finsert, gsoap_uom1_0_fbase))
				break;
			if (!soap_in_PointerTouom10__classMappingSet(soap, tag, NULL, "uom10:classMappingSet"))
				break;
		}
		else
		{	if (!soap_in_PointerTouom10__classMappingSet(soap, tag, n, "uom10:classMappingSet"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<uom10__classMappingSet *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTouom10__classMappingSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTouom10__classMappingSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<uom10__classMappingSet *> *p;
	size_t k = sizeof(std::vector<uom10__classMappingSet *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_gsoap_uom1_0_std__vectorTemplateOfPointerTouom10__classMappingSet, n, gsoap_uom1_0_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<uom10__classMappingSet *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<uom10__classMappingSet *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<uom10__classMappingSet *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

} // namespace gsoap_uom1_0


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of gsoap_uom1_0C.cpp */
