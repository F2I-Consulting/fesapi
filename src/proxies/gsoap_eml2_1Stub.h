/*-----------------------------------------------------------------------
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"; you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-----------------------------------------------------------------------*/
/* gsoap_eml2_1Stub.h
   Generated by gSOAP 2.8.54 for eml2_1ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use, no resale/redistribution.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_prodml2	"http://www.energistics.org/energyml/data/prodmlv2"
#define SOAP_NAMESPACE_OF_eml21	"http://www.energistics.org/energyml/data/commonv2"
#define SOAP_NAMESPACE_OF_gml	"http://www.opengis.net/gml/3.2"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_gmd	"http://www.isotc211.org/2005/gmd"
#define SOAP_NAMESPACE_OF_gts	"http://www.isotc211.org/2005/gts"
#define SOAP_NAMESPACE_OF_gco	"http://www.isotc211.org/2005/gco"
#define SOAP_NAMESPACE_OF_gsr	"http://www.isotc211.org/2005/gsr"

#ifndef gsoap_eml2_1Stub_H
#define gsoap_eml2_1Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20854
# error "GSOAP VERSION 20854 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_eml2_1 {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* eml2_1ForGsoap.h:3020 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ParameterKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ParameterKind (913)
/* eml21:ParameterKind */
enum eml21__ParameterKind {
	eml21__ParameterKind__dataObject = 0,
	eml21__ParameterKind__double_ = 1,
	eml21__ParameterKind__integer = 2,
	eml21__ParameterKind__string = 3,
	eml21__ParameterKind__timestamp = 4,
	eml21__ParameterKind__subActivity = 5
};
#endif

/* eml2_1ForGsoap.h:3036 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_1_eml21__AxisOrder2d (914)
/* eml21:AxisOrder2d */
enum eml21__AxisOrder2d {
	eml21__AxisOrder2d__easting_x0020northing = 0,
	eml21__AxisOrder2d__northing_x0020easting = 1,
	eml21__AxisOrder2d__westing_x0020southing = 2,
	eml21__AxisOrder2d__southing_x0020westing = 3,
	eml21__AxisOrder2d__northing_x0020westing = 4,
	eml21__AxisOrder2d__westing_x0020northing = 5
};
#endif

/* eml2_1ForGsoap.h:3067 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalDirection (915)
/* eml21:VerticalDirection */
enum eml21__VerticalDirection {
	eml21__VerticalDirection__up = 0,
	eml21__VerticalDirection__down = 1
};
#endif

/* eml2_1ForGsoap.h:3108 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AggregationType
#define SOAP_TYPE_gsoap_eml2_1_gml__AggregationType (918)
/* gml:AggregationType */
enum gml__AggregationType {
	gml__AggregationType__set = 0,
	gml__AggregationType__bag = 1,
	gml__AggregationType__sequence = 2,
	gml__AggregationType__array = 3,
	gml__AggregationType__record = 4,
	gml__AggregationType__table = 5
};
#endif

/* eml2_1ForGsoap.h:3135 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__show
#define SOAP_TYPE_gsoap_eml2_1__xlink__show (919)
/* xlink:show */
enum _xlink__show {
	_xlink__show__new_ = 0,
	_xlink__show__replace = 1,
	_xlink__show__embed = 2,
	_xlink__show__other = 3,
	_xlink__show__none = 4
};
#endif

/* eml2_1ForGsoap.h:3151 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__actuate
#define SOAP_TYPE_gsoap_eml2_1__xlink__actuate (920)
/* xlink:actuate */
enum _xlink__actuate {
	_xlink__actuate__onLoad = 0,
	_xlink__actuate__onRequest = 1,
	_xlink__actuate__other = 2,
	_xlink__actuate__none = 3
};
#endif

/* eml2_1ForGsoap.h:3295 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasure (927)
/* eml21:UnitOfMeasure */
enum eml21__UnitOfMeasure {
	eml21__UnitOfMeasure__A = 'A',
	eml21__UnitOfMeasure__a = 'a',
	eml21__UnitOfMeasure__b = 'b',
	eml21__UnitOfMeasure__B = 'B',
	eml21__UnitOfMeasure__C = 'C',
	eml21__UnitOfMeasure__D = 'D',
	eml21__UnitOfMeasure__d = 'd',
	eml21__UnitOfMeasure__F = 'F',
	eml21__UnitOfMeasure__g = 'g',
	eml21__UnitOfMeasure__H = 'H',
	eml21__UnitOfMeasure__h = 'h',
	eml21__UnitOfMeasure__J = 'J',
	eml21__UnitOfMeasure__K = 'K',
	eml21__UnitOfMeasure__L = 'L',
	eml21__UnitOfMeasure__m = 'm',
	eml21__UnitOfMeasure__N = 'N',
	eml21__UnitOfMeasure__O = 'O',
	eml21__UnitOfMeasure__P = 'P',
	eml21__UnitOfMeasure__S = 'S',
	eml21__UnitOfMeasure__s = 's',
	eml21__UnitOfMeasure__t = 't',
	eml21__UnitOfMeasure__T = 'T',
	eml21__UnitOfMeasure__V = 'V',
	eml21__UnitOfMeasure__W = 'W',
	eml21__UnitOfMeasure___x0025 = 'u',
	eml21__UnitOfMeasure___x0025_x005barea_x005d = 'v',
	eml21__UnitOfMeasure___x0025_x005bmass_x005d = 'w',
	eml21__UnitOfMeasure___x0025_x005bmolar_x005d = 'x',
	eml21__UnitOfMeasure___x0025_x005bvol_x005d = 'y',
	eml21__UnitOfMeasure___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 'z',
	eml21__UnitOfMeasure___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 123,
	eml21__UnitOfMeasure___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 124,
	eml21__UnitOfMeasure__0_x002e001_x0020bbl_x002fft3 = 125,
	eml21__UnitOfMeasure__0_x002e001_x0020bbl_x002fm3 = 126,
	eml21__UnitOfMeasure__0_x002e001_x0020d_x002fft3 = 127,
	eml21__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 128,
	eml21__UnitOfMeasure__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 129,
	eml21__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 130,
	eml21__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 131,
	eml21__UnitOfMeasure__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 132,
	eml21__UnitOfMeasure__0_x002e001_x0020h_x002fft = 133,
	eml21__UnitOfMeasure__0_x002e001_x0020kPa2_x002fcP = 134,
	eml21__UnitOfMeasure__0_x002e001_x0020lbm_x002fbbl = 135,
	eml21__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 136,
	eml21__UnitOfMeasure__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 137,
	eml21__UnitOfMeasure__0_x002e001_x0020psi_x002fft = 138,
	eml21__UnitOfMeasure__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 139,
	eml21__UnitOfMeasure__0_x002e001_x0020seca = 140,
	eml21__UnitOfMeasure__0_x002e01_x0020bbl_x002fbbl = 141,
	eml21__UnitOfMeasure__0_x002e01_x0020dega_x002fft = 142,
	eml21__UnitOfMeasure__0_x002e01_x0020degF_x002fft = 143,
	eml21__UnitOfMeasure__0_x002e01_x0020dm3_x002fkm = 144,
	eml21__UnitOfMeasure__0_x002e01_x0020ft_x002fft = 145,
	eml21__UnitOfMeasure__0_x002e01_x0020grain_x002fft3 = 146,
	eml21__UnitOfMeasure__0_x002e01_x0020L_x002fkg = 147,
	eml21__UnitOfMeasure__0_x002e01_x0020L_x002fkm = 148,
	eml21__UnitOfMeasure__0_x002e01_x0020lbf_x002fft = 149,
	eml21__UnitOfMeasure__0_x002e01_x0020lbf_x002fft2 = 150,
	eml21__UnitOfMeasure__0_x002e01_x0020lbm_x002fft2 = 151,
	eml21__UnitOfMeasure__0_x002e01_x0020psi_x002fft = 152,
	eml21__UnitOfMeasure__0_x002e1_x0020ft = 153,
	eml21__UnitOfMeasure__0_x002e1_x0020ft_x005bUS_x005d = 154,
	eml21__UnitOfMeasure__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 155,
	eml21__UnitOfMeasure__0_x002e1_x0020in = 156,
	eml21__UnitOfMeasure__0_x002e1_x0020L_x002fbbl = 157,
	eml21__UnitOfMeasure__0_x002e1_x0020lbm_x002fbbl = 158,
	eml21__UnitOfMeasure__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 159,
	eml21__UnitOfMeasure__0_x002e1_x0020yd = 160,
	eml21__UnitOfMeasure__1_x002f_x0028kg_x002es_x0029 = 161,
	eml21__UnitOfMeasure__1_x002f16_x0020in = 162,
	eml21__UnitOfMeasure__1_x002f2_x0020ft = 163,
	eml21__UnitOfMeasure__1_x002f2_x0020ms = 164,
	eml21__UnitOfMeasure__1_x002f30_x0020cm3_x002fmin = 165,
	eml21__UnitOfMeasure__1_x002f30_x0020dega_x002fft = 166,
	eml21__UnitOfMeasure__1_x002f30_x0020dega_x002fm = 167,
	eml21__UnitOfMeasure__1_x002f30_x0020lbf_x002fm = 168,
	eml21__UnitOfMeasure__1_x002f30_x0020m_x002fm = 169,
	eml21__UnitOfMeasure__1_x002f30_x0020N_x002fm = 170,
	eml21__UnitOfMeasure__1_x002f32_x0020in = 171,
	eml21__UnitOfMeasure__1_x002f64_x0020in = 172,
	eml21__UnitOfMeasure__1_x002fa = 173,
	eml21__UnitOfMeasure__1_x002fangstrom = 174,
	eml21__UnitOfMeasure__1_x002fbar = 175,
	eml21__UnitOfMeasure__1_x002fbbl = 176,
	eml21__UnitOfMeasure__1_x002fcm = 177,
	eml21__UnitOfMeasure__1_x002fd = 178,
	eml21__UnitOfMeasure__1_x002fdegC = 179,
	eml21__UnitOfMeasure__1_x002fdegF = 180,
	eml21__UnitOfMeasure__1_x002fdegR = 181,
	eml21__UnitOfMeasure__1_x002fft = 182,
	eml21__UnitOfMeasure__1_x002fft2 = 183,
	eml21__UnitOfMeasure__1_x002fft3 = 184,
	eml21__UnitOfMeasure__1_x002fg = 185,
	eml21__UnitOfMeasure__1_x002fgal_x005bUK_x005d = 186,
	eml21__UnitOfMeasure__1_x002fgal_x005bUS_x005d = 187,
	eml21__UnitOfMeasure__1_x002fh = 188,
	eml21__UnitOfMeasure__1_x002fH = 189,
	eml21__UnitOfMeasure__1_x002fin = 190,
	eml21__UnitOfMeasure__1_x002fK = 191,
	eml21__UnitOfMeasure__1_x002fkg = 192,
	eml21__UnitOfMeasure__1_x002fkm2 = 193,
	eml21__UnitOfMeasure__1_x002fkPa = 194,
	eml21__UnitOfMeasure__1_x002fL = 195,
	eml21__UnitOfMeasure__1_x002flbf = 196,
	eml21__UnitOfMeasure__1_x002flbm = 197,
	eml21__UnitOfMeasure__1_x002fm = 198,
	eml21__UnitOfMeasure__1_x002fm2 = 199,
	eml21__UnitOfMeasure__1_x002fm3 = 200,
	eml21__UnitOfMeasure__1_x002fmi = 201,
	eml21__UnitOfMeasure__1_x002fmi2 = 202,
	eml21__UnitOfMeasure__1_x002fmin = 203,
	eml21__UnitOfMeasure__1_x002fmm = 204,
	eml21__UnitOfMeasure__1_x002fms = 205,
	eml21__UnitOfMeasure__1_x002fN = 206,
	eml21__UnitOfMeasure__1_x002fnm = 207,
	eml21__UnitOfMeasure__1_x002fPa = 208,
	eml21__UnitOfMeasure__1_x002fpPa = 209,
	eml21__UnitOfMeasure__1_x002fpsi = 210,
	eml21__UnitOfMeasure__1_x002fs = 211,
	eml21__UnitOfMeasure__1_x002fupsi = 212,
	eml21__UnitOfMeasure__1_x002fus = 213,
	eml21__UnitOfMeasure__1_x002fuV = 214,
	eml21__UnitOfMeasure__1_x002fV = 215,
	eml21__UnitOfMeasure__1_x002fwk = 216,
	eml21__UnitOfMeasure__1_x002fyd = 217,
	eml21__UnitOfMeasure__10_x0020ft = 218,
	eml21__UnitOfMeasure__10_x0020in = 219,
	eml21__UnitOfMeasure__10_x0020km = 220,
	eml21__UnitOfMeasure__10_x0020kN = 221,
	eml21__UnitOfMeasure__10_x0020Mg_x002fm3 = 222,
	eml21__UnitOfMeasure__100_x0020ft = 223,
	eml21__UnitOfMeasure__100_x0020ka_x005bt_x005d = 224,
	eml21__UnitOfMeasure__100_x0020km = 225,
	eml21__UnitOfMeasure__1000_x0020bbl = 226,
	eml21__UnitOfMeasure__1000_x0020bbl_x002eft_x002fd = 227,
	eml21__UnitOfMeasure__1000_x0020bbl_x002fd = 228,
	eml21__UnitOfMeasure__1000_x0020ft = 229,
	eml21__UnitOfMeasure__1000_x0020ft_x002fh = 230,
	eml21__UnitOfMeasure__1000_x0020ft_x002fs = 231,
	eml21__UnitOfMeasure__1000_x0020ft3 = 232,
	eml21__UnitOfMeasure__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 233,
	eml21__UnitOfMeasure__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 234,
	eml21__UnitOfMeasure__1000_x0020ft3_x002fbbl = 235,
	eml21__UnitOfMeasure__1000_x0020ft3_x002fd = 236,
	eml21__UnitOfMeasure__1000_x0020gal_x005bUK_x005d = 237,
	eml21__UnitOfMeasure__1000_x0020gal_x005bUS_x005d = 238,
	eml21__UnitOfMeasure__1000_x0020lbf_x002eft = 239,
	eml21__UnitOfMeasure__1000_x0020m3 = 240,
	eml21__UnitOfMeasure__1000_x0020m3_x002f_x0028d_x002em_x0029 = 241,
	eml21__UnitOfMeasure__1000_x0020m3_x002f_x0028h_x002em_x0029 = 242,
	eml21__UnitOfMeasure__1000_x0020m3_x002fd = 243,
	eml21__UnitOfMeasure__1000_x0020m3_x002fh = 244,
	eml21__UnitOfMeasure__1000_x0020m3_x002fm3 = 245,
	eml21__UnitOfMeasure__1000_x0020m4_x002fd = 246,
	eml21__UnitOfMeasure__1E12_x0020ft3 = 247,
	eml21__UnitOfMeasure__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 248,
	eml21__UnitOfMeasure__1E_6_x0020acre_x002eft_x002fbbl = 249,
	eml21__UnitOfMeasure__1E6_x0020bbl = 250,
	eml21__UnitOfMeasure__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 251,
	eml21__UnitOfMeasure__1E6_x0020bbl_x002facre = 252,
	eml21__UnitOfMeasure__1E6_x0020bbl_x002fd = 253,
	eml21__UnitOfMeasure__1E_6_x0020bbl_x002fft3 = 254,
	eml21__UnitOfMeasure__1E_6_x0020bbl_x002fm3 = 255,
	eml21__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d = 256,
	eml21__UnitOfMeasure__1E6_x0020Btu_x005bIT_x005d_x002fh = 257,
	eml21__UnitOfMeasure__1E6_x0020ft3 = 258,
	eml21__UnitOfMeasure__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 259,
	eml21__UnitOfMeasure__1E6_x0020ft3_x002fbbl = 260,
	eml21__UnitOfMeasure__1E6_x0020ft3_x002fd = 261,
	eml21__UnitOfMeasure__1E_6_x0020gal_x005bUS_x005d = 262,
	eml21__UnitOfMeasure__1E6_x0020lbm_x002fa = 263,
	eml21__UnitOfMeasure__1E6_x0020m3 = 264,
	eml21__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = 265,
	eml21__UnitOfMeasure__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = 266,
	eml21__UnitOfMeasure__1E6_x0020m3_x002fd = 267,
	eml21__UnitOfMeasure__1E_9_x00201_x002fft = 268,
	eml21__UnitOfMeasure__1E9_x0020bbl = 269,
	eml21__UnitOfMeasure__1E9_x0020ft3 = 270,
	eml21__UnitOfMeasure__30_x0020ft = 271,
	eml21__UnitOfMeasure__30_x0020m = 272,
	eml21__UnitOfMeasure__A_x002eh = 273,
	eml21__UnitOfMeasure__A_x002em2 = 274,
	eml21__UnitOfMeasure__A_x002es = 275,
	eml21__UnitOfMeasure__A_x002es_x002fkg = 276,
	eml21__UnitOfMeasure__A_x002es_x002fm3 = 277,
	eml21__UnitOfMeasure__A_x002fcm2 = 278,
	eml21__UnitOfMeasure__A_x002fft2 = 279,
	eml21__UnitOfMeasure__A_x002fm = 280,
	eml21__UnitOfMeasure__A_x002fm2 = 281,
	eml21__UnitOfMeasure__A_x002fmm = 282,
	eml21__UnitOfMeasure__A_x002fmm2 = 283,
	eml21__UnitOfMeasure__a_x005bt_x005d = 284,
	eml21__UnitOfMeasure__acre = 285,
	eml21__UnitOfMeasure__acre_x002eft = 286,
	eml21__UnitOfMeasure__ag = 287,
	eml21__UnitOfMeasure__aJ = 288,
	eml21__UnitOfMeasure__angstrom = 289,
	eml21__UnitOfMeasure__at = 290,
	eml21__UnitOfMeasure__atm = 291,
	eml21__UnitOfMeasure__atm_x002fft = 292,
	eml21__UnitOfMeasure__atm_x002fh = 293,
	eml21__UnitOfMeasure__atm_x002fhm = 294,
	eml21__UnitOfMeasure__atm_x002fm = 295,
	eml21__UnitOfMeasure__B_x002eW = 296,
	eml21__UnitOfMeasure__b_x002fcm3 = 297,
	eml21__UnitOfMeasure__B_x002fm = 298,
	eml21__UnitOfMeasure__B_x002fO = 299,
	eml21__UnitOfMeasure__bar = 300,
	eml21__UnitOfMeasure__bar_x002fh = 301,
	eml21__UnitOfMeasure__bar_x002fkm = 302,
	eml21__UnitOfMeasure__bar_x002fm = 303,
	eml21__UnitOfMeasure__bar2 = 304,
	eml21__UnitOfMeasure__bar2_x002fcP = 305,
	eml21__UnitOfMeasure__bbl = 306,
	eml21__UnitOfMeasure__bbl_x002f_x0028acre_x002eft_x0029 = 307,
	eml21__UnitOfMeasure__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 308,
	eml21__UnitOfMeasure__bbl_x002f_x0028d_x002eft_x0029 = 309,
	eml21__UnitOfMeasure__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 310,
	eml21__UnitOfMeasure__bbl_x002f_x0028kPa_x002ed_x0029 = 311,
	eml21__UnitOfMeasure__bbl_x002f_x0028psi_x002ed_x0029 = 312,
	eml21__UnitOfMeasure__bbl_x002facre = 313,
	eml21__UnitOfMeasure__bbl_x002fbbl = 314,
	eml21__UnitOfMeasure__bbl_x002fd = 315,
	eml21__UnitOfMeasure__bbl_x002fd2 = 316,
	eml21__UnitOfMeasure__bbl_x002fft = 317,
	eml21__UnitOfMeasure__bbl_x002fft3 = 318,
	eml21__UnitOfMeasure__bbl_x002fh = 319,
	eml21__UnitOfMeasure__bbl_x002fh2 = 320,
	eml21__UnitOfMeasure__bbl_x002fin = 321,
	eml21__UnitOfMeasure__bbl_x002fm3 = 322,
	eml21__UnitOfMeasure__bbl_x002fmi = 323,
	eml21__UnitOfMeasure__bbl_x002fmin = 324,
	eml21__UnitOfMeasure__bbl_x002fpsi = 325,
	eml21__UnitOfMeasure__bbl_x002fton_x005bUK_x005d = 326,
	eml21__UnitOfMeasure__bbl_x002fton_x005bUS_x005d = 327,
	eml21__UnitOfMeasure__Bd = 328,
	eml21__UnitOfMeasure__bit = 329,
	eml21__UnitOfMeasure__bit_x002fs = 330,
	eml21__UnitOfMeasure__Bq = 331,
	eml21__UnitOfMeasure__Bq_x002fkg = 332,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d = 333,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = 334,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = 335,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 336,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = 337,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = 338,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 339,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = 340,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 341,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 342,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = 343,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = 344,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = 345,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 346,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = 347,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 348,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = 349,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fbbl = 350,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fft3 = 351,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 352,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 353,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fh = 354,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002flbm = 355,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002flbmol = 356,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fmin = 357,
	eml21__UnitOfMeasure__Btu_x005bIT_x005d_x002fs = 358,
	eml21__UnitOfMeasure__Btu_x005bth_x005d = 359,
	eml21__UnitOfMeasure__Btu_x005bUK_x005d = 360,
	eml21__UnitOfMeasure__byte = 361,
	eml21__UnitOfMeasure__byte_x002fs = 362,
	eml21__UnitOfMeasure__C_x002em = 363,
	eml21__UnitOfMeasure__C_x002fcm2 = 364,
	eml21__UnitOfMeasure__C_x002fcm3 = 365,
	eml21__UnitOfMeasure__C_x002fg = 366,
	eml21__UnitOfMeasure__C_x002fkg = 367,
	eml21__UnitOfMeasure__C_x002fm2 = 368,
	eml21__UnitOfMeasure__C_x002fm3 = 369,
	eml21__UnitOfMeasure__C_x002fmm2 = 370,
	eml21__UnitOfMeasure__C_x002fmm3 = 371,
	eml21__UnitOfMeasure__ca = 372,
	eml21__UnitOfMeasure__cA = 373,
	eml21__UnitOfMeasure__cal_x005bIT_x005d = 374,
	eml21__UnitOfMeasure__cal_x005bth_x005d = 375,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = 376,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = 377,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 378,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = 379,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 380,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = 381,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = 382,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = 383,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 384,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fcm3 = 385,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fg = 386,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fh = 387,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fkg = 388,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002flbm = 389,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fmL = 390,
	eml21__UnitOfMeasure__cal_x005bth_x005d_x002fmm3 = 391,
	eml21__UnitOfMeasure__cC = 392,
	eml21__UnitOfMeasure__ccal_x005bth_x005d = 393,
	eml21__UnitOfMeasure__ccgr = 394,
	eml21__UnitOfMeasure__cd = 395,
	eml21__UnitOfMeasure__cd_x002fm2 = 396,
	eml21__UnitOfMeasure__cEuc = 397,
	eml21__UnitOfMeasure__ceV = 398,
	eml21__UnitOfMeasure__cF = 399,
	eml21__UnitOfMeasure__cg = 400,
	eml21__UnitOfMeasure__cgauss = 401,
	eml21__UnitOfMeasure__cgr = 402,
	eml21__UnitOfMeasure__cGy = 403,
	eml21__UnitOfMeasure__cH = 404,
	eml21__UnitOfMeasure__chain = 405,
	eml21__UnitOfMeasure__chain_x005bBnA_x005d = 406,
	eml21__UnitOfMeasure__chain_x005bBnB_x005d = 407,
	eml21__UnitOfMeasure__chain_x005bCla_x005d = 408,
	eml21__UnitOfMeasure__chain_x005bInd37_x005d = 409,
	eml21__UnitOfMeasure__chain_x005bSe_x005d = 410,
	eml21__UnitOfMeasure__chain_x005bSeT_x005d = 411,
	eml21__UnitOfMeasure__chain_x005bUS_x005d = 412,
	eml21__UnitOfMeasure__cHz = 413,
	eml21__UnitOfMeasure__Ci = 414,
	eml21__UnitOfMeasure__cJ = 415,
	eml21__UnitOfMeasure__cm = 416,
	eml21__UnitOfMeasure__cm_x002fa = 417,
	eml21__UnitOfMeasure__cm_x002fs = 418,
	eml21__UnitOfMeasure__cm_x002fs2 = 419,
	eml21__UnitOfMeasure__cm2 = 420,
	eml21__UnitOfMeasure__cm2_x002fg = 421,
	eml21__UnitOfMeasure__cm2_x002fs = 422,
	eml21__UnitOfMeasure__cm3 = 423,
	eml21__UnitOfMeasure__cm3_x002fcm3 = 424,
	eml21__UnitOfMeasure__cm3_x002fg = 425,
	eml21__UnitOfMeasure__cm3_x002fh = 426,
	eml21__UnitOfMeasure__cm3_x002fL = 427,
	eml21__UnitOfMeasure__cm3_x002fm3 = 428,
	eml21__UnitOfMeasure__cm3_x002fmin = 429,
	eml21__UnitOfMeasure__cm3_x002fs = 430,
	eml21__UnitOfMeasure__cm4 = 431,
	eml21__UnitOfMeasure__cmH2O_x005b4degC_x005d = 432,
	eml21__UnitOfMeasure__cN = 433,
	eml21__UnitOfMeasure__cohm = 434,
	eml21__UnitOfMeasure__cP = 435,
	eml21__UnitOfMeasure__cPa = 436,
	eml21__UnitOfMeasure__crd = 437,
	eml21__UnitOfMeasure__cS = 438,
	eml21__UnitOfMeasure__cs = 439,
	eml21__UnitOfMeasure__cSt = 440,
	eml21__UnitOfMeasure__ct = 441,
	eml21__UnitOfMeasure__cT = 442,
	eml21__UnitOfMeasure__cu = 443,
	eml21__UnitOfMeasure__cV = 444,
	eml21__UnitOfMeasure__cW = 445,
	eml21__UnitOfMeasure__cWb = 446,
	eml21__UnitOfMeasure__cwt_x005bUK_x005d = 447,
	eml21__UnitOfMeasure__cwt_x005bUS_x005d = 448,
	eml21__UnitOfMeasure__D_x002eft = 449,
	eml21__UnitOfMeasure__D_x002em = 450,
	eml21__UnitOfMeasure__D_x002f_x0028Pa_x002es_x0029 = 451,
	eml21__UnitOfMeasure__d_x002fbbl = 452,
	eml21__UnitOfMeasure__D_x002fcP = 453,
	eml21__UnitOfMeasure__d_x002fft3 = 454,
	eml21__UnitOfMeasure__d_x002fm3 = 455,
	eml21__UnitOfMeasure__D_x005bAPI_x005d = 456,
	eml21__UnitOfMeasure__dA = 457,
	eml21__UnitOfMeasure__dam = 458,
	eml21__UnitOfMeasure__daN = 459,
	eml21__UnitOfMeasure__daN_x002em = 460,
	eml21__UnitOfMeasure__dAPI = 461,
	eml21__UnitOfMeasure__dB = 462,
	eml21__UnitOfMeasure__dB_x002emW = 463,
	eml21__UnitOfMeasure__dB_x002eMW = 464,
	eml21__UnitOfMeasure__dB_x002eW = 465,
	eml21__UnitOfMeasure__dB_x002fft = 466,
	eml21__UnitOfMeasure__dB_x002fkm = 467,
	eml21__UnitOfMeasure__dB_x002fm = 468,
	eml21__UnitOfMeasure__dB_x002fO = 469,
	eml21__UnitOfMeasure__dC = 470,
	eml21__UnitOfMeasure__dcal_x005bth_x005d = 471,
	eml21__UnitOfMeasure__dega = 472,
	eml21__UnitOfMeasure__dega_x002fft = 473,
	eml21__UnitOfMeasure__dega_x002fh = 474,
	eml21__UnitOfMeasure__dega_x002fm = 475,
	eml21__UnitOfMeasure__dega_x002fmin = 476,
	eml21__UnitOfMeasure__dega_x002fs = 477,
	eml21__UnitOfMeasure__degC = 478,
	eml21__UnitOfMeasure__degC_x002em2_x002eh_x002fkcal_x005bth_x005d = 479,
	eml21__UnitOfMeasure__degC_x002fft = 480,
	eml21__UnitOfMeasure__degC_x002fh = 481,
	eml21__UnitOfMeasure__degC_x002fhm = 482,
	eml21__UnitOfMeasure__degC_x002fkm = 483,
	eml21__UnitOfMeasure__degC_x002fkPa = 484,
	eml21__UnitOfMeasure__degC_x002fm = 485,
	eml21__UnitOfMeasure__degC_x002fmin = 486,
	eml21__UnitOfMeasure__degC_x002fs = 487,
	eml21__UnitOfMeasure__degF = 488,
	eml21__UnitOfMeasure__degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 489,
	eml21__UnitOfMeasure__degF_x002fft = 490,
	eml21__UnitOfMeasure__degF_x002fh = 491,
	eml21__UnitOfMeasure__degF_x002fm = 492,
	eml21__UnitOfMeasure__degF_x002fmin = 493,
	eml21__UnitOfMeasure__degF_x002fpsi = 494,
	eml21__UnitOfMeasure__degF_x002fs = 495,
	eml21__UnitOfMeasure__degR = 496,
	eml21__UnitOfMeasure__dEuc = 497,
	eml21__UnitOfMeasure__deV = 498,
	eml21__UnitOfMeasure__dF = 499,
	eml21__UnitOfMeasure__dgauss = 500,
	eml21__UnitOfMeasure__dGy = 501,
	eml21__UnitOfMeasure__dH = 502,
	eml21__UnitOfMeasure__dHz = 503,
	eml21__UnitOfMeasure__dJ = 504,
	eml21__UnitOfMeasure__dm = 505,
	eml21__UnitOfMeasure__dm_x002fs = 506,
	eml21__UnitOfMeasure__dm3 = 507,
	eml21__UnitOfMeasure__dm3_x002f_x0028kW_x002eh_x0029 = 508,
	eml21__UnitOfMeasure__dm3_x002fkg = 509,
	eml21__UnitOfMeasure__dm3_x002fkmol = 510,
	eml21__UnitOfMeasure__dm3_x002fm = 511,
	eml21__UnitOfMeasure__dm3_x002fm3 = 512,
	eml21__UnitOfMeasure__dm3_x002fMJ = 513,
	eml21__UnitOfMeasure__dm3_x002fs = 514,
	eml21__UnitOfMeasure__dm3_x002fs2 = 515,
	eml21__UnitOfMeasure__dm3_x002ft = 516,
	eml21__UnitOfMeasure__dN = 517,
	eml21__UnitOfMeasure__dN_x002em = 518,
	eml21__UnitOfMeasure__dohm = 519,
	eml21__UnitOfMeasure__dP = 520,
	eml21__UnitOfMeasure__dPa = 521,
	eml21__UnitOfMeasure__drd = 522,
	eml21__UnitOfMeasure__ds = 523,
	eml21__UnitOfMeasure__dS = 524,
	eml21__UnitOfMeasure__dT = 525,
	eml21__UnitOfMeasure__dV = 526,
	eml21__UnitOfMeasure__dW = 527,
	eml21__UnitOfMeasure__dWb = 528,
	eml21__UnitOfMeasure__dyne = 529,
	eml21__UnitOfMeasure__dyne_x002ecm2 = 530,
	eml21__UnitOfMeasure__dyne_x002es_x002fcm2 = 531,
	eml21__UnitOfMeasure__dyne_x002fcm = 532,
	eml21__UnitOfMeasure__dyne_x002fcm2 = 533,
	eml21__UnitOfMeasure__EA = 534,
	eml21__UnitOfMeasure__Ea_x005bt_x005d = 535,
	eml21__UnitOfMeasure__EC = 536,
	eml21__UnitOfMeasure__Ecal_x005bth_x005d = 537,
	eml21__UnitOfMeasure__EEuc = 538,
	eml21__UnitOfMeasure__EeV = 539,
	eml21__UnitOfMeasure__EF = 540,
	eml21__UnitOfMeasure__Eg = 541,
	eml21__UnitOfMeasure__Egauss = 542,
	eml21__UnitOfMeasure__EGy = 543,
	eml21__UnitOfMeasure__EH = 544,
	eml21__UnitOfMeasure__EHz = 545,
	eml21__UnitOfMeasure__EJ = 546,
	eml21__UnitOfMeasure__EJ_x002fa = 547,
	eml21__UnitOfMeasure__Em = 548,
	eml21__UnitOfMeasure__EN = 549,
	eml21__UnitOfMeasure__Eohm = 550,
	eml21__UnitOfMeasure__EP = 551,
	eml21__UnitOfMeasure__EPa = 552,
	eml21__UnitOfMeasure__Erd = 553,
	eml21__UnitOfMeasure__erg = 554,
	eml21__UnitOfMeasure__erg_x002fa = 555,
	eml21__UnitOfMeasure__erg_x002fcm2 = 556,
	eml21__UnitOfMeasure__erg_x002fcm3 = 557,
	eml21__UnitOfMeasure__erg_x002fg = 558,
	eml21__UnitOfMeasure__erg_x002fkg = 559,
	eml21__UnitOfMeasure__erg_x002fm3 = 560,
	eml21__UnitOfMeasure__ES = 561,
	eml21__UnitOfMeasure__ET = 562,
	eml21__UnitOfMeasure__Euc = 563,
	eml21__UnitOfMeasure__eV = 564,
	eml21__UnitOfMeasure__EW = 565,
	eml21__UnitOfMeasure__EWb = 566,
	eml21__UnitOfMeasure__F_x002fm = 567,
	eml21__UnitOfMeasure__fa = 568,
	eml21__UnitOfMeasure__fA = 569,
	eml21__UnitOfMeasure__fathom = 570,
	eml21__UnitOfMeasure__fC = 571,
	eml21__UnitOfMeasure__fcal_x005bth_x005d = 572,
	eml21__UnitOfMeasure__fEuc = 573,
	eml21__UnitOfMeasure__feV = 574,
	eml21__UnitOfMeasure__fF = 575,
	eml21__UnitOfMeasure__fg = 576,
	eml21__UnitOfMeasure__fgauss = 577,
	eml21__UnitOfMeasure__fGy = 578,
	eml21__UnitOfMeasure__fH = 579,
	eml21__UnitOfMeasure__fHz = 580,
	eml21__UnitOfMeasure__fJ = 581,
	eml21__UnitOfMeasure__floz_x005bUK_x005d = 582,
	eml21__UnitOfMeasure__floz_x005bUS_x005d = 583,
	eml21__UnitOfMeasure__fm = 584,
	eml21__UnitOfMeasure__fN = 585,
	eml21__UnitOfMeasure__fohm = 586,
	eml21__UnitOfMeasure__footcandle = 587,
	eml21__UnitOfMeasure__footcandle_x002es = 588,
	eml21__UnitOfMeasure__fP = 589,
	eml21__UnitOfMeasure__fPa = 590,
	eml21__UnitOfMeasure__frd = 591,
	eml21__UnitOfMeasure__fS = 592,
	eml21__UnitOfMeasure__ft = 593,
	eml21__UnitOfMeasure__fT = 594,
	eml21__UnitOfMeasure__ft_x002fbbl = 595,
	eml21__UnitOfMeasure__ft_x002fd = 596,
	eml21__UnitOfMeasure__ft_x002fdegF = 597,
	eml21__UnitOfMeasure__ft_x002fft = 598,
	eml21__UnitOfMeasure__ft_x002fft3 = 599,
	eml21__UnitOfMeasure__ft_x002fgal_x005bUS_x005d = 600,
	eml21__UnitOfMeasure__ft_x002fh = 601,
	eml21__UnitOfMeasure__ft_x002fin = 602,
	eml21__UnitOfMeasure__ft_x002flbm = 603,
	eml21__UnitOfMeasure__ft_x002fm = 604,
	eml21__UnitOfMeasure__ft_x002fmi = 605,
	eml21__UnitOfMeasure__ft_x002fmin = 606,
	eml21__UnitOfMeasure__ft_x002fms = 607,
	eml21__UnitOfMeasure__ft_x002fpsi = 608,
	eml21__UnitOfMeasure__ft_x002fs = 609,
	eml21__UnitOfMeasure__ft_x002fs2 = 610,
	eml21__UnitOfMeasure__ft_x002fus = 611,
	eml21__UnitOfMeasure__ft_x005bBnA_x005d = 612,
	eml21__UnitOfMeasure__ft_x005bBnB_x005d = 613,
	eml21__UnitOfMeasure__ft_x005bBr36_x005d = 614,
	eml21__UnitOfMeasure__ft_x005bBr65_x005d = 615,
	eml21__UnitOfMeasure__ft_x005bCla_x005d = 616,
	eml21__UnitOfMeasure__ft_x005bGC_x005d = 617,
	eml21__UnitOfMeasure__ft_x005bInd_x005d = 618,
	eml21__UnitOfMeasure__ft_x005bInd37_x005d = 619,
	eml21__UnitOfMeasure__ft_x005bInd62_x005d = 620,
	eml21__UnitOfMeasure__ft_x005bInd75_x005d = 621,
	eml21__UnitOfMeasure__ft_x005bSe_x005d = 622,
	eml21__UnitOfMeasure__ft_x005bSeT_x005d = 623,
	eml21__UnitOfMeasure__ft_x005bUS_x005d = 624,
	eml21__UnitOfMeasure__ft2 = 625,
	eml21__UnitOfMeasure__ft2_x002fh = 626,
	eml21__UnitOfMeasure__ft2_x002fin3 = 627,
	eml21__UnitOfMeasure__ft2_x002flbm = 628,
	eml21__UnitOfMeasure__ft2_x002fs = 629,
	eml21__UnitOfMeasure__ft3 = 630,
	eml21__UnitOfMeasure__ft3_x002f_x0028d_x002eft_x0029 = 631,
	eml21__UnitOfMeasure__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 632,
	eml21__UnitOfMeasure__ft3_x002f_x0028min_x002eft2_x0029 = 633,
	eml21__UnitOfMeasure__ft3_x002f_x0028s_x002eft2_x0029 = 634,
	eml21__UnitOfMeasure__ft3_x002fbbl = 635,
	eml21__UnitOfMeasure__ft3_x002fd = 636,
	eml21__UnitOfMeasure__ft3_x002fd2 = 637,
	eml21__UnitOfMeasure__ft3_x002fft = 638,
	eml21__UnitOfMeasure__ft3_x002fft2 = 639,
	eml21__UnitOfMeasure__ft3_x002fft3 = 640,
	eml21__UnitOfMeasure__ft3_x002fh = 641,
	eml21__UnitOfMeasure__ft3_x002fh2 = 642,
	eml21__UnitOfMeasure__ft3_x002fkg = 643,
	eml21__UnitOfMeasure__ft3_x002flbm = 644,
	eml21__UnitOfMeasure__ft3_x002flbmol = 645,
	eml21__UnitOfMeasure__ft3_x002fmin = 646,
	eml21__UnitOfMeasure__ft3_x002fmin2 = 647,
	eml21__UnitOfMeasure__ft3_x002frad = 648,
	eml21__UnitOfMeasure__ft3_x002fs = 649,
	eml21__UnitOfMeasure__ft3_x002fs2 = 650,
	eml21__UnitOfMeasure__ft3_x002fsack_x005b94lbm_x005d = 651,
	eml21__UnitOfMeasure__fur_x005bUS_x005d = 652,
	eml21__UnitOfMeasure__fV = 653,
	eml21__UnitOfMeasure__fW = 654,
	eml21__UnitOfMeasure__fWb = 655,
	eml21__UnitOfMeasure__g_x002eft_x002f_x0028cm3_x002es_x0029 = 656,
	eml21__UnitOfMeasure__g_x002em_x002f_x0028cm3_x002es_x0029 = 657,
	eml21__UnitOfMeasure__g_x002fcm3 = 658,
	eml21__UnitOfMeasure__g_x002fcm4 = 659,
	eml21__UnitOfMeasure__g_x002fdm3 = 660,
	eml21__UnitOfMeasure__g_x002fgal_x005bUK_x005d = 661,
	eml21__UnitOfMeasure__g_x002fgal_x005bUS_x005d = 662,
	eml21__UnitOfMeasure__g_x002fkg = 663,
	eml21__UnitOfMeasure__g_x002fL = 664,
	eml21__UnitOfMeasure__g_x002fm3 = 665,
	eml21__UnitOfMeasure__g_x002fmol = 666,
	eml21__UnitOfMeasure__g_x002fs = 667,
	eml21__UnitOfMeasure__g_x002ft = 668,
	eml21__UnitOfMeasure__GA = 669,
	eml21__UnitOfMeasure__Ga_x005bt_x005d = 670,
	eml21__UnitOfMeasure__Gal = 671,
	eml21__UnitOfMeasure__gal_x005bUK_x005d = 672,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 673,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 674,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 675,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 676,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 677,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 678,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fd = 679,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fft3 = 680,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fh = 681,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fh2 = 682,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002flbm = 683,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fmi = 684,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fmin = 685,
	eml21__UnitOfMeasure__gal_x005bUK_x005d_x002fmin2 = 686,
	eml21__UnitOfMeasure__gal_x005bUS_x005d = 687,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 688,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 689,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 690,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 691,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 692,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 693,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fbbl = 694,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fd = 695,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fft = 696,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fft3 = 697,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fh = 698,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fh2 = 699,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002flbm = 700,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fmi = 701,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fmin = 702,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fmin2 = 703,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 704,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 705,
	eml21__UnitOfMeasure__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 706,
	eml21__UnitOfMeasure__gAPI = 707,
	eml21__UnitOfMeasure__gauss = 708,
	eml21__UnitOfMeasure__gauss_x002fcm = 709,
	eml21__UnitOfMeasure__GBq = 710,
	eml21__UnitOfMeasure__GC = 711,
	eml21__UnitOfMeasure__Gcal_x005bth_x005d = 712,
	eml21__UnitOfMeasure__GEuc = 713,
	eml21__UnitOfMeasure__GeV = 714,
	eml21__UnitOfMeasure__gf = 715,
	eml21__UnitOfMeasure__GF = 716,
	eml21__UnitOfMeasure__Gg = 717,
	eml21__UnitOfMeasure__Ggauss = 718,
	eml21__UnitOfMeasure__GGy = 719,
	eml21__UnitOfMeasure__GH = 720,
	eml21__UnitOfMeasure__GHz = 721,
	eml21__UnitOfMeasure__GJ = 722,
	eml21__UnitOfMeasure__Gm = 723,
	eml21__UnitOfMeasure__GN = 724,
	eml21__UnitOfMeasure__gn = 725,
	eml21__UnitOfMeasure__Gohm = 726,
	eml21__UnitOfMeasure__gon = 727,
	eml21__UnitOfMeasure__GP = 728,
	eml21__UnitOfMeasure__GPa = 729,
	eml21__UnitOfMeasure__GPa_x002fcm = 730,
	eml21__UnitOfMeasure__GPa2 = 731,
	eml21__UnitOfMeasure__grain = 732,
	eml21__UnitOfMeasure__grain_x002fft3 = 733,
	eml21__UnitOfMeasure__grain_x002fgal_x005bUS_x005d = 734,
	eml21__UnitOfMeasure__Grd = 735,
	eml21__UnitOfMeasure__GS = 736,
	eml21__UnitOfMeasure__GT = 737,
	eml21__UnitOfMeasure__GV = 738,
	eml21__UnitOfMeasure__GW = 739,
	eml21__UnitOfMeasure__GW_x002eh = 740,
	eml21__UnitOfMeasure__GWb = 741,
	eml21__UnitOfMeasure__Gy = 742,
	eml21__UnitOfMeasure__h_x002fft3 = 743,
	eml21__UnitOfMeasure__h_x002fkm = 744,
	eml21__UnitOfMeasure__H_x002fm = 745,
	eml21__UnitOfMeasure__h_x002fm3 = 746,
	eml21__UnitOfMeasure__ha = 747,
	eml21__UnitOfMeasure__ha_x002em = 748,
	eml21__UnitOfMeasure__hbar = 749,
	eml21__UnitOfMeasure__hg = 750,
	eml21__UnitOfMeasure__hL = 751,
	eml21__UnitOfMeasure__hm = 752,
	eml21__UnitOfMeasure__hN = 753,
	eml21__UnitOfMeasure__hp = 754,
	eml21__UnitOfMeasure__hp_x002eh = 755,
	eml21__UnitOfMeasure__hp_x002eh_x002fbbl = 756,
	eml21__UnitOfMeasure__hp_x002eh_x002flbm = 757,
	eml21__UnitOfMeasure__hp_x002fft3 = 758,
	eml21__UnitOfMeasure__hp_x002fin2 = 759,
	eml21__UnitOfMeasure__hp_x005belec_x005d = 760,
	eml21__UnitOfMeasure__hp_x005bhyd_x005d = 761,
	eml21__UnitOfMeasure__hp_x005bhyd_x005d_x002fin2 = 762,
	eml21__UnitOfMeasure__hp_x005bmetric_x005d = 763,
	eml21__UnitOfMeasure__hp_x005bmetric_x005d_x002eh = 764,
	eml21__UnitOfMeasure__hs = 765,
	eml21__UnitOfMeasure__Hz = 766,
	eml21__UnitOfMeasure__in = 767,
	eml21__UnitOfMeasure__in_x002f_x0028in_x002edegF_x0029 = 768,
	eml21__UnitOfMeasure__in_x002fa = 769,
	eml21__UnitOfMeasure__in_x002fmin = 770,
	eml21__UnitOfMeasure__in_x002fs = 771,
	eml21__UnitOfMeasure__in_x002fs2 = 772,
	eml21__UnitOfMeasure__in_x005bUS_x005d = 773,
	eml21__UnitOfMeasure__in2 = 774,
	eml21__UnitOfMeasure__in2_x002fft2 = 775,
	eml21__UnitOfMeasure__in2_x002fin2 = 776,
	eml21__UnitOfMeasure__in2_x002fs = 777,
	eml21__UnitOfMeasure__in3 = 778,
	eml21__UnitOfMeasure__in3_x002fft = 779,
	eml21__UnitOfMeasure__in4 = 780,
	eml21__UnitOfMeasure__inH2O_x005b39degF_x005d = 781,
	eml21__UnitOfMeasure__inH2O_x005b60degF_x005d = 782,
	eml21__UnitOfMeasure__inHg_x005b32degF_x005d = 783,
	eml21__UnitOfMeasure__inHg_x005b60degF_x005d = 784,
	eml21__UnitOfMeasure__J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = 785,
	eml21__UnitOfMeasure__J_x002em_x002fm2 = 786,
	eml21__UnitOfMeasure__J_x002f_x0028g_x002eK_x0029 = 787,
	eml21__UnitOfMeasure__J_x002f_x0028kg_x002eK_x0029 = 788,
	eml21__UnitOfMeasure__J_x002f_x0028mol_x002eK_x0029 = 789,
	eml21__UnitOfMeasure__J_x002f_x0028s_x002em2_x002edegC_x0029 = 790,
	eml21__UnitOfMeasure__J_x002fcm2 = 791,
	eml21__UnitOfMeasure__J_x002fdm3 = 792,
	eml21__UnitOfMeasure__J_x002fg = 793,
	eml21__UnitOfMeasure__J_x002fK = 794,
	eml21__UnitOfMeasure__J_x002fkg = 795,
	eml21__UnitOfMeasure__J_x002fm = 796,
	eml21__UnitOfMeasure__J_x002fm2 = 797,
	eml21__UnitOfMeasure__J_x002fm3 = 798,
	eml21__UnitOfMeasure__J_x002fmol = 799,
	eml21__UnitOfMeasure__J_x002fs = 800,
	eml21__UnitOfMeasure__K_x002em2_x002fkW = 801,
	eml21__UnitOfMeasure__K_x002em2_x002fW = 802,
	eml21__UnitOfMeasure__K_x002fkm = 803,
	eml21__UnitOfMeasure__K_x002fm = 804,
	eml21__UnitOfMeasure__K_x002fPa = 805,
	eml21__UnitOfMeasure__K_x002fs = 806,
	eml21__UnitOfMeasure__K_x002fW = 807,
	eml21__UnitOfMeasure__kA = 808,
	eml21__UnitOfMeasure__ka_x005bt_x005d = 809,
	eml21__UnitOfMeasure__kC = 810,
	eml21__UnitOfMeasure__kcal_x005bth_x005d = 811,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002em_x002fcm2 = 812,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = 813,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 814,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = 815,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fcm3 = 816,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fg = 817,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fh = 818,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fkg = 819,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fm3 = 820,
	eml21__UnitOfMeasure__kcal_x005bth_x005d_x002fmol = 821,
	eml21__UnitOfMeasure__kcd = 822,
	eml21__UnitOfMeasure__kdyne = 823,
	eml21__UnitOfMeasure__kEuc = 824,
	eml21__UnitOfMeasure__keV = 825,
	eml21__UnitOfMeasure__kF = 826,
	eml21__UnitOfMeasure__kg = 827,
	eml21__UnitOfMeasure__kg_x002em = 828,
	eml21__UnitOfMeasure__kg_x002em_x002fcm2 = 829,
	eml21__UnitOfMeasure__kg_x002em_x002fs = 830,
	eml21__UnitOfMeasure__kg_x002em2 = 831,
	eml21__UnitOfMeasure__kg_x002f_x0028kW_x002eh_x0029 = 832,
	eml21__UnitOfMeasure__kg_x002f_x0028m_x002es_x0029 = 833,
	eml21__UnitOfMeasure__kg_x002f_x0028m2_x002es_x0029 = 834,
	eml21__UnitOfMeasure__kg_x002fd = 835,
	eml21__UnitOfMeasure__kg_x002fdm3 = 836,
	eml21__UnitOfMeasure__kg_x002fdm4 = 837,
	eml21__UnitOfMeasure__kg_x002fh = 838,
	eml21__UnitOfMeasure__kg_x002fJ = 839,
	eml21__UnitOfMeasure__kg_x002fkg = 840,
	eml21__UnitOfMeasure__kg_x002fL = 841,
	eml21__UnitOfMeasure__kg_x002fm = 842,
	eml21__UnitOfMeasure__kg_x002fm2 = 843,
	eml21__UnitOfMeasure__kg_x002fm3 = 844,
	eml21__UnitOfMeasure__kg_x002fm4 = 845,
	eml21__UnitOfMeasure__kg_x002fmin = 846,
	eml21__UnitOfMeasure__kg_x002fMJ = 847,
	eml21__UnitOfMeasure__kg_x002fmol = 848,
	eml21__UnitOfMeasure__kg_x002fs = 849,
	eml21__UnitOfMeasure__kg_x002fsack_x005b94lbm_x005d = 850,
	eml21__UnitOfMeasure__kg_x002ft = 851,
	eml21__UnitOfMeasure__kgauss = 852,
	eml21__UnitOfMeasure__kgf = 853,
	eml21__UnitOfMeasure__kgf_x002em = 854,
	eml21__UnitOfMeasure__kgf_x002em_x002fcm2 = 855,
	eml21__UnitOfMeasure__kgf_x002em_x002fm = 856,
	eml21__UnitOfMeasure__kgf_x002em2 = 857,
	eml21__UnitOfMeasure__kgf_x002es_x002fm2 = 858,
	eml21__UnitOfMeasure__kgf_x002fcm = 859,
	eml21__UnitOfMeasure__kgf_x002fcm2 = 860,
	eml21__UnitOfMeasure__kgf_x002fkgf = 861,
	eml21__UnitOfMeasure__kgf_x002fm2 = 862,
	eml21__UnitOfMeasure__kgf_x002fmm2 = 863,
	eml21__UnitOfMeasure__kGy = 864,
	eml21__UnitOfMeasure__kH = 865,
	eml21__UnitOfMeasure__kHz = 866,
	eml21__UnitOfMeasure__Kibyte = 867,
	eml21__UnitOfMeasure__kJ = 868,
	eml21__UnitOfMeasure__kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = 869,
	eml21__UnitOfMeasure__kJ_x002f_x0028h_x002em2_x002eK_x0029 = 870,
	eml21__UnitOfMeasure__kJ_x002f_x0028kg_x002eK_x0029 = 871,
	eml21__UnitOfMeasure__kJ_x002f_x0028kmol_x002eK_x0029 = 872,
	eml21__UnitOfMeasure__kJ_x002fdm3 = 873,
	eml21__UnitOfMeasure__kJ_x002fkg = 874,
	eml21__UnitOfMeasure__kJ_x002fkmol = 875,
	eml21__UnitOfMeasure__kJ_x002fm3 = 876,
	eml21__UnitOfMeasure__klbf = 877,
	eml21__UnitOfMeasure__klbm = 878,
	eml21__UnitOfMeasure__klbm_x002fin = 879,
	eml21__UnitOfMeasure__klx = 880,
	eml21__UnitOfMeasure__km = 881,
	eml21__UnitOfMeasure__km_x002fcm = 882,
	eml21__UnitOfMeasure__km_x002fdm3 = 883,
	eml21__UnitOfMeasure__km_x002fh = 884,
	eml21__UnitOfMeasure__km_x002fL = 885,
	eml21__UnitOfMeasure__km_x002fs = 886,
	eml21__UnitOfMeasure__km2 = 887,
	eml21__UnitOfMeasure__km3 = 888,
	eml21__UnitOfMeasure__kmol = 889,
	eml21__UnitOfMeasure__kmol_x002fh = 890,
	eml21__UnitOfMeasure__kmol_x002fm3 = 891,
	eml21__UnitOfMeasure__kmol_x002fs = 892,
	eml21__UnitOfMeasure__kN = 893,
	eml21__UnitOfMeasure__kN_x002em = 894,
	eml21__UnitOfMeasure__kN_x002em2 = 895,
	eml21__UnitOfMeasure__kN_x002fm = 896,
	eml21__UnitOfMeasure__kN_x002fm2 = 897,
	eml21__UnitOfMeasure__knot = 898,
	eml21__UnitOfMeasure__kohm = 899,
	eml21__UnitOfMeasure__kohm_x002em = 900,
	eml21__UnitOfMeasure__kP = 901,
	eml21__UnitOfMeasure__kPa = 902,
	eml21__UnitOfMeasure__kPa_x002es_x002fm = 903,
	eml21__UnitOfMeasure__kPa_x002fh = 904,
	eml21__UnitOfMeasure__kPa_x002fhm = 905,
	eml21__UnitOfMeasure__kPa_x002fm = 906,
	eml21__UnitOfMeasure__kPa_x002fmin = 907,
	eml21__UnitOfMeasure__kPa2 = 908,
	eml21__UnitOfMeasure__kPa2_x002fcP = 909,
	eml21__UnitOfMeasure__kpsi = 910,
	eml21__UnitOfMeasure__kpsi2 = 911,
	eml21__UnitOfMeasure__krad = 912,
	eml21__UnitOfMeasure__krd = 913,
	eml21__UnitOfMeasure__kS = 914,
	eml21__UnitOfMeasure__kS_x002fm = 915,
	eml21__UnitOfMeasure__kT = 916,
	eml21__UnitOfMeasure__kV = 917,
	eml21__UnitOfMeasure__kW = 918,
	eml21__UnitOfMeasure__kW_x002eh = 919,
	eml21__UnitOfMeasure__kW_x002eh_x002f_x0028kg_x002edegC_x0029 = 920,
	eml21__UnitOfMeasure__kW_x002eh_x002fdm3 = 921,
	eml21__UnitOfMeasure__kW_x002eh_x002fkg = 922,
	eml21__UnitOfMeasure__kW_x002eh_x002fm3 = 923,
	eml21__UnitOfMeasure__kW_x002f_x0028m2_x002eK_x0029 = 924,
	eml21__UnitOfMeasure__kW_x002f_x0028m3_x002eK_x0029 = 925,
	eml21__UnitOfMeasure__kW_x002fcm2 = 926,
	eml21__UnitOfMeasure__kW_x002fm2 = 927,
	eml21__UnitOfMeasure__kW_x002fm3 = 928,
	eml21__UnitOfMeasure__kWb = 929,
	eml21__UnitOfMeasure__L_x002f_x0028bar_x002emin_x0029 = 930,
	eml21__UnitOfMeasure__L_x002fh = 931,
	eml21__UnitOfMeasure__L_x002fkg = 932,
	eml21__UnitOfMeasure__L_x002fkmol = 933,
	eml21__UnitOfMeasure__L_x002fm = 934,
	eml21__UnitOfMeasure__L_x002fm3 = 935,
	eml21__UnitOfMeasure__L_x002fmin = 936,
	eml21__UnitOfMeasure__L_x002fmol = 937,
	eml21__UnitOfMeasure__L_x002fs = 938,
	eml21__UnitOfMeasure__L_x002fs2 = 939,
	eml21__UnitOfMeasure__L_x002ft = 940,
	eml21__UnitOfMeasure__L_x002fton_x005bUK_x005d = 941,
	eml21__UnitOfMeasure__lbf = 942,
	eml21__UnitOfMeasure__lbf_x002eft = 943,
	eml21__UnitOfMeasure__lbf_x002eft_x002fbbl = 944,
	eml21__UnitOfMeasure__lbf_x002eft_x002fgal_x005bUS_x005d = 945,
	eml21__UnitOfMeasure__lbf_x002eft_x002fin = 946,
	eml21__UnitOfMeasure__lbf_x002eft_x002fin2 = 947,
	eml21__UnitOfMeasure__lbf_x002eft_x002flbm = 948,
	eml21__UnitOfMeasure__lbf_x002eft_x002fmin = 949,
	eml21__UnitOfMeasure__lbf_x002eft_x002fs = 950,
	eml21__UnitOfMeasure__lbf_x002ein = 951,
	eml21__UnitOfMeasure__lbf_x002ein_x002fin = 952,
	eml21__UnitOfMeasure__lbf_x002ein2 = 953,
	eml21__UnitOfMeasure__lbf_x002es_x002fft2 = 954,
	eml21__UnitOfMeasure__lbf_x002es_x002fin2 = 955,
	eml21__UnitOfMeasure__lbf_x002fft = 956,
	eml21__UnitOfMeasure__lbf_x002fft2 = 957,
	eml21__UnitOfMeasure__lbf_x002fft3 = 958,
	eml21__UnitOfMeasure__lbf_x002fgal_x005bUS_x005d = 959,
	eml21__UnitOfMeasure__lbf_x002fin = 960,
	eml21__UnitOfMeasure__lbf_x002flbf = 961,
	eml21__UnitOfMeasure__lbm = 962,
	eml21__UnitOfMeasure__lbm_x002eft = 963,
	eml21__UnitOfMeasure__lbm_x002eft_x002fs = 964,
	eml21__UnitOfMeasure__lbm_x002eft2 = 965,
	eml21__UnitOfMeasure__lbm_x002eft2_x002fs2 = 966,
	eml21__UnitOfMeasure__lbm_x002f_x0028ft_x002eh_x0029 = 967,
	eml21__UnitOfMeasure__lbm_x002f_x0028ft_x002es_x0029 = 968,
	eml21__UnitOfMeasure__lbm_x002f_x0028ft2_x002eh_x0029 = 969,
	eml21__UnitOfMeasure__lbm_x002f_x0028ft2_x002es_x0029 = 970,
	eml21__UnitOfMeasure__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 971,
	eml21__UnitOfMeasure__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 972,
	eml21__UnitOfMeasure__lbm_x002f_x0028hp_x002eh_x0029 = 973,
	eml21__UnitOfMeasure__lbm_x002fbbl = 974,
	eml21__UnitOfMeasure__lbm_x002fd = 975,
	eml21__UnitOfMeasure__lbm_x002fft = 976,
	eml21__UnitOfMeasure__lbm_x002fft2 = 977,
	eml21__UnitOfMeasure__lbm_x002fft3 = 978,
	eml21__UnitOfMeasure__lbm_x002fft4 = 979,
	eml21__UnitOfMeasure__lbm_x002fgal_x005bUK_x005d = 980,
	eml21__UnitOfMeasure__lbm_x002fgal_x005bUS_x005d = 981,
	eml21__UnitOfMeasure__lbm_x002fh = 982,
	eml21__UnitOfMeasure__lbm_x002fin3 = 983,
	eml21__UnitOfMeasure__lbm_x002flbmol = 984,
	eml21__UnitOfMeasure__lbm_x002fmin = 985,
	eml21__UnitOfMeasure__lbm_x002fs = 986,
	eml21__UnitOfMeasure__lbmol = 987,
	eml21__UnitOfMeasure__lbmol_x002f_x0028h_x002eft2_x0029 = 988,
	eml21__UnitOfMeasure__lbmol_x002f_x0028s_x002eft2_x0029 = 989,
	eml21__UnitOfMeasure__lbmol_x002fft3 = 990,
	eml21__UnitOfMeasure__lbmol_x002fgal_x005bUK_x005d = 991,
	eml21__UnitOfMeasure__lbmol_x002fgal_x005bUS_x005d = 992,
	eml21__UnitOfMeasure__lbmol_x002fh = 993,
	eml21__UnitOfMeasure__lbmol_x002fs = 994,
	eml21__UnitOfMeasure__link = 995,
	eml21__UnitOfMeasure__link_x005bBnA_x005d = 996,
	eml21__UnitOfMeasure__link_x005bBnB_x005d = 997,
	eml21__UnitOfMeasure__link_x005bCla_x005d = 998,
	eml21__UnitOfMeasure__link_x005bSe_x005d = 999,
	eml21__UnitOfMeasure__link_x005bSeT_x005d = 1000,
	eml21__UnitOfMeasure__link_x005bUS_x005d = 1001,
	eml21__UnitOfMeasure__lm = 1002,
	eml21__UnitOfMeasure__lm_x002es = 1003,
	eml21__UnitOfMeasure__lm_x002fm2 = 1004,
	eml21__UnitOfMeasure__lm_x002fW = 1005,
	eml21__UnitOfMeasure__lx = 1006,
	eml21__UnitOfMeasure__lx_x002es = 1007,
	eml21__UnitOfMeasure__m_x002f_x0028m_x002eK_x0029 = 1008,
	eml21__UnitOfMeasure__m_x002fcm = 1009,
	eml21__UnitOfMeasure__m_x002fd = 1010,
	eml21__UnitOfMeasure__m_x002fh = 1011,
	eml21__UnitOfMeasure__m_x002fK = 1012,
	eml21__UnitOfMeasure__m_x002fkg = 1013,
	eml21__UnitOfMeasure__m_x002fkm = 1014,
	eml21__UnitOfMeasure__m_x002fkPa = 1015,
	eml21__UnitOfMeasure__m_x002fm = 1016,
	eml21__UnitOfMeasure__m_x002fm3 = 1017,
	eml21__UnitOfMeasure__m_x002fmin = 1018,
	eml21__UnitOfMeasure__m_x002fms = 1019,
	eml21__UnitOfMeasure__m_x002fPa = 1020,
	eml21__UnitOfMeasure__m_x002fs = 1021,
	eml21__UnitOfMeasure__m_x002fs2 = 1022,
	eml21__UnitOfMeasure__m_x005bGer_x005d = 1023,
	eml21__UnitOfMeasure__m2 = 1024,
	eml21__UnitOfMeasure__m2_x002f_x0028kPa_x002ed_x0029 = 1025,
	eml21__UnitOfMeasure__m2_x002f_x0028Pa_x002es_x0029 = 1026,
	eml21__UnitOfMeasure__m2_x002fcm3 = 1027,
	eml21__UnitOfMeasure__m2_x002fd = 1028,
	eml21__UnitOfMeasure__m2_x002fg = 1029,
	eml21__UnitOfMeasure__m2_x002fh = 1030,
	eml21__UnitOfMeasure__m2_x002fkg = 1031,
	eml21__UnitOfMeasure__m2_x002fm2 = 1032,
	eml21__UnitOfMeasure__m2_x002fm3 = 1033,
	eml21__UnitOfMeasure__m2_x002fmol = 1034,
	eml21__UnitOfMeasure__m2_x002fs = 1035,
	eml21__UnitOfMeasure__m3 = 1036,
	eml21__UnitOfMeasure__m3_x002f_x0028bar_x002ed_x0029 = 1037,
	eml21__UnitOfMeasure__m3_x002f_x0028bar_x002eh_x0029 = 1038,
	eml21__UnitOfMeasure__m3_x002f_x0028bar_x002emin_x0029 = 1039,
	eml21__UnitOfMeasure__m3_x002f_x0028d_x002em_x0029 = 1040,
	eml21__UnitOfMeasure__m3_x002f_x0028h_x002em_x0029 = 1041,
	eml21__UnitOfMeasure__m3_x002f_x0028ha_x002em_x0029 = 1042,
	eml21__UnitOfMeasure__m3_x002f_x0028kPa_x002ed_x0029 = 1043,
	eml21__UnitOfMeasure__m3_x002f_x0028kPa_x002eh_x0029 = 1044,
	eml21__UnitOfMeasure__m3_x002f_x0028kW_x002eh_x0029 = 1045,
	eml21__UnitOfMeasure__m3_x002f_x0028m3_x002eK_x0029 = 1046,
	eml21__UnitOfMeasure__m3_x002f_x0028Pa_x002es_x0029 = 1047,
	eml21__UnitOfMeasure__m3_x002f_x0028psi_x002ed_x0029 = 1048,
	eml21__UnitOfMeasure__m3_x002f_x0028s_x002eft_x0029 = 1049,
	eml21__UnitOfMeasure__m3_x002f_x0028s_x002em_x0029 = 1050,
	eml21__UnitOfMeasure__m3_x002f_x0028s_x002em2_x0029 = 1051,
	eml21__UnitOfMeasure__m3_x002f_x0028s_x002em3_x0029 = 1052,
	eml21__UnitOfMeasure__m3_x002fbbl = 1053,
	eml21__UnitOfMeasure__m3_x002fd = 1054,
	eml21__UnitOfMeasure__m3_x002fd2 = 1055,
	eml21__UnitOfMeasure__m3_x002fg = 1056,
	eml21__UnitOfMeasure__m3_x002fh = 1057,
	eml21__UnitOfMeasure__m3_x002fJ = 1058,
	eml21__UnitOfMeasure__m3_x002fkg = 1059,
	eml21__UnitOfMeasure__m3_x002fkm = 1060,
	eml21__UnitOfMeasure__m3_x002fkmol = 1061,
	eml21__UnitOfMeasure__m3_x002fkPa = 1062,
	eml21__UnitOfMeasure__m3_x002fm = 1063,
	eml21__UnitOfMeasure__m3_x002fm2 = 1064,
	eml21__UnitOfMeasure__m3_x002fm3 = 1065,
	eml21__UnitOfMeasure__m3_x002fmin = 1066,
	eml21__UnitOfMeasure__m3_x002fmol = 1067,
	eml21__UnitOfMeasure__m3_x002fPa = 1068,
	eml21__UnitOfMeasure__m3_x002frad = 1069,
	eml21__UnitOfMeasure__m3_x002frev = 1070,
	eml21__UnitOfMeasure__m3_x002fs = 1071,
	eml21__UnitOfMeasure__m3_x002fs2 = 1072,
	eml21__UnitOfMeasure__m3_x002ft = 1073,
	eml21__UnitOfMeasure__m3_x002fton_x005bUK_x005d = 1074,
	eml21__UnitOfMeasure__m3_x002fton_x005bUS_x005d = 1075,
	eml21__UnitOfMeasure__m4 = 1076,
	eml21__UnitOfMeasure__m4_x002fs = 1077,
	eml21__UnitOfMeasure__mA = 1078,
	eml21__UnitOfMeasure__MA = 1079,
	eml21__UnitOfMeasure__mA_x002fcm2 = 1080,
	eml21__UnitOfMeasure__mA_x002fft2 = 1081,
	eml21__UnitOfMeasure__Ma_x005bt_x005d = 1082,
	eml21__UnitOfMeasure__mbar = 1083,
	eml21__UnitOfMeasure__MBq = 1084,
	eml21__UnitOfMeasure__mC = 1085,
	eml21__UnitOfMeasure__MC = 1086,
	eml21__UnitOfMeasure__mC_x002fm2 = 1087,
	eml21__UnitOfMeasure__mcal_x005bth_x005d = 1088,
	eml21__UnitOfMeasure__Mcal_x005bth_x005d = 1089,
	eml21__UnitOfMeasure__mCi = 1090,
	eml21__UnitOfMeasure__mD = 1091,
	eml21__UnitOfMeasure__mD_x002eft = 1092,
	eml21__UnitOfMeasure__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 1093,
	eml21__UnitOfMeasure__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 1094,
	eml21__UnitOfMeasure__mD_x002em = 1095,
	eml21__UnitOfMeasure__mD_x002f_x0028Pa_x002es_x0029 = 1096,
	eml21__UnitOfMeasure__mD_x002fcP = 1097,
	eml21__UnitOfMeasure__MEuc = 1098,
	eml21__UnitOfMeasure__mEuc = 1099,
	eml21__UnitOfMeasure__meV = 1100,
	eml21__UnitOfMeasure__MeV = 1101,
	eml21__UnitOfMeasure__MF = 1102,
	eml21__UnitOfMeasure__mF = 1103,
	eml21__UnitOfMeasure__mg = 1104,
	eml21__UnitOfMeasure__Mg = 1105,
	eml21__UnitOfMeasure__Mg_x002fa = 1106,
	eml21__UnitOfMeasure__Mg_x002fd = 1107,
	eml21__UnitOfMeasure__mg_x002fdm3 = 1108,
	eml21__UnitOfMeasure__mg_x002fg = 1109,
	eml21__UnitOfMeasure__mg_x002fgal_x005bUS_x005d = 1110,
	eml21__UnitOfMeasure__Mg_x002fh = 1111,
	eml21__UnitOfMeasure__Mg_x002fin = 1112,
	eml21__UnitOfMeasure__mg_x002fJ = 1113,
	eml21__UnitOfMeasure__mg_x002fkg = 1114,
	eml21__UnitOfMeasure__mg_x002fL = 1115,
	eml21__UnitOfMeasure__Mg_x002fm2 = 1116,
	eml21__UnitOfMeasure__mg_x002fm3 = 1117,
	eml21__UnitOfMeasure__Mg_x002fm3 = 1118,
	eml21__UnitOfMeasure__Mg_x002fmin = 1119,
	eml21__UnitOfMeasure__mGal = 1120,
	eml21__UnitOfMeasure__mgauss = 1121,
	eml21__UnitOfMeasure__Mgauss = 1122,
	eml21__UnitOfMeasure__Mgf = 1123,
	eml21__UnitOfMeasure__mgn = 1124,
	eml21__UnitOfMeasure__MGy = 1125,
	eml21__UnitOfMeasure__mGy = 1126,
	eml21__UnitOfMeasure__mH = 1127,
	eml21__UnitOfMeasure__MH = 1128,
	eml21__UnitOfMeasure__mHz = 1129,
	eml21__UnitOfMeasure__MHz = 1130,
	eml21__UnitOfMeasure__mi = 1131,
	eml21__UnitOfMeasure__mi_x002fgal_x005bUK_x005d = 1132,
	eml21__UnitOfMeasure__mi_x002fgal_x005bUS_x005d = 1133,
	eml21__UnitOfMeasure__mi_x002fh = 1134,
	eml21__UnitOfMeasure__mi_x002fin = 1135,
	eml21__UnitOfMeasure__mi_x005bnaut_x005d = 1136,
	eml21__UnitOfMeasure__mi_x005bnautUK_x005d = 1137,
	eml21__UnitOfMeasure__mi_x005bUS_x005d = 1138,
	eml21__UnitOfMeasure__mi_x005bUS_x005d2 = 1139,
	eml21__UnitOfMeasure__mi2 = 1140,
	eml21__UnitOfMeasure__mi3 = 1141,
	eml21__UnitOfMeasure__Mibyte = 1142,
	eml21__UnitOfMeasure__mil = 1143,
	eml21__UnitOfMeasure__mil_x002fa = 1144,
	eml21__UnitOfMeasure__mila = 1145,
	eml21__UnitOfMeasure__min_ = 1146,
	eml21__UnitOfMeasure__min_x002fft = 1147,
	eml21__UnitOfMeasure__min_x002fm = 1148,
	eml21__UnitOfMeasure__mina = 1149,
	eml21__UnitOfMeasure__mJ = 1150,
	eml21__UnitOfMeasure__MJ = 1151,
	eml21__UnitOfMeasure__MJ_x002fa = 1152,
	eml21__UnitOfMeasure__mJ_x002fcm2 = 1153,
	eml21__UnitOfMeasure__MJ_x002fkg = 1154,
	eml21__UnitOfMeasure__MJ_x002fkmol = 1155,
	eml21__UnitOfMeasure__MJ_x002fm = 1156,
	eml21__UnitOfMeasure__mJ_x002fm2 = 1157,
	eml21__UnitOfMeasure__MJ_x002fm3 = 1158,
	eml21__UnitOfMeasure__mL = 1159,
	eml21__UnitOfMeasure__mL_x002fgal_x005bUK_x005d = 1160,
	eml21__UnitOfMeasure__mL_x002fgal_x005bUS_x005d = 1161,
	eml21__UnitOfMeasure__mL_x002fmL = 1162,
	eml21__UnitOfMeasure__mm = 1163,
	eml21__UnitOfMeasure__Mm = 1164,
	eml21__UnitOfMeasure__mm_x002f_x0028mm_x002eK_x0029 = 1165,
	eml21__UnitOfMeasure__mm_x002fa = 1166,
	eml21__UnitOfMeasure__mm_x002fs = 1167,
	eml21__UnitOfMeasure__mm2 = 1168,
	eml21__UnitOfMeasure__mm2_x002fmm2 = 1169,
	eml21__UnitOfMeasure__mm2_x002fs = 1170,
	eml21__UnitOfMeasure__mm3 = 1171,
	eml21__UnitOfMeasure__mm3_x002fJ = 1172,
	eml21__UnitOfMeasure__mmHg_x005b0degC_x005d = 1173,
	eml21__UnitOfMeasure__mmol = 1174,
	eml21__UnitOfMeasure__MN = 1175,
	eml21__UnitOfMeasure__mN = 1176,
	eml21__UnitOfMeasure__mN_x002em2 = 1177,
	eml21__UnitOfMeasure__mN_x002fkm = 1178,
	eml21__UnitOfMeasure__mN_x002fm = 1179,
	eml21__UnitOfMeasure__Mohm = 1180,
	eml21__UnitOfMeasure__mohm = 1181,
	eml21__UnitOfMeasure__mol = 1182,
	eml21__UnitOfMeasure__mol_x002em2_x002f_x0028mol_x002es_x0029 = 1183,
	eml21__UnitOfMeasure__mol_x002f_x0028s_x002em2_x0029 = 1184,
	eml21__UnitOfMeasure__mol_x002fm2 = 1185,
	eml21__UnitOfMeasure__mol_x002fm3 = 1186,
	eml21__UnitOfMeasure__mol_x002fmol = 1187,
	eml21__UnitOfMeasure__mol_x002fs = 1188,
	eml21__UnitOfMeasure__MP = 1189,
	eml21__UnitOfMeasure__mP = 1190,
	eml21__UnitOfMeasure__mPa = 1191,
	eml21__UnitOfMeasure__MPa = 1192,
	eml21__UnitOfMeasure__mPa_x002es = 1193,
	eml21__UnitOfMeasure__MPa_x002es_x002fm = 1194,
	eml21__UnitOfMeasure__MPa_x002fh = 1195,
	eml21__UnitOfMeasure__MPa_x002fm = 1196,
	eml21__UnitOfMeasure__Mpsi = 1197,
	eml21__UnitOfMeasure__Mrad = 1198,
	eml21__UnitOfMeasure__mrad = 1199,
	eml21__UnitOfMeasure__mrd = 1200,
	eml21__UnitOfMeasure__Mrd = 1201,
	eml21__UnitOfMeasure__mrem = 1202,
	eml21__UnitOfMeasure__mrem_x002fh = 1203,
	eml21__UnitOfMeasure__ms = 1204,
	eml21__UnitOfMeasure__MS = 1205,
	eml21__UnitOfMeasure__mS = 1206,
	eml21__UnitOfMeasure__mS_x002fcm = 1207,
	eml21__UnitOfMeasure__ms_x002fcm = 1208,
	eml21__UnitOfMeasure__ms_x002fft = 1209,
	eml21__UnitOfMeasure__ms_x002fin = 1210,
	eml21__UnitOfMeasure__mS_x002fm = 1211,
	eml21__UnitOfMeasure__ms_x002fm = 1212,
	eml21__UnitOfMeasure__ms_x002fs = 1213,
	eml21__UnitOfMeasure__mSv = 1214,
	eml21__UnitOfMeasure__mSv_x002fh = 1215,
	eml21__UnitOfMeasure__mT = 1216,
	eml21__UnitOfMeasure__mT_x002fdm = 1217,
	eml21__UnitOfMeasure__MV = 1218,
	eml21__UnitOfMeasure__mV = 1219,
	eml21__UnitOfMeasure__mV_x002fft = 1220,
	eml21__UnitOfMeasure__mV_x002fm = 1221,
	eml21__UnitOfMeasure__mW = 1222,
	eml21__UnitOfMeasure__MW = 1223,
	eml21__UnitOfMeasure__MW_x002eh = 1224,
	eml21__UnitOfMeasure__MW_x002eh_x002fkg = 1225,
	eml21__UnitOfMeasure__MW_x002eh_x002fm3 = 1226,
	eml21__UnitOfMeasure__mW_x002fm2 = 1227,
	eml21__UnitOfMeasure__MWb = 1228,
	eml21__UnitOfMeasure__mWb = 1229,
	eml21__UnitOfMeasure__N_x002em = 1230,
	eml21__UnitOfMeasure__N_x002em_x002fm = 1231,
	eml21__UnitOfMeasure__N_x002em2 = 1232,
	eml21__UnitOfMeasure__N_x002es_x002fm2 = 1233,
	eml21__UnitOfMeasure__N_x002fm = 1234,
	eml21__UnitOfMeasure__N_x002fm2 = 1235,
	eml21__UnitOfMeasure__N_x002fm3 = 1236,
	eml21__UnitOfMeasure__N_x002fmm2 = 1237,
	eml21__UnitOfMeasure__N_x002fN = 1238,
	eml21__UnitOfMeasure__na = 1239,
	eml21__UnitOfMeasure__nA = 1240,
	eml21__UnitOfMeasure__nAPI = 1241,
	eml21__UnitOfMeasure__nC = 1242,
	eml21__UnitOfMeasure__ncal_x005bth_x005d = 1243,
	eml21__UnitOfMeasure__nCi = 1244,
	eml21__UnitOfMeasure__nEuc = 1245,
	eml21__UnitOfMeasure__neV = 1246,
	eml21__UnitOfMeasure__nF = 1247,
	eml21__UnitOfMeasure__ng = 1248,
	eml21__UnitOfMeasure__ng_x002fg = 1249,
	eml21__UnitOfMeasure__ng_x002fmg = 1250,
	eml21__UnitOfMeasure__ngauss = 1251,
	eml21__UnitOfMeasure__nGy = 1252,
	eml21__UnitOfMeasure__nH = 1253,
	eml21__UnitOfMeasure__nHz = 1254,
	eml21__UnitOfMeasure__nJ = 1255,
	eml21__UnitOfMeasure__nm = 1256,
	eml21__UnitOfMeasure__nm_x002fs = 1257,
	eml21__UnitOfMeasure__nN = 1258,
	eml21__UnitOfMeasure__nohm = 1259,
	eml21__UnitOfMeasure__nohm_x002emil2_x002fft = 1260,
	eml21__UnitOfMeasure__nohm_x002emm2_x002fm = 1261,
	eml21__UnitOfMeasure__nP = 1262,
	eml21__UnitOfMeasure__nPa = 1263,
	eml21__UnitOfMeasure__nrd = 1264,
	eml21__UnitOfMeasure__ns = 1265,
	eml21__UnitOfMeasure__nS = 1266,
	eml21__UnitOfMeasure__ns_x002fft = 1267,
	eml21__UnitOfMeasure__ns_x002fm = 1268,
	eml21__UnitOfMeasure__nT = 1269,
	eml21__UnitOfMeasure__nV = 1270,
	eml21__UnitOfMeasure__nW = 1271,
	eml21__UnitOfMeasure__nWb = 1272,
	eml21__UnitOfMeasure__Oe = 1273,
	eml21__UnitOfMeasure__ohm = 1274,
	eml21__UnitOfMeasure__ohm_x002ecm = 1275,
	eml21__UnitOfMeasure__ohm_x002em = 1276,
	eml21__UnitOfMeasure__ohm_x002em2_x002fm = 1277,
	eml21__UnitOfMeasure__ohm_x002fm = 1278,
	eml21__UnitOfMeasure__ozf = 1279,
	eml21__UnitOfMeasure__ozm = 1280,
	eml21__UnitOfMeasure__ozm_x005btroy_x005d = 1281,
	eml21__UnitOfMeasure__Pa = 1282,
	eml21__UnitOfMeasure__pA = 1283,
	eml21__UnitOfMeasure__Pa_x002es = 1284,
	eml21__UnitOfMeasure__Pa_x002es_x002em3_x002fkg = 1285,
	eml21__UnitOfMeasure__Pa_x002es_x002fm3 = 1286,
	eml21__UnitOfMeasure__Pa_x002es2_x002fm3 = 1287,
	eml21__UnitOfMeasure__Pa_x002fh = 1288,
	eml21__UnitOfMeasure__Pa_x002fm = 1289,
	eml21__UnitOfMeasure__Pa_x002fm3 = 1290,
	eml21__UnitOfMeasure__Pa_x002fs = 1291,
	eml21__UnitOfMeasure__Pa2 = 1292,
	eml21__UnitOfMeasure__Pa2_x002f_x0028Pa_x002es_x0029 = 1293,
	eml21__UnitOfMeasure__pC = 1294,
	eml21__UnitOfMeasure__pcal_x005bth_x005d = 1295,
	eml21__UnitOfMeasure__pCi = 1296,
	eml21__UnitOfMeasure__pCi_x002fg = 1297,
	eml21__UnitOfMeasure__pdl = 1298,
	eml21__UnitOfMeasure__pdl_x002ecm2 = 1299,
	eml21__UnitOfMeasure__pdl_x002eft = 1300,
	eml21__UnitOfMeasure__pdl_x002fcm = 1301,
	eml21__UnitOfMeasure__pEuc = 1302,
	eml21__UnitOfMeasure__peV = 1303,
	eml21__UnitOfMeasure__pF = 1304,
	eml21__UnitOfMeasure__pg = 1305,
	eml21__UnitOfMeasure__pgauss = 1306,
	eml21__UnitOfMeasure__pGy = 1307,
	eml21__UnitOfMeasure__pHz = 1308,
	eml21__UnitOfMeasure__pJ = 1309,
	eml21__UnitOfMeasure__pm = 1310,
	eml21__UnitOfMeasure__pN = 1311,
	eml21__UnitOfMeasure__pohm = 1312,
	eml21__UnitOfMeasure__pP = 1313,
	eml21__UnitOfMeasure__pPa = 1314,
	eml21__UnitOfMeasure__ppk = 1315,
	eml21__UnitOfMeasure__ppm = 1316,
	eml21__UnitOfMeasure__ppm_x005bmass_x005d = 1317,
	eml21__UnitOfMeasure__ppm_x005bvol_x005d = 1318,
	eml21__UnitOfMeasure__ppm_x005bvol_x005d_x002fdegC = 1319,
	eml21__UnitOfMeasure__ppm_x005bvol_x005d_x002fdegF = 1320,
	eml21__UnitOfMeasure__prd = 1321,
	eml21__UnitOfMeasure__pS = 1322,
	eml21__UnitOfMeasure__ps = 1323,
	eml21__UnitOfMeasure__psi = 1324,
	eml21__UnitOfMeasure__psi_x002ed_x002fbbl = 1325,
	eml21__UnitOfMeasure__psi_x002es = 1326,
	eml21__UnitOfMeasure__psi_x002fft = 1327,
	eml21__UnitOfMeasure__psi_x002fh = 1328,
	eml21__UnitOfMeasure__psi_x002fm = 1329,
	eml21__UnitOfMeasure__psi_x002fmin = 1330,
	eml21__UnitOfMeasure__psi2 = 1331,
	eml21__UnitOfMeasure__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1332,
	eml21__UnitOfMeasure__psi2_x002fcP = 1333,
	eml21__UnitOfMeasure__pT = 1334,
	eml21__UnitOfMeasure__pt_x005bUK_x005d = 1335,
	eml21__UnitOfMeasure__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 1336,
	eml21__UnitOfMeasure__pt_x005bUS_x005d = 1337,
	eml21__UnitOfMeasure__pV = 1338,
	eml21__UnitOfMeasure__pW = 1339,
	eml21__UnitOfMeasure__pWb = 1340,
	eml21__UnitOfMeasure__qt_x005bUK_x005d = 1341,
	eml21__UnitOfMeasure__qt_x005bUS_x005d = 1342,
	eml21__UnitOfMeasure__quad = 1343,
	eml21__UnitOfMeasure__quad_x002fa = 1344,
	eml21__UnitOfMeasure__rad = 1345,
	eml21__UnitOfMeasure__rad_x002fft = 1346,
	eml21__UnitOfMeasure__rad_x002fft3 = 1347,
	eml21__UnitOfMeasure__rad_x002fm = 1348,
	eml21__UnitOfMeasure__rad_x002fm3 = 1349,
	eml21__UnitOfMeasure__rad_x002fs = 1350,
	eml21__UnitOfMeasure__rad_x002fs2 = 1351,
	eml21__UnitOfMeasure__rd = 1352,
	eml21__UnitOfMeasure__rem = 1353,
	eml21__UnitOfMeasure__rem_x002fh = 1354,
	eml21__UnitOfMeasure__rev = 1355,
	eml21__UnitOfMeasure__rev_x002fft = 1356,
	eml21__UnitOfMeasure__rev_x002fm = 1357,
	eml21__UnitOfMeasure__rev_x002fs = 1358,
	eml21__UnitOfMeasure__rod_x005bUS_x005d = 1359,
	eml21__UnitOfMeasure__rpm = 1360,
	eml21__UnitOfMeasure__rpm_x002fs = 1361,
	eml21__UnitOfMeasure__s_x002fcm = 1362,
	eml21__UnitOfMeasure__s_x002fft = 1363,
	eml21__UnitOfMeasure__s_x002fft3 = 1364,
	eml21__UnitOfMeasure__s_x002fin = 1365,
	eml21__UnitOfMeasure__s_x002fkg = 1366,
	eml21__UnitOfMeasure__s_x002fL = 1367,
	eml21__UnitOfMeasure__s_x002fm = 1368,
	eml21__UnitOfMeasure__S_x002fm = 1369,
	eml21__UnitOfMeasure__s_x002fm3 = 1370,
	eml21__UnitOfMeasure__s_x002fqt_x005bUK_x005d = 1371,
	eml21__UnitOfMeasure__s_x002fqt_x005bUS_x005d = 1372,
	eml21__UnitOfMeasure__s_x002fs = 1373,
	eml21__UnitOfMeasure__sack_x005b94lbm_x005d = 1374,
	eml21__UnitOfMeasure__seca = 1375,
	eml21__UnitOfMeasure__section = 1376,
	eml21__UnitOfMeasure__sr = 1377,
	eml21__UnitOfMeasure__St = 1378,
	eml21__UnitOfMeasure__Sv = 1379,
	eml21__UnitOfMeasure__Sv_x002fh = 1380,
	eml21__UnitOfMeasure__Sv_x002fs = 1381,
	eml21__UnitOfMeasure__t_x002fa = 1382,
	eml21__UnitOfMeasure__t_x002fd = 1383,
	eml21__UnitOfMeasure__t_x002fh = 1384,
	eml21__UnitOfMeasure__T_x002fm = 1385,
	eml21__UnitOfMeasure__t_x002fm3 = 1386,
	eml21__UnitOfMeasure__t_x002fmin = 1387,
	eml21__UnitOfMeasure__TA = 1388,
	eml21__UnitOfMeasure__Ta_x005bt_x005d = 1389,
	eml21__UnitOfMeasure__TBq = 1390,
	eml21__UnitOfMeasure__TC = 1391,
	eml21__UnitOfMeasure__Tcal_x005bth_x005d = 1392,
	eml21__UnitOfMeasure__TD_x005bAPI_x005d = 1393,
	eml21__UnitOfMeasure__TD_x005bAPI_x005d_x002em = 1394,
	eml21__UnitOfMeasure__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 1395,
	eml21__UnitOfMeasure__TEuc = 1396,
	eml21__UnitOfMeasure__TeV = 1397,
	eml21__UnitOfMeasure__TF = 1398,
	eml21__UnitOfMeasure__Tg = 1399,
	eml21__UnitOfMeasure__Tgauss = 1400,
	eml21__UnitOfMeasure__TGy = 1401,
	eml21__UnitOfMeasure__TH = 1402,
	eml21__UnitOfMeasure__therm_x005bEC_x005d = 1403,
	eml21__UnitOfMeasure__therm_x005bUK_x005d = 1404,
	eml21__UnitOfMeasure__therm_x005bUS_x005d = 1405,
	eml21__UnitOfMeasure__THz = 1406,
	eml21__UnitOfMeasure__TJ = 1407,
	eml21__UnitOfMeasure__TJ_x002fa = 1408,
	eml21__UnitOfMeasure__Tm = 1409,
	eml21__UnitOfMeasure__TN = 1410,
	eml21__UnitOfMeasure__Tohm = 1411,
	eml21__UnitOfMeasure__ton_x005bUK_x005d = 1412,
	eml21__UnitOfMeasure__ton_x005bUK_x005d_x002fa = 1413,
	eml21__UnitOfMeasure__ton_x005bUK_x005d_x002fd = 1414,
	eml21__UnitOfMeasure__ton_x005bUK_x005d_x002fh = 1415,
	eml21__UnitOfMeasure__ton_x005bUK_x005d_x002fmin = 1416,
	eml21__UnitOfMeasure__ton_x005bUS_x005d = 1417,
	eml21__UnitOfMeasure__ton_x005bUS_x005d_x002fa = 1418,
	eml21__UnitOfMeasure__ton_x005bUS_x005d_x002fd = 1419,
	eml21__UnitOfMeasure__ton_x005bUS_x005d_x002fft2 = 1420,
	eml21__UnitOfMeasure__ton_x005bUS_x005d_x002fh = 1421,
	eml21__UnitOfMeasure__ton_x005bUS_x005d_x002fmin = 1422,
	eml21__UnitOfMeasure__tonf_x005bUK_x005d = 1423,
	eml21__UnitOfMeasure__tonf_x005bUK_x005d_x002eft2 = 1424,
	eml21__UnitOfMeasure__tonf_x005bUK_x005d_x002fft = 1425,
	eml21__UnitOfMeasure__tonf_x005bUK_x005d_x002fft2 = 1426,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d = 1427,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002eft = 1428,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002eft2 = 1429,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002emi = 1430,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002emi_x002fbbl = 1431,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002emi_x002fft = 1432,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002fft = 1433,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002fft2 = 1434,
	eml21__UnitOfMeasure__tonf_x005bUS_x005d_x002fin2 = 1435,
	eml21__UnitOfMeasure__tonRefrig = 1436,
	eml21__UnitOfMeasure__torr = 1437,
	eml21__UnitOfMeasure__TP = 1438,
	eml21__UnitOfMeasure__TPa = 1439,
	eml21__UnitOfMeasure__Trd = 1440,
	eml21__UnitOfMeasure__TS = 1441,
	eml21__UnitOfMeasure__TT = 1442,
	eml21__UnitOfMeasure__TV = 1443,
	eml21__UnitOfMeasure__TW = 1444,
	eml21__UnitOfMeasure__TW_x002eh = 1445,
	eml21__UnitOfMeasure__TWb = 1446,
	eml21__UnitOfMeasure__uA = 1447,
	eml21__UnitOfMeasure__uA_x002fcm2 = 1448,
	eml21__UnitOfMeasure__uA_x002fin2 = 1449,
	eml21__UnitOfMeasure__ubar = 1450,
	eml21__UnitOfMeasure__uC = 1451,
	eml21__UnitOfMeasure__ucal_x005bth_x005d = 1452,
	eml21__UnitOfMeasure__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 1453,
	eml21__UnitOfMeasure__ucal_x005bth_x005d_x002fs = 1454,
	eml21__UnitOfMeasure__uCi = 1455,
	eml21__UnitOfMeasure__uEuc = 1456,
	eml21__UnitOfMeasure__ueV = 1457,
	eml21__UnitOfMeasure__uF = 1458,
	eml21__UnitOfMeasure__uF_x002fm = 1459,
	eml21__UnitOfMeasure__ug = 1460,
	eml21__UnitOfMeasure__ug_x002fcm3 = 1461,
	eml21__UnitOfMeasure__ug_x002fg = 1462,
	eml21__UnitOfMeasure__ug_x002fmg = 1463,
	eml21__UnitOfMeasure__ugauss = 1464,
	eml21__UnitOfMeasure__uGy = 1465,
	eml21__UnitOfMeasure__uH = 1466,
	eml21__UnitOfMeasure__uH_x002fm = 1467,
	eml21__UnitOfMeasure__uHz = 1468,
	eml21__UnitOfMeasure__uJ = 1469,
	eml21__UnitOfMeasure__um = 1470,
	eml21__UnitOfMeasure__um_x002fs = 1471,
	eml21__UnitOfMeasure__um2 = 1472,
	eml21__UnitOfMeasure__um2_x002em = 1473,
	eml21__UnitOfMeasure__umHg_x005b0degC_x005d = 1474,
	eml21__UnitOfMeasure__umol = 1475,
	eml21__UnitOfMeasure__uN = 1476,
	eml21__UnitOfMeasure__uohm = 1477,
	eml21__UnitOfMeasure__uohm_x002fft = 1478,
	eml21__UnitOfMeasure__uohm_x002fm = 1479,
	eml21__UnitOfMeasure__uP = 1480,
	eml21__UnitOfMeasure__uPa = 1481,
	eml21__UnitOfMeasure__upsi = 1482,
	eml21__UnitOfMeasure__urad = 1483,
	eml21__UnitOfMeasure__urd = 1484,
	eml21__UnitOfMeasure__us = 1485,
	eml21__UnitOfMeasure__uS = 1486,
	eml21__UnitOfMeasure__us_x002fft = 1487,
	eml21__UnitOfMeasure__us_x002fin = 1488,
	eml21__UnitOfMeasure__us_x002fm = 1489,
	eml21__UnitOfMeasure__uT = 1490,
	eml21__UnitOfMeasure__uV = 1491,
	eml21__UnitOfMeasure__uV_x002fft = 1492,
	eml21__UnitOfMeasure__uV_x002fm = 1493,
	eml21__UnitOfMeasure__uW = 1494,
	eml21__UnitOfMeasure__uW_x002fm3 = 1495,
	eml21__UnitOfMeasure__uWb = 1496,
	eml21__UnitOfMeasure__V_x002fB = 1497,
	eml21__UnitOfMeasure__V_x002fdB = 1498,
	eml21__UnitOfMeasure__V_x002fm = 1499,
	eml21__UnitOfMeasure__W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = 1500,
	eml21__UnitOfMeasure__W_x002f_x0028m_x002eK_x0029 = 1501,
	eml21__UnitOfMeasure__W_x002f_x0028m2_x002eK_x0029 = 1502,
	eml21__UnitOfMeasure__W_x002f_x0028m2_x002esr_x0029 = 1503,
	eml21__UnitOfMeasure__W_x002f_x0028m3_x002eK_x0029 = 1504,
	eml21__UnitOfMeasure__W_x002fcm2 = 1505,
	eml21__UnitOfMeasure__W_x002fK = 1506,
	eml21__UnitOfMeasure__W_x002fkW = 1507,
	eml21__UnitOfMeasure__W_x002fm2 = 1508,
	eml21__UnitOfMeasure__W_x002fm3 = 1509,
	eml21__UnitOfMeasure__W_x002fmm2 = 1510,
	eml21__UnitOfMeasure__W_x002fsr = 1511,
	eml21__UnitOfMeasure__W_x002fW = 1512,
	eml21__UnitOfMeasure__Wb = 1513,
	eml21__UnitOfMeasure__Wb_x002em = 1514,
	eml21__UnitOfMeasure__Wb_x002fm = 1515,
	eml21__UnitOfMeasure__Wb_x002fmm = 1516,
	eml21__UnitOfMeasure__wk = 1517,
	eml21__UnitOfMeasure__yd = 1518,
	eml21__UnitOfMeasure__yd_x005bBnA_x005d = 1519,
	eml21__UnitOfMeasure__yd_x005bBnB_x005d = 1520,
	eml21__UnitOfMeasure__yd_x005bCla_x005d = 1521,
	eml21__UnitOfMeasure__yd_x005bInd_x005d = 1522,
	eml21__UnitOfMeasure__yd_x005bInd37_x005d = 1523,
	eml21__UnitOfMeasure__yd_x005bInd62_x005d = 1524,
	eml21__UnitOfMeasure__yd_x005bInd75_x005d = 1525,
	eml21__UnitOfMeasure__yd_x005bSe_x005d = 1526,
	eml21__UnitOfMeasure__yd_x005bSeT_x005d = 1527,
	eml21__UnitOfMeasure__yd_x005bUS_x005d = 1528,
	eml21__UnitOfMeasure__yd2 = 1529,
	eml21__UnitOfMeasure__yd3 = 1530
};
#endif

/* eml2_1ForGsoap.h:4755 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUom (930)
/* eml21:AbsorbedDoseUom */
enum eml21__AbsorbedDoseUom {
	eml21__AbsorbedDoseUom__cGy = 0,
	eml21__AbsorbedDoseUom__crd = 1,
	eml21__AbsorbedDoseUom__dGy = 2,
	eml21__AbsorbedDoseUom__drd = 3,
	eml21__AbsorbedDoseUom__EGy = 4,
	eml21__AbsorbedDoseUom__Erd = 5,
	eml21__AbsorbedDoseUom__fGy = 6,
	eml21__AbsorbedDoseUom__frd = 7,
	eml21__AbsorbedDoseUom__GGy = 8,
	eml21__AbsorbedDoseUom__Grd = 9,
	eml21__AbsorbedDoseUom__Gy = 10,
	eml21__AbsorbedDoseUom__kGy = 11,
	eml21__AbsorbedDoseUom__krd = 12,
	eml21__AbsorbedDoseUom__mGy = 13,
	eml21__AbsorbedDoseUom__MGy = 14,
	eml21__AbsorbedDoseUom__Mrd = 15,
	eml21__AbsorbedDoseUom__mrd = 16,
	eml21__AbsorbedDoseUom__nGy = 17,
	eml21__AbsorbedDoseUom__nrd = 18,
	eml21__AbsorbedDoseUom__pGy = 19,
	eml21__AbsorbedDoseUom__prd = 20,
	eml21__AbsorbedDoseUom__rd = 21,
	eml21__AbsorbedDoseUom__TGy = 22,
	eml21__AbsorbedDoseUom__Trd = 23,
	eml21__AbsorbedDoseUom__uGy = 24,
	eml21__AbsorbedDoseUom__urd = 25
};
#endif

/* eml2_1ForGsoap.h:4866 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUom (931)
/* eml21:ActivityOfRadioactivityUom */
enum eml21__ActivityOfRadioactivityUom {
	eml21__ActivityOfRadioactivityUom__Bq = 0,
	eml21__ActivityOfRadioactivityUom__Ci = 1,
	eml21__ActivityOfRadioactivityUom__GBq = 2,
	eml21__ActivityOfRadioactivityUom__MBq = 3,
	eml21__ActivityOfRadioactivityUom__mCi = 4,
	eml21__ActivityOfRadioactivityUom__nCi = 5,
	eml21__ActivityOfRadioactivityUom__pCi = 6,
	eml21__ActivityOfRadioactivityUom__TBq = 7,
	eml21__ActivityOfRadioactivityUom__uCi = 8
};
#endif

/* eml2_1ForGsoap.h:4909 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUom (932)
/* eml21:AmountOfSubstancePerAmountOfSubstanceUom */
enum eml21__AmountOfSubstancePerAmountOfSubstanceUom {
	eml21__AmountOfSubstancePerAmountOfSubstanceUom___x0025 = 0,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom___x0025_x005bmolar_x005d = 1,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom__Euc = 2,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom__mol_x002fmol = 3,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom__nEuc = 4,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom__ppk = 5,
	eml21__AmountOfSubstancePerAmountOfSubstanceUom__ppm = 6
};
#endif

/* eml2_1ForGsoap.h:4944 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUom (933)
/* eml21:AmountOfSubstancePerAreaUom */
enum eml21__AmountOfSubstancePerAreaUom {
	eml21__AmountOfSubstancePerAreaUom__mol_x002fm2 = 0
};
#endif

/* eml2_1ForGsoap.h:4955 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUom (934)
/* eml21:AmountOfSubstancePerTimePerAreaUom */
enum eml21__AmountOfSubstancePerTimePerAreaUom {
	eml21__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028h_x002eft2_x0029 = 0,
	eml21__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028s_x002eft2_x0029 = 1,
	eml21__AmountOfSubstancePerTimePerAreaUom__mol_x002f_x0028s_x002em2_x0029 = 2
};
#endif

/* eml2_1ForGsoap.h:4974 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUom (935)
/* eml21:AmountOfSubstancePerTimeUom */
enum eml21__AmountOfSubstancePerTimeUom {
	eml21__AmountOfSubstancePerTimeUom__kat = 0,
	eml21__AmountOfSubstancePerTimeUom__kmol_x002fh = 1,
	eml21__AmountOfSubstancePerTimeUom__kmol_x002fs = 2,
	eml21__AmountOfSubstancePerTimeUom__lbmol_x002fh = 3,
	eml21__AmountOfSubstancePerTimeUom__lbmol_x002fs = 4,
	eml21__AmountOfSubstancePerTimeUom__mol_x002fs = 5
};
#endif

/* eml2_1ForGsoap.h:5005 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUom (936)
/* eml21:AmountOfSubstancePerVolumeUom */
enum eml21__AmountOfSubstancePerVolumeUom {
	eml21__AmountOfSubstancePerVolumeUom__kmol_x002fm3 = 0,
	eml21__AmountOfSubstancePerVolumeUom__lbmol_x002fft3 = 1,
	eml21__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUK_x005d = 2,
	eml21__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUS_x005d = 3,
	eml21__AmountOfSubstancePerVolumeUom__mol_x002fm3 = 4
};
#endif

/* eml2_1ForGsoap.h:5032 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUom (937)
/* eml21:AmountOfSubstanceUom */
enum eml21__AmountOfSubstanceUom {
	eml21__AmountOfSubstanceUom__kmol = 0,
	eml21__AmountOfSubstanceUom__lbmol = 1,
	eml21__AmountOfSubstanceUom__mmol = 2,
	eml21__AmountOfSubstanceUom__mol = 3,
	eml21__AmountOfSubstanceUom__umol = 4
};
#endif

/* eml2_1ForGsoap.h:5059 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUom (938)
/* eml21:AnglePerLengthUom */
enum eml21__AnglePerLengthUom {
	eml21__AnglePerLengthUom__0_x002e01_x0020dega_x002fft = 0,
	eml21__AnglePerLengthUom__1_x002f30_x0020dega_x002fft = 1,
	eml21__AnglePerLengthUom__1_x002f30_x0020dega_x002fm = 2,
	eml21__AnglePerLengthUom__dega_x002fft = 3,
	eml21__AnglePerLengthUom__dega_x002fm = 4,
	eml21__AnglePerLengthUom__rad_x002fft = 5,
	eml21__AnglePerLengthUom__rad_x002fm = 6,
	eml21__AnglePerLengthUom__rev_x002fft = 7,
	eml21__AnglePerLengthUom__rev_x002fm = 8
};
#endif

/* eml2_1ForGsoap.h:5102 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUom (939)
/* eml21:AnglePerVolumeUom */
enum eml21__AnglePerVolumeUom {
	eml21__AnglePerVolumeUom__rad_x002fft3 = 0,
	eml21__AnglePerVolumeUom__rad_x002fm3 = 1
};
#endif

/* eml2_1ForGsoap.h:5117 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUom (940)
/* eml21:AngularAccelerationUom */
enum eml21__AngularAccelerationUom {
	eml21__AngularAccelerationUom__rad_x002fs2 = 0,
	eml21__AngularAccelerationUom__rpm_x002fs = 1
};
#endif

/* eml2_1ForGsoap.h:5132 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUom (941)
/* eml21:AngularVelocityUom */
enum eml21__AngularVelocityUom {
	eml21__AngularVelocityUom__dega_x002fh = 0,
	eml21__AngularVelocityUom__dega_x002fmin = 1,
	eml21__AngularVelocityUom__dega_x002fs = 2,
	eml21__AngularVelocityUom__rad_x002fs = 3,
	eml21__AngularVelocityUom__rev_x002fs = 4,
	eml21__AngularVelocityUom__rpm = 5
};
#endif

/* eml2_1ForGsoap.h:5163 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUom (942)
/* eml21:APIGammaRayUom */
enum eml21__APIGammaRayUom {
	eml21__APIGammaRayUom__gAPI = 0
};
#endif

/* eml2_1ForGsoap.h:5174 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUom (943)
/* eml21:APIGravityUom */
enum eml21__APIGravityUom {
	eml21__APIGravityUom__dAPI = 0
};
#endif

/* eml2_1ForGsoap.h:5185 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUom (944)
/* eml21:APINeutronUom */
enum eml21__APINeutronUom {
	eml21__APINeutronUom__nAPI = 0
};
#endif

/* eml2_1ForGsoap.h:5196 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUom (945)
/* eml21:AreaPerAmountOfSubstanceUom */
enum eml21__AreaPerAmountOfSubstanceUom {
	eml21__AreaPerAmountOfSubstanceUom__m2_x002fmol = 0
};
#endif

/* eml2_1ForGsoap.h:5207 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUom (946)
/* eml21:AreaPerAreaUom */
enum eml21__AreaPerAreaUom {
	eml21__AreaPerAreaUom___x0025 = 0,
	eml21__AreaPerAreaUom___x0025_x005barea_x005d = 1,
	eml21__AreaPerAreaUom__cEuc = 2,
	eml21__AreaPerAreaUom__Euc = 3,
	eml21__AreaPerAreaUom__in2_x002fft2 = 4,
	eml21__AreaPerAreaUom__in2_x002fin2 = 5,
	eml21__AreaPerAreaUom__m2_x002fm2 = 6,
	eml21__AreaPerAreaUom__mm2_x002fmm2 = 7
};
#endif

/* eml2_1ForGsoap.h:5246 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUom (947)
/* eml21:AreaPerCountUom */
enum eml21__AreaPerCountUom {
	eml21__AreaPerCountUom__b_x002felectron = 0
};
#endif

/* eml2_1ForGsoap.h:5254 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUom (948)
/* eml21:AreaPerMassUom */
enum eml21__AreaPerMassUom {
	eml21__AreaPerMassUom__cm2_x002fg = 0,
	eml21__AreaPerMassUom__ft2_x002flbm = 1,
	eml21__AreaPerMassUom__m2_x002fg = 2,
	eml21__AreaPerMassUom__m2_x002fkg = 3
};
#endif

/* eml2_1ForGsoap.h:5277 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUom (949)
/* eml21:AreaPerTimeUom */
enum eml21__AreaPerTimeUom {
	eml21__AreaPerTimeUom__cm2_x002fs = 0,
	eml21__AreaPerTimeUom__ft2_x002fh = 1,
	eml21__AreaPerTimeUom__ft2_x002fs = 2,
	eml21__AreaPerTimeUom__in2_x002fs = 3,
	eml21__AreaPerTimeUom__m2_x002fd = 4,
	eml21__AreaPerTimeUom__m2_x002fh = 5,
	eml21__AreaPerTimeUom__m2_x002fs = 6,
	eml21__AreaPerTimeUom__mm2_x002fs = 7
};
#endif

/* eml2_1ForGsoap.h:5316 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUom (950)
/* eml21:AreaPerVolumeUom */
enum eml21__AreaPerVolumeUom {
	eml21__AreaPerVolumeUom__1_x002fm = 0,
	eml21__AreaPerVolumeUom__b_x002fcm3 = 1,
	eml21__AreaPerVolumeUom__cu = 2,
	eml21__AreaPerVolumeUom__ft2_x002fin3 = 3,
	eml21__AreaPerVolumeUom__m2_x002fcm3 = 4,
	eml21__AreaPerVolumeUom__m2_x002fm3 = 5
};
#endif

/* eml2_1ForGsoap.h:5347 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaUom (951)
/* eml21:AreaUom */
enum eml21__AreaUom {
	eml21__AreaUom__b = 'b',
	eml21__AreaUom__acre = 'c',
	eml21__AreaUom__cm2 = 'd',
	eml21__AreaUom__ft2 = 'e',
	eml21__AreaUom__ha = 'f',
	eml21__AreaUom__in2 = 'g',
	eml21__AreaUom__km2 = 'h',
	eml21__AreaUom__m2 = 'i',
	eml21__AreaUom__mi_x005bUS_x005d2 = 'j',
	eml21__AreaUom__mi2 = 'k',
	eml21__AreaUom__mm2 = 'l',
	eml21__AreaUom__section = 'm',
	eml21__AreaUom__um2 = 'n',
	eml21__AreaUom__yd2 = 'o'
};
#endif

/* eml2_1ForGsoap.h:5410 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUom (952)
/* eml21:AttenuationPerFrequencyIntervalUom */
enum eml21__AttenuationPerFrequencyIntervalUom {
	eml21__AttenuationPerFrequencyIntervalUom__B_x002fO = 0,
	eml21__AttenuationPerFrequencyIntervalUom__dB_x002fO = 1
};
#endif

/* eml2_1ForGsoap.h:5425 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUom (953)
/* eml21:CapacitanceUom */
enum eml21__CapacitanceUom {
	eml21__CapacitanceUom__F = 'F',
	eml21__CapacitanceUom__cF = 'G',
	eml21__CapacitanceUom__dF = 'H',
	eml21__CapacitanceUom__EF = 'I',
	eml21__CapacitanceUom__fF = 'J',
	eml21__CapacitanceUom__GF = 'K',
	eml21__CapacitanceUom__kF = 'L',
	eml21__CapacitanceUom__mF = 'M',
	eml21__CapacitanceUom__MF = 'N',
	eml21__CapacitanceUom__nF = 'O',
	eml21__CapacitanceUom__pF = 'P',
	eml21__CapacitanceUom__TF = 'Q',
	eml21__CapacitanceUom__uF = 'R'
};
#endif

/* eml2_1ForGsoap.h:5484 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUom (954)
/* eml21:CationExchangeCapacityUom */
enum eml21__CationExchangeCapacityUom {
	eml21__CationExchangeCapacityUom___x002e01_x0020meq_x002fg = 0
};
#endif

/* eml2_1ForGsoap.h:5492 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUom (955)
/* eml21:DataTransferSpeedUom */
enum eml21__DataTransferSpeedUom {
	eml21__DataTransferSpeedUom__bit_x002fs = 0,
	eml21__DataTransferSpeedUom__byte_x002fs = 1
};
#endif

/* eml2_1ForGsoap.h:5507 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUom (956)
/* eml21:DiffusionCoefficientUom */
enum eml21__DiffusionCoefficientUom {
	eml21__DiffusionCoefficientUom__m2_x002fs = 0
};
#endif

/* eml2_1ForGsoap.h:5518 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUom (957)
/* eml21:DiffusiveTimeOfFlightUom */
enum eml21__DiffusiveTimeOfFlightUom {
	eml21__DiffusiveTimeOfFlightUom__h_x00280_x002e5_x0029 = 0,
	eml21__DiffusiveTimeOfFlightUom__s_x00280_x002e5_x0029 = 1
};
#endif

/* eml2_1ForGsoap.h:5530 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUom (958)
/* eml21:DigitalStorageUom */
enum eml21__DigitalStorageUom {
	eml21__DigitalStorageUom__bit = 0,
	eml21__DigitalStorageUom__byte = 1,
	eml21__DigitalStorageUom__Kibyte = 2,
	eml21__DigitalStorageUom__Mibyte = 3
};
#endif

/* eml2_1ForGsoap.h:5553 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUom (959)
/* eml21:DimensionlessUom */
enum eml21__DimensionlessUom {
	eml21__DimensionlessUom___x0025 = 0,
	eml21__DimensionlessUom__cEuc = 1,
	eml21__DimensionlessUom__dEuc = 2,
	eml21__DimensionlessUom__EEuc = 3,
	eml21__DimensionlessUom__Euc = 4,
	eml21__DimensionlessUom__fEuc = 5,
	eml21__DimensionlessUom__GEuc = 6,
	eml21__DimensionlessUom__kEuc = 7,
	eml21__DimensionlessUom__MEuc = 8,
	eml21__DimensionlessUom__mEuc = 9,
	eml21__DimensionlessUom__nEuc = 10,
	eml21__DimensionlessUom__pEuc = 11,
	eml21__DimensionlessUom__ppk = 12,
	eml21__DimensionlessUom__ppm = 13,
	eml21__DimensionlessUom__TEuc = 14,
	eml21__DimensionlessUom__uEuc = 15
};
#endif

/* eml2_1ForGsoap.h:5624 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUom (960)
/* eml21:DipoleMomentUom */
enum eml21__DipoleMomentUom {
	eml21__DipoleMomentUom__C_x002em = 0
};
#endif

/* eml2_1ForGsoap.h:5635 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUom (961)
/* eml21:DoseEquivalentUom */
enum eml21__DoseEquivalentUom {
	eml21__DoseEquivalentUom__mrem = 0,
	eml21__DoseEquivalentUom__mSv = 1,
	eml21__DoseEquivalentUom__rem = 2,
	eml21__DoseEquivalentUom__Sv = 3
};
#endif

/* eml2_1ForGsoap.h:5658 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUom (962)
/* eml21:DynamicViscosityUom */
enum eml21__DynamicViscosityUom {
	eml21__DynamicViscosityUom__P = 'P',
	eml21__DynamicViscosityUom__cP = 'Q',
	eml21__DynamicViscosityUom__dP = 'R',
	eml21__DynamicViscosityUom__dyne_x002es_x002fcm2 = 'S',
	eml21__DynamicViscosityUom__EP = 'T',
	eml21__DynamicViscosityUom__fP = 'U',
	eml21__DynamicViscosityUom__GP = 'V',
	eml21__DynamicViscosityUom__kgf_x002es_x002fm2 = 'W',
	eml21__DynamicViscosityUom__kP = 'X',
	eml21__DynamicViscosityUom__lbf_x002es_x002fft2 = 'Y',
	eml21__DynamicViscosityUom__lbf_x002es_x002fin2 = 'Z',
	eml21__DynamicViscosityUom__mP = 91,
	eml21__DynamicViscosityUom__MP = 92,
	eml21__DynamicViscosityUom__mPa_x002es = 93,
	eml21__DynamicViscosityUom__N_x002es_x002fm2 = 94,
	eml21__DynamicViscosityUom__nP = 95,
	eml21__DynamicViscosityUom__Pa_x002es = 96,
	eml21__DynamicViscosityUom__pP = 'a',
	eml21__DynamicViscosityUom__psi_x002es = 'b',
	eml21__DynamicViscosityUom__TP = 'c',
	eml21__DynamicViscosityUom__uP = 'd'
};
#endif

/* eml2_1ForGsoap.h:5749 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUom (963)
/* eml21:ElectricalResistivityUom */
enum eml21__ElectricalResistivityUom {
	eml21__ElectricalResistivityUom__kohm_x002em = 0,
	eml21__ElectricalResistivityUom__nohm_x002emil2_x002fft = 1,
	eml21__ElectricalResistivityUom__nohm_x002emm2_x002fm = 2,
	eml21__ElectricalResistivityUom__ohm_x002ecm = 3,
	eml21__ElectricalResistivityUom__ohm_x002em = 4,
	eml21__ElectricalResistivityUom__ohm_x002em2_x002fm = 5
};
#endif

/* eml2_1ForGsoap.h:5780 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUom (964)
/* eml21:ElectricChargePerAreaUom */
enum eml21__ElectricChargePerAreaUom {
	eml21__ElectricChargePerAreaUom__C_x002fcm2 = 0,
	eml21__ElectricChargePerAreaUom__C_x002fm2 = 1,
	eml21__ElectricChargePerAreaUom__C_x002fmm2 = 2,
	eml21__ElectricChargePerAreaUom__mC_x002fm2 = 3
};
#endif

/* eml2_1ForGsoap.h:5803 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUom (965)
/* eml21:ElectricChargePerMassUom */
enum eml21__ElectricChargePerMassUom {
	eml21__ElectricChargePerMassUom__A_x002es_x002fkg = 0,
	eml21__ElectricChargePerMassUom__C_x002fg = 1,
	eml21__ElectricChargePerMassUom__C_x002fkg = 2
};
#endif

/* eml2_1ForGsoap.h:5822 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUom (966)
/* eml21:ElectricChargePerVolumeUom */
enum eml21__ElectricChargePerVolumeUom {
	eml21__ElectricChargePerVolumeUom__A_x002es_x002fm3 = 0,
	eml21__ElectricChargePerVolumeUom__C_x002fcm3 = 1,
	eml21__ElectricChargePerVolumeUom__C_x002fm3 = 2,
	eml21__ElectricChargePerVolumeUom__C_x002fmm3 = 3
};
#endif

/* eml2_1ForGsoap.h:5845 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUom (967)
/* eml21:ElectricChargeUom */
enum eml21__ElectricChargeUom {
	eml21__ElectricChargeUom__C = 'C',
	eml21__ElectricChargeUom__A_x002eh = 'D',
	eml21__ElectricChargeUom__A_x002es = 'E',
	eml21__ElectricChargeUom__cC = 'F',
	eml21__ElectricChargeUom__dC = 'G',
	eml21__ElectricChargeUom__EC = 'H',
	eml21__ElectricChargeUom__fC = 'I',
	eml21__ElectricChargeUom__GC = 'J',
	eml21__ElectricChargeUom__kC = 'K',
	eml21__ElectricChargeUom__MC = 'L',
	eml21__ElectricChargeUom__mC = 'M',
	eml21__ElectricChargeUom__nC = 'N',
	eml21__ElectricChargeUom__pC = 'O',
	eml21__ElectricChargeUom__TC = 'P',
	eml21__ElectricChargeUom__uC = 'Q'
};
#endif

/* eml2_1ForGsoap.h:5912 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUom (968)
/* eml21:ElectricConductanceUom */
enum eml21__ElectricConductanceUom {
	eml21__ElectricConductanceUom__S = 'S',
	eml21__ElectricConductanceUom__cS = 'T',
	eml21__ElectricConductanceUom__dS = 'U',
	eml21__ElectricConductanceUom__ES = 'V',
	eml21__ElectricConductanceUom__fS = 'W',
	eml21__ElectricConductanceUom__GS = 'X',
	eml21__ElectricConductanceUom__kS = 'Y',
	eml21__ElectricConductanceUom__mS = 'Z',
	eml21__ElectricConductanceUom__MS = 91,
	eml21__ElectricConductanceUom__nS = 92,
	eml21__ElectricConductanceUom__pS = 93,
	eml21__ElectricConductanceUom__TS = 94,
	eml21__ElectricConductanceUom__uS = 95
};
#endif

/* eml2_1ForGsoap.h:5971 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUom (969)
/* eml21:ElectricConductivityUom */
enum eml21__ElectricConductivityUom {
	eml21__ElectricConductivityUom__kS_x002fm = 0,
	eml21__ElectricConductivityUom__mS_x002fcm = 1,
	eml21__ElectricConductivityUom__mS_x002fm = 2,
	eml21__ElectricConductivityUom__S_x002fm = 3
};
#endif

/* eml2_1ForGsoap.h:5994 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUom (970)
/* eml21:ElectricCurrentDensityUom */
enum eml21__ElectricCurrentDensityUom {
	eml21__ElectricCurrentDensityUom__A_x002fcm2 = 0,
	eml21__ElectricCurrentDensityUom__A_x002fft2 = 1,
	eml21__ElectricCurrentDensityUom__A_x002fm2 = 2,
	eml21__ElectricCurrentDensityUom__A_x002fmm2 = 3,
	eml21__ElectricCurrentDensityUom__mA_x002fcm2 = 4,
	eml21__ElectricCurrentDensityUom__mA_x002fft2 = 5,
	eml21__ElectricCurrentDensityUom__uA_x002fcm2 = 6,
	eml21__ElectricCurrentDensityUom__uA_x002fin2 = 7
};
#endif

/* eml2_1ForGsoap.h:6033 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUom (971)
/* eml21:ElectricCurrentUom */
enum eml21__ElectricCurrentUom {
	eml21__ElectricCurrentUom__A = 'A',
	eml21__ElectricCurrentUom__cA = 'B',
	eml21__ElectricCurrentUom__dA = 'C',
	eml21__ElectricCurrentUom__EA = 'D',
	eml21__ElectricCurrentUom__fA = 'E',
	eml21__ElectricCurrentUom__GA = 'F',
	eml21__ElectricCurrentUom__kA = 'G',
	eml21__ElectricCurrentUom__MA = 'H',
	eml21__ElectricCurrentUom__mA = 'I',
	eml21__ElectricCurrentUom__nA = 'J',
	eml21__ElectricCurrentUom__pA = 'K',
	eml21__ElectricCurrentUom__TA = 'L',
	eml21__ElectricCurrentUom__uA = 'M'
};
#endif

/* eml2_1ForGsoap.h:6092 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUom (972)
/* eml21:ElectricFieldStrengthUom */
enum eml21__ElectricFieldStrengthUom {
	eml21__ElectricFieldStrengthUom__mV_x002fft = 0,
	eml21__ElectricFieldStrengthUom__mV_x002fm = 1,
	eml21__ElectricFieldStrengthUom__uV_x002fft = 2,
	eml21__ElectricFieldStrengthUom__uV_x002fm = 3,
	eml21__ElectricFieldStrengthUom__V_x002fm = 4
};
#endif

/* eml2_1ForGsoap.h:6119 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUom (973)
/* eml21:ElectricPotentialDifferenceUom */
enum eml21__ElectricPotentialDifferenceUom {
	eml21__ElectricPotentialDifferenceUom__V = 'V',
	eml21__ElectricPotentialDifferenceUom__cV = 'W',
	eml21__ElectricPotentialDifferenceUom__dV = 'X',
	eml21__ElectricPotentialDifferenceUom__fV = 'Y',
	eml21__ElectricPotentialDifferenceUom__GV = 'Z',
	eml21__ElectricPotentialDifferenceUom__kV = 91,
	eml21__ElectricPotentialDifferenceUom__mV = 92,
	eml21__ElectricPotentialDifferenceUom__MV = 93,
	eml21__ElectricPotentialDifferenceUom__nV = 94,
	eml21__ElectricPotentialDifferenceUom__pV = 95,
	eml21__ElectricPotentialDifferenceUom__TV = 96,
	eml21__ElectricPotentialDifferenceUom__uV = 'a'
};
#endif

/* eml2_1ForGsoap.h:6174 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUom (974)
/* eml21:ElectricResistancePerLengthUom */
enum eml21__ElectricResistancePerLengthUom {
	eml21__ElectricResistancePerLengthUom__ohm_x002fm = 0,
	eml21__ElectricResistancePerLengthUom__uohm_x002fft = 1,
	eml21__ElectricResistancePerLengthUom__uohm_x002fm = 2
};
#endif

/* eml2_1ForGsoap.h:6193 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUom (975)
/* eml21:ElectricResistanceUom */
enum eml21__ElectricResistanceUom {
	eml21__ElectricResistanceUom__cohm = 0,
	eml21__ElectricResistanceUom__dohm = 1,
	eml21__ElectricResistanceUom__Eohm = 2,
	eml21__ElectricResistanceUom__fohm = 3,
	eml21__ElectricResistanceUom__Gohm = 4,
	eml21__ElectricResistanceUom__kohm = 5,
	eml21__ElectricResistanceUom__Mohm = 6,
	eml21__ElectricResistanceUom__mohm = 7,
	eml21__ElectricResistanceUom__nohm = 8,
	eml21__ElectricResistanceUom__ohm = 9,
	eml21__ElectricResistanceUom__pohm = 10,
	eml21__ElectricResistanceUom__Tohm = 11,
	eml21__ElectricResistanceUom__uohm = 12
};
#endif

/* eml2_1ForGsoap.h:6252 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUom (976)
/* eml21:ElectromagneticMomentUom */
enum eml21__ElectromagneticMomentUom {
	eml21__ElectromagneticMomentUom__A_x002em2 = 0
};
#endif

/* eml2_1ForGsoap.h:6263 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUom (977)
/* eml21:EnergyLengthPerAreaUom */
enum eml21__EnergyLengthPerAreaUom {
	eml21__EnergyLengthPerAreaUom__J_x002em_x002fm2 = 0,
	eml21__EnergyLengthPerAreaUom__kcal_x005bth_x005d_x002em_x002fcm2 = 1
};
#endif

/* eml2_1ForGsoap.h:6278 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUom (978)
/* eml21:EnergyLengthPerTimeAreaTemperatureUom */
enum eml21__EnergyLengthPerTimeAreaTemperatureUom {
	eml21__EnergyLengthPerTimeAreaTemperatureUom__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml21__EnergyLengthPerTimeAreaTemperatureUom__J_x002em_x002f_x0028s_x002em2_x002edeltaK_x0029 = 1,
	eml21__EnergyLengthPerTimeAreaTemperatureUom__kJ_x002em_x002f_x0028h_x002em2_x002edeltaK_x0029 = 2,
	eml21__EnergyLengthPerTimeAreaTemperatureUom__W_x002f_x0028m_x002edeltaK_x0029 = 3
};
#endif

/* eml2_1ForGsoap.h:6301 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUom (979)
/* eml21:EnergyPerAreaUom */
enum eml21__EnergyPerAreaUom {
	eml21__EnergyPerAreaUom__erg_x002fcm2 = 0,
	eml21__EnergyPerAreaUom__J_x002fcm2 = 1,
	eml21__EnergyPerAreaUom__J_x002fm2 = 2,
	eml21__EnergyPerAreaUom__kgf_x002em_x002fcm2 = 3,
	eml21__EnergyPerAreaUom__lbf_x002eft_x002fin2 = 4,
	eml21__EnergyPerAreaUom__mJ_x002fcm2 = 5,
	eml21__EnergyPerAreaUom__mJ_x002fm2 = 6,
	eml21__EnergyPerAreaUom__N_x002fm = 7
};
#endif

/* eml2_1ForGsoap.h:6340 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUom (980)
/* eml21:EnergyPerLengthUom */
enum eml21__EnergyPerLengthUom {
	eml21__EnergyPerLengthUom__J_x002fm = 0,
	eml21__EnergyPerLengthUom__MJ_x002fm = 1
};
#endif

/* eml2_1ForGsoap.h:6355 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUom (981)
/* eml21:EnergyPerMassPerTimeUom */
enum eml21__EnergyPerMassPerTimeUom {
	eml21__EnergyPerMassPerTimeUom__mrem_x002fh = 0,
	eml21__EnergyPerMassPerTimeUom__mSv_x002fh = 1,
	eml21__EnergyPerMassPerTimeUom__rem_x002fh = 2,
	eml21__EnergyPerMassPerTimeUom__Sv_x002fh = 3,
	eml21__EnergyPerMassPerTimeUom__Sv_x002fs = 4
};
#endif

/* eml2_1ForGsoap.h:6382 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUom (982)
/* eml21:EnergyPerMassUom */
enum eml21__EnergyPerMassUom {
	eml21__EnergyPerMassUom__Btu_x005bIT_x005d_x002flbm = 0,
	eml21__EnergyPerMassUom__cal_x005bth_x005d_x002fg = 1,
	eml21__EnergyPerMassUom__cal_x005bth_x005d_x002fkg = 2,
	eml21__EnergyPerMassUom__cal_x005bth_x005d_x002flbm = 3,
	eml21__EnergyPerMassUom__erg_x002fg = 4,
	eml21__EnergyPerMassUom__erg_x002fkg = 5,
	eml21__EnergyPerMassUom__hp_x002eh_x002flbm = 6,
	eml21__EnergyPerMassUom__J_x002fg = 7,
	eml21__EnergyPerMassUom__J_x002fkg = 8,
	eml21__EnergyPerMassUom__kcal_x005bth_x005d_x002fg = 9,
	eml21__EnergyPerMassUom__kcal_x005bth_x005d_x002fkg = 10,
	eml21__EnergyPerMassUom__kJ_x002fkg = 11,
	eml21__EnergyPerMassUom__kW_x002eh_x002fkg = 12,
	eml21__EnergyPerMassUom__lbf_x002eft_x002flbm = 13,
	eml21__EnergyPerMassUom__MJ_x002fkg = 14,
	eml21__EnergyPerMassUom__MW_x002eh_x002fkg = 15
};
#endif

/* eml2_1ForGsoap.h:6453 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUom (983)
/* eml21:EnergyPerVolumeUom */
enum eml21__EnergyPerVolumeUom {
	eml21__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fbbl = 0,
	eml21__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fft3 = 1,
	eml21__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 2,
	eml21__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 3,
	eml21__EnergyPerVolumeUom__cal_x005bth_x005d_x002fcm3 = 4,
	eml21__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmL = 5,
	eml21__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmm3 = 6,
	eml21__EnergyPerVolumeUom__erg_x002fcm3 = 7,
	eml21__EnergyPerVolumeUom__erg_x002fm3 = 8,
	eml21__EnergyPerVolumeUom__hp_x002eh_x002fbbl = 9,
	eml21__EnergyPerVolumeUom__J_x002fdm3 = 10,
	eml21__EnergyPerVolumeUom__J_x002fm3 = 11,
	eml21__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fcm3 = 12,
	eml21__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fm3 = 13,
	eml21__EnergyPerVolumeUom__kJ_x002fdm3 = 14,
	eml21__EnergyPerVolumeUom__kJ_x002fm3 = 15,
	eml21__EnergyPerVolumeUom__kW_x002eh_x002fdm3 = 16,
	eml21__EnergyPerVolumeUom__kW_x002eh_x002fm3 = 17,
	eml21__EnergyPerVolumeUom__lbf_x002eft_x002fbbl = 18,
	eml21__EnergyPerVolumeUom__lbf_x002eft_x002fgal_x005bUS_x005d = 19,
	eml21__EnergyPerVolumeUom__MJ_x002fm3 = 20,
	eml21__EnergyPerVolumeUom__MW_x002eh_x002fm3 = 21,
	eml21__EnergyPerVolumeUom__tonf_x005bUS_x005d_x002emi_x002fbbl = 22
};
#endif

/* eml2_1ForGsoap.h:6552 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUom (984)
/* eml21:EnergyUom */
enum eml21__EnergyUom {
	eml21__EnergyUom__J = 'J',
	eml21__EnergyUom__1E6_x0020Btu_x005bIT_x005d = 'K',
	eml21__EnergyUom__aJ = 'L',
	eml21__EnergyUom__Btu_x005bIT_x005d = 'M',
	eml21__EnergyUom__Btu_x005bth_x005d = 'N',
	eml21__EnergyUom__Btu_x005bUK_x005d = 'O',
	eml21__EnergyUom__cal_x005bIT_x005d = 'P',
	eml21__EnergyUom__cal_x005bth_x005d = 'Q',
	eml21__EnergyUom__ccal_x005bth_x005d = 'R',
	eml21__EnergyUom__ceV = 'S',
	eml21__EnergyUom__cJ = 'T',
	eml21__EnergyUom__dcal_x005bth_x005d = 'U',
	eml21__EnergyUom__deV = 'V',
	eml21__EnergyUom__dJ = 'W',
	eml21__EnergyUom__Ecal_x005bth_x005d = 'X',
	eml21__EnergyUom__EeV = 'Y',
	eml21__EnergyUom__EJ = 'Z',
	eml21__EnergyUom__erg = 91,
	eml21__EnergyUom__eV = 92,
	eml21__EnergyUom__fcal_x005bth_x005d = 93,
	eml21__EnergyUom__feV = 94,
	eml21__EnergyUom__fJ = 95,
	eml21__EnergyUom__Gcal_x005bth_x005d = 96,
	eml21__EnergyUom__GeV = 'a',
	eml21__EnergyUom__GJ = 'b',
	eml21__EnergyUom__GW_x002eh = 'c',
	eml21__EnergyUom__hp_x002eh = 'd',
	eml21__EnergyUom__hp_x005bmetric_x005d_x002eh = 'e',
	eml21__EnergyUom__kcal_x005bth_x005d = 'f',
	eml21__EnergyUom__keV = 'g',
	eml21__EnergyUom__kJ = 'h',
	eml21__EnergyUom__kW_x002eh = 'i',
	eml21__EnergyUom__mcal_x005bth_x005d = 'j',
	eml21__EnergyUom__Mcal_x005bth_x005d = 'k',
	eml21__EnergyUom__meV = 'l',
	eml21__EnergyUom__MeV = 'm',
	eml21__EnergyUom__MJ = 'n',
	eml21__EnergyUom__mJ = 'o',
	eml21__EnergyUom__MW_x002eh = 'p',
	eml21__EnergyUom__ncal_x005bth_x005d = 'q',
	eml21__EnergyUom__neV = 'r',
	eml21__EnergyUom__nJ = 's',
	eml21__EnergyUom__pcal_x005bth_x005d = 't',
	eml21__EnergyUom__peV = 'u',
	eml21__EnergyUom__pJ = 'v',
	eml21__EnergyUom__quad = 'w',
	eml21__EnergyUom__Tcal_x005bth_x005d = 'x',
	eml21__EnergyUom__TeV = 'y',
	eml21__EnergyUom__therm_x005bEC_x005d = 'z',
	eml21__EnergyUom__therm_x005bUK_x005d = 123,
	eml21__EnergyUom__therm_x005bUS_x005d = 124,
	eml21__EnergyUom__TJ = 125,
	eml21__EnergyUom__TW_x002eh = 126,
	eml21__EnergyUom__ucal_x005bth_x005d = 127,
	eml21__EnergyUom__ueV = 128,
	eml21__EnergyUom__uJ = 129
};
#endif

/* eml2_1ForGsoap.h:6783 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUom (985)
/* eml21:ForceAreaUom */
enum eml21__ForceAreaUom {
	eml21__ForceAreaUom__dyne_x002ecm2 = 0,
	eml21__ForceAreaUom__kgf_x002em2 = 1,
	eml21__ForceAreaUom__kN_x002em2 = 2,
	eml21__ForceAreaUom__lbf_x002ein2 = 3,
	eml21__ForceAreaUom__mN_x002em2 = 4,
	eml21__ForceAreaUom__N_x002em2 = 5,
	eml21__ForceAreaUom__pdl_x002ecm2 = 6,
	eml21__ForceAreaUom__tonf_x005bUK_x005d_x002eft2 = 7,
	eml21__ForceAreaUom__tonf_x005bUS_x005d_x002eft2 = 8
};
#endif

/* eml2_1ForGsoap.h:6826 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUom (986)
/* eml21:ForceLengthPerLengthUom */
enum eml21__ForceLengthPerLengthUom {
	eml21__ForceLengthPerLengthUom__kgf_x002em_x002fm = 0,
	eml21__ForceLengthPerLengthUom__lbf_x002eft_x002fin = 1,
	eml21__ForceLengthPerLengthUom__lbf_x002ein_x002fin = 2,
	eml21__ForceLengthPerLengthUom__N_x002em_x002fm = 3,
	eml21__ForceLengthPerLengthUom__tonf_x005bUS_x005d_x002emi_x002fft = 4
};
#endif

/* eml2_1ForGsoap.h:6853 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUom (987)
/* eml21:ForcePerForceUom */
enum eml21__ForcePerForceUom {
	eml21__ForcePerForceUom___x0025 = 0,
	eml21__ForcePerForceUom__Euc = 1,
	eml21__ForcePerForceUom__kgf_x002fkgf = 2,
	eml21__ForcePerForceUom__lbf_x002flbf = 3,
	eml21__ForcePerForceUom__N_x002fN = 4
};
#endif

/* eml2_1ForGsoap.h:6880 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUom (988)
/* eml21:ForcePerLengthUom */
enum eml21__ForcePerLengthUom {
	eml21__ForcePerLengthUom__0_x002e01_x0020lbf_x002fft = 0,
	eml21__ForcePerLengthUom__1_x002f30_x0020lbf_x002fm = 1,
	eml21__ForcePerLengthUom__1_x002f30_x0020N_x002fm = 2,
	eml21__ForcePerLengthUom__dyne_x002fcm = 3,
	eml21__ForcePerLengthUom__kgf_x002fcm = 4,
	eml21__ForcePerLengthUom__kN_x002fm = 5,
	eml21__ForcePerLengthUom__lbf_x002fft = 6,
	eml21__ForcePerLengthUom__lbf_x002fin = 7,
	eml21__ForcePerLengthUom__mN_x002fkm = 8,
	eml21__ForcePerLengthUom__mN_x002fm = 9,
	eml21__ForcePerLengthUom__N_x002fm = 10,
	eml21__ForcePerLengthUom__pdl_x002fcm = 11,
	eml21__ForcePerLengthUom__tonf_x005bUK_x005d_x002fft = 12,
	eml21__ForcePerLengthUom__tonf_x005bUS_x005d_x002fft = 13
};
#endif

/* eml2_1ForGsoap.h:6943 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUom (989)
/* eml21:ForcePerVolumeUom */
enum eml21__ForcePerVolumeUom {
	eml21__ForcePerVolumeUom__0_x002e001_x0020psi_x002fft = 0,
	eml21__ForcePerVolumeUom__0_x002e01_x0020psi_x002fft = 1,
	eml21__ForcePerVolumeUom__atm_x002fft = 2,
	eml21__ForcePerVolumeUom__atm_x002fhm = 3,
	eml21__ForcePerVolumeUom__atm_x002fm = 4,
	eml21__ForcePerVolumeUom__bar_x002fkm = 5,
	eml21__ForcePerVolumeUom__bar_x002fm = 6,
	eml21__ForcePerVolumeUom__GPa_x002fcm = 7,
	eml21__ForcePerVolumeUom__kPa_x002fhm = 8,
	eml21__ForcePerVolumeUom__kPa_x002fm = 9,
	eml21__ForcePerVolumeUom__lbf_x002fft3 = 10,
	eml21__ForcePerVolumeUom__lbf_x002fgal_x005bUS_x005d = 11,
	eml21__ForcePerVolumeUom__MPa_x002fm = 12,
	eml21__ForcePerVolumeUom__N_x002fm3 = 13,
	eml21__ForcePerVolumeUom__Pa_x002fm = 14,
	eml21__ForcePerVolumeUom__psi_x002fft = 15,
	eml21__ForcePerVolumeUom__psi_x002fm = 16
};
#endif

/* eml2_1ForGsoap.h:7018 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceUom (990)
/* eml21:ForceUom */
enum eml21__ForceUom {
	eml21__ForceUom__N = 'N',
	eml21__ForceUom__10_x0020kN = 'O',
	eml21__ForceUom__cN = 'P',
	eml21__ForceUom__daN = 'Q',
	eml21__ForceUom__dN = 'R',
	eml21__ForceUom__dyne = 'S',
	eml21__ForceUom__EN = 'T',
	eml21__ForceUom__fN = 'U',
	eml21__ForceUom__gf = 'V',
	eml21__ForceUom__GN = 'W',
	eml21__ForceUom__hN = 'X',
	eml21__ForceUom__kdyne = 'Y',
	eml21__ForceUom__kgf = 'Z',
	eml21__ForceUom__klbf = 91,
	eml21__ForceUom__kN = 92,
	eml21__ForceUom__lbf = 93,
	eml21__ForceUom__Mgf = 94,
	eml21__ForceUom__mN = 95,
	eml21__ForceUom__MN = 96,
	eml21__ForceUom__nN = 'a',
	eml21__ForceUom__ozf = 'b',
	eml21__ForceUom__pdl = 'c',
	eml21__ForceUom__pN = 'd',
	eml21__ForceUom__TN = 'e',
	eml21__ForceUom__tonf_x005bUK_x005d = 'f',
	eml21__ForceUom__tonf_x005bUS_x005d = 'g',
	eml21__ForceUom__uN = 'h'
};
#endif

/* eml2_1ForGsoap.h:7133 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUom (991)
/* eml21:FrequencyIntervalUom */
enum eml21__FrequencyIntervalUom {
	eml21__FrequencyIntervalUom__O = 'O'
};
#endif

/* eml2_1ForGsoap.h:7144 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUom (992)
/* eml21:FrequencyUom */
enum eml21__FrequencyUom {
	eml21__FrequencyUom__cHz = 0,
	eml21__FrequencyUom__dHz = 1,
	eml21__FrequencyUom__EHz = 2,
	eml21__FrequencyUom__fHz = 3,
	eml21__FrequencyUom__GHz = 4,
	eml21__FrequencyUom__Hz = 5,
	eml21__FrequencyUom__kHz = 6,
	eml21__FrequencyUom__mHz = 7,
	eml21__FrequencyUom__MHz = 8,
	eml21__FrequencyUom__nHz = 9,
	eml21__FrequencyUom__pHz = 10,
	eml21__FrequencyUom__THz = 11,
	eml21__FrequencyUom__uHz = 12
};
#endif

/* eml2_1ForGsoap.h:7203 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUom (993)
/* eml21:HeatCapacityUom */
enum eml21__HeatCapacityUom {
	eml21__HeatCapacityUom__J_x002fdeltaK = 0
};
#endif

/* eml2_1ForGsoap.h:7214 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUom (994)
/* eml21:HeatFlowRateUom */
enum eml21__HeatFlowRateUom {
	eml21__HeatFlowRateUom__W = 'W',
	eml21__HeatFlowRateUom__1E6_x0020Btu_x005bIT_x005d_x002fh = 'X',
	eml21__HeatFlowRateUom__Btu_x005bIT_x005d_x002fh = 'Y',
	eml21__HeatFlowRateUom__Btu_x005bIT_x005d_x002fmin = 'Z',
	eml21__HeatFlowRateUom__Btu_x005bIT_x005d_x002fs = 91,
	eml21__HeatFlowRateUom__cal_x005bth_x005d_x002fh = 92,
	eml21__HeatFlowRateUom__EJ_x002fa = 93,
	eml21__HeatFlowRateUom__erg_x002fa = 94,
	eml21__HeatFlowRateUom__GW = 95,
	eml21__HeatFlowRateUom__J_x002fs = 96,
	eml21__HeatFlowRateUom__kcal_x005bth_x005d_x002fh = 'a',
	eml21__HeatFlowRateUom__kW = 'b',
	eml21__HeatFlowRateUom__lbf_x002eft_x002fmin = 'c',
	eml21__HeatFlowRateUom__lbf_x002eft_x002fs = 'd',
	eml21__HeatFlowRateUom__MJ_x002fa = 'e',
	eml21__HeatFlowRateUom__mW = 'f',
	eml21__HeatFlowRateUom__MW = 'g',
	eml21__HeatFlowRateUom__nW = 'h',
	eml21__HeatFlowRateUom__quad_x002fa = 'i',
	eml21__HeatFlowRateUom__TJ_x002fa = 'j',
	eml21__HeatFlowRateUom__TW = 'k',
	eml21__HeatFlowRateUom__ucal_x005bth_x005d_x002fs = 'l',
	eml21__HeatFlowRateUom__uW = 'm'
};
#endif

/* eml2_1ForGsoap.h:7313 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUom (995)
/* eml21:HeatTransferCoefficientUom */
enum eml21__HeatTransferCoefficientUom {
	eml21__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml21__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaR_x0029 = 1,
	eml21__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 2,
	eml21__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edeltaF_x0029 = 3,
	eml21__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edeltaC_x0029 = 4,
	eml21__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edeltaC_x0029 = 5,
	eml21__HeatTransferCoefficientUom__J_x002f_x0028s_x002em2_x002edeltaC_x0029 = 6,
	eml21__HeatTransferCoefficientUom__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 7,
	eml21__HeatTransferCoefficientUom__kJ_x002f_x0028h_x002em2_x002edeltaK_x0029 = 8,
	eml21__HeatTransferCoefficientUom__kW_x002f_x0028m2_x002edeltaK_x0029 = 9,
	eml21__HeatTransferCoefficientUom__W_x002f_x0028m2_x002edeltaK_x0029 = 10
};
#endif

/* eml2_1ForGsoap.h:7364 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUom (996)
/* eml21:IlluminanceUom */
enum eml21__IlluminanceUom {
	eml21__IlluminanceUom__footcandle = 0,
	eml21__IlluminanceUom__klx = 1,
	eml21__IlluminanceUom__lm_x002fm2 = 2,
	eml21__IlluminanceUom__lx = 3
};
#endif

/* eml2_1ForGsoap.h:7387 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUom (997)
/* eml21:InductanceUom */
enum eml21__InductanceUom {
	eml21__InductanceUom__H = 'H',
	eml21__InductanceUom__cH = 'I',
	eml21__InductanceUom__dH = 'J',
	eml21__InductanceUom__EH = 'K',
	eml21__InductanceUom__fH = 'L',
	eml21__InductanceUom__GH = 'M',
	eml21__InductanceUom__kH = 'N',
	eml21__InductanceUom__MH = 'O',
	eml21__InductanceUom__mH = 'P',
	eml21__InductanceUom__nH = 'Q',
	eml21__InductanceUom__TH = 'R',
	eml21__InductanceUom__uH = 'S'
};
#endif

/* eml2_1ForGsoap.h:7442 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUom (998)
/* eml21:IsothermalCompressibilityUom */
enum eml21__IsothermalCompressibilityUom {
	eml21__IsothermalCompressibilityUom__dm3_x002f_x0028kW_x002eh_x0029 = 0,
	eml21__IsothermalCompressibilityUom__dm3_x002fMJ = 1,
	eml21__IsothermalCompressibilityUom__m3_x002f_x0028kW_x002eh_x0029 = 2,
	eml21__IsothermalCompressibilityUom__m3_x002fJ = 3,
	eml21__IsothermalCompressibilityUom__mm3_x002fJ = 4,
	eml21__IsothermalCompressibilityUom__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 5
};
#endif

/* eml2_1ForGsoap.h:7473 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUom (999)
/* eml21:KinematicViscosityUom */
enum eml21__KinematicViscosityUom {
	eml21__KinematicViscosityUom__cm2_x002fs = 0,
	eml21__KinematicViscosityUom__cSt = 1,
	eml21__KinematicViscosityUom__ft2_x002fh = 2,
	eml21__KinematicViscosityUom__ft2_x002fs = 3,
	eml21__KinematicViscosityUom__in2_x002fs = 4,
	eml21__KinematicViscosityUom__m2_x002fh = 5,
	eml21__KinematicViscosityUom__m2_x002fs = 6,
	eml21__KinematicViscosityUom__mm2_x002fs = 7,
	eml21__KinematicViscosityUom__Pa_x002es_x002em3_x002fkg = 8,
	eml21__KinematicViscosityUom__St = 9
};
#endif

/* eml2_1ForGsoap.h:7520 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUom (1000)
/* eml21:LengthPerLengthUom */
enum eml21__LengthPerLengthUom {
	eml21__LengthPerLengthUom___x0025 = 0,
	eml21__LengthPerLengthUom__0_x002e01_x0020ft_x002fft = 1,
	eml21__LengthPerLengthUom__1_x002f30_x0020m_x002fm = 2,
	eml21__LengthPerLengthUom__Euc = 3,
	eml21__LengthPerLengthUom__ft_x002fft = 4,
	eml21__LengthPerLengthUom__ft_x002fin = 5,
	eml21__LengthPerLengthUom__ft_x002fm = 6,
	eml21__LengthPerLengthUom__ft_x002fmi = 7,
	eml21__LengthPerLengthUom__km_x002fcm = 8,
	eml21__LengthPerLengthUom__m_x002fcm = 9,
	eml21__LengthPerLengthUom__m_x002fkm = 10,
	eml21__LengthPerLengthUom__m_x002fm = 11,
	eml21__LengthPerLengthUom__mi_x002fin = 12
};
#endif

/* eml2_1ForGsoap.h:7579 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUom (1001)
/* eml21:LengthPerMassUom */
enum eml21__LengthPerMassUom {
	eml21__LengthPerMassUom__ft_x002flbm = 0,
	eml21__LengthPerMassUom__m_x002fkg = 1
};
#endif

/* eml2_1ForGsoap.h:7594 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUom (1002)
/* eml21:LengthPerPressureUom */
enum eml21__LengthPerPressureUom {
	eml21__LengthPerPressureUom__ft_x002fpsi = 0,
	eml21__LengthPerPressureUom__m_x002fkPa = 1,
	eml21__LengthPerPressureUom__m_x002fPa = 2
};
#endif

/* eml2_1ForGsoap.h:7613 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUom (1003)
/* eml21:LengthPerTemperatureUom */
enum eml21__LengthPerTemperatureUom {
	eml21__LengthPerTemperatureUom__ft_x002fdeltaF = 0,
	eml21__LengthPerTemperatureUom__m_x002fdeltaK = 1
};
#endif

/* eml2_1ForGsoap.h:7628 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUom (1004)
/* eml21:LengthPerTimeUom */
enum eml21__LengthPerTimeUom {
	eml21__LengthPerTimeUom__1000_x0020ft_x002fh = 0,
	eml21__LengthPerTimeUom__1000_x0020ft_x002fs = 1,
	eml21__LengthPerTimeUom__cm_x002fa = 2,
	eml21__LengthPerTimeUom__cm_x002fs = 3,
	eml21__LengthPerTimeUom__dm_x002fs = 4,
	eml21__LengthPerTimeUom__ft_x002fd = 5,
	eml21__LengthPerTimeUom__ft_x002fh = 6,
	eml21__LengthPerTimeUom__ft_x002fmin = 7,
	eml21__LengthPerTimeUom__ft_x002fms = 8,
	eml21__LengthPerTimeUom__ft_x002fs = 9,
	eml21__LengthPerTimeUom__ft_x002fus = 10,
	eml21__LengthPerTimeUom__in_x002fa = 11,
	eml21__LengthPerTimeUom__in_x002fmin = 12,
	eml21__LengthPerTimeUom__in_x002fs = 13,
	eml21__LengthPerTimeUom__km_x002fh = 14,
	eml21__LengthPerTimeUom__km_x002fs = 15,
	eml21__LengthPerTimeUom__knot = 16,
	eml21__LengthPerTimeUom__m_x002fd = 17,
	eml21__LengthPerTimeUom__m_x002fh = 18,
	eml21__LengthPerTimeUom__m_x002fmin = 19,
	eml21__LengthPerTimeUom__m_x002fms = 20,
	eml21__LengthPerTimeUom__m_x002fs = 21,
	eml21__LengthPerTimeUom__mi_x002fh = 22,
	eml21__LengthPerTimeUom__mil_x002fa = 23,
	eml21__LengthPerTimeUom__mm_x002fa = 24,
	eml21__LengthPerTimeUom__mm_x002fs = 25,
	eml21__LengthPerTimeUom__nm_x002fs = 26,
	eml21__LengthPerTimeUom__um_x002fs = 27
};
#endif

/* eml2_1ForGsoap.h:7747 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUom (1005)
/* eml21:LengthPerVolumeUom */
enum eml21__LengthPerVolumeUom {
	eml21__LengthPerVolumeUom__ft_x002fbbl = 0,
	eml21__LengthPerVolumeUom__ft_x002fft3 = 1,
	eml21__LengthPerVolumeUom__ft_x002fgal_x005bUS_x005d = 2,
	eml21__LengthPerVolumeUom__km_x002fdm3 = 3,
	eml21__LengthPerVolumeUom__km_x002fL = 4,
	eml21__LengthPerVolumeUom__m_x002fm3 = 5,
	eml21__LengthPerVolumeUom__mi_x002fgal_x005bUK_x005d = 6,
	eml21__LengthPerVolumeUom__mi_x002fgal_x005bUS_x005d = 7
};
#endif

/* eml2_1ForGsoap.h:7786 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthUom (1006)
/* eml21:LengthUom */
enum eml21__LengthUom {
	eml21__LengthUom__m = 'm',
	eml21__LengthUom__0_x002e1_x0020ft = 'n',
	eml21__LengthUom__0_x002e1_x0020ft_x005bUS_x005d = 'o',
	eml21__LengthUom__0_x002e1_x0020in = 'p',
	eml21__LengthUom__0_x002e1_x0020yd = 'q',
	eml21__LengthUom__1_x002f16_x0020in = 'r',
	eml21__LengthUom__1_x002f2_x0020ft = 's',
	eml21__LengthUom__1_x002f32_x0020in = 't',
	eml21__LengthUom__1_x002f64_x0020in = 'u',
	eml21__LengthUom__10_x0020ft = 'v',
	eml21__LengthUom__10_x0020in = 'w',
	eml21__LengthUom__10_x0020km = 'x',
	eml21__LengthUom__100_x0020ft = 'y',
	eml21__LengthUom__100_x0020km = 'z',
	eml21__LengthUom__1000_x0020ft = 123,
	eml21__LengthUom__30_x0020ft = 124,
	eml21__LengthUom__30_x0020m = 125,
	eml21__LengthUom__angstrom = 126,
	eml21__LengthUom__chain = 127,
	eml21__LengthUom__chain_x005bBnA_x005d = 128,
	eml21__LengthUom__chain_x005bBnB_x005d = 129,
	eml21__LengthUom__chain_x005bCla_x005d = 130,
	eml21__LengthUom__chain_x005bInd37_x005d = 131,
	eml21__LengthUom__chain_x005bSe_x005d = 132,
	eml21__LengthUom__chain_x005bSeT_x005d = 133,
	eml21__LengthUom__chain_x005bUS_x005d = 134,
	eml21__LengthUom__cm = 135,
	eml21__LengthUom__dam = 136,
	eml21__LengthUom__dm = 137,
	eml21__LengthUom__Em = 138,
	eml21__LengthUom__fathom = 139,
	eml21__LengthUom__fm = 140,
	eml21__LengthUom__ft = 141,
	eml21__LengthUom__ft_x005bBnA_x005d = 142,
	eml21__LengthUom__ft_x005bBnB_x005d = 143,
	eml21__LengthUom__ft_x005bBr36_x005d = 144,
	eml21__LengthUom__ft_x005bBr65_x005d = 145,
	eml21__LengthUom__ft_x005bCla_x005d = 146,
	eml21__LengthUom__ft_x005bGC_x005d = 147,
	eml21__LengthUom__ft_x005bInd_x005d = 148,
	eml21__LengthUom__ft_x005bInd37_x005d = 149,
	eml21__LengthUom__ft_x005bInd62_x005d = 150,
	eml21__LengthUom__ft_x005bInd75_x005d = 151,
	eml21__LengthUom__ft_x005bSe_x005d = 152,
	eml21__LengthUom__ft_x005bSeT_x005d = 153,
	eml21__LengthUom__ft_x005bUS_x005d = 154,
	eml21__LengthUom__fur_x005bUS_x005d = 155,
	eml21__LengthUom__Gm = 156,
	eml21__LengthUom__hm = 157,
	eml21__LengthUom__in = 158,
	eml21__LengthUom__in_x005bUS_x005d = 159,
	eml21__LengthUom__km = 160,
	eml21__LengthUom__link = 161,
	eml21__LengthUom__link_x005bBnA_x005d = 162,
	eml21__LengthUom__link_x005bBnB_x005d = 163,
	eml21__LengthUom__link_x005bCla_x005d = 164,
	eml21__LengthUom__link_x005bSe_x005d = 165,
	eml21__LengthUom__link_x005bSeT_x005d = 166,
	eml21__LengthUom__link_x005bUS_x005d = 167,
	eml21__LengthUom__m_x005bGer_x005d = 168,
	eml21__LengthUom__mi = 169,
	eml21__LengthUom__mi_x005bnaut_x005d = 170,
	eml21__LengthUom__mi_x005bnautUK_x005d = 171,
	eml21__LengthUom__mi_x005bUS_x005d = 172,
	eml21__LengthUom__mil = 173,
	eml21__LengthUom__mm = 174,
	eml21__LengthUom__Mm = 175,
	eml21__LengthUom__nm = 176,
	eml21__LengthUom__pm = 177,
	eml21__LengthUom__rod_x005bUS_x005d = 178,
	eml21__LengthUom__Tm = 179,
	eml21__LengthUom__um = 180,
	eml21__LengthUom__yd = 181,
	eml21__LengthUom__yd_x005bBnA_x005d = 182,
	eml21__LengthUom__yd_x005bBnB_x005d = 183,
	eml21__LengthUom__yd_x005bCla_x005d = 184,
	eml21__LengthUom__yd_x005bInd_x005d = 185,
	eml21__LengthUom__yd_x005bInd37_x005d = 186,
	eml21__LengthUom__yd_x005bInd62_x005d = 187,
	eml21__LengthUom__yd_x005bInd75_x005d = 188,
	eml21__LengthUom__yd_x005bSe_x005d = 189,
	eml21__LengthUom__yd_x005bSeT_x005d = 190,
	eml21__LengthUom__yd_x005bUS_x005d = 191
};
#endif

/* eml2_1ForGsoap.h:8125 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUom (1007)
/* eml21:LightExposureUom */
enum eml21__LightExposureUom {
	eml21__LightExposureUom__footcandle_x002es = 0,
	eml21__LightExposureUom__lx_x002es = 1
};
#endif

/* eml2_1ForGsoap.h:8140 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUom (1008)
/* eml21:LinearAccelerationUom */
enum eml21__LinearAccelerationUom {
	eml21__LinearAccelerationUom__cm_x002fs2 = 0,
	eml21__LinearAccelerationUom__ft_x002fs2 = 1,
	eml21__LinearAccelerationUom__Gal = 2,
	eml21__LinearAccelerationUom__gn = 3,
	eml21__LinearAccelerationUom__in_x002fs2 = 4,
	eml21__LinearAccelerationUom__m_x002fs2 = 5,
	eml21__LinearAccelerationUom__mGal = 6,
	eml21__LinearAccelerationUom__mgn = 7
};
#endif

/* eml2_1ForGsoap.h:8179 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUom (1009)
/* eml21:LinearThermalExpansionUom */
enum eml21__LinearThermalExpansionUom {
	eml21__LinearThermalExpansionUom__1_x002fdeltaK = 0,
	eml21__LinearThermalExpansionUom__in_x002f_x0028in_x002edeltaF_x0029 = 1,
	eml21__LinearThermalExpansionUom__m_x002f_x0028m_x002edeltaK_x0029 = 2,
	eml21__LinearThermalExpansionUom__mm_x002f_x0028mm_x002edeltaK_x0029 = 3
};
#endif

/* eml2_1ForGsoap.h:8202 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUom (1010)
/* eml21:LogarithmicPowerRatioPerLengthUom */
enum eml21__LogarithmicPowerRatioPerLengthUom {
	eml21__LogarithmicPowerRatioPerLengthUom__B_x002fm = 0,
	eml21__LogarithmicPowerRatioPerLengthUom__dB_x002fft = 1,
	eml21__LogarithmicPowerRatioPerLengthUom__dB_x002fkm = 2,
	eml21__LogarithmicPowerRatioPerLengthUom__dB_x002fm = 3
};
#endif

/* eml2_1ForGsoap.h:8225 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUom (1011)
/* eml21:LogarithmicPowerRatioUom */
enum eml21__LogarithmicPowerRatioUom {
	eml21__LogarithmicPowerRatioUom__B = 'B',
	eml21__LogarithmicPowerRatioUom__dB = 'C'
};
#endif

/* eml2_1ForGsoap.h:8240 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUom (1012)
/* eml21:LuminanceUom */
enum eml21__LuminanceUom {
	eml21__LuminanceUom__cd_x002fm2 = 0
};
#endif

/* eml2_1ForGsoap.h:8251 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUom (1013)
/* eml21:LuminousEfficacyUom */
enum eml21__LuminousEfficacyUom {
	eml21__LuminousEfficacyUom__lm_x002fW = 0
};
#endif

/* eml2_1ForGsoap.h:8262 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUom (1014)
/* eml21:LuminousFluxUom */
enum eml21__LuminousFluxUom {
	eml21__LuminousFluxUom__lm = 0
};
#endif

/* eml2_1ForGsoap.h:8273 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUom (1015)
/* eml21:LuminousIntensityUom */
enum eml21__LuminousIntensityUom {
	eml21__LuminousIntensityUom__cd = 0,
	eml21__LuminousIntensityUom__kcd = 1
};
#endif

/* eml2_1ForGsoap.h:8288 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUom (1016)
/* eml21:MagneticDipoleMomentUom */
enum eml21__MagneticDipoleMomentUom {
	eml21__MagneticDipoleMomentUom__Wb_x002em = 0
};
#endif

/* eml2_1ForGsoap.h:8299 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUom (1017)
/* eml21:MagneticFieldStrengthUom */
enum eml21__MagneticFieldStrengthUom {
	eml21__MagneticFieldStrengthUom__A_x002fm = 0,
	eml21__MagneticFieldStrengthUom__A_x002fmm = 1,
	eml21__MagneticFieldStrengthUom__Oe = 2
};
#endif

/* eml2_1ForGsoap.h:8318 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUom (1018)
/* eml21:MagneticFluxDensityPerLengthUom */
enum eml21__MagneticFluxDensityPerLengthUom {
	eml21__MagneticFluxDensityPerLengthUom__gauss_x002fcm = 0,
	eml21__MagneticFluxDensityPerLengthUom__mT_x002fdm = 1,
	eml21__MagneticFluxDensityPerLengthUom__T_x002fm = 2
};
#endif

/* eml2_1ForGsoap.h:8337 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUom (1019)
/* eml21:MagneticFluxDensityUom */
enum eml21__MagneticFluxDensityUom {
	eml21__MagneticFluxDensityUom__T = 'T',
	eml21__MagneticFluxDensityUom__cgauss = 'U',
	eml21__MagneticFluxDensityUom__cT = 'V',
	eml21__MagneticFluxDensityUom__dgauss = 'W',
	eml21__MagneticFluxDensityUom__dT = 'X',
	eml21__MagneticFluxDensityUom__Egauss = 'Y',
	eml21__MagneticFluxDensityUom__ET = 'Z',
	eml21__MagneticFluxDensityUom__fgauss = 91,
	eml21__MagneticFluxDensityUom__fT = 92,
	eml21__MagneticFluxDensityUom__gauss = 93,
	eml21__MagneticFluxDensityUom__Ggauss = 94,
	eml21__MagneticFluxDensityUom__GT = 95,
	eml21__MagneticFluxDensityUom__kgauss = 96,
	eml21__MagneticFluxDensityUom__kT = 'a',
	eml21__MagneticFluxDensityUom__mgauss = 'b',
	eml21__MagneticFluxDensityUom__Mgauss = 'c',
	eml21__MagneticFluxDensityUom__mT = 'd',
	eml21__MagneticFluxDensityUom__ngauss = 'e',
	eml21__MagneticFluxDensityUom__nT = 'f',
	eml21__MagneticFluxDensityUom__pgauss = 'g',
	eml21__MagneticFluxDensityUom__pT = 'h',
	eml21__MagneticFluxDensityUom__Tgauss = 'i',
	eml21__MagneticFluxDensityUom__TT = 'j',
	eml21__MagneticFluxDensityUom__ugauss = 'k',
	eml21__MagneticFluxDensityUom__uT = 'l'
};
#endif

/* eml2_1ForGsoap.h:8444 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUom (1020)
/* eml21:MagneticFluxUom */
enum eml21__MagneticFluxUom {
	eml21__MagneticFluxUom__cWb = 0,
	eml21__MagneticFluxUom__dWb = 1,
	eml21__MagneticFluxUom__EWb = 2,
	eml21__MagneticFluxUom__fWb = 3,
	eml21__MagneticFluxUom__GWb = 4,
	eml21__MagneticFluxUom__kWb = 5,
	eml21__MagneticFluxUom__mWb = 6,
	eml21__MagneticFluxUom__MWb = 7,
	eml21__MagneticFluxUom__nWb = 8,
	eml21__MagneticFluxUom__pWb = 9,
	eml21__MagneticFluxUom__TWb = 10,
	eml21__MagneticFluxUom__uWb = 11,
	eml21__MagneticFluxUom__Wb = 12
};
#endif

/* eml2_1ForGsoap.h:8503 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUom (1021)
/* eml21:MagneticPermeabilityUom */
enum eml21__MagneticPermeabilityUom {
	eml21__MagneticPermeabilityUom__H_x002fm = 0,
	eml21__MagneticPermeabilityUom__uH_x002fm = 1
};
#endif

/* eml2_1ForGsoap.h:8518 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUom (1022)
/* eml21:MagneticVectorPotentialUom */
enum eml21__MagneticVectorPotentialUom {
	eml21__MagneticVectorPotentialUom__Wb_x002fm = 0,
	eml21__MagneticVectorPotentialUom__Wb_x002fmm = 1
};
#endif

/* eml2_1ForGsoap.h:8533 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUom (1023)
/* eml21:MassLengthUom */
enum eml21__MassLengthUom {
	eml21__MassLengthUom__kg_x002em = 0,
	eml21__MassLengthUom__lbm_x002eft = 1
};
#endif

/* eml2_1ForGsoap.h:8548 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUom (1024)
/* eml21:MassPerAreaUom */
enum eml21__MassPerAreaUom {
	eml21__MassPerAreaUom__0_x002e01_x0020lbm_x002fft2 = 0,
	eml21__MassPerAreaUom__kg_x002fm2 = 1,
	eml21__MassPerAreaUom__lbm_x002fft2 = 2,
	eml21__MassPerAreaUom__Mg_x002fm2 = 3,
	eml21__MassPerAreaUom__ton_x005bUS_x005d_x002fft2 = 4
};
#endif

/* eml2_1ForGsoap.h:8575 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUom (1025)
/* eml21:MassPerEnergyUom */
enum eml21__MassPerEnergyUom {
	eml21__MassPerEnergyUom__kg_x002f_x0028kW_x002eh_x0029 = 0,
	eml21__MassPerEnergyUom__kg_x002fJ = 1,
	eml21__MassPerEnergyUom__kg_x002fMJ = 2,
	eml21__MassPerEnergyUom__lbm_x002f_x0028hp_x002eh_x0029 = 3,
	eml21__MassPerEnergyUom__mg_x002fJ = 4
};
#endif

/* eml2_1ForGsoap.h:8602 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUom (1026)
/* eml21:MassPerLengthUom */
enum eml21__MassPerLengthUom {
	eml21__MassPerLengthUom__kg_x002em_x002fcm2 = 0,
	eml21__MassPerLengthUom__kg_x002fm = 1,
	eml21__MassPerLengthUom__klbm_x002fin = 2,
	eml21__MassPerLengthUom__lbm_x002fft = 3,
	eml21__MassPerLengthUom__Mg_x002fin = 4
};
#endif

/* eml2_1ForGsoap.h:8629 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUom (1027)
/* eml21:MassPerMassUom */
enum eml21__MassPerMassUom {
	eml21__MassPerMassUom___x0025 = 0,
	eml21__MassPerMassUom___x0025_x005bmass_x005d = 1,
	eml21__MassPerMassUom__Euc = 2,
	eml21__MassPerMassUom__g_x002fkg = 3,
	eml21__MassPerMassUom__g_x002ft = 4,
	eml21__MassPerMassUom__kg_x002fkg = 5,
	eml21__MassPerMassUom__kg_x002fsack_x005b94lbm_x005d = 6,
	eml21__MassPerMassUom__kg_x002ft = 7,
	eml21__MassPerMassUom__mg_x002fg = 8,
	eml21__MassPerMassUom__mg_x002fkg = 9,
	eml21__MassPerMassUom__ng_x002fg = 10,
	eml21__MassPerMassUom__ng_x002fmg = 11,
	eml21__MassPerMassUom__ppk = 12,
	eml21__MassPerMassUom__ppm = 13,
	eml21__MassPerMassUom__ppm_x005bmass_x005d = 14,
	eml21__MassPerMassUom__ug_x002fg = 15,
	eml21__MassPerMassUom__ug_x002fmg = 16
};
#endif

/* eml2_1ForGsoap.h:8704 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUom (1028)
/* eml21:MassPerTimePerAreaUom */
enum eml21__MassPerTimePerAreaUom {
	eml21__MassPerTimePerAreaUom__g_x002eft_x002f_x0028cm3_x002es_x0029 = 0,
	eml21__MassPerTimePerAreaUom__g_x002em_x002f_x0028cm3_x002es_x0029 = 1,
	eml21__MassPerTimePerAreaUom__kg_x002f_x0028m2_x002es_x0029 = 2,
	eml21__MassPerTimePerAreaUom__kPa_x002es_x002fm = 3,
	eml21__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002eh_x0029 = 4,
	eml21__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002es_x0029 = 5,
	eml21__MassPerTimePerAreaUom__MPa_x002es_x002fm = 6
};
#endif

/* eml2_1ForGsoap.h:8739 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUom (1029)
/* eml21:MassPerTimePerLengthUom */
enum eml21__MassPerTimePerLengthUom {
	eml21__MassPerTimePerLengthUom__kg_x002f_x0028m_x002es_x0029 = 0,
	eml21__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002eh_x0029 = 1,
	eml21__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002es_x0029 = 2,
	eml21__MassPerTimePerLengthUom__Pa_x002es = 3
};
#endif

/* eml2_1ForGsoap.h:8762 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUom (1030)
/* eml21:MassPerTimeUom */
enum eml21__MassPerTimeUom {
	eml21__MassPerTimeUom__1E6_x0020lbm_x002fa = 0,
	eml21__MassPerTimeUom__g_x002fs = 1,
	eml21__MassPerTimeUom__kg_x002fd = 2,
	eml21__MassPerTimeUom__kg_x002fh = 3,
	eml21__MassPerTimeUom__kg_x002fmin = 4,
	eml21__MassPerTimeUom__kg_x002fs = 5,
	eml21__MassPerTimeUom__lbm_x002fd = 6,
	eml21__MassPerTimeUom__lbm_x002fh = 7,
	eml21__MassPerTimeUom__lbm_x002fmin = 8,
	eml21__MassPerTimeUom__lbm_x002fs = 9,
	eml21__MassPerTimeUom__Mg_x002fa = 10,
	eml21__MassPerTimeUom__Mg_x002fd = 11,
	eml21__MassPerTimeUom__Mg_x002fh = 12,
	eml21__MassPerTimeUom__Mg_x002fmin = 13,
	eml21__MassPerTimeUom__t_x002fa = 14,
	eml21__MassPerTimeUom__t_x002fd = 15,
	eml21__MassPerTimeUom__t_x002fh = 16,
	eml21__MassPerTimeUom__t_x002fmin = 17,
	eml21__MassPerTimeUom__ton_x005bUK_x005d_x002fa = 18,
	eml21__MassPerTimeUom__ton_x005bUK_x005d_x002fd = 19,
	eml21__MassPerTimeUom__ton_x005bUK_x005d_x002fh = 20,
	eml21__MassPerTimeUom__ton_x005bUK_x005d_x002fmin = 21,
	eml21__MassPerTimeUom__ton_x005bUS_x005d_x002fa = 22,
	eml21__MassPerTimeUom__ton_x005bUS_x005d_x002fd = 23,
	eml21__MassPerTimeUom__ton_x005bUS_x005d_x002fh = 24,
	eml21__MassPerTimeUom__ton_x005bUS_x005d_x002fmin = 25
};
#endif

/* eml2_1ForGsoap.h:8873 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUom (1031)
/* eml21:MassPerVolumePerLengthUom */
enum eml21__MassPerVolumePerLengthUom {
	eml21__MassPerVolumePerLengthUom__g_x002fcm4 = 0,
	eml21__MassPerVolumePerLengthUom__kg_x002fdm4 = 1,
	eml21__MassPerVolumePerLengthUom__kg_x002fm4 = 2,
	eml21__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 3,
	eml21__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 4,
	eml21__MassPerVolumePerLengthUom__lbm_x002fft4 = 5,
	eml21__MassPerVolumePerLengthUom__Pa_x002es2_x002fm3 = 6
};
#endif

/* eml2_1ForGsoap.h:8908 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUom (1032)
/* eml21:MassPerVolumePerPressureUom */
enum eml21__MassPerVolumePerPressureUom {
	eml21__MassPerVolumePerPressureUom__kg_x002fm3_x002ekPa = 0,
	eml21__MassPerVolumePerPressureUom__lb_x002fft_x002epsi = 1
};
#endif

/* eml2_1ForGsoap.h:8917 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUom (1033)
/* eml21:MassPerVolumePerTemperatureUom */
enum eml21__MassPerVolumePerTemperatureUom {
	eml21__MassPerVolumePerTemperatureUom__kg_x002fm3_x002edegC = 0,
	eml21__MassPerVolumePerTemperatureUom__kg_x002fm3_x002eK = 1,
	eml21__MassPerVolumePerTemperatureUom__lb_x002fft_x002edegF = 2
};
#endif

/* eml2_1ForGsoap.h:8927 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUom (1034)
/* eml21:MassPerVolumeUom */
enum eml21__MassPerVolumeUom {
	eml21__MassPerVolumeUom__0_x002e001_x0020lbm_x002fbbl = 0,
	eml21__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 1,
	eml21__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 2,
	eml21__MassPerVolumeUom__0_x002e01_x0020grain_x002fft3 = 3,
	eml21__MassPerVolumeUom__0_x002e1_x0020lbm_x002fbbl = 4,
	eml21__MassPerVolumeUom__10_x0020Mg_x002fm3 = 5,
	eml21__MassPerVolumeUom__g_x002fcm3 = 6,
	eml21__MassPerVolumeUom__g_x002fdm3 = 7,
	eml21__MassPerVolumeUom__g_x002fgal_x005bUK_x005d = 8,
	eml21__MassPerVolumeUom__g_x002fgal_x005bUS_x005d = 9,
	eml21__MassPerVolumeUom__g_x002fL = 10,
	eml21__MassPerVolumeUom__g_x002fm3 = 11,
	eml21__MassPerVolumeUom__grain_x002fft3 = 12,
	eml21__MassPerVolumeUom__grain_x002fgal_x005bUS_x005d = 13,
	eml21__MassPerVolumeUom__kg_x002fdm3 = 14,
	eml21__MassPerVolumeUom__kg_x002fL = 15,
	eml21__MassPerVolumeUom__kg_x002fm3 = 16,
	eml21__MassPerVolumeUom__lbm_x002fbbl = 17,
	eml21__MassPerVolumeUom__lbm_x002fft3 = 18,
	eml21__MassPerVolumeUom__lbm_x002fgal_x005bUK_x005d = 19,
	eml21__MassPerVolumeUom__lbm_x002fgal_x005bUS_x005d = 20,
	eml21__MassPerVolumeUom__lbm_x002fin3 = 21,
	eml21__MassPerVolumeUom__mg_x002fdm3 = 22,
	eml21__MassPerVolumeUom__mg_x002fgal_x005bUS_x005d = 23,
	eml21__MassPerVolumeUom__mg_x002fL = 24,
	eml21__MassPerVolumeUom__mg_x002fm3 = 25,
	eml21__MassPerVolumeUom__Mg_x002fm3 = 26,
	eml21__MassPerVolumeUom__t_x002fm3 = 27,
	eml21__MassPerVolumeUom__ug_x002fcm3 = 28
};
#endif

/* eml2_1ForGsoap.h:9050 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassUom (1035)
/* eml21:MassUom */
enum eml21__MassUom {
	eml21__MassUom__g = 'g',
	eml21__MassUom__t = 't',
	eml21__MassUom__ag = 'u',
	eml21__MassUom__cg = 'v',
	eml21__MassUom__ct = 'w',
	eml21__MassUom__cwt_x005bUK_x005d = 'x',
	eml21__MassUom__cwt_x005bUS_x005d = 'y',
	eml21__MassUom__Eg = 'z',
	eml21__MassUom__fg = 123,
	eml21__MassUom__Gg = 124,
	eml21__MassUom__grain = 125,
	eml21__MassUom__hg = 126,
	eml21__MassUom__kg = 127,
	eml21__MassUom__klbm = 128,
	eml21__MassUom__lbm = 129,
	eml21__MassUom__mg = 130,
	eml21__MassUom__Mg = 131,
	eml21__MassUom__ng = 132,
	eml21__MassUom__ozm = 133,
	eml21__MassUom__ozm_x005btroy_x005d = 134,
	eml21__MassUom__pg = 135,
	eml21__MassUom__sack_x005b94lbm_x005d = 136,
	eml21__MassUom__Tg = 137,
	eml21__MassUom__ton_x005bUK_x005d = 138,
	eml21__MassUom__ton_x005bUS_x005d = 139,
	eml21__MassUom__ug = 140
};
#endif

/* eml2_1ForGsoap.h:9161 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUom (1036)
/* eml21:MobilityUom */
enum eml21__MobilityUom {
	eml21__MobilityUom__D_x002f_x0028Pa_x002es_x0029 = 0,
	eml21__MobilityUom__D_x002fcP = 1,
	eml21__MobilityUom__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 2,
	eml21__MobilityUom__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 3,
	eml21__MobilityUom__mD_x002f_x0028Pa_x002es_x0029 = 4,
	eml21__MobilityUom__mD_x002fcP = 5,
	eml21__MobilityUom__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 6
};
#endif

/* eml2_1ForGsoap.h:9196 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUom (1037)
/* eml21:MolarEnergyUom */
enum eml21__MolarEnergyUom {
	eml21__MolarEnergyUom__Btu_x005bIT_x005d_x002flbmol = 0,
	eml21__MolarEnergyUom__J_x002fmol = 1,
	eml21__MolarEnergyUom__kcal_x005bth_x005d_x002fmol = 2,
	eml21__MolarEnergyUom__kJ_x002fkmol = 3,
	eml21__MolarEnergyUom__MJ_x002fkmol = 4
};
#endif

/* eml2_1ForGsoap.h:9223 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUom (1038)
/* eml21:MolarHeatCapacityUom */
enum eml21__MolarHeatCapacityUom {
	eml21__MolarHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edeltaF_x0029 = 0,
	eml21__MolarHeatCapacityUom__cal_x005bth_x005d_x002f_x0028mol_x002edeltaC_x0029 = 1,
	eml21__MolarHeatCapacityUom__J_x002f_x0028mol_x002edeltaK_x0029 = 2,
	eml21__MolarHeatCapacityUom__kJ_x002f_x0028kmol_x002edeltaK_x0029 = 3
};
#endif

/* eml2_1ForGsoap.h:9246 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUom (1039)
/* eml21:MolarVolumeUom */
enum eml21__MolarVolumeUom {
	eml21__MolarVolumeUom__dm3_x002fkmol = 0,
	eml21__MolarVolumeUom__ft3_x002flbmol = 1,
	eml21__MolarVolumeUom__L_x002fkmol = 2,
	eml21__MolarVolumeUom__L_x002fmol = 3,
	eml21__MolarVolumeUom__m3_x002fkmol = 4,
	eml21__MolarVolumeUom__m3_x002fmol = 5
};
#endif

/* eml2_1ForGsoap.h:9277 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUom (1040)
/* eml21:MolecularWeightUom */
enum eml21__MolecularWeightUom {
	eml21__MolecularWeightUom__g_x002fmol = 0,
	eml21__MolecularWeightUom__kg_x002fmol = 1,
	eml21__MolecularWeightUom__lbm_x002flbmol = 2
};
#endif

/* eml2_1ForGsoap.h:9296 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUom (1041)
/* eml21:MomentOfForceUom */
enum eml21__MomentOfForceUom {
	eml21__MomentOfForceUom__J = 'J',
	eml21__MomentOfForceUom__1000_x0020lbf_x002eft = 'K',
	eml21__MomentOfForceUom__daN_x002em = 'L',
	eml21__MomentOfForceUom__dN_x002em = 'M',
	eml21__MomentOfForceUom__kgf_x002em = 'N',
	eml21__MomentOfForceUom__kN_x002em = 'O',
	eml21__MomentOfForceUom__lbf_x002eft = 'P',
	eml21__MomentOfForceUom__lbf_x002ein = 'Q',
	eml21__MomentOfForceUom__lbm_x002eft2_x002fs2 = 'R',
	eml21__MomentOfForceUom__N_x002em = 'S',
	eml21__MomentOfForceUom__pdl_x002eft = 'T',
	eml21__MomentOfForceUom__tonf_x005bUS_x005d_x002eft = 'U',
	eml21__MomentOfForceUom__tonf_x005bUS_x005d_x002emi = 'V'
};
#endif

/* eml2_1ForGsoap.h:9355 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUom (1042)
/* eml21:MomentOfInertiaUom */
enum eml21__MomentOfInertiaUom {
	eml21__MomentOfInertiaUom__kg_x002em2 = 0,
	eml21__MomentOfInertiaUom__lbm_x002eft2 = 1
};
#endif

/* eml2_1ForGsoap.h:9370 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUom (1043)
/* eml21:MomentumUom */
enum eml21__MomentumUom {
	eml21__MomentumUom__kg_x002em_x002fs = 0,
	eml21__MomentumUom__lbm_x002eft_x002fs = 1
};
#endif

/* eml2_1ForGsoap.h:9385 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUom (1044)
/* eml21:NormalizedPowerUom */
enum eml21__NormalizedPowerUom {
	eml21__NormalizedPowerUom__B_x002eW = 0,
	eml21__NormalizedPowerUom__dB_x002emW = 1,
	eml21__NormalizedPowerUom__dB_x002eMW = 2,
	eml21__NormalizedPowerUom__dB_x002eW = 3
};
#endif

/* eml2_1ForGsoap.h:9408 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUom (1045)
/* eml21:PermeabilityLengthUom */
enum eml21__PermeabilityLengthUom {
	eml21__PermeabilityLengthUom__D_x002eft = 0,
	eml21__PermeabilityLengthUom__D_x002em = 1,
	eml21__PermeabilityLengthUom__mD_x002eft = 2,
	eml21__PermeabilityLengthUom__mD_x002em = 3,
	eml21__PermeabilityLengthUom__TD_x005bAPI_x005d_x002em = 4
};
#endif

/* eml2_1ForGsoap.h:9435 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUom (1046)
/* eml21:PermeabilityRockUom */
enum eml21__PermeabilityRockUom {
	eml21__PermeabilityRockUom__D = 'D',
	eml21__PermeabilityRockUom__D_x005bAPI_x005d = 'E',
	eml21__PermeabilityRockUom__mD = 'F',
	eml21__PermeabilityRockUom__TD_x005bAPI_x005d = 'G'
};
#endif

/* eml2_1ForGsoap.h:9458 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUom (1047)
/* eml21:PermittivityUom */
enum eml21__PermittivityUom {
	eml21__PermittivityUom__F_x002fm = 0,
	eml21__PermittivityUom__uF_x002fm = 1
};
#endif

/* eml2_1ForGsoap.h:9473 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUom (1048)
/* eml21:PlaneAngleUom */
enum eml21__PlaneAngleUom {
	eml21__PlaneAngleUom__0_x002e001_x0020seca = 0,
	eml21__PlaneAngleUom__ccgr = 1,
	eml21__PlaneAngleUom__cgr = 2,
	eml21__PlaneAngleUom__dega = 3,
	eml21__PlaneAngleUom__gon = 4,
	eml21__PlaneAngleUom__krad = 5,
	eml21__PlaneAngleUom__mila = 6,
	eml21__PlaneAngleUom__mina = 7,
	eml21__PlaneAngleUom__Mrad = 8,
	eml21__PlaneAngleUom__mrad = 9,
	eml21__PlaneAngleUom__rad = 10,
	eml21__PlaneAngleUom__rev = 11,
	eml21__PlaneAngleUom__seca = 12,
	eml21__PlaneAngleUom__urad = 13
};
#endif

/* eml2_1ForGsoap.h:9536 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUom (1049)
/* eml21:PotentialDifferencePerPowerDropUom */
enum eml21__PotentialDifferencePerPowerDropUom {
	eml21__PotentialDifferencePerPowerDropUom__V_x002fB = 0,
	eml21__PotentialDifferencePerPowerDropUom__V_x002fdB = 1
};
#endif

/* eml2_1ForGsoap.h:9551 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUom (1050)
/* eml21:PowerPerAreaUom */
enum eml21__PowerPerAreaUom {
	eml21__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 0,
	eml21__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 1,
	eml21__PowerPerAreaUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 2,
	eml21__PowerPerAreaUom__hp_x002fin2 = 3,
	eml21__PowerPerAreaUom__hp_x005bhyd_x005d_x002fin2 = 4,
	eml21__PowerPerAreaUom__kW_x002fcm2 = 5,
	eml21__PowerPerAreaUom__kW_x002fm2 = 6,
	eml21__PowerPerAreaUom__mW_x002fm2 = 7,
	eml21__PowerPerAreaUom__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 8,
	eml21__PowerPerAreaUom__W_x002fcm2 = 9,
	eml21__PowerPerAreaUom__W_x002fm2 = 10,
	eml21__PowerPerAreaUom__W_x002fmm2 = 11
};
#endif

/* eml2_1ForGsoap.h:9606 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUom (1051)
/* eml21:PowerPerPowerUom */
enum eml21__PowerPerPowerUom {
	eml21__PowerPerPowerUom___x0025 = 0,
	eml21__PowerPerPowerUom__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 1,
	eml21__PowerPerPowerUom__Euc = 2,
	eml21__PowerPerPowerUom__W_x002fkW = 3,
	eml21__PowerPerPowerUom__W_x002fW = 4
};
#endif

/* eml2_1ForGsoap.h:9633 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUom (1052)
/* eml21:PowerPerVolumeUom */
enum eml21__PowerPerVolumeUom {
	eml21__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 0,
	eml21__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 1,
	eml21__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 2,
	eml21__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 3,
	eml21__PowerPerVolumeUom__hp_x002fft3 = 4,
	eml21__PowerPerVolumeUom__kW_x002fm3 = 5,
	eml21__PowerPerVolumeUom__uW_x002fm3 = 6,
	eml21__PowerPerVolumeUom__W_x002fm3 = 7
};
#endif

/* eml2_1ForGsoap.h:9672 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerUom (1053)
/* eml21:PowerUom */
enum eml21__PowerUom {
	eml21__PowerUom__W = 'W',
	eml21__PowerUom__cW = 'X',
	eml21__PowerUom__dW = 'Y',
	eml21__PowerUom__EW = 'Z',
	eml21__PowerUom__fW = 91,
	eml21__PowerUom__GW = 92,
	eml21__PowerUom__hp = 93,
	eml21__PowerUom__hp_x005belec_x005d = 94,
	eml21__PowerUom__hp_x005bhyd_x005d = 95,
	eml21__PowerUom__hp_x005bmetric_x005d = 96,
	eml21__PowerUom__kW = 'a',
	eml21__PowerUom__MW = 'b',
	eml21__PowerUom__mW = 'c',
	eml21__PowerUom__nW = 'd',
	eml21__PowerUom__pW = 'e',
	eml21__PowerUom__tonRefrig = 'f',
	eml21__PowerUom__TW = 'g',
	eml21__PowerUom__uW = 'h'
};
#endif

/* eml2_1ForGsoap.h:9751 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUom (1054)
/* eml21:PressurePerPressureUom */
enum eml21__PressurePerPressureUom {
	eml21__PressurePerPressureUom__atm_x002fatm = 0,
	eml21__PressurePerPressureUom__bar_x002fbar = 1,
	eml21__PressurePerPressureUom__Euc = 2,
	eml21__PressurePerPressureUom__kPa_x002fkPa = 3,
	eml21__PressurePerPressureUom__MPa_x002fMPa = 4,
	eml21__PressurePerPressureUom__Pa_x002fPa = 5,
	eml21__PressurePerPressureUom__psi_x002fpsi = 6
};
#endif

/* eml2_1ForGsoap.h:9786 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUom (1055)
/* eml21:PressurePerTimeUom */
enum eml21__PressurePerTimeUom {
	eml21__PressurePerTimeUom__atm_x002fh = 0,
	eml21__PressurePerTimeUom__bar_x002fh = 1,
	eml21__PressurePerTimeUom__kPa_x002fh = 2,
	eml21__PressurePerTimeUom__kPa_x002fmin = 3,
	eml21__PressurePerTimeUom__MPa_x002fh = 4,
	eml21__PressurePerTimeUom__Pa_x002fh = 5,
	eml21__PressurePerTimeUom__Pa_x002fs = 6,
	eml21__PressurePerTimeUom__psi_x002fh = 7,
	eml21__PressurePerTimeUom__psi_x002fmin = 8
};
#endif

/* eml2_1ForGsoap.h:9829 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUom (1056)
/* eml21:PressurePerVolumeUom */
enum eml21__PressurePerVolumeUom {
	eml21__PressurePerVolumeUom__Pa_x002fm3 = 0,
	eml21__PressurePerVolumeUom__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1
};
#endif

/* eml2_1ForGsoap.h:9844 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUom (1057)
/* eml21:PressureSquaredPerForceTimePerAreaUom */
enum eml21__PressureSquaredPerForceTimePerAreaUom {
	eml21__PressureSquaredPerForceTimePerAreaUom__0_x002e001_x0020kPa2_x002fcP = 0,
	eml21__PressureSquaredPerForceTimePerAreaUom__bar2_x002fcP = 1,
	eml21__PressureSquaredPerForceTimePerAreaUom__kPa2_x002fcP = 2,
	eml21__PressureSquaredPerForceTimePerAreaUom__Pa2_x002f_x0028Pa_x002es_x0029 = 3,
	eml21__PressureSquaredPerForceTimePerAreaUom__psi2_x002fcP = 4
};
#endif

/* eml2_1ForGsoap.h:9871 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUom (1058)
/* eml21:PressureSquaredUom */
enum eml21__PressureSquaredUom {
	eml21__PressureSquaredUom__bar2 = 0,
	eml21__PressureSquaredUom__GPa2 = 1,
	eml21__PressureSquaredUom__kPa2 = 2,
	eml21__PressureSquaredUom__kpsi2 = 3,
	eml21__PressureSquaredUom__Pa2 = 4,
	eml21__PressureSquaredUom__psi2 = 5
};
#endif

/* eml2_1ForGsoap.h:9902 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUom (1059)
/* eml21:PressureTimePerVolumeUom */
enum eml21__PressureTimePerVolumeUom {
	eml21__PressureTimePerVolumeUom__Pa_x002es_x002fm3 = 0,
	eml21__PressureTimePerVolumeUom__psi_x002ed_x002fbbl = 1
};
#endif

/* eml2_1ForGsoap.h:9917 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureUom (1060)
/* eml21:PressureUom */
enum eml21__PressureUom {
	eml21__PressureUom__0_x002e01_x0020lbf_x002fft2 = 0,
	eml21__PressureUom__at = 1,
	eml21__PressureUom__atm = 2,
	eml21__PressureUom__bar = 3,
	eml21__PressureUom__cmH2O_x005b4degC_x005d = 4,
	eml21__PressureUom__cPa = 5,
	eml21__PressureUom__dPa = 6,
	eml21__PressureUom__dyne_x002fcm2 = 7,
	eml21__PressureUom__EPa = 8,
	eml21__PressureUom__fPa = 9,
	eml21__PressureUom__GPa = 10,
	eml21__PressureUom__hbar = 11,
	eml21__PressureUom__inH2O_x005b39degF_x005d = 12,
	eml21__PressureUom__inH2O_x005b60degF_x005d = 13,
	eml21__PressureUom__inHg_x005b32degF_x005d = 14,
	eml21__PressureUom__inHg_x005b60degF_x005d = 15,
	eml21__PressureUom__kgf_x002fcm2 = 16,
	eml21__PressureUom__kgf_x002fm2 = 17,
	eml21__PressureUom__kgf_x002fmm2 = 18,
	eml21__PressureUom__kN_x002fm2 = 19,
	eml21__PressureUom__kPa = 20,
	eml21__PressureUom__kpsi = 21,
	eml21__PressureUom__lbf_x002fft2 = 22,
	eml21__PressureUom__mbar = 23,
	eml21__PressureUom__mmHg_x005b0degC_x005d = 24,
	eml21__PressureUom__mPa = 25,
	eml21__PressureUom__MPa = 26,
	eml21__PressureUom__Mpsi = 27,
	eml21__PressureUom__N_x002fm2 = 28,
	eml21__PressureUom__N_x002fmm2 = 29,
	eml21__PressureUom__nPa = 30,
	eml21__PressureUom__Pa = 31,
	eml21__PressureUom__pPa = 32,
	eml21__PressureUom__psi = 33,
	eml21__PressureUom__tonf_x005bUK_x005d_x002fft2 = 34,
	eml21__PressureUom__tonf_x005bUS_x005d_x002fft2 = 35,
	eml21__PressureUom__tonf_x005bUS_x005d_x002fin2 = 36,
	eml21__PressureUom__torr = 37,
	eml21__PressureUom__TPa = 38,
	eml21__PressureUom__ubar = 39,
	eml21__PressureUom__umHg_x005b0degC_x005d = 40,
	eml21__PressureUom__uPa = 41,
	eml21__PressureUom__upsi = 42
};
#endif

/* eml2_1ForGsoap.h:10096 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUom (1061)
/* eml21:QuantityOfLightUom */
enum eml21__QuantityOfLightUom {
	eml21__QuantityOfLightUom__lm_x002es = 0
};
#endif

/* eml2_1ForGsoap.h:10107 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUom (1062)
/* eml21:RadianceUom */
enum eml21__RadianceUom {
	eml21__RadianceUom__W_x002f_x0028m2_x002esr_x0029 = 0
};
#endif

/* eml2_1ForGsoap.h:10118 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUom (1063)
/* eml21:RadiantIntensityUom */
enum eml21__RadiantIntensityUom {
	eml21__RadiantIntensityUom__W_x002fsr = 0
};
#endif

/* eml2_1ForGsoap.h:10129 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUom (1064)
/* eml21:ReciprocalAreaUom */
enum eml21__ReciprocalAreaUom {
	eml21__ReciprocalAreaUom__1_x002fft2 = 0,
	eml21__ReciprocalAreaUom__1_x002fkm2 = 1,
	eml21__ReciprocalAreaUom__1_x002fm2 = 2,
	eml21__ReciprocalAreaUom__1_x002fmi2 = 3
};
#endif

/* eml2_1ForGsoap.h:10152 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUom (1065)
/* eml21:ReciprocalElectricPotentialDifferenceUom */
enum eml21__ReciprocalElectricPotentialDifferenceUom {
	eml21__ReciprocalElectricPotentialDifferenceUom__1_x002fuV = 0,
	eml21__ReciprocalElectricPotentialDifferenceUom__1_x002fV = 1
};
#endif

/* eml2_1ForGsoap.h:10167 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUom (1066)
/* eml21:ReciprocalForceUom */
enum eml21__ReciprocalForceUom {
	eml21__ReciprocalForceUom__1_x002flbf = 0,
	eml21__ReciprocalForceUom__1_x002fN = 1
};
#endif

/* eml2_1ForGsoap.h:10182 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUom (1067)
/* eml21:ReciprocalLengthUom */
enum eml21__ReciprocalLengthUom {
	eml21__ReciprocalLengthUom__1_x002fangstrom = 0,
	eml21__ReciprocalLengthUom__1_x002fcm = 1,
	eml21__ReciprocalLengthUom__1_x002fft = 2,
	eml21__ReciprocalLengthUom__1_x002fin = 3,
	eml21__ReciprocalLengthUom__1_x002fm = 4,
	eml21__ReciprocalLengthUom__1_x002fmi = 5,
	eml21__ReciprocalLengthUom__1_x002fmm = 6,
	eml21__ReciprocalLengthUom__1_x002fnm = 7,
	eml21__ReciprocalLengthUom__1_x002fyd = 8,
	eml21__ReciprocalLengthUom__1E_9_x00201_x002fft = 9
};
#endif

/* eml2_1ForGsoap.h:10229 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUom (1068)
/* eml21:ReciprocalMassTimeUom */
enum eml21__ReciprocalMassTimeUom {
	eml21__ReciprocalMassTimeUom__1_x002f_x0028kg_x002es_x0029 = 0,
	eml21__ReciprocalMassTimeUom__Bq_x002fkg = 1,
	eml21__ReciprocalMassTimeUom__pCi_x002fg = 2
};
#endif

/* eml2_1ForGsoap.h:10248 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUom (1069)
/* eml21:ReciprocalMassUom */
enum eml21__ReciprocalMassUom {
	eml21__ReciprocalMassUom__1_x002fg = 0,
	eml21__ReciprocalMassUom__1_x002fkg = 1,
	eml21__ReciprocalMassUom__1_x002flbm = 2
};
#endif

/* eml2_1ForGsoap.h:10267 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUom (1070)
/* eml21:ReciprocalPressureUom */
enum eml21__ReciprocalPressureUom {
	eml21__ReciprocalPressureUom__1_x002fbar = 0,
	eml21__ReciprocalPressureUom__1_x002fkPa = 1,
	eml21__ReciprocalPressureUom__1_x002fPa = 2,
	eml21__ReciprocalPressureUom__1_x002fpPa = 3,
	eml21__ReciprocalPressureUom__1_x002fpsi = 4,
	eml21__ReciprocalPressureUom__1_x002fupsi = 5
};
#endif

/* eml2_1ForGsoap.h:10298 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUom (1071)
/* eml21:ReciprocalTimeUom */
enum eml21__ReciprocalTimeUom {
	eml21__ReciprocalTimeUom__1_x002fa = 0,
	eml21__ReciprocalTimeUom__1_x002fd = 1,
	eml21__ReciprocalTimeUom__1_x002fh = 2,
	eml21__ReciprocalTimeUom__1_x002fmin = 3,
	eml21__ReciprocalTimeUom__1_x002fms = 4,
	eml21__ReciprocalTimeUom__1_x002fs = 5,
	eml21__ReciprocalTimeUom__1_x002fus = 6,
	eml21__ReciprocalTimeUom__1_x002fwk = 7
};
#endif

/* eml2_1ForGsoap.h:10337 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUom (1072)
/* eml21:ReciprocalVolumeUom */
enum eml21__ReciprocalVolumeUom {
	eml21__ReciprocalVolumeUom__1_x002fbbl = 0,
	eml21__ReciprocalVolumeUom__1_x002fft3 = 1,
	eml21__ReciprocalVolumeUom__1_x002fgal_x005bUK_x005d = 2,
	eml21__ReciprocalVolumeUom__1_x002fgal_x005bUS_x005d = 3,
	eml21__ReciprocalVolumeUom__1_x002fL = 4,
	eml21__ReciprocalVolumeUom__1_x002fm3 = 5
};
#endif

/* eml2_1ForGsoap.h:10368 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUom (1073)
/* eml21:ReluctanceUom */
enum eml21__ReluctanceUom {
	eml21__ReluctanceUom__1_x002fH = 0
};
#endif

/* eml2_1ForGsoap.h:10379 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUom (1074)
/* eml21:SecondMomentOfAreaUom */
enum eml21__SecondMomentOfAreaUom {
	eml21__SecondMomentOfAreaUom__cm4 = 0,
	eml21__SecondMomentOfAreaUom__in4 = 1,
	eml21__SecondMomentOfAreaUom__m4 = 2
};
#endif

/* eml2_1ForGsoap.h:10398 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUom (1075)
/* eml21:SignalingEventPerTimeUom */
enum eml21__SignalingEventPerTimeUom {
	eml21__SignalingEventPerTimeUom__Bd = 0
};
#endif

/* eml2_1ForGsoap.h:10409 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUom (1076)
/* eml21:SolidAngleUom */
enum eml21__SolidAngleUom {
	eml21__SolidAngleUom__sr = 0
};
#endif

/* eml2_1ForGsoap.h:10420 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUom (1077)
/* eml21:SpecificHeatCapacityUom */
enum eml21__SpecificHeatCapacityUom {
	eml21__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaF_x0029 = 0,
	eml21__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaR_x0029 = 1,
	eml21__SpecificHeatCapacityUom__cal_x005bth_x005d_x002f_x0028g_x002edeltaK_x0029 = 2,
	eml21__SpecificHeatCapacityUom__J_x002f_x0028g_x002edeltaK_x0029 = 3,
	eml21__SpecificHeatCapacityUom__J_x002f_x0028kg_x002edeltaK_x0029 = 4,
	eml21__SpecificHeatCapacityUom__kcal_x005bth_x005d_x002f_x0028kg_x002edeltaC_x0029 = 5,
	eml21__SpecificHeatCapacityUom__kJ_x002f_x0028kg_x002edeltaK_x0029 = 6,
	eml21__SpecificHeatCapacityUom__kW_x002eh_x002f_x0028kg_x002edeltaC_x0029 = 7
};
#endif

/* eml2_1ForGsoap.h:10459 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUom (1078)
/* eml21:TemperatureIntervalPerLengthUom */
enum eml21__TemperatureIntervalPerLengthUom {
	eml21__TemperatureIntervalPerLengthUom__0_x002e01_x0020deltaF_x002fft = 0,
	eml21__TemperatureIntervalPerLengthUom__deltaC_x002fft = 1,
	eml21__TemperatureIntervalPerLengthUom__deltaC_x002fhm = 2,
	eml21__TemperatureIntervalPerLengthUom__deltaC_x002fkm = 3,
	eml21__TemperatureIntervalPerLengthUom__deltaC_x002fm = 4,
	eml21__TemperatureIntervalPerLengthUom__deltaF_x002fft = 5,
	eml21__TemperatureIntervalPerLengthUom__deltaF_x002fm = 6,
	eml21__TemperatureIntervalPerLengthUom__deltaK_x002fkm = 7,
	eml21__TemperatureIntervalPerLengthUom__deltaK_x002fm = 8
};
#endif

/* eml2_1ForGsoap.h:10502 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUom (1079)
/* eml21:TemperatureIntervalPerPressureUom */
enum eml21__TemperatureIntervalPerPressureUom {
	eml21__TemperatureIntervalPerPressureUom__deltaC_x002fkPa = 0,
	eml21__TemperatureIntervalPerPressureUom__deltaF_x002fpsi = 1,
	eml21__TemperatureIntervalPerPressureUom__deltaK_x002fPa = 2
};
#endif

/* eml2_1ForGsoap.h:10521 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUom (1080)
/* eml21:TemperatureIntervalPerTimeUom */
enum eml21__TemperatureIntervalPerTimeUom {
	eml21__TemperatureIntervalPerTimeUom__deltaC_x002fh = 0,
	eml21__TemperatureIntervalPerTimeUom__deltaC_x002fmin = 1,
	eml21__TemperatureIntervalPerTimeUom__deltaC_x002fs = 2,
	eml21__TemperatureIntervalPerTimeUom__deltaF_x002fh = 3,
	eml21__TemperatureIntervalPerTimeUom__deltaF_x002fmin = 4,
	eml21__TemperatureIntervalPerTimeUom__deltaF_x002fs = 5,
	eml21__TemperatureIntervalPerTimeUom__deltaK_x002fs = 6
};
#endif

/* eml2_1ForGsoap.h:10556 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUom (1081)
/* eml21:TemperatureIntervalUom */
enum eml21__TemperatureIntervalUom {
	eml21__TemperatureIntervalUom__deltaC = 0,
	eml21__TemperatureIntervalUom__deltaF = 1,
	eml21__TemperatureIntervalUom__deltaK = 2,
	eml21__TemperatureIntervalUom__deltaR = 3
};
#endif

/* eml2_1ForGsoap.h:10579 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUom (1082)
/* eml21:ThermalConductanceUom */
enum eml21__ThermalConductanceUom {
	eml21__ThermalConductanceUom__W_x002fdeltaK = 0
};
#endif

/* eml2_1ForGsoap.h:10590 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUom (1083)
/* eml21:ThermalConductivityUom */
enum eml21__ThermalConductivityUom {
	eml21__ThermalConductivityUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edeltaF_x0029 = 0,
	eml21__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edeltaC_x0029 = 1,
	eml21__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edeltaC_x0029 = 2,
	eml21__ThermalConductivityUom__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edeltaC_x0029 = 3,
	eml21__ThermalConductivityUom__W_x002f_x0028m_x002edeltaK_x0029 = 4
};
#endif

/* eml2_1ForGsoap.h:10617 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUom (1084)
/* eml21:ThermalDiffusivityUom */
enum eml21__ThermalDiffusivityUom {
	eml21__ThermalDiffusivityUom__cm2_x002fs = 0,
	eml21__ThermalDiffusivityUom__ft2_x002fh = 1,
	eml21__ThermalDiffusivityUom__ft2_x002fs = 2,
	eml21__ThermalDiffusivityUom__in2_x002fs = 3,
	eml21__ThermalDiffusivityUom__m2_x002fh = 4,
	eml21__ThermalDiffusivityUom__m2_x002fs = 5,
	eml21__ThermalDiffusivityUom__mm2_x002fs = 6
};
#endif

/* eml2_1ForGsoap.h:10652 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUom (1085)
/* eml21:ThermalInsulanceUom */
enum eml21__ThermalInsulanceUom {
	eml21__ThermalInsulanceUom__deltaC_x002em2_x002eh_x002fkcal_x005bth_x005d = 0,
	eml21__ThermalInsulanceUom__deltaF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 1,
	eml21__ThermalInsulanceUom__deltaK_x002em2_x002fkW = 2,
	eml21__ThermalInsulanceUom__deltaK_x002em2_x002fW = 3
};
#endif

/* eml2_1ForGsoap.h:10675 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUom (1086)
/* eml21:ThermalResistanceUom */
enum eml21__ThermalResistanceUom {
	eml21__ThermalResistanceUom__deltaK_x002fW = 0
};
#endif

/* eml2_1ForGsoap.h:10686 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom (1087)
/* eml21:ThermodynamicTemperaturePerThermodynamicTemperatureUom */
enum eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom {
	eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom__degC_x002fdegC = 0,
	eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom__degF_x002fdegF = 1,
	eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom__degR_x002fdegR = 2,
	eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom__Euc = 3,
	eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom__K_x002fK = 4
};
#endif

/* eml2_1ForGsoap.h:10713 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUom (1088)
/* eml21:ThermodynamicTemperatureUom */
enum eml21__ThermodynamicTemperatureUom {
	eml21__ThermodynamicTemperatureUom__K = 'K',
	eml21__ThermodynamicTemperatureUom__degC = 'L',
	eml21__ThermodynamicTemperatureUom__degF = 'M',
	eml21__ThermodynamicTemperatureUom__degR = 'N'
};
#endif

/* eml2_1ForGsoap.h:10736 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUom (1089)
/* eml21:TimePerLengthUom */
enum eml21__TimePerLengthUom {
	eml21__TimePerLengthUom__0_x002e001_x0020h_x002fft = 0,
	eml21__TimePerLengthUom__h_x002fkm = 1,
	eml21__TimePerLengthUom__min_x002fft = 2,
	eml21__TimePerLengthUom__min_x002fm = 3,
	eml21__TimePerLengthUom__ms_x002fcm = 4,
	eml21__TimePerLengthUom__ms_x002fft = 5,
	eml21__TimePerLengthUom__ms_x002fin = 6,
	eml21__TimePerLengthUom__ms_x002fm = 7,
	eml21__TimePerLengthUom__ns_x002fft = 8,
	eml21__TimePerLengthUom__ns_x002fm = 9,
	eml21__TimePerLengthUom__s_x002fcm = 10,
	eml21__TimePerLengthUom__s_x002fft = 11,
	eml21__TimePerLengthUom__s_x002fin = 12,
	eml21__TimePerLengthUom__s_x002fm = 13,
	eml21__TimePerLengthUom__us_x002fft = 14,
	eml21__TimePerLengthUom__us_x002fin = 15,
	eml21__TimePerLengthUom__us_x002fm = 16
};
#endif

/* eml2_1ForGsoap.h:10811 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUom (1090)
/* eml21:TimePerMassUom */
enum eml21__TimePerMassUom {
	eml21__TimePerMassUom__s_x002fkg = 0
};
#endif

/* eml2_1ForGsoap.h:10822 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUom (1091)
/* eml21:TimePerTimeUom */
enum eml21__TimePerTimeUom {
	eml21__TimePerTimeUom___x0025 = 0,
	eml21__TimePerTimeUom__Euc = 1,
	eml21__TimePerTimeUom__ms_x002fs = 2,
	eml21__TimePerTimeUom__s_x002fs = 3
};
#endif

/* eml2_1ForGsoap.h:10845 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUom (1092)
/* eml21:TimePerVolumeUom */
enum eml21__TimePerVolumeUom {
	eml21__TimePerVolumeUom__0_x002e001_x0020d_x002fft3 = 0,
	eml21__TimePerVolumeUom__d_x002fbbl = 1,
	eml21__TimePerVolumeUom__d_x002fft3 = 2,
	eml21__TimePerVolumeUom__d_x002fm3 = 3,
	eml21__TimePerVolumeUom__h_x002fft3 = 4,
	eml21__TimePerVolumeUom__h_x002fm3 = 5,
	eml21__TimePerVolumeUom__s_x002fft3 = 6,
	eml21__TimePerVolumeUom__s_x002fL = 7,
	eml21__TimePerVolumeUom__s_x002fm3 = 8,
	eml21__TimePerVolumeUom__s_x002fqt_x005bUK_x005d = 9,
	eml21__TimePerVolumeUom__s_x002fqt_x005bUS_x005d = 10
};
#endif

/* eml2_1ForGsoap.h:10896 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeUom (1093)
/* eml21:TimeUom */
enum eml21__TimeUom {
	eml21__TimeUom__a = 'a',
	eml21__TimeUom__d = 'd',
	eml21__TimeUom__h = 'h',
	eml21__TimeUom__s = 's',
	eml21__TimeUom__1_x002f2_x0020ms = 't',
	eml21__TimeUom__100_x0020ka_x005bt_x005d = 'u',
	eml21__TimeUom__a_x005bt_x005d = 'v',
	eml21__TimeUom__ca = 'w',
	eml21__TimeUom__cs = 'x',
	eml21__TimeUom__ds = 'y',
	eml21__TimeUom__Ea_x005bt_x005d = 'z',
	eml21__TimeUom__fa = 123,
	eml21__TimeUom__Ga_x005bt_x005d = 124,
	eml21__TimeUom__hs = 125,
	eml21__TimeUom__ka_x005bt_x005d = 126,
	eml21__TimeUom__Ma_x005bt_x005d = 127,
	eml21__TimeUom__min_ = 128,
	eml21__TimeUom__ms = 129,
	eml21__TimeUom__na = 130,
	eml21__TimeUom__ns = 131,
	eml21__TimeUom__ps = 132,
	eml21__TimeUom__Ta_x005bt_x005d = 133,
	eml21__TimeUom__us = 134,
	eml21__TimeUom__wk = 135
};
#endif

/* eml2_1ForGsoap.h:11002 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUom (1094)
/* eml21:VerticalCoordinateUom */
enum eml21__VerticalCoordinateUom {
	eml21__VerticalCoordinateUom__m = 'm',
	eml21__VerticalCoordinateUom__ft = 'n',
	eml21__VerticalCoordinateUom__ftUS = 'o',
	eml21__VerticalCoordinateUom__ftBr_x002865_x0029 = 'p'
};
#endif

/* eml2_1ForGsoap.h:11025 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUom (1095)
/* eml21:VolumeFlowRatePerVolumeFlowRateUom */
enum eml21__VolumeFlowRatePerVolumeFlowRateUom {
	eml21__VolumeFlowRatePerVolumeFlowRateUom___x0025 = 0,
	eml21__VolumeFlowRatePerVolumeFlowRateUom___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 1,
	eml21__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 2,
	eml21__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 3,
	eml21__VolumeFlowRatePerVolumeFlowRateUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 4,
	eml21__VolumeFlowRatePerVolumeFlowRateUom__Euc = 5
};
#endif

/* eml2_1ForGsoap.h:11056 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUom (1096)
/* eml21:VolumePerAreaUom */
enum eml21__VolumePerAreaUom {
	eml21__VolumePerAreaUom__1E6_x0020bbl_x002facre = 0,
	eml21__VolumePerAreaUom__bbl_x002facre = 1,
	eml21__VolumePerAreaUom__ft3_x002fft2 = 2,
	eml21__VolumePerAreaUom__m3_x002fm2 = 3
};
#endif

/* eml2_1ForGsoap.h:11079 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUom (1097)
/* eml21:VolumePerLengthUom */
enum eml21__VolumePerLengthUom {
	eml21__VolumePerLengthUom__0_x002e01_x0020dm3_x002fkm = 0,
	eml21__VolumePerLengthUom__0_x002e01_x0020L_x002fkm = 1,
	eml21__VolumePerLengthUom__bbl_x002fft = 2,
	eml21__VolumePerLengthUom__bbl_x002fin = 3,
	eml21__VolumePerLengthUom__bbl_x002fmi = 4,
	eml21__VolumePerLengthUom__dm3_x002fm = 5,
	eml21__VolumePerLengthUom__ft3_x002fft = 6,
	eml21__VolumePerLengthUom__gal_x005bUK_x005d_x002fmi = 7,
	eml21__VolumePerLengthUom__gal_x005bUS_x005d_x002fft = 8,
	eml21__VolumePerLengthUom__gal_x005bUS_x005d_x002fmi = 9,
	eml21__VolumePerLengthUom__in3_x002fft = 10,
	eml21__VolumePerLengthUom__L_x002fm = 11,
	eml21__VolumePerLengthUom__m3_x002fkm = 12,
	eml21__VolumePerLengthUom__m3_x002fm = 13
};
#endif

/* eml2_1ForGsoap.h:11142 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUom (1098)
/* eml21:VolumePerMassUom */
enum eml21__VolumePerMassUom {
	eml21__VolumePerMassUom__0_x002e01_x0020L_x002fkg = 0,
	eml21__VolumePerMassUom__bbl_x002fton_x005bUK_x005d = 1,
	eml21__VolumePerMassUom__bbl_x002fton_x005bUS_x005d = 2,
	eml21__VolumePerMassUom__cm3_x002fg = 3,
	eml21__VolumePerMassUom__dm3_x002fkg = 4,
	eml21__VolumePerMassUom__dm3_x002ft = 5,
	eml21__VolumePerMassUom__ft3_x002fkg = 6,
	eml21__VolumePerMassUom__ft3_x002flbm = 7,
	eml21__VolumePerMassUom__ft3_x002fsack_x005b94lbm_x005d = 8,
	eml21__VolumePerMassUom__gal_x005bUK_x005d_x002flbm = 9,
	eml21__VolumePerMassUom__gal_x005bUS_x005d_x002flbm = 10,
	eml21__VolumePerMassUom__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 11,
	eml21__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 12,
	eml21__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 13,
	eml21__VolumePerMassUom__L_x002fkg = 14,
	eml21__VolumePerMassUom__L_x002ft = 15,
	eml21__VolumePerMassUom__L_x002fton_x005bUK_x005d = 16,
	eml21__VolumePerMassUom__m3_x002fg = 17,
	eml21__VolumePerMassUom__m3_x002fkg = 18,
	eml21__VolumePerMassUom__m3_x002ft = 19,
	eml21__VolumePerMassUom__m3_x002fton_x005bUK_x005d = 20,
	eml21__VolumePerMassUom__m3_x002fton_x005bUS_x005d = 21
};
#endif

/* eml2_1ForGsoap.h:11237 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUom (1099)
/* eml21:VolumePerPressureUom */
enum eml21__VolumePerPressureUom {
	eml21__VolumePerPressureUom__bbl_x002fpsi = 0,
	eml21__VolumePerPressureUom__m3_x002fkPa = 1,
	eml21__VolumePerPressureUom__m3_x002fPa = 2
};
#endif

/* eml2_1ForGsoap.h:11256 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUom (1100)
/* eml21:VolumePerRotationUom */
enum eml21__VolumePerRotationUom {
	eml21__VolumePerRotationUom__ft3_x002frad = 0,
	eml21__VolumePerRotationUom__m3_x002frad = 1,
	eml21__VolumePerRotationUom__m3_x002frev = 2
};
#endif

/* eml2_1ForGsoap.h:11275 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUom (1101)
/* eml21:VolumePerTimeLengthUom */
enum eml21__VolumePerTimeLengthUom {
	eml21__VolumePerTimeLengthUom__1000_x0020bbl_x002eft_x002fd = 0,
	eml21__VolumePerTimeLengthUom__1000_x0020m4_x002fd = 1,
	eml21__VolumePerTimeLengthUom__m4_x002fs = 2
};
#endif

/* eml2_1ForGsoap.h:11294 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUom (1102)
/* eml21:VolumePerTimePerAreaUom */
enum eml21__VolumePerTimePerAreaUom {
	eml21__VolumePerTimePerAreaUom__ft3_x002f_x0028min_x002eft2_x0029 = 0,
	eml21__VolumePerTimePerAreaUom__ft3_x002f_x0028s_x002eft2_x0029 = 1,
	eml21__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 2,
	eml21__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 3,
	eml21__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 4,
	eml21__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 5,
	eml21__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 6,
	eml21__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 7,
	eml21__VolumePerTimePerAreaUom__m3_x002f_x0028s_x002em2_x0029 = 8
};
#endif

/* eml2_1ForGsoap.h:11337 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUom (1103)
/* eml21:VolumePerTimePerLengthUom */
enum eml21__VolumePerTimePerLengthUom {
	eml21__VolumePerTimePerLengthUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 0,
	eml21__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = 1,
	eml21__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = 2,
	eml21__VolumePerTimePerLengthUom__bbl_x002f_x0028d_x002eft_x0029 = 3,
	eml21__VolumePerTimePerLengthUom__ft3_x002f_x0028d_x002eft_x0029 = 4,
	eml21__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 5,
	eml21__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 6,
	eml21__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 7,
	eml21__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 8,
	eml21__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 9,
	eml21__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 10,
	eml21__VolumePerTimePerLengthUom__m3_x002f_x0028d_x002em_x0029 = 11,
	eml21__VolumePerTimePerLengthUom__m3_x002f_x0028h_x002em_x0029 = 12,
	eml21__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002eft_x0029 = 13,
	eml21__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002em_x0029 = 14
};
#endif

/* eml2_1ForGsoap.h:11404 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUom (1104)
/* eml21:VolumePerTimePerPressureLengthUom */
enum eml21__VolumePerTimePerPressureLengthUom {
	eml21__VolumePerTimePerPressureLengthUom__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 0,
	eml21__VolumePerTimePerPressureLengthUom__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 1,
	eml21__VolumePerTimePerPressureLengthUom__m2_x002f_x0028kPa_x002ed_x0029 = 2,
	eml21__VolumePerTimePerPressureLengthUom__m2_x002f_x0028Pa_x002es_x0029 = 3
};
#endif

/* eml2_1ForGsoap.h:11427 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUom (1105)
/* eml21:VolumePerTimePerPressureUom */
enum eml21__VolumePerTimePerPressureUom {
	eml21__VolumePerTimePerPressureUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 0,
	eml21__VolumePerTimePerPressureUom__bbl_x002f_x0028kPa_x002ed_x0029 = 1,
	eml21__VolumePerTimePerPressureUom__bbl_x002f_x0028psi_x002ed_x0029 = 2,
	eml21__VolumePerTimePerPressureUom__L_x002f_x0028bar_x002emin_x0029 = 3,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002ed_x0029 = 4,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002eh_x0029 = 5,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002emin_x0029 = 6,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002ed_x0029 = 7,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002eh_x0029 = 8,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028Pa_x002es_x0029 = 9,
	eml21__VolumePerTimePerPressureUom__m3_x002f_x0028psi_x002ed_x0029 = 10
};
#endif

/* eml2_1ForGsoap.h:11478 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUom (1106)
/* eml21:VolumePerTimePerTimeUom */
enum eml21__VolumePerTimePerTimeUom {
	eml21__VolumePerTimePerTimeUom__bbl_x002fd2 = 0,
	eml21__VolumePerTimePerTimeUom__bbl_x002fh2 = 1,
	eml21__VolumePerTimePerTimeUom__dm3_x002fs2 = 2,
	eml21__VolumePerTimePerTimeUom__ft3_x002fd2 = 3,
	eml21__VolumePerTimePerTimeUom__ft3_x002fh2 = 4,
	eml21__VolumePerTimePerTimeUom__ft3_x002fmin2 = 5,
	eml21__VolumePerTimePerTimeUom__ft3_x002fs2 = 6,
	eml21__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fh2 = 7,
	eml21__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fmin2 = 8,
	eml21__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fh2 = 9,
	eml21__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fmin2 = 10,
	eml21__VolumePerTimePerTimeUom__L_x002fs2 = 11,
	eml21__VolumePerTimePerTimeUom__m3_x002fd2 = 12,
	eml21__VolumePerTimePerTimeUom__m3_x002fs2 = 13
};
#endif

/* eml2_1ForGsoap.h:11541 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUom (1107)
/* eml21:VolumePerTimePerVolumeUom */
enum eml21__VolumePerTimePerVolumeUom {
	eml21__VolumePerTimePerVolumeUom__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 0,
	eml21__VolumePerTimePerVolumeUom__m3_x002f_x0028s_x002em3_x0029 = 1
};
#endif

/* eml2_1ForGsoap.h:11556 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUom (1108)
/* eml21:VolumePerTimeUom */
enum eml21__VolumePerTimeUom {
	eml21__VolumePerTimeUom__1_x002f30_x0020cm3_x002fmin = 0,
	eml21__VolumePerTimeUom__1000_x0020bbl_x002fd = 1,
	eml21__VolumePerTimeUom__1000_x0020ft3_x002fd = 2,
	eml21__VolumePerTimeUom__1000_x0020m3_x002fd = 3,
	eml21__VolumePerTimeUom__1000_x0020m3_x002fh = 4,
	eml21__VolumePerTimeUom__1E6_x0020bbl_x002fd = 5,
	eml21__VolumePerTimeUom__1E6_x0020ft3_x002fd = 6,
	eml21__VolumePerTimeUom__1E6_x0020m3_x002fd = 7,
	eml21__VolumePerTimeUom__bbl_x002fd = 8,
	eml21__VolumePerTimeUom__bbl_x002fh = 9,
	eml21__VolumePerTimeUom__bbl_x002fmin = 10,
	eml21__VolumePerTimeUom__cm3_x002fh = 11,
	eml21__VolumePerTimeUom__cm3_x002fmin = 12,
	eml21__VolumePerTimeUom__cm3_x002fs = 13,
	eml21__VolumePerTimeUom__dm3_x002fs = 14,
	eml21__VolumePerTimeUom__ft3_x002fd = 15,
	eml21__VolumePerTimeUom__ft3_x002fh = 16,
	eml21__VolumePerTimeUom__ft3_x002fmin = 17,
	eml21__VolumePerTimeUom__ft3_x002fs = 18,
	eml21__VolumePerTimeUom__gal_x005bUK_x005d_x002fd = 19,
	eml21__VolumePerTimeUom__gal_x005bUK_x005d_x002fh = 20,
	eml21__VolumePerTimeUom__gal_x005bUK_x005d_x002fmin = 21,
	eml21__VolumePerTimeUom__gal_x005bUS_x005d_x002fd = 22,
	eml21__VolumePerTimeUom__gal_x005bUS_x005d_x002fh = 23,
	eml21__VolumePerTimeUom__gal_x005bUS_x005d_x002fmin = 24,
	eml21__VolumePerTimeUom__L_x002fh = 25,
	eml21__VolumePerTimeUom__L_x002fmin = 26,
	eml21__VolumePerTimeUom__L_x002fs = 27,
	eml21__VolumePerTimeUom__m3_x002fd = 28,
	eml21__VolumePerTimeUom__m3_x002fh = 29,
	eml21__VolumePerTimeUom__m3_x002fmin = 30,
	eml21__VolumePerTimeUom__m3_x002fs = 31
};
#endif

/* eml2_1ForGsoap.h:11691 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUom (1109)
/* eml21:VolumePerVolumeUom */
enum eml21__VolumePerVolumeUom {
	eml21__VolumePerVolumeUom___x0025 = 0,
	eml21__VolumePerVolumeUom___x0025_x005bvol_x005d = 1,
	eml21__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fft3 = 2,
	eml21__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fm3 = 3,
	eml21__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 4,
	eml21__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 5,
	eml21__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 6,
	eml21__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 7,
	eml21__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 8,
	eml21__VolumePerVolumeUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 9,
	eml21__VolumePerVolumeUom__0_x002e01_x0020bbl_x002fbbl = 10,
	eml21__VolumePerVolumeUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 11,
	eml21__VolumePerVolumeUom__0_x002e1_x0020L_x002fbbl = 12,
	eml21__VolumePerVolumeUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 13,
	eml21__VolumePerVolumeUom__1000_x0020ft3_x002fbbl = 14,
	eml21__VolumePerVolumeUom__1000_x0020m3_x002fm3 = 15,
	eml21__VolumePerVolumeUom__1E_6_x0020acre_x002eft_x002fbbl = 16,
	eml21__VolumePerVolumeUom__1E_6_x0020bbl_x002fft3 = 17,
	eml21__VolumePerVolumeUom__1E_6_x0020bbl_x002fm3 = 18,
	eml21__VolumePerVolumeUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 19,
	eml21__VolumePerVolumeUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 20,
	eml21__VolumePerVolumeUom__1E6_x0020ft3_x002fbbl = 21,
	eml21__VolumePerVolumeUom__bbl_x002f_x0028acre_x002eft_x0029 = 22,
	eml21__VolumePerVolumeUom__bbl_x002fbbl = 23,
	eml21__VolumePerVolumeUom__bbl_x002fft3 = 24,
	eml21__VolumePerVolumeUom__bbl_x002fm3 = 25,
	eml21__VolumePerVolumeUom__cEuc = 26,
	eml21__VolumePerVolumeUom__cm3_x002fcm3 = 27,
	eml21__VolumePerVolumeUom__cm3_x002fL = 28,
	eml21__VolumePerVolumeUom__cm3_x002fm3 = 29,
	eml21__VolumePerVolumeUom__dm3_x002fm3 = 30,
	eml21__VolumePerVolumeUom__Euc = 31,
	eml21__VolumePerVolumeUom__ft3_x002fbbl = 32,
	eml21__VolumePerVolumeUom__ft3_x002fft3 = 33,
	eml21__VolumePerVolumeUom__gal_x005bUK_x005d_x002fft3 = 34,
	eml21__VolumePerVolumeUom__gal_x005bUS_x005d_x002fbbl = 35,
	eml21__VolumePerVolumeUom__gal_x005bUS_x005d_x002fft3 = 36,
	eml21__VolumePerVolumeUom__L_x002fm3 = 37,
	eml21__VolumePerVolumeUom__m3_x002f_x0028ha_x002em_x0029 = 38,
	eml21__VolumePerVolumeUom__m3_x002fbbl = 39,
	eml21__VolumePerVolumeUom__m3_x002fm3 = 40,
	eml21__VolumePerVolumeUom__mL_x002fgal_x005bUK_x005d = 41,
	eml21__VolumePerVolumeUom__mL_x002fgal_x005bUS_x005d = 42,
	eml21__VolumePerVolumeUom__mL_x002fmL = 43,
	eml21__VolumePerVolumeUom__ppk = 44,
	eml21__VolumePerVolumeUom__ppm = 45,
	eml21__VolumePerVolumeUom__ppm_x005bvol_x005d = 46
};
#endif

/* eml2_1ForGsoap.h:11886 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUom (1110)
/* eml21:VolumetricHeatTransferCoefficientUom */
enum eml21__VolumetricHeatTransferCoefficientUom {
	eml21__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edeltaF_x0029 = 0,
	eml21__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edeltaF_x0029 = 1,
	eml21__VolumetricHeatTransferCoefficientUom__kW_x002f_x0028m3_x002edeltaK_x0029 = 2,
	eml21__VolumetricHeatTransferCoefficientUom__W_x002f_x0028m3_x002edeltaK_x0029 = 3
};
#endif

/* eml2_1ForGsoap.h:11909 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUom (1111)
/* eml21:VolumetricThermalExpansionUom */
enum eml21__VolumetricThermalExpansionUom {
	eml21__VolumetricThermalExpansionUom__1_x002fdeltaC = 0,
	eml21__VolumetricThermalExpansionUom__1_x002fdeltaF = 1,
	eml21__VolumetricThermalExpansionUom__1_x002fdeltaK = 2,
	eml21__VolumetricThermalExpansionUom__1_x002fdeltaR = 3,
	eml21__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaC_x0029 = 4,
	eml21__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaF_x0029 = 5,
	eml21__VolumetricThermalExpansionUom__m3_x002f_x0028m3_x002edeltaK_x0029 = 6,
	eml21__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaC = 7,
	eml21__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaF = 8
};
#endif

/* eml2_1ForGsoap.h:11952 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUom (1112)
/* eml21:VolumeUom */
enum eml21__VolumeUom {
	eml21__VolumeUom__L = 'L',
	eml21__VolumeUom__1000_x0020bbl = 'M',
	eml21__VolumeUom__1000_x0020ft3 = 'N',
	eml21__VolumeUom__1000_x0020gal_x005bUK_x005d = 'O',
	eml21__VolumeUom__1000_x0020gal_x005bUS_x005d = 'P',
	eml21__VolumeUom__1000_x0020m3 = 'Q',
	eml21__VolumeUom__1E_6_x0020gal_x005bUS_x005d = 'R',
	eml21__VolumeUom__1E12_x0020ft3 = 'S',
	eml21__VolumeUom__1E6_x0020bbl = 'T',
	eml21__VolumeUom__1E6_x0020ft3 = 'U',
	eml21__VolumeUom__1E6_x0020m3 = 'V',
	eml21__VolumeUom__1E9_x0020bbl = 'W',
	eml21__VolumeUom__1E9_x0020ft3 = 'X',
	eml21__VolumeUom__acre_x002eft = 'Y',
	eml21__VolumeUom__bbl = 'Z',
	eml21__VolumeUom__cm3 = 91,
	eml21__VolumeUom__dm3 = 92,
	eml21__VolumeUom__floz_x005bUK_x005d = 93,
	eml21__VolumeUom__floz_x005bUS_x005d = 94,
	eml21__VolumeUom__ft3 = 95,
	eml21__VolumeUom__gal_x005bUK_x005d = 96,
	eml21__VolumeUom__gal_x005bUS_x005d = 'a',
	eml21__VolumeUom__ha_x002em = 'b',
	eml21__VolumeUom__hL = 'c',
	eml21__VolumeUom__in3 = 'd',
	eml21__VolumeUom__km3 = 'e',
	eml21__VolumeUom__m3 = 'f',
	eml21__VolumeUom__mi3 = 'g',
	eml21__VolumeUom__mL = 'h',
	eml21__VolumeUom__mm3 = 'i',
	eml21__VolumeUom__pt_x005bUK_x005d = 'j',
	eml21__VolumeUom__pt_x005bUS_x005d = 'k',
	eml21__VolumeUom__qt_x005bUK_x005d = 'l',
	eml21__VolumeUom__qt_x005bUS_x005d = 'm',
	eml21__VolumeUom__um2_x002em = 'n',
	eml21__VolumeUom__yd3 = 'o'
};
#endif

/* eml2_1ForGsoap.h:12154 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationType (1113)
/* prodml2:DasCalibrationType */
enum prodml2__DasCalibrationType {
	prodml2__DasCalibrationType__last_x0020locus_x0020to_x0020end_x0020of_x0020fiber = 0,
	prodml2__DasCalibrationType__locus_x0020calibration = 1,
	prodml2__DasCalibrationType__tap_x0020test = 2
};
#endif

/* eml2_1ForGsoap.h:12179 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasDimensions
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasDimensions (1114)
/* prodml2:DasDimensions */
enum prodml2__DasDimensions {
	prodml2__DasDimensions__frequency = 0,
	prodml2__DasDimensions__locus = 1,
	prodml2__DasDimensions__time = 2
};
#endif

/* eml2_1ForGsoap.h:12201 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityKind (1115)
/* prodml2:FacilityKind */
enum prodml2__FacilityKind {
	prodml2__FacilityKind__generic = 0,
	prodml2__FacilityKind__pipeline = 1,
	prodml2__FacilityKind__well = 2
};
#endif

/* eml2_1ForGsoap.h:12223 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AddressKindEnum (1116)
/* prodml2:AddressKindEnum */
enum prodml2__AddressKindEnum {
	prodml2__AddressKindEnum__both = 0,
	prodml2__AddressKindEnum__mailing = 1,
	prodml2__AddressKindEnum__physical = 2
};
#endif

/* eml2_1ForGsoap.h:12239 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AddressQualifier (1117)
/* prodml2:AddressQualifier */
enum prodml2__AddressQualifier {
	prodml2__AddressQualifier__permanent = 0,
	prodml2__AddressQualifier__personal = 1,
	prodml2__AddressQualifier__work = 2
};
#endif

/* eml2_1ForGsoap.h:12258 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessUnitKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessUnitKind (1118)
/* prodml2:BusinessUnitKind */
enum prodml2__BusinessUnitKind {
	prodml2__BusinessUnitKind__businessarea = 0,
	prodml2__BusinessUnitKind__company = 1,
	prodml2__BusinessUnitKind__field = 2,
	prodml2__BusinessUnitKind__license = 3,
	prodml2__BusinessUnitKind__platform = 4,
	prodml2__BusinessUnitKind__terminal = 5,
	prodml2__BusinessUnitKind__unknown = 6
};
#endif

/* eml2_1ForGsoap.h:12275 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifier (1119)
/* prodml2:EndpointQualifier */
enum prodml2__EndpointQualifier {
	prodml2__EndpointQualifier__exclusive = 0,
	prodml2__EndpointQualifier__extensive = 1,
	prodml2__EndpointQualifier__inclusive = 2,
	prodml2__EndpointQualifier__overlap_x0020extensive = 3
};
#endif

/* eml2_1ForGsoap.h:12302 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifierInterval
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifierInterval (1120)
/* prodml2:EndpointQualifierInterval */
enum prodml2__EndpointQualifierInterval {
	prodml2__EndpointQualifierInterval__exclusive = 0,
	prodml2__EndpointQualifierInterval__inclusive = 1,
	prodml2__EndpointQualifierInterval__unknown = 2
};
#endif

/* eml2_1ForGsoap.h:12324 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParameter
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParameter (1121)
/* prodml2:FacilityParameter */
enum prodml2__FacilityParameter {
	prodml2__FacilityParameter__absorbed_x0020dose_x0020class = 0,
	prodml2__FacilityParameter__acceleration_x0020linear_x0020class = 1,
	prodml2__FacilityParameter__activity_x0020_x0028of_x0020radioactivity_x0029_x0020class = 2,
	prodml2__FacilityParameter__alarm_x0020absolute_x0020pressure = 3,
	prodml2__FacilityParameter__amount_x0020of_x0020substance_x0020class = 4,
	prodml2__FacilityParameter__angle_x0020per_x0020length = 5,
	prodml2__FacilityParameter__angle_x0020per_x0020time = 6,
	prodml2__FacilityParameter__angle_x0020per_x0020volume = 7,
	prodml2__FacilityParameter__angular_x0020acceleration_x0020class = 8,
	prodml2__FacilityParameter__annulus_x0020inner_x0020diameter = 9,
	prodml2__FacilityParameter__annulus_x0020outer_x0020diameter = 10,
	prodml2__FacilityParameter__area_x0020class = 11,
	prodml2__FacilityParameter__area_x0020per_x0020area = 12,
	prodml2__FacilityParameter__area_x0020per_x0020volume = 13,
	prodml2__FacilityParameter__atmospheric_x0020pressure = 14,
	prodml2__FacilityParameter__attenuation_x0020class = 15,
	prodml2__FacilityParameter__attenuation_x0020per_x0020length = 16,
	prodml2__FacilityParameter__available = 17,
	prodml2__FacilityParameter__available_x0020room = 18,
	prodml2__FacilityParameter__block_x0020valve_x0020status = 19,
	prodml2__FacilityParameter__capacitance_x0020class = 20,
	prodml2__FacilityParameter__categorical = 21,
	prodml2__FacilityParameter__cathodic_x0020protection_x0020output_x0020current = 22,
	prodml2__FacilityParameter__cathodic_x0020protection_x0020output_x0020voltage = 23,
	prodml2__FacilityParameter__charge_x0020density_x0020class = 24,
	prodml2__FacilityParameter__chemical_x0020potential_x0020class = 25,
	prodml2__FacilityParameter__choke_x0020position = 26,
	prodml2__FacilityParameter__choke_x0020setting = 27,
	prodml2__FacilityParameter__code = 28,
	prodml2__FacilityParameter__compressibility_x0020class = 29,
	prodml2__FacilityParameter__concentration_x0020of_x0020B_x0020class = 30,
	prodml2__FacilityParameter__conductivity_x0020class = 31,
	prodml2__FacilityParameter__continuous = 32,
	prodml2__FacilityParameter__cross_x0020section_x0020absorption_x0020class = 33,
	prodml2__FacilityParameter__current_x0020density_x0020class = 34,
	prodml2__FacilityParameter__darcy_x0020flow_x0020coefficient_x0020class = 35,
	prodml2__FacilityParameter__data_x0020transmission_x0020speed_x0020class = 36,
	prodml2__FacilityParameter__delta_x0020temperature_x0020class = 37,
	prodml2__FacilityParameter__density = 38,
	prodml2__FacilityParameter__density_x0020class = 39,
	prodml2__FacilityParameter__density_x0020flow_x0020rate = 40,
	prodml2__FacilityParameter__density_x0020standard = 41,
	prodml2__FacilityParameter__dewpoint_x0020temperature = 42,
	prodml2__FacilityParameter__differential_x0020pressure = 43,
	prodml2__FacilityParameter__differential_x0020temperature = 44,
	prodml2__FacilityParameter__diffusion_x0020coefficient_x0020class = 45,
	prodml2__FacilityParameter__digital_x0020storage_x0020class = 46,
	prodml2__FacilityParameter__dimensionless_x0020class = 47,
	prodml2__FacilityParameter__discrete = 48,
	prodml2__FacilityParameter__dose_x0020equivalent_x0020class = 49,
	prodml2__FacilityParameter__dose_x0020equivalent_x0020rate_x0020class = 50,
	prodml2__FacilityParameter__dynamic_x0020viscosity_x0020class = 51,
	prodml2__FacilityParameter__electric_x0020charge_x0020class = 52,
	prodml2__FacilityParameter__electric_x0020conductance_x0020class = 53,
	prodml2__FacilityParameter__electric_x0020current_x0020class = 54,
	prodml2__FacilityParameter__electric_x0020dipole_x0020moment_x0020class = 55,
	prodml2__FacilityParameter__electric_x0020field_x0020strength_x0020class = 56,
	prodml2__FacilityParameter__electric_x0020polarization_x0020class = 57,
	prodml2__FacilityParameter__electric_x0020potential_x0020class = 58,
	prodml2__FacilityParameter__electrical_x0020resistivity_x0020class = 59,
	prodml2__FacilityParameter__electrochemical_x0020equivalent_x0020class = 60,
	prodml2__FacilityParameter__electromagnetic_x0020moment_x0020class = 61,
	prodml2__FacilityParameter__energy_x0020length_x0020per_x0020area = 62,
	prodml2__FacilityParameter__energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 63,
	prodml2__FacilityParameter__energy_x0020per_x0020area = 64,
	prodml2__FacilityParameter__energy_x0020per_x0020length = 'A',
	prodml2__FacilityParameter__equivalent_x0020per_x0020mass = 'B',
	prodml2__FacilityParameter__equivalent_x0020per_x0020volume = 'C',
	prodml2__FacilityParameter__exposure_x0020_x0028radioactivity_x0029_x0020class = 'D',
	prodml2__FacilityParameter__facility_x0020uptime = 'E',
	prodml2__FacilityParameter__flow_x0020rate = 'F',
	prodml2__FacilityParameter__flow_x0020rate_x0020standard = 'G',
	prodml2__FacilityParameter__force_x0020area_x0020class = 'H',
	prodml2__FacilityParameter__force_x0020class = 'I',
	prodml2__FacilityParameter__force_x0020length_x0020per_x0020length = 'J',
	prodml2__FacilityParameter__force_x0020per_x0020force = 'K',
	prodml2__FacilityParameter__force_x0020per_x0020length = 'L',
	prodml2__FacilityParameter__force_x0020per_x0020volume = 'M',
	prodml2__FacilityParameter__frequency_x0020class = 'N',
	prodml2__FacilityParameter__frequency_x0020interval_x0020class = 'O',
	prodml2__FacilityParameter__gamma_x0020ray_x0020API_x0020unit_x0020class = 'P',
	prodml2__FacilityParameter__gas_x0020liquid_x0020ratio = 'Q',
	prodml2__FacilityParameter__gas_x0020oil_x0020ratio = 'R',
	prodml2__FacilityParameter__gross_x0020calorific_x0020value_x0020standard = 'S',
	prodml2__FacilityParameter__heat_x0020capacity_x0020class = 'T',
	prodml2__FacilityParameter__heat_x0020flow_x0020rate_x0020class = 'U',
	prodml2__FacilityParameter__heat_x0020transfer_x0020coefficient_x0020class = 'V',
	prodml2__FacilityParameter__illuminance_x0020class = 'W',
	prodml2__FacilityParameter__internal_x0020control_x0020valve_x0020status = 'X',
	prodml2__FacilityParameter__irradiance_x0020class = 'Y',
	prodml2__FacilityParameter__isothermal_x0020compressibility_x0020class = 'Z',
	prodml2__FacilityParameter__kinematic_x0020viscosity_x0020class = 91,
	prodml2__FacilityParameter__length_x0020class = 92,
	prodml2__FacilityParameter__length_x0020per_x0020length = 93,
	prodml2__FacilityParameter__length_x0020per_x0020temperature = 94,
	prodml2__FacilityParameter__length_x0020per_x0020volume = 95,
	prodml2__FacilityParameter__level_x0020of_x0020power_x0020intensity_x0020class = 96,
	prodml2__FacilityParameter__light_x0020exposure_x0020class = 'a',
	prodml2__FacilityParameter__linear_x0020thermal_x0020expansion_x0020class = 'b',
	prodml2__FacilityParameter__luminance_x0020class = 'c',
	prodml2__FacilityParameter__luminous_x0020efficacy_x0020class = 'd',
	prodml2__FacilityParameter__luminous_x0020flux_x0020class = 'e',
	prodml2__FacilityParameter__luminous_x0020intensity_x0020class = 'f',
	prodml2__FacilityParameter__magnetic_x0020dipole_x0020moment_x0020class = 'g',
	prodml2__FacilityParameter__magnetic_x0020field_x0020strength_x0020class = 'h',
	prodml2__FacilityParameter__magnetic_x0020flux_x0020class = 'i',
	prodml2__FacilityParameter__magnetic_x0020induction_x0020class = 'j',
	prodml2__FacilityParameter__magnetic_x0020permeability_x0020class = 'k',
	prodml2__FacilityParameter__magnetic_x0020vector_x0020potential_x0020class = 'l',
	prodml2__FacilityParameter__mass = 'm',
	prodml2__FacilityParameter__mass_x0020attenuation_x0020coefficient_x0020class = 'n',
	prodml2__FacilityParameter__mass_x0020class = 'o',
	prodml2__FacilityParameter__mass_x0020concentration = 'p',
	prodml2__FacilityParameter__mass_x0020concentration_x0020class = 'q',
	prodml2__FacilityParameter__mass_x0020flow_x0020rate_x0020class = 'r',
	prodml2__FacilityParameter__mass_x0020length_x0020class = 's',
	prodml2__FacilityParameter__mass_x0020per_x0020energy = 't',
	prodml2__FacilityParameter__mass_x0020per_x0020length = 'u',
	prodml2__FacilityParameter__mass_x0020per_x0020time_x0020per_x0020area = 'v',
	prodml2__FacilityParameter__mass_x0020per_x0020time_x0020per_x0020length = 'w',
	prodml2__FacilityParameter__mass_x0020per_x0020volume_x0020per_x0020length = 'x',
	prodml2__FacilityParameter__measured_x0020depth = 'y',
	prodml2__FacilityParameter__mobility_x0020class = 'z',
	prodml2__FacilityParameter__modulus_x0020of_x0020compression_x0020class = 123,
	prodml2__FacilityParameter__molar_x0020concentration = 124,
	prodml2__FacilityParameter__molar_x0020fraction = 125,
	prodml2__FacilityParameter__molar_x0020heat_x0020capacity_x0020class = 126,
	prodml2__FacilityParameter__molar_x0020volume_x0020class = 127,
	prodml2__FacilityParameter__mole_x0020per_x0020area = 128,
	prodml2__FacilityParameter__mole_x0020per_x0020time = 129,
	prodml2__FacilityParameter__mole_x0020per_x0020time_x0020per_x0020area = 130,
	prodml2__FacilityParameter__molecular_x0020weight = 131,
	prodml2__FacilityParameter__moment_x0020of_x0020force_x0020class = 132,
	prodml2__FacilityParameter__moment_x0020of_x0020inertia_x0020class = 133,
	prodml2__FacilityParameter__moment_x0020of_x0020section_x0020class = 134,
	prodml2__FacilityParameter__momentum_x0020class = 135,
	prodml2__FacilityParameter__motor_x0020current = 136,
	prodml2__FacilityParameter__motor_x0020current_x0020leakage = 137,
	prodml2__FacilityParameter__motor_x0020speed = 138,
	prodml2__FacilityParameter__motor_x0020temperature = 139,
	prodml2__FacilityParameter__motor_x0020vibration = 140,
	prodml2__FacilityParameter__motor_x0020voltage = 141,
	prodml2__FacilityParameter__neutron_x0020API_x0020unit_x0020class = 142,
	prodml2__FacilityParameter__nonDarcy_x0020flow_x0020coefficient_x0020class = 143,
	prodml2__FacilityParameter__opening_x0020size = 144,
	prodml2__FacilityParameter__operations_x0020per_x0020time = 145,
	prodml2__FacilityParameter__parachor_x0020class = 146,
	prodml2__FacilityParameter__per_x0020area = 147,
	prodml2__FacilityParameter__per_x0020electric_x0020potential = 148,
	prodml2__FacilityParameter__per_x0020force = 149,
	prodml2__FacilityParameter__per_x0020length = 150,
	prodml2__FacilityParameter__per_x0020mass = 151,
	prodml2__FacilityParameter__per_x0020volume = 152,
	prodml2__FacilityParameter__permeability_x0020length_x0020class = 153,
	prodml2__FacilityParameter__permeability_x0020rock_x0020class = 154,
	prodml2__FacilityParameter__permeance_x0020class = 155,
	prodml2__FacilityParameter__permittivity_x0020class = 156,
	prodml2__FacilityParameter__pH_x0020class = 157,
	prodml2__FacilityParameter__plane_x0020angle_x0020class = 158,
	prodml2__FacilityParameter__potential_x0020difference_x0020per_x0020power_x0020drop = 159,
	prodml2__FacilityParameter__power_x0020class = 160,
	prodml2__FacilityParameter__power_x0020per_x0020volume = 161,
	prodml2__FacilityParameter__pressure = 162,
	prodml2__FacilityParameter__pressure_x0020class = 163,
	prodml2__FacilityParameter__pressure_x0020per_x0020time = 164,
	prodml2__FacilityParameter__pressure_x0020squared_x0020class = 165,
	prodml2__FacilityParameter__pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 166,
	prodml2__FacilityParameter__pressure_x0020time_x0020per_x0020volume = 167,
	prodml2__FacilityParameter__productivity_x0020index_x0020class = 168,
	prodml2__FacilityParameter__pump_x0020count_x0020online = 169,
	prodml2__FacilityParameter__pump_x0020status = 170,
	prodml2__FacilityParameter__quantity = 171,
	prodml2__FacilityParameter__quantity_x0020of_x0020light_x0020class = 172,
	prodml2__FacilityParameter__radiance_x0020class = 173,
	prodml2__FacilityParameter__radiant_x0020intensity_x0020class = 174,
	prodml2__FacilityParameter__reciprocating_x0020speed = 175,
	prodml2__FacilityParameter__rectifier_x0020structure_x0020potential = 176,
	prodml2__FacilityParameter__reid_x0020vapor_x0020pressure = 177,
	prodml2__FacilityParameter__relative_x0020opening_x0020size = 178,
	prodml2__FacilityParameter__relative_x0020power_x0020class = 179,
	prodml2__FacilityParameter__relative_x0020tank_x0020level = 180,
	prodml2__FacilityParameter__relative_x0020time_x0020class = 181,
	prodml2__FacilityParameter__relative_x0020valve_x0020opening = 182,
	prodml2__FacilityParameter__reluctance_x0020class = 183,
	prodml2__FacilityParameter__resistance_x0020class = 184,
	prodml2__FacilityParameter__resistivity_x0020per_x0020length = 185,
	prodml2__FacilityParameter__root_x0020property = 186,
	prodml2__FacilityParameter__scheduled_x0020downtime = 187,
	prodml2__FacilityParameter__second_x0020moment_x0020of_x0020area_x0020class = 188,
	prodml2__FacilityParameter__shutdown_x0020order = 189,
	prodml2__FacilityParameter__shutin_x0020pressure = 190,
	prodml2__FacilityParameter__shutin_x0020temperature = 191,
	prodml2__FacilityParameter__solid_x0020angle_x0020class = 192,
	prodml2__FacilityParameter__specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029 = 193,
	prodml2__FacilityParameter__specific_x0020energy_x0020class = 194,
	prodml2__FacilityParameter__specific_x0020gravity = 195,
	prodml2__FacilityParameter__specific_x0020heat_x0020capacity_x0020class = 196,
	prodml2__FacilityParameter__specific_x0020productivity_x0020index_x0020class = 197,
	prodml2__FacilityParameter__specific_x0020volume_x0020class = 198,
	prodml2__FacilityParameter__sub_x0020surface_x0020safety_x0020valve_x0020status = 199,
	prodml2__FacilityParameter__surface_x0020density_x0020class = 200,
	prodml2__FacilityParameter__surface_x0020safety_x0020valve_x0020status = 201,
	prodml2__FacilityParameter__tank_x0020fluid_x0020level = 202,
	prodml2__FacilityParameter__tank_x0020product_x0020standard_x0020volume = 203,
	prodml2__FacilityParameter__tank_x0020product_x0020volume = 204,
	prodml2__FacilityParameter__temperature = 205,
	prodml2__FacilityParameter__temperature_x0020per_x0020length = 206,
	prodml2__FacilityParameter__temperature_x0020per_x0020time = 207,
	prodml2__FacilityParameter__thermal_x0020conductance_x0020class = 208,
	prodml2__FacilityParameter__thermal_x0020conductivity_x0020class = 209,
	prodml2__FacilityParameter__thermal_x0020diffusivity_x0020class = 210,
	prodml2__FacilityParameter__thermal_x0020insulance_x0020class = 211,
	prodml2__FacilityParameter__thermal_x0020resistance_x0020class = 212,
	prodml2__FacilityParameter__thermodynamic_x0020temperature_x0020class = 213,
	prodml2__FacilityParameter__time_x0020class = 214,
	prodml2__FacilityParameter__time_x0020per_x0020length = 215,
	prodml2__FacilityParameter__time_x0020per_x0020volume = 216,
	prodml2__FacilityParameter__true_x0020vapor_x0020pressure = 217,
	prodml2__FacilityParameter__unit_x0020productivity_x0020index_x0020class = 218,
	prodml2__FacilityParameter__unitless = 219,
	prodml2__FacilityParameter__unknown = 220,
	prodml2__FacilityParameter__valve_x0020opening = 221,
	prodml2__FacilityParameter__valve_x0020status = 222,
	prodml2__FacilityParameter__velocity_x0020class = 223,
	prodml2__FacilityParameter__volume = 224,
	prodml2__FacilityParameter__volume_x0020class = 225,
	prodml2__FacilityParameter__volume_x0020concentration = 226,
	prodml2__FacilityParameter__volume_x0020flow_x0020rate_x0020class = 227,
	prodml2__FacilityParameter__volume_x0020length_x0020per_x0020time = 228,
	prodml2__FacilityParameter__volume_x0020per_x0020area = 229,
	prodml2__FacilityParameter__volume_x0020per_x0020length = 230,
	prodml2__FacilityParameter__volume_x0020per_x0020time_x0020per_x0020area = 231,
	prodml2__FacilityParameter__volume_x0020per_x0020time_x0020per_x0020length = 232,
	prodml2__FacilityParameter__volume_x0020per_x0020time_x0020per_x0020time = 233,
	prodml2__FacilityParameter__volume_x0020per_x0020time_x0020per_x0020volume = 234,
	prodml2__FacilityParameter__volume_x0020per_x0020volume = 235,
	prodml2__FacilityParameter__volume_x0020standard = 236,
	prodml2__FacilityParameter__volumetric_x0020efficiency = 237,
	prodml2__FacilityParameter__volumetric_x0020heat_x0020transfer_x0020coefficient = 238,
	prodml2__FacilityParameter__volumetric_x0020thermal_x0020expansion_x0020class = 239,
	prodml2__FacilityParameter__well_x0020operating_x0020status = 240,
	prodml2__FacilityParameter__well_x0020operation_x0020type = 241,
	prodml2__FacilityParameter__wobbe_x0020index = 242,
	prodml2__FacilityParameter__work = 243,
	prodml2__FacilityParameter__work_x0020class = 244
};
#endif

/* eml2_1ForGsoap.h:13315 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberMode
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberMode (1122)
/* prodml2:FiberMode */
enum prodml2__FiberMode {
	prodml2__FiberMode__multimode = 0,
	prodml2__FiberMode__other = 1,
	prodml2__FiberMode__singlemode = 2
};
#endif

/* eml2_1ForGsoap.h:13328 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FlowQualifier (1123)
/* prodml2:FlowQualifier */
enum prodml2__FlowQualifier {
	prodml2__FlowQualifier__allocated = 0,
	prodml2__FlowQualifier__budget = 1,
	prodml2__FlowQualifier__constraint = 2,
	prodml2__FlowQualifier__derived = 3,
	prodml2__FlowQualifier__difference = 4,
	prodml2__FlowQualifier__estimate = 5,
	prodml2__FlowQualifier__forecast = 6,
	prodml2__FlowQualifier__mass_x0020adjusted = 7,
	prodml2__FlowQualifier__measured = 8,
	prodml2__FlowQualifier__metered = 9,
	prodml2__FlowQualifier__metered_x0020__x0020fiscal = 10,
	prodml2__FlowQualifier__nominated = 11,
	prodml2__FlowQualifier__potential = 12,
	prodml2__FlowQualifier__processed = 13,
	prodml2__FlowQualifier__quota = 14,
	prodml2__FlowQualifier__recommended = 15,
	prodml2__FlowQualifier__simulated = 16,
	prodml2__FlowQualifier__target = 17,
	prodml2__FlowQualifier__tariff_x0020basis = 18,
	prodml2__FlowQualifier__value_x0020adjusted = 19
};
#endif

/* eml2_1ForGsoap.h:13358 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FlowSubQualifier (1124)
/* prodml2:FlowSubQualifier */
enum prodml2__FlowSubQualifier {
	prodml2__FlowSubQualifier__decline_x0020curve = 0,
	prodml2__FlowSubQualifier__difference = 1,
	prodml2__FlowSubQualifier__fiscal = 2,
	prodml2__FlowSubQualifier__fixed = 3,
	prodml2__FlowSubQualifier__maximum = 4,
	prodml2__FlowSubQualifier__minimum = 5,
	prodml2__FlowSubQualifier__raw = 6,
	prodml2__FlowSubQualifier__recalibrated = 7,
	prodml2__FlowSubQualifier__standard = 8
};
#endif

/* eml2_1ForGsoap.h:13377 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyType (1125)
/* prodml2:GeologyType */
enum prodml2__GeologyType {
	prodml2__GeologyType__aquifer = 0,
	prodml2__GeologyType__reservoir = 1
};
#endif

/* eml2_1ForGsoap.h:13395 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneType (1126)
/* prodml2:PhoneType */
enum prodml2__PhoneType {
	prodml2__PhoneType__fax = 0,
	prodml2__PhoneType__mobile = 1,
	prodml2__PhoneType__pager = 2,
	prodml2__PhoneType__unknown = 3,
	prodml2__PhoneType__voice = 4,
	prodml2__PhoneType__voice_x002ffax = 5,
	prodml2__PhoneType__voicemail = 6
};
#endif

/* eml2_1ForGsoap.h:13412 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnum (1127)
/* prodml2:PlusComponentEnum */
enum prodml2__PlusComponentEnum {
	prodml2__PlusComponentEnum__c10_x002b = 0,
	prodml2__PlusComponentEnum__c11_x002b = 1,
	prodml2__PlusComponentEnum__c12_x002b = 2,
	prodml2__PlusComponentEnum__c20_x002b = 3,
	prodml2__PlusComponentEnum__c25_x002b = 4,
	prodml2__PlusComponentEnum__c30_x002b = 5,
	prodml2__PlusComponentEnum__c36_x002b = 6,
	prodml2__PlusComponentEnum__c5_x002b = 7,
	prodml2__PlusComponentEnum__c6_x002b = 8,
	prodml2__PlusComponentEnum__c7_x002b = 9,
	prodml2__PlusComponentEnum__c8_x002b = 10,
	prodml2__PlusComponentEnum__c9_x002b = 11
};
#endif

/* eml2_1ForGsoap.h:13434 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPortType (1128)
/* prodml2:ProductFlowPortType */
enum prodml2__ProductFlowPortType {
	prodml2__ProductFlowPortType__inlet = 0,
	prodml2__ProductFlowPortType__outlet = 1,
	prodml2__ProductFlowPortType__unknown = 2
};
#endif

/* eml2_1ForGsoap.h:13447 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFluidKind (1129)
/* prodml2:ProductFluidKind */
enum prodml2__ProductFluidKind {
	prodml2__ProductFluidKind__condensate = 0,
	prodml2__ProductFluidKind__condensate_x0020__x0020gross = 1,
	prodml2__ProductFluidKind__condensate_x0020__x0020net = 2,
	prodml2__ProductFluidKind__crude_x0020__x0020stabilized = 3,
	prodml2__ProductFluidKind__gas_x0020__x0020component_x0020in_x0020oil = 4,
	prodml2__ProductFluidKind__gas_x0020__x0020dry = 5,
	prodml2__ProductFluidKind__gas_x0020__x0020rich = 6,
	prodml2__ProductFluidKind__gas_x0020__x0020wet = 7,
	prodml2__ProductFluidKind__liquefied_x0020natural_x0020gas = 8,
	prodml2__ProductFluidKind__liquefied_x0020petroleum_x0020gas = 9,
	prodml2__ProductFluidKind__liquid = 10,
	prodml2__ProductFluidKind__naphtha = 11,
	prodml2__ProductFluidKind__natural_x0020gas_x0020liquid = 12,
	prodml2__ProductFluidKind__NGL_x0020__x0020component_x0020in_x0020gas = 13,
	prodml2__ProductFluidKind__oil_x0020__x0020component_x0020in_x0020water = 14,
	prodml2__ProductFluidKind__oil_x0020__x0020gross = 15,
	prodml2__ProductFluidKind__oil_x0020__x0020net = 16,
	prodml2__ProductFluidKind__oil_x0020and_x0020gas = 17,
	prodml2__ProductFluidKind__petroleum_x0020gas_x0020liquid = 18,
	prodml2__ProductFluidKind__vapor = 19,
	prodml2__ProductFluidKind__sand = 20,
	prodml2__ProductFluidKind__water_x0020__x0020discharge = 21,
	prodml2__ProductFluidKind__water_x0020__x0020processed = 22
};
#endif

/* eml2_1ForGsoap.h:13480 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnum (1130)
/* prodml2:PseudoComponentEnum */
enum prodml2__PseudoComponentEnum {
	prodml2__PseudoComponentEnum__c10 = 0,
	prodml2__PseudoComponentEnum__c11 = 1,
	prodml2__PseudoComponentEnum__c12 = 2,
	prodml2__PseudoComponentEnum__c13 = 3,
	prodml2__PseudoComponentEnum__c14 = 4,
	prodml2__PseudoComponentEnum__c15 = 5,
	prodml2__PseudoComponentEnum__c16 = 6,
	prodml2__PseudoComponentEnum__c17 = 7,
	prodml2__PseudoComponentEnum__c18 = 8,
	prodml2__PseudoComponentEnum__c19 = 9,
	prodml2__PseudoComponentEnum__c20 = 10,
	prodml2__PseudoComponentEnum__c21 = 11,
	prodml2__PseudoComponentEnum__c22 = 12,
	prodml2__PseudoComponentEnum__c23 = 13,
	prodml2__PseudoComponentEnum__c24 = 14,
	prodml2__PseudoComponentEnum__c25 = 15,
	prodml2__PseudoComponentEnum__c26 = 16,
	prodml2__PseudoComponentEnum__c27 = 17,
	prodml2__PseudoComponentEnum__c28 = 18,
	prodml2__PseudoComponentEnum__c29 = 19,
	prodml2__PseudoComponentEnum__c2_c4_x002bn2 = 20,
	prodml2__PseudoComponentEnum__c30 = 21,
	prodml2__PseudoComponentEnum__c31 = 22,
	prodml2__PseudoComponentEnum__c32 = 23,
	prodml2__PseudoComponentEnum__c33 = 24,
	prodml2__PseudoComponentEnum__c34 = 25,
	prodml2__PseudoComponentEnum__c35 = 26,
	prodml2__PseudoComponentEnum__c4 = 27,
	prodml2__PseudoComponentEnum__c5 = 28,
	prodml2__PseudoComponentEnum__c6 = 29,
	prodml2__PseudoComponentEnum__c7 = 30,
	prodml2__PseudoComponentEnum__c8 = 31,
	prodml2__PseudoComponentEnum__c9 = 32
};
#endif

/* eml2_1ForGsoap.h:13526 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnum (1131)
/* prodml2:PureComponentEnum */
enum prodml2__PureComponentEnum {
	prodml2__PureComponentEnum__1_2_4_trimethylbenzene = 0,
	prodml2__PureComponentEnum__2_dimethylbutane = 1,
	prodml2__PureComponentEnum__3_dimethylbutane = 2,
	prodml2__PureComponentEnum__ar = 3,
	prodml2__PureComponentEnum__c1 = 4,
	prodml2__PureComponentEnum__c2 = 5,
	prodml2__PureComponentEnum__c3 = 6,
	prodml2__PureComponentEnum__co2 = 7,
	prodml2__PureComponentEnum__h2 = 8,
	prodml2__PureComponentEnum__h2o = 9,
	prodml2__PureComponentEnum__h2s = 10,
	prodml2__PureComponentEnum__he = 11,
	prodml2__PureComponentEnum__hg = 12,
	prodml2__PureComponentEnum__i_c4 = 13,
	prodml2__PureComponentEnum__i_c5 = 14,
	prodml2__PureComponentEnum__n2 = 15,
	prodml2__PureComponentEnum__n_c10 = 16,
	prodml2__PureComponentEnum__n_c4 = 17,
	prodml2__PureComponentEnum__n_c5 = 18,
	prodml2__PureComponentEnum__n_c6 = 19,
	prodml2__PureComponentEnum__n_c7 = 20,
	prodml2__PureComponentEnum__n_c8 = 21,
	prodml2__PureComponentEnum__n_c9 = 22,
	prodml2__PureComponentEnum__neo_c5 = 23,
	prodml2__PureComponentEnum__benzene = 24,
	prodml2__PureComponentEnum__2_methylpentane = 25,
	prodml2__PureComponentEnum__3_methylpentane = 26,
	prodml2__PureComponentEnum__2_methylhexane = 27,
	prodml2__PureComponentEnum__3_methylhexane = 28,
	prodml2__PureComponentEnum__2_methylheptane = 29,
	prodml2__PureComponentEnum__3_methylheptane = 30,
	prodml2__PureComponentEnum__cyclohexane = 31,
	prodml2__PureComponentEnum__ethylbenzene = 32,
	prodml2__PureComponentEnum__ethylcyclohexane = 33,
	prodml2__PureComponentEnum__methylcyclohexane = 34,
	prodml2__PureComponentEnum__methylcyclopentane = 35,
	prodml2__PureComponentEnum__toluene = 36,
	prodml2__PureComponentEnum__m_xylene = 37,
	prodml2__PureComponentEnum__o_xylene = 38,
	prodml2__PureComponentEnum__p_xylene = 39
};
#endif

/* eml2_1ForGsoap.h:13579 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKind (1132)
/* prodml2:ReportingDurationKind */
enum prodml2__ReportingDurationKind {
	prodml2__ReportingDurationKind__day = 0,
	prodml2__ReportingDurationKind__life_x0020to_x0020date = 1,
	prodml2__ReportingDurationKind__month = 2,
	prodml2__ReportingDurationKind__month_x0020to_x0020date = 3,
	prodml2__ReportingDurationKind__total_x0020cumulative = 4,
	prodml2__ReportingDurationKind__week = 5,
	prodml2__ReportingDurationKind__year = 6,
	prodml2__ReportingDurationKind__year_x0020to_x0020date = 7
};
#endif

/* eml2_1ForGsoap.h:13597 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingEntityKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingEntityKind (1133)
/* prodml2:ReportingEntityKind */
enum prodml2__ReportingEntityKind {
	prodml2__ReportingEntityKind__business_x0020unit = 0,
	prodml2__ReportingEntityKind__fpso = 1,
	prodml2__ReportingEntityKind__well_x0020completion = 2,
	prodml2__ReportingEntityKind__wellbore_x0020completion = 3,
	prodml2__ReportingEntityKind__commercial_x0020entity = 4,
	prodml2__ReportingEntityKind__company = 5,
	prodml2__ReportingEntityKind__contact_x0020interval = 6,
	prodml2__ReportingEntityKind__country = 7,
	prodml2__ReportingEntityKind__county = 8,
	prodml2__ReportingEntityKind__facility = 9,
	prodml2__ReportingEntityKind__field = 10,
	prodml2__ReportingEntityKind__field_x0020__x0020part = 11,
	prodml2__ReportingEntityKind__flow_x0020meter = 12,
	prodml2__ReportingEntityKind__formation = 13,
	prodml2__ReportingEntityKind__gas_x0020plant = 14,
	prodml2__ReportingEntityKind__lease = 15,
	prodml2__ReportingEntityKind__license = 16,
	prodml2__ReportingEntityKind__pipeline = 17,
	prodml2__ReportingEntityKind__platform = 18,
	prodml2__ReportingEntityKind__production_x0020processing_x0020facility = 19,
	prodml2__ReportingEntityKind__reservoir = 20,
	prodml2__ReportingEntityKind__rock_fluid_x0020unit_x0020feature = 21,
	prodml2__ReportingEntityKind__state = 22,
	prodml2__ReportingEntityKind__tank = 23,
	prodml2__ReportingEntityKind__terminal = 24,
	prodml2__ReportingEntityKind__well = 25,
	prodml2__ReportingEntityKind__well_x0020group = 26,
	prodml2__ReportingEntityKind__wellbore = 27,
	prodml2__ReportingEntityKind__oil_x0020tanker = 28,
	prodml2__ReportingEntityKind__tanker_x0020truck = 29
};
#endif

/* eml2_1ForGsoap.h:13727 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFacility (1134)
/* prodml2:ReportingFacility */
enum prodml2__ReportingFacility {
	prodml2__ReportingFacility__block_x0020valve = 0,
	prodml2__ReportingFacility__bottomhole = 1,
	prodml2__ReportingFacility__casing = 2,
	prodml2__ReportingFacility__choke = 3,
	prodml2__ReportingFacility__cluster = 4,
	prodml2__ReportingFacility__commercial_x0020entity = 5,
	prodml2__ReportingFacility__company = 6,
	prodml2__ReportingFacility__completion = 7,
	prodml2__ReportingFacility__compressor = 8,
	prodml2__ReportingFacility__controller = 9,
	prodml2__ReportingFacility__controller_x0020_x002d__x0020lift = 10,
	prodml2__ReportingFacility__country = 11,
	prodml2__ReportingFacility__county = 12,
	prodml2__ReportingFacility__downhole_x0020monitoring_x0020system = 13,
	prodml2__ReportingFacility__electric_x0020submersible_x0020pump = 14,
	prodml2__ReportingFacility__field = 15,
	prodml2__ReportingFacility__field_x0020__x0020area = 16,
	prodml2__ReportingFacility__field_x0020__x0020group = 17,
	prodml2__ReportingFacility__field_x0020__x0020part = 18,
	prodml2__ReportingFacility__flow_x0020meter = 19,
	prodml2__ReportingFacility__flowline = 20,
	prodml2__ReportingFacility__formation = 21,
	prodml2__ReportingFacility__gas_x0020lift_x0020valve_x0020mandrel = 22,
	prodml2__ReportingFacility__generator = 23,
	prodml2__ReportingFacility__installation = 24,
	prodml2__ReportingFacility__lease = 25,
	prodml2__ReportingFacility__license = 26,
	prodml2__ReportingFacility__manifold = 27,
	prodml2__ReportingFacility__organizational_x0020unit = 28,
	prodml2__ReportingFacility__packer = 29,
	prodml2__ReportingFacility__perforated_x0020interval = 30,
	prodml2__ReportingFacility__pipeline = 31,
	prodml2__ReportingFacility__plant_x0020__x0020processing = 32,
	prodml2__ReportingFacility__platform = 33,
	prodml2__ReportingFacility__pressure_x0020meter = 34,
	prodml2__ReportingFacility__processing_x0020facility = 35,
	prodml2__ReportingFacility__production_x0020tubing = 36,
	prodml2__ReportingFacility__pump = 37,
	prodml2__ReportingFacility__rectifier = 38,
	prodml2__ReportingFacility__regulating_x0020valve = 39,
	prodml2__ReportingFacility__remote_x0020terminal_x0020unit = 40,
	prodml2__ReportingFacility__reservoir = 41,
	prodml2__ReportingFacility__separator = 42,
	prodml2__ReportingFacility__sleeve_x0020valve = 43,
	prodml2__ReportingFacility__state = 44,
	prodml2__ReportingFacility__storage = 45,
	prodml2__ReportingFacility__tank = 46,
	prodml2__ReportingFacility__temperature_x0020meter = 47,
	prodml2__ReportingFacility__template_ = 48,
	prodml2__ReportingFacility__terminal = 49,
	prodml2__ReportingFacility__trap = 50,
	prodml2__ReportingFacility__trunkline = 51,
	prodml2__ReportingFacility__tubing_x0020head = 52,
	prodml2__ReportingFacility__turbine = 53,
	prodml2__ReportingFacility__unknown = 54,
	prodml2__ReportingFacility__well = 55,
	prodml2__ReportingFacility__well_x0020group = 56,
	prodml2__ReportingFacility__wellbore = 57,
	prodml2__ReportingFacility__wellhead = 58,
	prodml2__ReportingFacility__zone = 59
};
#endif

/* eml2_1ForGsoap.h:13977 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFlow (1135)
/* prodml2:ReportingFlow */
enum prodml2__ReportingFlow {
	prodml2__ReportingFlow__consume = 0,
	prodml2__ReportingFlow__consume_x0020__x0020black_x0020start = 1,
	prodml2__ReportingFlow__consume_x0020__x0020compressor = 2,
	prodml2__ReportingFlow__consume_x0020__x0020emitted = 3,
	prodml2__ReportingFlow__consume_x0020__x0020flare = 4,
	prodml2__ReportingFlow__consume_x0020__x0020fuel = 5,
	prodml2__ReportingFlow__consume_x0020__x0020HP_x0020flare = 6,
	prodml2__ReportingFlow__consume_x0020__x0020LP_x0020flare = 7,
	prodml2__ReportingFlow__consume_x0020__x0020non_x0020compressor = 8,
	prodml2__ReportingFlow__consume_x0020__x0020venting = 9,
	prodml2__ReportingFlow__disposal = 10,
	prodml2__ReportingFlow__export_ = 11,
	prodml2__ReportingFlow__export_x0020__x0020nominated = 12,
	prodml2__ReportingFlow__export_x0020__x0020requested = 13,
	prodml2__ReportingFlow__export_x0020__x0020shortfall = 14,
	prodml2__ReportingFlow__gas_x0020lift = 15,
	prodml2__ReportingFlow__hydrocarbon_x0020accounting = 16,
	prodml2__ReportingFlow__import = 17,
	prodml2__ReportingFlow__injection = 18,
	prodml2__ReportingFlow__inventory = 19,
	prodml2__ReportingFlow__overboard = 20,
	prodml2__ReportingFlow__production = 21,
	prodml2__ReportingFlow__sale = 22,
	prodml2__ReportingFlow__storage = 23,
	prodml2__ReportingFlow__unknown = 24
};
#endif

/* eml2_1ForGsoap.h:14087 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingProduct (1136)
/* prodml2:ReportingProduct */
enum prodml2__ReportingProduct {
	prodml2__ReportingProduct__aqueous = 0,
	prodml2__ReportingProduct__c10 = 1,
	prodml2__ReportingProduct__c10_x002d = 2,
	prodml2__ReportingProduct__c10_x002b = 3,
	prodml2__ReportingProduct__c2_x002d = 4,
	prodml2__ReportingProduct__c2_x002b = 5,
	prodml2__ReportingProduct__c3_x002d = 6,
	prodml2__ReportingProduct__c3_x002b = 7,
	prodml2__ReportingProduct__c4_x002d = 8,
	prodml2__ReportingProduct__c4_x002b = 9,
	prodml2__ReportingProduct__c5_x002d = 10,
	prodml2__ReportingProduct__c5_x002b = 11,
	prodml2__ReportingProduct__c6_x002d = 12,
	prodml2__ReportingProduct__c6_x002b = 13,
	prodml2__ReportingProduct__c7 = 14,
	prodml2__ReportingProduct__c7_x002d = 15,
	prodml2__ReportingProduct__c7_x002b = 16,
	prodml2__ReportingProduct__c8 = 17,
	prodml2__ReportingProduct__c8_x002d = 18,
	prodml2__ReportingProduct__c8_x002b = 19,
	prodml2__ReportingProduct__c9 = 20,
	prodml2__ReportingProduct__c9_x002d = 21,
	prodml2__ReportingProduct__c9_x002b = 22,
	prodml2__ReportingProduct__carbon_x0020dioxide_x0020gas = 23,
	prodml2__ReportingProduct__carbon_x0020monoxide_x0020gas = 24,
	prodml2__ReportingProduct__chemical = 25,
	prodml2__ReportingProduct__condensate = 26,
	prodml2__ReportingProduct__condensate_x0020__x0020gross = 27,
	prodml2__ReportingProduct__condensate_x0020__x0020net = 28,
	prodml2__ReportingProduct__crude_x0020__x0020stabilized = 29,
	prodml2__ReportingProduct__cuttings = 30,
	prodml2__ReportingProduct__diesel = 31,
	prodml2__ReportingProduct__diethylene_x0020glycol = 32,
	prodml2__ReportingProduct__dioxygen = 33,
	prodml2__ReportingProduct__electric_x0020power = 34,
	prodml2__ReportingProduct__ethane = 35,
	prodml2__ReportingProduct__ethane_x0020__x0020component = 36,
	prodml2__ReportingProduct__gas = 37,
	prodml2__ReportingProduct__gas_x0020__x0020component_x0020in_x0020oil = 38,
	prodml2__ReportingProduct__gas_x0020__x0020dry = 39,
	prodml2__ReportingProduct__gas_x0020__x0020rich = 40,
	prodml2__ReportingProduct__gas_x0020__x0020wet = 41,
	prodml2__ReportingProduct__helium_x0020gas = 42,
	prodml2__ReportingProduct__heptane = 43,
	prodml2__ReportingProduct__hydraulic_x0020control_x0020fluid = 44,
	prodml2__ReportingProduct__hydrogen_x0020gas = 45,
	prodml2__ReportingProduct__hydrogen_x0020sulfide = 46,
	prodml2__ReportingProduct__i_butane_x0020__x0020component = 47,
	prodml2__ReportingProduct__isobutane = 48,
	prodml2__ReportingProduct__isopentane = 49,
	prodml2__ReportingProduct__liquefied_x0020natural_x0020gas = 50,
	prodml2__ReportingProduct__liquefied_x0020petroleum_x0020gas = 51,
	prodml2__ReportingProduct__liquid = 52,
	prodml2__ReportingProduct__methane = 53,
	prodml2__ReportingProduct__methane_x0020__x0020component = 54,
	prodml2__ReportingProduct__methanol = 55,
	prodml2__ReportingProduct__mixed_x0020butane = 56,
	prodml2__ReportingProduct__monoethylene_x0020glycol = 57,
	prodml2__ReportingProduct__naphtha = 58,
	prodml2__ReportingProduct__natural_x0020gas_x0020liquid = 59,
	prodml2__ReportingProduct__n_butane_x0020__x0020component = 60,
	prodml2__ReportingProduct__neopentane = 61,
	prodml2__ReportingProduct__NGL_x0020__x0020component_x0020in_x0020gas = 62,
	prodml2__ReportingProduct__nitrogen_x0020gas = 63,
	prodml2__ReportingProduct__nitrogen_x0020oxide_x0020gas = 64,
	prodml2__ReportingProduct__normal_x0020butane = 'A',
	prodml2__ReportingProduct__normal_x0020pentane = 'B',
	prodml2__ReportingProduct__oil = 'C',
	prodml2__ReportingProduct__oil_x0020__x0020component_x0020in_x0020water = 'D',
	prodml2__ReportingProduct__oil_x0020__x0020gross = 'E',
	prodml2__ReportingProduct__oil_x0020__x0020net = 'F',
	prodml2__ReportingProduct__oil_x0020and_x0020gas = 'G',
	prodml2__ReportingProduct__oleic = 'H',
	prodml2__ReportingProduct__pentane_x0020__x0020component = 'I',
	prodml2__ReportingProduct__petroleum_x0020gas_x0020liquid = 'J',
	prodml2__ReportingProduct__propane = 'K',
	prodml2__ReportingProduct__propane_x0020__x0020component = 'L',
	prodml2__ReportingProduct__salt = 'M',
	prodml2__ReportingProduct__sand_x0020__x0020component = 'N',
	prodml2__ReportingProduct__triethylene_x0020glycol = 'O',
	prodml2__ReportingProduct__unknown = 'P',
	prodml2__ReportingProduct__vapor = 'Q',
	prodml2__ReportingProduct__water = 'R',
	prodml2__ReportingProduct__water_x0020__x0020discharge = 'S',
	prodml2__ReportingProduct__water_x0020__x0020processed = 'T'
};
#endif

/* eml2_1ForGsoap.h:14437 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReservoirFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReservoirFluidKind (1137)
/* prodml2:ReservoirFluidKind */
enum prodml2__ReservoirFluidKind {
	prodml2__ReservoirFluidKind__black_x0020oil = 0,
	prodml2__ReservoirFluidKind__critical_x0020or_x0020near_x0020critical = 1,
	prodml2__ReservoirFluidKind__dry_x0020gas = 2,
	prodml2__ReservoirFluidKind__heavy_x0020oil = 3,
	prodml2__ReservoirFluidKind__wet_x0020gas_x0020or_x0020condensate = 4,
	prodml2__ReservoirFluidKind__volatile_x0020oil = 5,
	prodml2__ReservoirFluidKind__unknown = 6
};
#endif

/* eml2_1ForGsoap.h:14475 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__SafetyType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__SafetyType (1138)
/* prodml2:SafetyType */
enum prodml2__SafetyType {
	prodml2__SafetyType__drill_x0020or_x0020exercise = 0,
	prodml2__SafetyType__fire = 1,
	prodml2__SafetyType__first_x0020aid = 2,
	prodml2__SafetyType__hazard_x0020report_x0020card = 3,
	prodml2__SafetyType__job_x0020observation = 4,
	prodml2__SafetyType__lost_x0020time_x0020accident = 5,
	prodml2__SafetyType__lost_x0020time_x0020incident = 6,
	prodml2__SafetyType__miscellaneous = 7,
	prodml2__SafetyType__near_x0020miss = 8,
	prodml2__SafetyType__permit_x0020with_x0020SJA = 9,
	prodml2__SafetyType__released_x0020to_x0020air = 10,
	prodml2__SafetyType__released_x0020to_x0020water = 11,
	prodml2__SafetyType__restricted_x0020work = 12,
	prodml2__SafetyType__safety_x0020meeting = 13,
	prodml2__SafetyType__sent_x0020ashore = 14,
	prodml2__SafetyType__severe_x0020accident = 15,
	prodml2__SafetyType__sick_x0020on_x0020board = 16,
	prodml2__SafetyType__spill_x0020or_x0020leak = 17,
	prodml2__SafetyType__total_x0020permits = 18,
	prodml2__SafetyType__traffic_x0020accident = 19,
	prodml2__SafetyType__year_to_date_x0020incidents = 20
};
#endif

/* eml2_1ForGsoap.h:14569 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__SaturationPointKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__SaturationPointKind (1139)
/* prodml2:SaturationPointKind */
enum prodml2__SaturationPointKind {
	prodml2__SaturationPointKind__bubble_x0020point = 0,
	prodml2__SaturationPointKind__dew_x0020point = 1,
	prodml2__SaturationPointKind__retrograde_x0020dew_x0020point = 2,
	prodml2__SaturationPointKind__critical_x0020point = 3
};
#endif

/* eml2_1ForGsoap.h:14595 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ServiceFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ServiceFluidKind (1140)
/* prodml2:ServiceFluidKind */
enum prodml2__ServiceFluidKind {
	prodml2__ServiceFluidKind__alkaline_x0020solutions = 0,
	prodml2__ServiceFluidKind__biocide = 1,
	prodml2__ServiceFluidKind__carbon_x0020dioxide = 2,
	prodml2__ServiceFluidKind__carbon_x0020monoxide = 3,
	prodml2__ServiceFluidKind__corrosion_x0020inhibitor = 4,
	prodml2__ServiceFluidKind__demulsifier = 5,
	prodml2__ServiceFluidKind__diesel = 6,
	prodml2__ServiceFluidKind__diethylene_x0020glycol = 7,
	prodml2__ServiceFluidKind__dispersant = 8,
	prodml2__ServiceFluidKind__drag_x0020reducing_x0020agent = 9,
	prodml2__ServiceFluidKind__emulsifier = 10,
	prodml2__ServiceFluidKind__flocculant = 11,
	prodml2__ServiceFluidKind__hydraulic_x0020control_x0020fluid = 12,
	prodml2__ServiceFluidKind__isopropanol = 13,
	prodml2__ServiceFluidKind__lubricant = 14,
	prodml2__ServiceFluidKind__methanol = 15,
	prodml2__ServiceFluidKind__monoethylene_x0020glycol = 16,
	prodml2__ServiceFluidKind__oil = 17,
	prodml2__ServiceFluidKind__other_x0020chemical = 18,
	prodml2__ServiceFluidKind__other_x0020hydrate_x0020inhibitor = 19,
	prodml2__ServiceFluidKind__polymer = 20,
	prodml2__ServiceFluidKind__scale_x0020inhibitor = 21,
	prodml2__ServiceFluidKind__solvent = 22,
	prodml2__ServiceFluidKind__stabilizing_x0020agent = 23,
	prodml2__ServiceFluidKind__surfactant = 24,
	prodml2__ServiceFluidKind__thinner = 25,
	prodml2__ServiceFluidKind__triethylene_x0020glycol = 26
};
#endif

/* eml2_1ForGsoap.h:14713 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__TimeSeriesKeyword
#define SOAP_TYPE_gsoap_eml2_1_prodml2__TimeSeriesKeyword (1141)
/* prodml2:TimeSeriesKeyword */
enum prodml2__TimeSeriesKeyword {
	prodml2__TimeSeriesKeyword__asset_x0020identifier = 0,
	prodml2__TimeSeriesKeyword__flow = 1,
	prodml2__TimeSeriesKeyword__product = 2,
	prodml2__TimeSeriesKeyword__qualifier = 3,
	prodml2__TimeSeriesKeyword__subqualifier = 4,
	prodml2__TimeSeriesKeyword__unknown = 5
};
#endif

/* eml2_1ForGsoap.h:14747 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ValueStatus
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ValueStatus (1142)
/* prodml2:ValueStatus */
enum prodml2__ValueStatus {
	prodml2__ValueStatus__access_x0020denied = 0,
	prodml2__ValueStatus__bad = 1,
	prodml2__ValueStatus__bad_x0020calibration = 2,
	prodml2__ValueStatus__calculation_x0020failure = 3,
	prodml2__ValueStatus__comm_x0020failure = 4,
	prodml2__ValueStatus__device_x0020failure = 5,
	prodml2__ValueStatus__frozen = 6,
	prodml2__ValueStatus__not_x0020available = 7,
	prodml2__ValueStatus__overflow = 8,
	prodml2__ValueStatus__questionable = 9,
	prodml2__ValueStatus__range_x0020limit = 10,
	prodml2__ValueStatus__sensor_x0020failure = 11,
	prodml2__ValueStatus__substituted = 12,
	prodml2__ValueStatus__timeout = 13
};
#endif

/* eml2_1ForGsoap.h:14813 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellDirection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellDirection (1143)
/* prodml2:WellDirection */
enum prodml2__WellDirection {
	prodml2__WellDirection__huff_n_puff = 0,
	prodml2__WellDirection__injector = 1,
	prodml2__WellDirection__producer = 2,
	prodml2__WellDirection__uncertain = 3
};
#endif

/* eml2_1ForGsoap.h:14839 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellFluid
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellFluid (1144)
/* prodml2:WellFluid */
enum prodml2__WellFluid {
	prodml2__WellFluid__air = 0,
	prodml2__WellFluid__condensate = 1,
	prodml2__WellFluid__dry = 2,
	prodml2__WellFluid__gas = 3,
	prodml2__WellFluid__gas_water = 4,
	prodml2__WellFluid__non_x0020HC_x0020gas = 5,
	prodml2__WellFluid__non_x0020HC_x0020gas_x0020_x002d__x0020CO2 = 6,
	prodml2__WellFluid__oil = 7,
	prodml2__WellFluid__oil_gas = 8,
	prodml2__WellFluid__oil_water = 9,
	prodml2__WellFluid__steam = 10,
	prodml2__WellFluid__water = 11,
	prodml2__WellFluid__water_x0020_x002d__x0020brine = 12,
	prodml2__WellFluid__water_x0020_x002d__x0020fresh_x0020water = 13
};
#endif

/* eml2_1ForGsoap.h:14905 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceDestinationType (1145)
/* prodml2:BalanceDestinationType */
enum prodml2__BalanceDestinationType {
	prodml2__BalanceDestinationType__harbor = 0,
	prodml2__BalanceDestinationType__terminal = 1,
	prodml2__BalanceDestinationType__unknown = 2
};
#endif

/* eml2_1ForGsoap.h:14927 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceEventKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceEventKind (1146)
/* prodml2:BalanceEventKind */
enum prodml2__BalanceEventKind {
	prodml2__BalanceEventKind__bill_x0020of_x0020lading = 0,
	prodml2__BalanceEventKind__transaction_x0020date = 1,
	prodml2__BalanceEventKind__unknown = 2
};
#endif

/* eml2_1ForGsoap.h:14949 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceFlowPart (1147)
/* prodml2:BalanceFlowPart */
enum prodml2__BalanceFlowPart {
	prodml2__BalanceFlowPart__adjusted_x0020closing = 0,
	prodml2__BalanceFlowPart__closing_x0020balance = 1,
	prodml2__BalanceFlowPart__closing_x0020storage_x0020inventory = 2,
	prodml2__BalanceFlowPart__completed_x0020lifting = 3,
	prodml2__BalanceFlowPart__gain_x002floss = 4,
	prodml2__BalanceFlowPart__input_x0020to_x0020storage = 5,
	prodml2__BalanceFlowPart__lifted = 6,
	prodml2__BalanceFlowPart__lifting_x0020entitlement = 7,
	prodml2__BalanceFlowPart__lifting_x0020entitlement_x0020remaining = 8,
	prodml2__BalanceFlowPart__linepack = 9,
	prodml2__BalanceFlowPart__opening_x0020balance = 10,
	prodml2__BalanceFlowPart__opflex = 11,
	prodml2__BalanceFlowPart__partial_x0020lifting = 12,
	prodml2__BalanceFlowPart__pipeline_x0020lifting = 13,
	prodml2__BalanceFlowPart__production_x0020__x0020mass_x0020adjustment = 14,
	prodml2__BalanceFlowPart__production_x0020_x002d__x0020value_x0020adjustment = 15,
	prodml2__BalanceFlowPart__production_x0020imbalance = 16,
	prodml2__BalanceFlowPart__swap = 17,
	prodml2__BalanceFlowPart__tanker_x0020lifting = 18,
	prodml2__BalanceFlowPart__transaction = 19,
	prodml2__BalanceFlowPart__transfer = 20,
	prodml2__BalanceFlowPart__unknown = 21
};
#endif

/* eml2_1ForGsoap.h:15047 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalculationMethod (1148)
/* prodml2:CalculationMethod */
enum prodml2__CalculationMethod {
	prodml2__CalculationMethod__none = 0,
	prodml2__CalculationMethod__step_x0020wise_x0020constant = 1,
	prodml2__CalculationMethod__unknown = 2
};
#endif

/* eml2_1ForGsoap.h:15069 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentBasis
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentBasis (1149)
/* prodml2:FluidComponentBasis */
enum prodml2__FluidComponentBasis {
	prodml2__FluidComponentBasis__1 = 1,
	prodml2__FluidComponentBasis__2 = 2,
	prodml2__FluidComponentBasis__3 = 3,
	prodml2__FluidComponentBasis__1_dimethylcyclopentane = 4,
	prodml2__FluidComponentBasis__2_x0020dimethylbenzene = 5,
	prodml2__FluidComponentBasis__2_x0020dimethylpropane = 6,
	prodml2__FluidComponentBasis__2_dimethylbutane = 7,
	prodml2__FluidComponentBasis__2_dimethylcyclopentane = 8,
	prodml2__FluidComponentBasis__2_dimethylhexane = 9,
	prodml2__FluidComponentBasis__2_dimethylpentane = 10,
	prodml2__FluidComponentBasis__2_methylbutane = 11,
	prodml2__FluidComponentBasis__2_methylhexane = 12,
	prodml2__FluidComponentBasis__2_methylpentane = 13,
	prodml2__FluidComponentBasis__2_methylpropane = 14,
	prodml2__FluidComponentBasis__3_x0020dimethylbenzene = 15,
	prodml2__FluidComponentBasis__3_dimethylbutane = 16,
	prodml2__FluidComponentBasis__3_dimethylcyclopentane = 17,
	prodml2__FluidComponentBasis__3_dimethylpentane = 18,
	prodml2__FluidComponentBasis__3_ethylpentane = 19,
	prodml2__FluidComponentBasis__3_methylhexane = 20,
	prodml2__FluidComponentBasis__3_methylpentane = 21,
	prodml2__FluidComponentBasis__3_trimethylbutane = 22,
	prodml2__FluidComponentBasis__3_trimethylpentane = 23,
	prodml2__FluidComponentBasis__4_dimethylbenzene = 24,
	prodml2__FluidComponentBasis__4_dimethylhexane = 25,
	prodml2__FluidComponentBasis__4_Dimethylpentane = 26,
	prodml2__FluidComponentBasis__4_trimethylbenzene = 27,
	prodml2__FluidComponentBasis__5_dimethylhexane = 28,
	prodml2__FluidComponentBasis__argon = 29,
	prodml2__FluidComponentBasis__benzene = 30,
	prodml2__FluidComponentBasis__butane = 31,
	prodml2__FluidComponentBasis__c11_x0020fraction = 32,
	prodml2__FluidComponentBasis__c12_x0020fraction = 33,
	prodml2__FluidComponentBasis__c13_x0020fraction = 34,
	prodml2__FluidComponentBasis__c14_x0020fraction = 35,
	prodml2__FluidComponentBasis__c15_x0020fraction = 36,
	prodml2__FluidComponentBasis__c16_x0020fraction = 37,
	prodml2__FluidComponentBasis__c17_x0020fraction = 38,
	prodml2__FluidComponentBasis__c18_x0020fraction = 39,
	prodml2__FluidComponentBasis__c19_x0020fraction = 40,
	prodml2__FluidComponentBasis__c20_x0020fraction = 41,
	prodml2__FluidComponentBasis__c21_x0020fraction = 42,
	prodml2__FluidComponentBasis__c22_x0020fraction = 43,
	prodml2__FluidComponentBasis__c23_x0020fraction = 44,
	prodml2__FluidComponentBasis__c24_x0020fraction = 45,
	prodml2__FluidComponentBasis__c25_x0020fraction = 46,
	prodml2__FluidComponentBasis__c26_x0020fraction = 47,
	prodml2__FluidComponentBasis__c27_x0020fraction = 48,
	prodml2__FluidComponentBasis__c28_x0020fraction = 49,
	prodml2__FluidComponentBasis__c29_x0020fraction = 50,
	prodml2__FluidComponentBasis__c30_x0020fraction = 51,
	prodml2__FluidComponentBasis__c31_x0020fraction = 52,
	prodml2__FluidComponentBasis__c32_x0020fraction = 53,
	prodml2__FluidComponentBasis__c33_x0020fraction = 54,
	prodml2__FluidComponentBasis__c34_x0020fraction = 55,
	prodml2__FluidComponentBasis__c35_x0020fraction = 56,
	prodml2__FluidComponentBasis__c36_x0020fraction = 57,
	prodml2__FluidComponentBasis__c37_x0020fraction = 58,
	prodml2__FluidComponentBasis__c38_x0020fraction = 59,
	prodml2__FluidComponentBasis__c39_x0020fraction = 60,
	prodml2__FluidComponentBasis__c40_x0020fraction = 61,
	prodml2__FluidComponentBasis__c41_x0020fraction = 62,
	prodml2__FluidComponentBasis__c42_x0020fraction = 63,
	prodml2__FluidComponentBasis__c43_x0020fraction = 64,
	prodml2__FluidComponentBasis__c44_x0020fraction = 'A',
	prodml2__FluidComponentBasis__c45_x0020fraction = 'B',
	prodml2__FluidComponentBasis__c46_x0020fraction = 'C',
	prodml2__FluidComponentBasis__c47_x0020fraction = 'D',
	prodml2__FluidComponentBasis__c48_x0020fraction = 'E',
	prodml2__FluidComponentBasis__c49_x0020fraction = 'F',
	prodml2__FluidComponentBasis__carbon_x0020dioxide = 'G',
	prodml2__FluidComponentBasis__cis_1 = 'H',
	prodml2__FluidComponentBasis__cyclohexane = 'I',
	prodml2__FluidComponentBasis__cyclopentane = 'J',
	prodml2__FluidComponentBasis__decanes = 'K',
	prodml2__FluidComponentBasis__ethane = 'L',
	prodml2__FluidComponentBasis__ethylbenzene = 'M',
	prodml2__FluidComponentBasis__ethylcyclopentane = 'N',
	prodml2__FluidComponentBasis__heptanes = 'O',
	prodml2__FluidComponentBasis__hexane = 'P',
	prodml2__FluidComponentBasis__hexanes = 'Q',
	prodml2__FluidComponentBasis__hydrogen = 'R',
	prodml2__FluidComponentBasis__hydrogen_x0020sulfide = 'S',
	prodml2__FluidComponentBasis__methane = 'T',
	prodml2__FluidComponentBasis__methylbenzene = 'U',
	prodml2__FluidComponentBasis__methylcyclohexane = 'V',
	prodml2__FluidComponentBasis__methylcyclopentane = 'W',
	prodml2__FluidComponentBasis__nitrogen = 'X',
	prodml2__FluidComponentBasis__nonanes = 'Y',
	prodml2__FluidComponentBasis__octanes = 'Z',
	prodml2__FluidComponentBasis__oxygen = 91,
	prodml2__FluidComponentBasis__pentane = 92,
	prodml2__FluidComponentBasis__propane = 93,
	prodml2__FluidComponentBasis__trans_1 = 94,
	prodml2__FluidComponentBasis__unknown = 95,
	prodml2__FluidComponentBasis__water = 96
};
#endif

/* eml2_1ForGsoap.h:15463 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellOperationMethod (1150)
/* prodml2:WellOperationMethod */
enum prodml2__WellOperationMethod {
	prodml2__WellOperationMethod__continuous_x0020gas_x0020lift = 0,
	prodml2__WellOperationMethod__electric_x0020submersible_x0020pump_x0020lift = 1,
	prodml2__WellOperationMethod__foam_x0020lift = 2,
	prodml2__WellOperationMethod__hydraulic_x0020pump_x0020lift = 3,
	prodml2__WellOperationMethod__intermittent_x0020gas_x0020lift = 4,
	prodml2__WellOperationMethod__jet_x0020pump_x0020lift = 5,
	prodml2__WellOperationMethod__natural_x0020flow = 6,
	prodml2__WellOperationMethod__plunger_x0020gas_x0020lift = 7,
	prodml2__WellOperationMethod__progressive_x0020cavity_x0020pump_x0020lift = 8,
	prodml2__WellOperationMethod__sucker_x0020rod_x0020pump_x0020lift = 9,
	prodml2__WellOperationMethod__unknown = 10
};
#endif

/* eml2_1ForGsoap.h:15517 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CableType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CableType (1151)
/* prodml2:CableType */
enum prodml2__CableType {
	prodml2__CableType__electrical_fiber_cable = 0,
	prodml2__CableType__multi_fiber_cable = 1,
	prodml2__CableType__single_fiber_cable = 2
};
#endif

/* eml2_1ForGsoap.h:15539 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationSize
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationSize (1152)
/* prodml2:ControlLineEncapsulationSize */
enum prodml2__ControlLineEncapsulationSize {
	prodml2__ControlLineEncapsulationSize__11x11 = 0,
	prodml2__ControlLineEncapsulationSize__23x11 = 1
};
#endif

/* eml2_1ForGsoap.h:15557 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationType (1153)
/* prodml2:ControlLineEncapsulationType */
enum prodml2__ControlLineEncapsulationType {
	prodml2__ControlLineEncapsulationType__round = 0,
	prodml2__ControlLineEncapsulationType__square = 1
};
#endif

/* eml2_1ForGsoap.h:15575 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineMaterial
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineMaterial (1154)
/* prodml2:ControlLineMaterial */
enum prodml2__ControlLineMaterial {
	prodml2__ControlLineMaterial__inc_x0020825 = 0,
	prodml2__ControlLineMaterial__ss_x0020316 = 1
};
#endif

/* eml2_1ForGsoap.h:15593 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineSize
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineSize (1155)
/* prodml2:ControlLineSize */
enum prodml2__ControlLineSize {
	prodml2__ControlLineSize__diameter_x00200_x002e25_x0020in_x0020weight_x00200_x002e028_x0020lb_x002fft = 0,
	prodml2__ControlLineSize__diameter_x00200_x002e25_x0020in_x0020weight_x00200_x002e035_x0020lb_x002fft = 1,
	prodml2__ControlLineSize__diameter_x00200_x002e375_x0020in_x0020weight_x00200_x002e048_x0020lb_x002fft = 2
};
#endif

/* eml2_1ForGsoap.h:15615 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnectorTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnectorTypes (1156)
/* prodml2:FiberConnectorTypes */
enum prodml2__FiberConnectorTypes {
	prodml2__FiberConnectorTypes__dry_x0020mate = 0,
	prodml2__FiberConnectorTypes__wet_x0020mate = 1
};
#endif

/* eml2_1ForGsoap.h:15633 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberEndType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberEndType (1157)
/* prodml2:FiberEndType */
enum prodml2__FiberEndType {
	prodml2__FiberEndType__angle_x0020polished = 0,
	prodml2__FiberEndType__flat_x0020polished = 1
};
#endif

/* eml2_1ForGsoap.h:15651 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSpliceTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSpliceTypes (1158)
/* prodml2:FiberSpliceTypes */
enum prodml2__FiberSpliceTypes {
	prodml2__FiberSpliceTypes__cable_x0020splice = 0,
	prodml2__FiberSpliceTypes__h_x0020splice = 1,
	prodml2__FiberSpliceTypes__user_custom = 2
};
#endif

/* eml2_1ForGsoap.h:15664 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyanceType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyanceType (1159)
/* prodml2:InterventionConveyanceType */
enum prodml2__InterventionConveyanceType {
	prodml2__InterventionConveyanceType__coiled_x0020tubing = 0,
	prodml2__InterventionConveyanceType__rod = 1,
	prodml2__InterventionConveyanceType__slickline = 2,
	prodml2__InterventionConveyanceType__wireline = 3
};
#endif

/* eml2_1ForGsoap.h:15678 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRDirection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRDirection (1160)
/* prodml2:OTDRDirection */
enum prodml2__OTDRDirection {
	prodml2__OTDRDirection__backward = 0,
	prodml2__OTDRDirection__forward = 1
};
#endif

/* eml2_1ForGsoap.h:15696 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRReason
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRReason (1161)
/* prodml2:OTDRReason */
enum prodml2__OTDRReason {
	prodml2__OTDRReason__dts = 0,
	prodml2__OTDRReason__other = 1,
	prodml2__OTDRReason__post_installation = 2,
	prodml2__OTDRReason__pre_installation = 3,
	prodml2__OTDRReason__run = 4
};
#endif

/* eml2_1ForGsoap.h:15726 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PathDefectTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PathDefectTypes (1162)
/* prodml2:PathDefectTypes */
enum prodml2__PathDefectTypes {
	prodml2__PathDefectTypes__darkened_x0020fiber = 0,
	prodml2__PathDefectTypes__other = 1
};
#endif

/* eml2_1ForGsoap.h:15744 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCableInstallationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCableInstallationType (1163)
/* prodml2:PermanentCableInstallationType */
enum prodml2__PermanentCableInstallationType {
	prodml2__PermanentCableInstallationType__buried_x0020parallel_x0020to_x0020tubular = 0,
	prodml2__PermanentCableInstallationType__clamped_x0020to_x0020tubular = 1,
	prodml2__PermanentCableInstallationType__wrapped_x0020around_x0020tubular = 2
};
#endif

/* eml2_1ForGsoap.h:15757 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__TerminationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__TerminationType (1164)
/* prodml2:TerminationType */
enum prodml2__TerminationType {
	prodml2__TerminationType__looped_x0020back_x0020to_x0020instrument_x0020box = 0,
	prodml2__TerminationType__termination_x0020at_x0020cable = 1
};
#endif

/* eml2_1ForGsoap.h:15777 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExistenceKind (1165)
/* eml21:ExistenceKind */
enum eml21__ExistenceKind {
	eml21__ExistenceKind__actual = 0,
	eml21__ExistenceKind__planned = 1,
	eml21__ExistenceKind__simulated = 2
};
#endif

/* eml2_1ForGsoap.h:15799 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeochronologicalRank (1166)
/* eml21:GeochronologicalRank */
enum eml21__GeochronologicalRank {
	eml21__GeochronologicalRank__eon = 0,
	eml21__GeochronologicalRank__era = 1,
	eml21__GeochronologicalRank__period = 2,
	eml21__GeochronologicalRank__epoch = 3,
	eml21__GeochronologicalRank__age = 4,
	eml21__GeochronologicalRank__chron = 5
};
#endif

/* eml2_1ForGsoap.h:15815 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKind (1167)
/* eml21:LithologyKind */
enum eml21__LithologyKind {
	eml21__LithologyKind__alkali_x0020feldspar_x0020rhyolite = 0,
	eml21__LithologyKind__alkali_x0020olivine_x0020basalt = 1,
	eml21__LithologyKind__amphibolite = 2,
	eml21__LithologyKind__andesite = 3,
	eml21__LithologyKind__anhydrite = 4,
	eml21__LithologyKind__anorthositic_x0020rock = 5,
	eml21__LithologyKind__anthracite = 6,
	eml21__LithologyKind__aplite = 7,
	eml21__LithologyKind__arenite = 8,
	eml21__LithologyKind__argillaceous = 9,
	eml21__LithologyKind__arkose = 10,
	eml21__LithologyKind__basalt = 11,
	eml21__LithologyKind__basanite = 12,
	eml21__LithologyKind__bauxite = 13,
	eml21__LithologyKind__bituminous_x0020coal = 14,
	eml21__LithologyKind__blueschist_x0020metamorphic_x0020rock = 15,
	eml21__LithologyKind__boninite = 16,
	eml21__LithologyKind__breccia = 17,
	eml21__LithologyKind__carbonate_x0020ooze = 18,
	eml21__LithologyKind__carbonatite = 19,
	eml21__LithologyKind__chalk = 20,
	eml21__LithologyKind__chert = 21,
	eml21__LithologyKind__clay = 22,
	eml21__LithologyKind__claystone = 23,
	eml21__LithologyKind__coal = 24,
	eml21__LithologyKind__conglomerate = 25,
	eml21__LithologyKind__dacite = 26,
	eml21__LithologyKind__diabase = 27,
	eml21__LithologyKind__diamictite = 28,
	eml21__LithologyKind__diorite = 29,
	eml21__LithologyKind__dioritoid = 30,
	eml21__LithologyKind__doleritic_x0020rock = 31,
	eml21__LithologyKind__dolomite = 32,
	eml21__LithologyKind__dolomitic = 33,
	eml21__LithologyKind__eclogite = 34,
	eml21__LithologyKind__exotic_x0020alkaline_x0020rock = 35,
	eml21__LithologyKind__feldspar = 36,
	eml21__LithologyKind__feldspathic_x0020arenite = 37,
	eml21__LithologyKind__fine_x0020grained_x0020igneous_x0020rock = 38,
	eml21__LithologyKind__foid_x0020dioritoid = 39,
	eml21__LithologyKind__foid_x0020gabbroid = 40,
	eml21__LithologyKind__foid_x0020syenitoid = 41,
	eml21__LithologyKind__foidite = 42,
	eml21__LithologyKind__foiditoid = 43,
	eml21__LithologyKind__foidolite = 44,
	eml21__LithologyKind__foliated_x0020metamorphic_x0020rock = 45,
	eml21__LithologyKind__fragmental_x0020igneous_x0020rock = 46,
	eml21__LithologyKind__gabbro = 47,
	eml21__LithologyKind__gabbroic_x0020rock = 48,
	eml21__LithologyKind__gabbroid = 49,
	eml21__LithologyKind__glauconite = 50,
	eml21__LithologyKind__gneiss = 51,
	eml21__LithologyKind__granite = 52,
	eml21__LithologyKind__granodiorite = 53,
	eml21__LithologyKind__granofels = 54,
	eml21__LithologyKind__granulite = 55,
	eml21__LithologyKind__gravel = 56,
	eml21__LithologyKind__greenstone = 57,
	eml21__LithologyKind__gumbo = 58,
	eml21__LithologyKind__gypsum = 59,
	eml21__LithologyKind__halite = 60,
	eml21__LithologyKind__hornfels = 61,
	eml21__LithologyKind__igneous_x0020rock = 62,
	eml21__LithologyKind__impact_x0020generated_x0020material = 63,
	eml21__LithologyKind__impure_x0020dolomite = 64,
	eml21__LithologyKind__impure_x0020limestone = 'A',
	eml21__LithologyKind__intrusive_x0020rock_x0020_x0028plutonic_x0029 = 'B',
	eml21__LithologyKind__iron_x0020rich_x0020sedimentary_x0020rock = 'C',
	eml21__LithologyKind__kalsilitic_x0020and_x0020melilitic_x0020rocks = 'D',
	eml21__LithologyKind__komatiitic_x0020rock = 'E',
	eml21__LithologyKind__latitic_x0020rock = 'F',
	eml21__LithologyKind__lignite = 'G',
	eml21__LithologyKind__lime_x0020boundstone = 'H',
	eml21__LithologyKind__lime_x0020framestone = 'I',
	eml21__LithologyKind__lime_x0020grainstone = 'J',
	eml21__LithologyKind__lime_x0020mudstone = 'K',
	eml21__LithologyKind__lime_x0020packstone = 'L',
	eml21__LithologyKind__lime_x0020wackestone = 'M',
	eml21__LithologyKind__limestone = 'N',
	eml21__LithologyKind__marble = 'O',
	eml21__LithologyKind__marl = 'P',
	eml21__LithologyKind__metamorphic_x0020rock = 'Q',
	eml21__LithologyKind__mica_x0020schist = 'R',
	eml21__LithologyKind__migmatite = 'S',
	eml21__LithologyKind__monzogabbro = 'T',
	eml21__LithologyKind__mud = 'U',
	eml21__LithologyKind__mudstone = 'V',
	eml21__LithologyKind__mylonitic_x0020rock = 'W',
	eml21__LithologyKind__no_x0020description = 'X',
	eml21__LithologyKind__no_x0020sample = 'Y',
	eml21__LithologyKind__ooze = 'Z',
	eml21__LithologyKind__ophiolite = 91,
	eml21__LithologyKind__organic_x0020bearing_x0020mudstone = 92,
	eml21__LithologyKind__peat = 93,
	eml21__LithologyKind__pegmatite = 94,
	eml21__LithologyKind__peridotite = 95,
	eml21__LithologyKind__phaneritic_x0020igneous_x0020rock = 96,
	eml21__LithologyKind__phonolite = 'a',
	eml21__LithologyKind__phonolitoid = 'b',
	eml21__LithologyKind__phosphate = 'c',
	eml21__LithologyKind__phosphate_x0020rock = 'd',
	eml21__LithologyKind__phyllite = 'e',
	eml21__LithologyKind__porphyry = 'f',
	eml21__LithologyKind__potassium_x0020and_x0020magnesium_x0020salts = 'g',
	eml21__LithologyKind__pyroclastic_x0020breccia = 'h',
	eml21__LithologyKind__pyroclastic_x0020rock = 'i',
	eml21__LithologyKind__pyroxenite = 'j',
	eml21__LithologyKind__quartz_x0020arenite = 'k',
	eml21__LithologyKind__quartzite = 'l',
	eml21__LithologyKind__rhyolite = 'm',
	eml21__LithologyKind__rock_x0020salt = 'n',
	eml21__LithologyKind__sand = 'o',
	eml21__LithologyKind__sandstone = 'p',
	eml21__LithologyKind__sandy = 'q',
	eml21__LithologyKind__sapropel = 'r',
	eml21__LithologyKind__schist = 's',
	eml21__LithologyKind__serpentinite = 't',
	eml21__LithologyKind__shale = 'u',
	eml21__LithologyKind__siliceous_x0020ooze = 'v',
	eml21__LithologyKind__silt = 'w',
	eml21__LithologyKind__siltstone = 'x',
	eml21__LithologyKind__skarn = 'y',
	eml21__LithologyKind__slate = 'z',
	eml21__LithologyKind__spilite = 123,
	eml21__LithologyKind__syenite = 124,
	eml21__LithologyKind__syenitoid = 125,
	eml21__LithologyKind__sylvite = 126,
	eml21__LithologyKind__tephrite = 127,
	eml21__LithologyKind__tephritoid = 128,
	eml21__LithologyKind__tholeiitic_x0020basalt = 129,
	eml21__LithologyKind__tonalite = 130,
	eml21__LithologyKind__trachyte = 131,
	eml21__LithologyKind__trachytic_x0020rock = 132,
	eml21__LithologyKind__trachytoid = 133,
	eml21__LithologyKind__travertine = 134,
	eml21__LithologyKind__tuff = 135,
	eml21__LithologyKind__tuffite = 136,
	eml21__LithologyKind__ultrabasic = 137,
	eml21__LithologyKind__undifferentiated = 138,
	eml21__LithologyKind__unknown = 139,
	eml21__LithologyKind__wacke = 140
};
#endif

/* eml2_1ForGsoap.h:15963 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKind (1168)
/* eml21:LithologyQualifierKind */
enum eml21__LithologyQualifierKind {
	eml21__LithologyQualifierKind__alkali_x0020feldspar_x0020rhyolite = 0,
	eml21__LithologyQualifierKind__alkali_x0020olivine_x0020basalt = 1,
	eml21__LithologyQualifierKind__amphibolite = 2,
	eml21__LithologyQualifierKind__amphibolitic = 3,
	eml21__LithologyQualifierKind__andesite = 4,
	eml21__LithologyQualifierKind__andesitic = 5,
	eml21__LithologyQualifierKind__anhydrite = 6,
	eml21__LithologyQualifierKind__anhydritic = 7,
	eml21__LithologyQualifierKind__ankerite = 8,
	eml21__LithologyQualifierKind__ankeritic = 9,
	eml21__LithologyQualifierKind__anorthositic_x0020rock = 10,
	eml21__LithologyQualifierKind__anthracite = 11,
	eml21__LithologyQualifierKind__anthracitic = 12,
	eml21__LithologyQualifierKind__aplite = 13,
	eml21__LithologyQualifierKind__aplitic = 14,
	eml21__LithologyQualifierKind__arenite = 15,
	eml21__LithologyQualifierKind__arenitic = 16,
	eml21__LithologyQualifierKind__argillaceous = 17,
	eml21__LithologyQualifierKind__arkose = 18,
	eml21__LithologyQualifierKind__arkosic = 19,
	eml21__LithologyQualifierKind__barite = 20,
	eml21__LithologyQualifierKind__baritic = 21,
	eml21__LithologyQualifierKind__basalt = 22,
	eml21__LithologyQualifierKind__basaltic = 23,
	eml21__LithologyQualifierKind__basanite = 24,
	eml21__LithologyQualifierKind__basanitic = 25,
	eml21__LithologyQualifierKind__bauxite = 26,
	eml21__LithologyQualifierKind__bauxitic = 27,
	eml21__LithologyQualifierKind__belemnites = 28,
	eml21__LithologyQualifierKind__belemnitic = 29,
	eml21__LithologyQualifierKind__bioturbated = 30,
	eml21__LithologyQualifierKind__bioturbation = 31,
	eml21__LithologyQualifierKind__bitumen = 32,
	eml21__LithologyQualifierKind__bituminous = 33,
	eml21__LithologyQualifierKind__bituminous_x0020coal = 34,
	eml21__LithologyQualifierKind__blueschist_x0020metamorphic_x0020rock = 35,
	eml21__LithologyQualifierKind__boninite = 36,
	eml21__LithologyQualifierKind__breccia = 37,
	eml21__LithologyQualifierKind__brecciated = 38,
	eml21__LithologyQualifierKind__bryozoan = 39,
	eml21__LithologyQualifierKind__bryozoans = 40,
	eml21__LithologyQualifierKind__burrowed = 41,
	eml21__LithologyQualifierKind__burrows = 42,
	eml21__LithologyQualifierKind__calcareous = 43,
	eml21__LithologyQualifierKind__calcite = 44,
	eml21__LithologyQualifierKind__calcite_x0020concretion = 45,
	eml21__LithologyQualifierKind__calcitic = 46,
	eml21__LithologyQualifierKind__carbonaceous = 47,
	eml21__LithologyQualifierKind__carbonate_x0020ooze = 48,
	eml21__LithologyQualifierKind__carbonatite = 49,
	eml21__LithologyQualifierKind__carbonatitic = 50,
	eml21__LithologyQualifierKind__chalk = 51,
	eml21__LithologyQualifierKind__chalky = 52,
	eml21__LithologyQualifierKind__chamosite = 53,
	eml21__LithologyQualifierKind__chamositic = 54,
	eml21__LithologyQualifierKind__chert = 55,
	eml21__LithologyQualifierKind__cherty = 56,
	eml21__LithologyQualifierKind__chlorite = 57,
	eml21__LithologyQualifierKind__chloritic = 58,
	eml21__LithologyQualifierKind__clay = 59,
	eml21__LithologyQualifierKind__claystone = 60,
	eml21__LithologyQualifierKind__coal = 61,
	eml21__LithologyQualifierKind__concretionary = 62,
	eml21__LithologyQualifierKind__concretions = 63,
	eml21__LithologyQualifierKind__conglomerate = 64,
	eml21__LithologyQualifierKind__conglomeratic = 'A',
	eml21__LithologyQualifierKind__coral_x0020fragments = 'B',
	eml21__LithologyQualifierKind__coralline = 'C',
	eml21__LithologyQualifierKind__crinoidal = 'D',
	eml21__LithologyQualifierKind__crinoids = 'E',
	eml21__LithologyQualifierKind__dacite = 'F',
	eml21__LithologyQualifierKind__dacitic = 'G',
	eml21__LithologyQualifierKind__diabase = 'H',
	eml21__LithologyQualifierKind__diabasic = 'I',
	eml21__LithologyQualifierKind__diamictite = 'J',
	eml21__LithologyQualifierKind__diamictitic = 'K',
	eml21__LithologyQualifierKind__diatomaceous = 'L',
	eml21__LithologyQualifierKind__diatoms = 'M',
	eml21__LithologyQualifierKind__diorite = 'N',
	eml21__LithologyQualifierKind__dioritic = 'O',
	eml21__LithologyQualifierKind__dioritoid = 'P',
	eml21__LithologyQualifierKind__dioritoidic = 'Q',
	eml21__LithologyQualifierKind__doleritic_x0020rock = 'R',
	eml21__LithologyQualifierKind__dolomite = 'S',
	eml21__LithologyQualifierKind__dolomite_x0020concretion = 'T',
	eml21__LithologyQualifierKind__dolomite_x0020stringer = 'U',
	eml21__LithologyQualifierKind__dolomitic = 'V',
	eml21__LithologyQualifierKind__eclogite = 'W',
	eml21__LithologyQualifierKind__eclogitic = 'X',
	eml21__LithologyQualifierKind__exotic_x0020alkaline_x0020rock = 'Y',
	eml21__LithologyQualifierKind__feldspar = 'Z',
	eml21__LithologyQualifierKind__feldsparic = 91,
	eml21__LithologyQualifierKind__feldspathic = 92,
	eml21__LithologyQualifierKind__feldspathic_x0020arenite = 93,
	eml21__LithologyQualifierKind__ferruginous = 94,
	eml21__LithologyQualifierKind__fine_x0020grained_x0020igneous_x0020rock = 95,
	eml21__LithologyQualifierKind__foid_x0020dioritoid = 96,
	eml21__LithologyQualifierKind__foid_x0020gabbroid = 'a',
	eml21__LithologyQualifierKind__foid_x0020syenitoid = 'b',
	eml21__LithologyQualifierKind__foidite = 'c',
	eml21__LithologyQualifierKind__foiditic = 'd',
	eml21__LithologyQualifierKind__foiditoid = 'e',
	eml21__LithologyQualifierKind__foidolite = 'f',
	eml21__LithologyQualifierKind__foidolitic = 'g',
	eml21__LithologyQualifierKind__foliated_x0020metamorphic_x0020rock = 'h',
	eml21__LithologyQualifierKind__foraminifera = 'i',
	eml21__LithologyQualifierKind__foraminiferous = 'j',
	eml21__LithologyQualifierKind__forams = 'k',
	eml21__LithologyQualifierKind__fossil_x0020fragments = 'l',
	eml21__LithologyQualifierKind__fossiliferous = 'm',
	eml21__LithologyQualifierKind__fossils_x0020undifferentiated = 'n',
	eml21__LithologyQualifierKind__fragmental_x0020igneous_x0020rock = 'o',
	eml21__LithologyQualifierKind__gabbro = 'p',
	eml21__LithologyQualifierKind__gabbroic = 'q',
	eml21__LithologyQualifierKind__gabbroic_x0020rock = 'r',
	eml21__LithologyQualifierKind__gabbroid = 's',
	eml21__LithologyQualifierKind__gabbroidic = 't',
	eml21__LithologyQualifierKind__gilsonite = 'u',
	eml21__LithologyQualifierKind__gilsonitic = 'v',
	eml21__LithologyQualifierKind__glauconite = 'w',
	eml21__LithologyQualifierKind__glauconitic = 'x',
	eml21__LithologyQualifierKind__gneiss = 'y',
	eml21__LithologyQualifierKind__gneissic = 'z',
	eml21__LithologyQualifierKind__granite = 123,
	eml21__LithologyQualifierKind__granitic = 124,
	eml21__LithologyQualifierKind__granodiorite = 125,
	eml21__LithologyQualifierKind__granodioritic = 126,
	eml21__LithologyQualifierKind__granofels = 127,
	eml21__LithologyQualifierKind__granulite = 128,
	eml21__LithologyQualifierKind__granulitic = 129,
	eml21__LithologyQualifierKind__gravel = 130,
	eml21__LithologyQualifierKind__gravelly = 131,
	eml21__LithologyQualifierKind__greenstone = 132,
	eml21__LithologyQualifierKind__gumbo = 133,
	eml21__LithologyQualifierKind__gypsiferous = 134,
	eml21__LithologyQualifierKind__gypsum = 135,
	eml21__LithologyQualifierKind__halite = 136,
	eml21__LithologyQualifierKind__halitic = 137,
	eml21__LithologyQualifierKind__hornfels = 138,
	eml21__LithologyQualifierKind__hornfelsic = 139,
	eml21__LithologyQualifierKind__igneous = 140,
	eml21__LithologyQualifierKind__igneous_x0020rock = 141,
	eml21__LithologyQualifierKind__illite = 142,
	eml21__LithologyQualifierKind__illitic = 143,
	eml21__LithologyQualifierKind__impact_x0020generated_x0020material = 144,
	eml21__LithologyQualifierKind__impure_x0020dolomite = 145,
	eml21__LithologyQualifierKind__impure_x0020limestone = 146,
	eml21__LithologyQualifierKind__intrusive_x0020rock_x0020_x0028plutonic_x0029 = 147,
	eml21__LithologyQualifierKind__iron_x0020rich_x0020sedimentary_x0020rock = 148,
	eml21__LithologyQualifierKind__kalsilitic_x0020and_x0020melilitic_x0020rocks = 149,
	eml21__LithologyQualifierKind__kaolinite = 150,
	eml21__LithologyQualifierKind__kaolinitic = 151,
	eml21__LithologyQualifierKind__komatiitic_x0020rock = 152,
	eml21__LithologyQualifierKind__latitic_x0020rock = 153,
	eml21__LithologyQualifierKind__lignite = 154,
	eml21__LithologyQualifierKind__lignitic = 155,
	eml21__LithologyQualifierKind__lime_x0020boundstone = 156,
	eml21__LithologyQualifierKind__lime_x0020framestone = 157,
	eml21__LithologyQualifierKind__lime_x0020grainstone = 158,
	eml21__LithologyQualifierKind__lime_x0020mudstone = 159,
	eml21__LithologyQualifierKind__lime_x0020packstone = 160,
	eml21__LithologyQualifierKind__lime_x0020wackestone = 161,
	eml21__LithologyQualifierKind__limestone = 162,
	eml21__LithologyQualifierKind__limestone_x0020stringer = 163,
	eml21__LithologyQualifierKind__lithic = 164,
	eml21__LithologyQualifierKind__lithic_x0020fragments = 165,
	eml21__LithologyQualifierKind__marble = 166,
	eml21__LithologyQualifierKind__marcasite = 167,
	eml21__LithologyQualifierKind__marcasitic = 168,
	eml21__LithologyQualifierKind__marl = 169,
	eml21__LithologyQualifierKind__marly = 170,
	eml21__LithologyQualifierKind__metamorphic_x0020rock = 171,
	eml21__LithologyQualifierKind__mica = 172,
	eml21__LithologyQualifierKind__mica_x0020schist = 173,
	eml21__LithologyQualifierKind__micaceous = 174,
	eml21__LithologyQualifierKind__microfossiliferous = 175,
	eml21__LithologyQualifierKind__microfossils = 176,
	eml21__LithologyQualifierKind__migmatite = 177,
	eml21__LithologyQualifierKind__migmatitic = 178,
	eml21__LithologyQualifierKind__monzogabbro = 179,
	eml21__LithologyQualifierKind__monzogabbroic = 180,
	eml21__LithologyQualifierKind__mud = 181,
	eml21__LithologyQualifierKind__muddy = 182,
	eml21__LithologyQualifierKind__mudstone = 183,
	eml21__LithologyQualifierKind__mylonitic_x0020rock = 184,
	eml21__LithologyQualifierKind__no_x0020sample = 185,
	eml21__LithologyQualifierKind__oncolite = 186,
	eml21__LithologyQualifierKind__oncoliths = 187,
	eml21__LithologyQualifierKind__oncolitic = 188,
	eml21__LithologyQualifierKind__ooids = 189,
	eml21__LithologyQualifierKind__ooliths = 190,
	eml21__LithologyQualifierKind__oolitic = 191,
	eml21__LithologyQualifierKind__ooze = 192,
	eml21__LithologyQualifierKind__ophiolite = 193,
	eml21__LithologyQualifierKind__ophiolitic = 194,
	eml21__LithologyQualifierKind__organic_x0020bearing_x0020mudstone = 195,
	eml21__LithologyQualifierKind__ostracodal = 196,
	eml21__LithologyQualifierKind__ostracods = 197,
	eml21__LithologyQualifierKind__peat = 198,
	eml21__LithologyQualifierKind__peaty = 199,
	eml21__LithologyQualifierKind__pebble = 200,
	eml21__LithologyQualifierKind__pebbly = 201,
	eml21__LithologyQualifierKind__pegmatite = 202,
	eml21__LithologyQualifierKind__pegmatitic = 203,
	eml21__LithologyQualifierKind__pelletal = 204,
	eml21__LithologyQualifierKind__pellets = 205,
	eml21__LithologyQualifierKind__peloidal = 206,
	eml21__LithologyQualifierKind__peloids = 207,
	eml21__LithologyQualifierKind__peridotite = 208,
	eml21__LithologyQualifierKind__peridotitic = 209,
	eml21__LithologyQualifierKind__phaneritic_x0020igneous_x0020rock = 210,
	eml21__LithologyQualifierKind__phonolite = 211,
	eml21__LithologyQualifierKind__phonolitic = 212,
	eml21__LithologyQualifierKind__phonolitoid = 213,
	eml21__LithologyQualifierKind__phosphate = 214,
	eml21__LithologyQualifierKind__phosphate_x0020rock = 215,
	eml21__LithologyQualifierKind__phosphatic = 216,
	eml21__LithologyQualifierKind__phyllite = 217,
	eml21__LithologyQualifierKind__phyllitic = 218,
	eml21__LithologyQualifierKind__pisolite = 219,
	eml21__LithologyQualifierKind__pisoliths = 220,
	eml21__LithologyQualifierKind__pisolitic = 221,
	eml21__LithologyQualifierKind__plant_x0020remains = 222,
	eml21__LithologyQualifierKind__porphyritic = 223,
	eml21__LithologyQualifierKind__porphyry = 224,
	eml21__LithologyQualifierKind__potassium_x0020and_x0020magnesium_x0020salts = 225,
	eml21__LithologyQualifierKind__pyrite = 226,
	eml21__LithologyQualifierKind__pyritic = 227,
	eml21__LithologyQualifierKind__pyroclastic_x0020breccia = 228,
	eml21__LithologyQualifierKind__pyroclastic_x0020rock = 229,
	eml21__LithologyQualifierKind__pyroxenite = 230,
	eml21__LithologyQualifierKind__pyroxenitic = 231,
	eml21__LithologyQualifierKind__quartiferous = 232,
	eml21__LithologyQualifierKind__quartz = 233,
	eml21__LithologyQualifierKind__quartz_x0020arenite = 234,
	eml21__LithologyQualifierKind__quartzite = 235,
	eml21__LithologyQualifierKind__quartzitic = 236,
	eml21__LithologyQualifierKind__radiolaria = 237,
	eml21__LithologyQualifierKind__radiolarian = 238,
	eml21__LithologyQualifierKind__rhyolite = 239,
	eml21__LithologyQualifierKind__rhyolitic = 240,
	eml21__LithologyQualifierKind__rock_x0020salt = 241,
	eml21__LithologyQualifierKind__rootlets = 242,
	eml21__LithologyQualifierKind__salty = 243,
	eml21__LithologyQualifierKind__sand = 244,
	eml21__LithologyQualifierKind__sandstone = 245,
	eml21__LithologyQualifierKind__sandy = 246,
	eml21__LithologyQualifierKind__sapropel = 247,
	eml21__LithologyQualifierKind__sapropelic = 248,
	eml21__LithologyQualifierKind__schist = 249,
	eml21__LithologyQualifierKind__schisty = 250,
	eml21__LithologyQualifierKind__sepentinitic = 251,
	eml21__LithologyQualifierKind__serpentinite = 252,
	eml21__LithologyQualifierKind__shale = 253,
	eml21__LithologyQualifierKind__shaly = 254,
	eml21__LithologyQualifierKind__shell_x0020fragments = 255,
	eml21__LithologyQualifierKind__shelly = 256,
	eml21__LithologyQualifierKind__siderite = 257,
	eml21__LithologyQualifierKind__siderite_x0020concretion = 258,
	eml21__LithologyQualifierKind__sideritic = 259,
	eml21__LithologyQualifierKind__siliceous_x0020ooze = 260,
	eml21__LithologyQualifierKind__silt = 261,
	eml21__LithologyQualifierKind__siltstone = 262,
	eml21__LithologyQualifierKind__silty = 263,
	eml21__LithologyQualifierKind__skarn = 264,
	eml21__LithologyQualifierKind__skarny = 265,
	eml21__LithologyQualifierKind__slate = 266,
	eml21__LithologyQualifierKind__slaty = 267,
	eml21__LithologyQualifierKind__smectite = 268,
	eml21__LithologyQualifierKind__smectitic = 269,
	eml21__LithologyQualifierKind__spicular = 270,
	eml21__LithologyQualifierKind__spicules = 271,
	eml21__LithologyQualifierKind__spilite = 272,
	eml21__LithologyQualifierKind__spilitic = 273,
	eml21__LithologyQualifierKind__stylolites = 274,
	eml21__LithologyQualifierKind__stylolitic = 275,
	eml21__LithologyQualifierKind__syenite = 276,
	eml21__LithologyQualifierKind__syenitic = 277,
	eml21__LithologyQualifierKind__syenitoid = 278,
	eml21__LithologyQualifierKind__sylvite = 279,
	eml21__LithologyQualifierKind__sylvitic = 280,
	eml21__LithologyQualifierKind__tarry = 281,
	eml21__LithologyQualifierKind__tephrite = 282,
	eml21__LithologyQualifierKind__tephritic = 283,
	eml21__LithologyQualifierKind__tephritoid = 284,
	eml21__LithologyQualifierKind__tholeiitic_x0020basalt = 285,
	eml21__LithologyQualifierKind__tonalite = 286,
	eml21__LithologyQualifierKind__tonalitic = 287,
	eml21__LithologyQualifierKind__trachyte = 288,
	eml21__LithologyQualifierKind__trachytic = 289,
	eml21__LithologyQualifierKind__trachytic_x0020rock = 290,
	eml21__LithologyQualifierKind__trachytoid = 291,
	eml21__LithologyQualifierKind__travertine = 292,
	eml21__LithologyQualifierKind__tuff = 293,
	eml21__LithologyQualifierKind__tuffaceous = 294,
	eml21__LithologyQualifierKind__tuffite = 295,
	eml21__LithologyQualifierKind__tuffitic = 296,
	eml21__LithologyQualifierKind__ultrabasic = 297,
	eml21__LithologyQualifierKind__undifferentiated = 298,
	eml21__LithologyQualifierKind__unknown = 299,
	eml21__LithologyQualifierKind__wacke = 300
};
#endif

/* eml2_1ForGsoap.h:16274 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithostratigraphicRank (1169)
/* eml21:LithostratigraphicRank */
enum eml21__LithostratigraphicRank {
	eml21__LithostratigraphicRank__group = 0,
	eml21__LithostratigraphicRank__formation = 1,
	eml21__LithostratigraphicRank__member = 2,
	eml21__LithostratigraphicRank__bed = 3
};
#endif

/* eml2_1ForGsoap.h:16318 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__MatrixCementKind (1170)
/* eml21:MatrixCementKind */
enum eml21__MatrixCementKind {
	eml21__MatrixCementKind__ankerite = 0,
	eml21__MatrixCementKind__calcite = 1,
	eml21__MatrixCementKind__chlorite = 2,
	eml21__MatrixCementKind__dolomite = 3,
	eml21__MatrixCementKind__illite = 4,
	eml21__MatrixCementKind__kaolinite = 5,
	eml21__MatrixCementKind__quartz = 6,
	eml21__MatrixCementKind__siderite = 7,
	eml21__MatrixCementKind__smectite = 8
};
#endif

/* eml2_1ForGsoap.h:16337 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MeasureClass
#define SOAP_TYPE_gsoap_eml2_1_eml21__MeasureClass (1171)
/* eml21:MeasureClass */
enum eml21__MeasureClass {
	eml21__MeasureClass__absorbed_x0020dose = 0,
	eml21__MeasureClass__activity_x0020of_x0020radioactivity = 1,
	eml21__MeasureClass__amount_x0020of_x0020substance = 2,
	eml21__MeasureClass__amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	eml21__MeasureClass__amount_x0020of_x0020substance_x0020per_x0020area = 4,
	eml21__MeasureClass__amount_x0020of_x0020substance_x0020per_x0020time = 5,
	eml21__MeasureClass__amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	eml21__MeasureClass__amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	eml21__MeasureClass__angle_x0020per_x0020length = 8,
	eml21__MeasureClass__angle_x0020per_x0020volume = 9,
	eml21__MeasureClass__angular_x0020acceleration = 10,
	eml21__MeasureClass__angular_x0020velocity = 11,
	eml21__MeasureClass__api_x0020gamma_x0020ray = 12,
	eml21__MeasureClass__api_x0020gravity = 13,
	eml21__MeasureClass__api_x0020neutron = 14,
	eml21__MeasureClass__area = 15,
	eml21__MeasureClass__area_x0020per_x0020amount_x0020of_x0020substance = 16,
	eml21__MeasureClass__area_x0020per_x0020area = 17,
	eml21__MeasureClass__area_x0020per_x0020count = 18,
	eml21__MeasureClass__area_x0020per_x0020mass = 19,
	eml21__MeasureClass__area_x0020per_x0020time = 20,
	eml21__MeasureClass__area_x0020per_x0020volume = 21,
	eml21__MeasureClass__attenuation_x0020per_x0020frequency_x0020interval = 22,
	eml21__MeasureClass__capacitance = 23,
	eml21__MeasureClass__cation_x0020exchange_x0020capacity = 24,
	eml21__MeasureClass__data_x0020transfer_x0020speed = 25,
	eml21__MeasureClass__diffusion_x0020coefficient = 26,
	eml21__MeasureClass__diffusive_x0020time_x0020of_x0020flight = 27,
	eml21__MeasureClass__digital_x0020storage = 28,
	eml21__MeasureClass__dimensionless = 29,
	eml21__MeasureClass__dipole_x0020moment = 30,
	eml21__MeasureClass__dose_x0020equivalent = 31,
	eml21__MeasureClass__dynamic_x0020viscosity = 32,
	eml21__MeasureClass__electric_x0020charge = 33,
	eml21__MeasureClass__electric_x0020charge_x0020per_x0020area = 34,
	eml21__MeasureClass__electric_x0020charge_x0020per_x0020mass = 35,
	eml21__MeasureClass__electric_x0020charge_x0020per_x0020volume = 36,
	eml21__MeasureClass__electric_x0020conductance = 37,
	eml21__MeasureClass__electric_x0020conductivity = 38,
	eml21__MeasureClass__electric_x0020current = 39,
	eml21__MeasureClass__electric_x0020current_x0020density = 40,
	eml21__MeasureClass__electric_x0020field_x0020strength = 41,
	eml21__MeasureClass__electric_x0020potential_x0020difference = 42,
	eml21__MeasureClass__electric_x0020resistance = 43,
	eml21__MeasureClass__electric_x0020resistance_x0020per_x0020length = 44,
	eml21__MeasureClass__electrical_x0020resistivity = 45,
	eml21__MeasureClass__electromagnetic_x0020moment = 46,
	eml21__MeasureClass__energy = 47,
	eml21__MeasureClass__energy_x0020length_x0020per_x0020area = 48,
	eml21__MeasureClass__energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	eml21__MeasureClass__energy_x0020per_x0020area = 50,
	eml21__MeasureClass__energy_x0020per_x0020length = 51,
	eml21__MeasureClass__energy_x0020per_x0020mass = 52,
	eml21__MeasureClass__energy_x0020per_x0020mass_x0020per_x0020time = 53,
	eml21__MeasureClass__energy_x0020per_x0020volume = 54,
	eml21__MeasureClass__force = 55,
	eml21__MeasureClass__force_x0020area = 56,
	eml21__MeasureClass__force_x0020length_x0020per_x0020length = 57,
	eml21__MeasureClass__force_x0020per_x0020force = 58,
	eml21__MeasureClass__force_x0020per_x0020length = 59,
	eml21__MeasureClass__force_x0020per_x0020volume = 60,
	eml21__MeasureClass__frequency = 61,
	eml21__MeasureClass__frequency_x0020interval = 62,
	eml21__MeasureClass__heat_x0020capacity = 63,
	eml21__MeasureClass__heat_x0020flow_x0020rate = 64,
	eml21__MeasureClass__heat_x0020transfer_x0020coefficient = 'A',
	eml21__MeasureClass__illuminance = 'B',
	eml21__MeasureClass__inductance = 'C',
	eml21__MeasureClass__isothermal_x0020compressibility = 'D',
	eml21__MeasureClass__kinematic_x0020viscosity = 'E',
	eml21__MeasureClass__length = 'F',
	eml21__MeasureClass__length_x0020per_x0020length = 'G',
	eml21__MeasureClass__length_x0020per_x0020mass = 'H',
	eml21__MeasureClass__length_x0020per_x0020pressure = 'I',
	eml21__MeasureClass__length_x0020per_x0020temperature = 'J',
	eml21__MeasureClass__length_x0020per_x0020time = 'K',
	eml21__MeasureClass__length_x0020per_x0020volume = 'L',
	eml21__MeasureClass__light_x0020exposure = 'M',
	eml21__MeasureClass__linear_x0020acceleration = 'N',
	eml21__MeasureClass__linear_x0020thermal_x0020expansion = 'O',
	eml21__MeasureClass__logarithmic_x0020power_x0020ratio = 'P',
	eml21__MeasureClass__logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	eml21__MeasureClass__luminance = 'R',
	eml21__MeasureClass__luminous_x0020efficacy = 'S',
	eml21__MeasureClass__luminous_x0020flux = 'T',
	eml21__MeasureClass__luminous_x0020intensity = 'U',
	eml21__MeasureClass__magnetic_x0020dipole_x0020moment = 'V',
	eml21__MeasureClass__magnetic_x0020field_x0020strength = 'W',
	eml21__MeasureClass__magnetic_x0020flux = 'X',
	eml21__MeasureClass__magnetic_x0020flux_x0020density = 'Y',
	eml21__MeasureClass__magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	eml21__MeasureClass__magnetic_x0020permeability = 91,
	eml21__MeasureClass__magnetic_x0020vector_x0020potential = 92,
	eml21__MeasureClass__mass = 93,
	eml21__MeasureClass__mass_x0020length = 94,
	eml21__MeasureClass__mass_x0020per_x0020area = 95,
	eml21__MeasureClass__mass_x0020per_x0020energy = 96,
	eml21__MeasureClass__mass_x0020per_x0020length = 'a',
	eml21__MeasureClass__mass_x0020per_x0020mass = 'b',
	eml21__MeasureClass__mass_x0020per_x0020time = 'c',
	eml21__MeasureClass__mass_x0020per_x0020time_x0020per_x0020area = 'd',
	eml21__MeasureClass__mass_x0020per_x0020time_x0020per_x0020length = 'e',
	eml21__MeasureClass__mass_x0020per_x0020volume = 'f',
	eml21__MeasureClass__mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	eml21__MeasureClass__mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	eml21__MeasureClass__mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	eml21__MeasureClass__mobility = 'j',
	eml21__MeasureClass__molar_x0020energy = 'k',
	eml21__MeasureClass__molar_x0020heat_x0020capacity = 'l',
	eml21__MeasureClass__molar_x0020volume = 'm',
	eml21__MeasureClass__molecular_x0020weight = 'n',
	eml21__MeasureClass__moment_x0020of_x0020force = 'o',
	eml21__MeasureClass__moment_x0020of_x0020inertia = 'p',
	eml21__MeasureClass__momentum = 'q',
	eml21__MeasureClass__normalized_x0020power = 'r',
	eml21__MeasureClass__permeability_x0020length = 's',
	eml21__MeasureClass__permeability_x0020rock = 't',
	eml21__MeasureClass__permittivity = 'u',
	eml21__MeasureClass__plane_x0020angle = 'v',
	eml21__MeasureClass__potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	eml21__MeasureClass__power = 'x',
	eml21__MeasureClass__power_x0020per_x0020area = 'y',
	eml21__MeasureClass__power_x0020per_x0020power = 'z',
	eml21__MeasureClass__power_x0020per_x0020volume = 123,
	eml21__MeasureClass__pressure = 124,
	eml21__MeasureClass__pressure_x0020per_x0020pressure = 125,
	eml21__MeasureClass__pressure_x0020per_x0020time = 126,
	eml21__MeasureClass__pressure_x0020per_x0020volume = 127,
	eml21__MeasureClass__pressure_x0020squared = 128,
	eml21__MeasureClass__pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	eml21__MeasureClass__pressure_x0020time_x0020per_x0020volume = 130,
	eml21__MeasureClass__quantity_x0020of_x0020light = 131,
	eml21__MeasureClass__radiance = 132,
	eml21__MeasureClass__radiant_x0020intensity = 133,
	eml21__MeasureClass__reciprocal_x0020area = 134,
	eml21__MeasureClass__reciprocal_x0020electric_x0020potential_x0020difference = 135,
	eml21__MeasureClass__reciprocal_x0020force = 136,
	eml21__MeasureClass__reciprocal_x0020length = 137,
	eml21__MeasureClass__reciprocal_x0020mass = 138,
	eml21__MeasureClass__reciprocal_x0020mass_x0020time = 139,
	eml21__MeasureClass__reciprocal_x0020pressure = 140,
	eml21__MeasureClass__reciprocal_x0020time = 141,
	eml21__MeasureClass__reciprocal_x0020volume = 142,
	eml21__MeasureClass__reluctance = 143,
	eml21__MeasureClass__second_x0020moment_x0020of_x0020area = 144,
	eml21__MeasureClass__signaling_x0020event_x0020per_x0020time = 145,
	eml21__MeasureClass__solid_x0020angle = 146,
	eml21__MeasureClass__specific_x0020heat_x0020capacity = 147,
	eml21__MeasureClass__temperature_x0020interval = 148,
	eml21__MeasureClass__temperature_x0020interval_x0020per_x0020length = 149,
	eml21__MeasureClass__temperature_x0020interval_x0020per_x0020pressure = 150,
	eml21__MeasureClass__temperature_x0020interval_x0020per_x0020time = 151,
	eml21__MeasureClass__thermal_x0020conductance = 152,
	eml21__MeasureClass__thermal_x0020conductivity = 153,
	eml21__MeasureClass__thermal_x0020diffusivity = 154,
	eml21__MeasureClass__thermal_x0020insulance = 155,
	eml21__MeasureClass__thermal_x0020resistance = 156,
	eml21__MeasureClass__thermodynamic_x0020temperature = 157,
	eml21__MeasureClass__thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	eml21__MeasureClass__time = 159,
	eml21__MeasureClass__time_x0020per_x0020length = 160,
	eml21__MeasureClass__time_x0020per_x0020mass = 161,
	eml21__MeasureClass__time_x0020per_x0020time = 162,
	eml21__MeasureClass__time_x0020per_x0020volume = 163,
	eml21__MeasureClass__vertical_x0020coordinate = 164,
	eml21__MeasureClass__volume = 165,
	eml21__MeasureClass__volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	eml21__MeasureClass__volume_x0020per_x0020area = 167,
	eml21__MeasureClass__volume_x0020per_x0020length = 168,
	eml21__MeasureClass__volume_x0020per_x0020mass = 169,
	eml21__MeasureClass__volume_x0020per_x0020pressure = 170,
	eml21__MeasureClass__volume_x0020per_x0020rotation = 171,
	eml21__MeasureClass__volume_x0020per_x0020time = 172,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020length = 173,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020area = 174,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020length = 175,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020time = 178,
	eml21__MeasureClass__volume_x0020per_x0020time_x0020per_x0020volume = 179,
	eml21__MeasureClass__volume_x0020per_x0020volume = 180,
	eml21__MeasureClass__volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	eml21__MeasureClass__volumetric_x0020thermal_x0020expansion = 182,
	eml21__MeasureClass__unitless = 183
};
#endif

/* eml2_1ForGsoap.h:16528 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKind (1172)
/* eml21:QuantityClassKind */
enum eml21__QuantityClassKind {
	eml21__QuantityClassKind__absorbed_x0020dose = 0,
	eml21__QuantityClassKind__activity_x0020of_x0020radioactivity = 1,
	eml21__QuantityClassKind__amount_x0020of_x0020substance = 2,
	eml21__QuantityClassKind__amount_x0020of_x0020substance_x0020per_x0020amount_x0020of_x0020substance = 3,
	eml21__QuantityClassKind__amount_x0020of_x0020substance_x0020per_x0020area = 4,
	eml21__QuantityClassKind__amount_x0020of_x0020substance_x0020per_x0020time = 5,
	eml21__QuantityClassKind__amount_x0020of_x0020substance_x0020per_x0020time_x0020per_x0020area = 6,
	eml21__QuantityClassKind__amount_x0020of_x0020substance_x0020per_x0020volume = 7,
	eml21__QuantityClassKind__angle_x0020per_x0020length = 8,
	eml21__QuantityClassKind__angle_x0020per_x0020volume = 9,
	eml21__QuantityClassKind__angular_x0020acceleration = 10,
	eml21__QuantityClassKind__angular_x0020velocity = 11,
	eml21__QuantityClassKind__api_x0020gamma_x0020ray = 12,
	eml21__QuantityClassKind__api_x0020gravity = 13,
	eml21__QuantityClassKind__api_x0020neutron = 14,
	eml21__QuantityClassKind__area = 15,
	eml21__QuantityClassKind__area_x0020per_x0020amount_x0020of_x0020substance = 16,
	eml21__QuantityClassKind__area_x0020per_x0020area = 17,
	eml21__QuantityClassKind__area_x0020per_x0020count = 18,
	eml21__QuantityClassKind__area_x0020per_x0020mass = 19,
	eml21__QuantityClassKind__area_x0020per_x0020time = 20,
	eml21__QuantityClassKind__area_x0020per_x0020volume = 21,
	eml21__QuantityClassKind__attenuation_x0020per_x0020frequency_x0020interval = 22,
	eml21__QuantityClassKind__capacitance = 23,
	eml21__QuantityClassKind__cation_x0020exchange_x0020capacity = 24,
	eml21__QuantityClassKind__data_x0020transfer_x0020speed = 25,
	eml21__QuantityClassKind__diffusion_x0020coefficient = 26,
	eml21__QuantityClassKind__diffusive_x0020time_x0020of_x0020flight = 27,
	eml21__QuantityClassKind__digital_x0020storage = 28,
	eml21__QuantityClassKind__dimensionless = 29,
	eml21__QuantityClassKind__dipole_x0020moment = 30,
	eml21__QuantityClassKind__dose_x0020equivalent = 31,
	eml21__QuantityClassKind__dynamic_x0020viscosity = 32,
	eml21__QuantityClassKind__electric_x0020charge = 33,
	eml21__QuantityClassKind__electric_x0020charge_x0020per_x0020area = 34,
	eml21__QuantityClassKind__electric_x0020charge_x0020per_x0020mass = 35,
	eml21__QuantityClassKind__electric_x0020charge_x0020per_x0020volume = 36,
	eml21__QuantityClassKind__electric_x0020conductance = 37,
	eml21__QuantityClassKind__electric_x0020conductivity = 38,
	eml21__QuantityClassKind__electric_x0020current = 39,
	eml21__QuantityClassKind__electric_x0020current_x0020density = 40,
	eml21__QuantityClassKind__electric_x0020field_x0020strength = 41,
	eml21__QuantityClassKind__electric_x0020potential_x0020difference = 42,
	eml21__QuantityClassKind__electric_x0020resistance = 43,
	eml21__QuantityClassKind__electric_x0020resistance_x0020per_x0020length = 44,
	eml21__QuantityClassKind__electrical_x0020resistivity = 45,
	eml21__QuantityClassKind__electromagnetic_x0020moment = 46,
	eml21__QuantityClassKind__energy = 47,
	eml21__QuantityClassKind__energy_x0020length_x0020per_x0020area = 48,
	eml21__QuantityClassKind__energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 49,
	eml21__QuantityClassKind__energy_x0020per_x0020area = 50,
	eml21__QuantityClassKind__energy_x0020per_x0020length = 51,
	eml21__QuantityClassKind__energy_x0020per_x0020mass = 52,
	eml21__QuantityClassKind__energy_x0020per_x0020mass_x0020per_x0020time = 53,
	eml21__QuantityClassKind__energy_x0020per_x0020volume = 54,
	eml21__QuantityClassKind__force = 55,
	eml21__QuantityClassKind__force_x0020area = 56,
	eml21__QuantityClassKind__force_x0020length_x0020per_x0020length = 57,
	eml21__QuantityClassKind__force_x0020per_x0020force = 58,
	eml21__QuantityClassKind__force_x0020per_x0020length = 59,
	eml21__QuantityClassKind__force_x0020per_x0020volume = 60,
	eml21__QuantityClassKind__frequency = 61,
	eml21__QuantityClassKind__frequency_x0020interval = 62,
	eml21__QuantityClassKind__heat_x0020capacity = 63,
	eml21__QuantityClassKind__heat_x0020flow_x0020rate = 64,
	eml21__QuantityClassKind__heat_x0020transfer_x0020coefficient = 'A',
	eml21__QuantityClassKind__illuminance = 'B',
	eml21__QuantityClassKind__inductance = 'C',
	eml21__QuantityClassKind__isothermal_x0020compressibility = 'D',
	eml21__QuantityClassKind__kinematic_x0020viscosity = 'E',
	eml21__QuantityClassKind__length = 'F',
	eml21__QuantityClassKind__length_x0020per_x0020length = 'G',
	eml21__QuantityClassKind__length_x0020per_x0020mass = 'H',
	eml21__QuantityClassKind__length_x0020per_x0020pressure = 'I',
	eml21__QuantityClassKind__length_x0020per_x0020temperature = 'J',
	eml21__QuantityClassKind__length_x0020per_x0020time = 'K',
	eml21__QuantityClassKind__length_x0020per_x0020volume = 'L',
	eml21__QuantityClassKind__light_x0020exposure = 'M',
	eml21__QuantityClassKind__linear_x0020acceleration = 'N',
	eml21__QuantityClassKind__linear_x0020thermal_x0020expansion = 'O',
	eml21__QuantityClassKind__logarithmic_x0020power_x0020ratio = 'P',
	eml21__QuantityClassKind__logarithmic_x0020power_x0020ratio_x0020per_x0020length = 'Q',
	eml21__QuantityClassKind__luminance = 'R',
	eml21__QuantityClassKind__luminous_x0020efficacy = 'S',
	eml21__QuantityClassKind__luminous_x0020flux = 'T',
	eml21__QuantityClassKind__luminous_x0020intensity = 'U',
	eml21__QuantityClassKind__magnetic_x0020dipole_x0020moment = 'V',
	eml21__QuantityClassKind__magnetic_x0020field_x0020strength = 'W',
	eml21__QuantityClassKind__magnetic_x0020flux = 'X',
	eml21__QuantityClassKind__magnetic_x0020flux_x0020density = 'Y',
	eml21__QuantityClassKind__magnetic_x0020flux_x0020density_x0020per_x0020length = 'Z',
	eml21__QuantityClassKind__magnetic_x0020permeability = 91,
	eml21__QuantityClassKind__magnetic_x0020vector_x0020potential = 92,
	eml21__QuantityClassKind__mass = 93,
	eml21__QuantityClassKind__mass_x0020length = 94,
	eml21__QuantityClassKind__mass_x0020per_x0020area = 95,
	eml21__QuantityClassKind__mass_x0020per_x0020energy = 96,
	eml21__QuantityClassKind__mass_x0020per_x0020length = 'a',
	eml21__QuantityClassKind__mass_x0020per_x0020mass = 'b',
	eml21__QuantityClassKind__mass_x0020per_x0020time = 'c',
	eml21__QuantityClassKind__mass_x0020per_x0020time_x0020per_x0020area = 'd',
	eml21__QuantityClassKind__mass_x0020per_x0020time_x0020per_x0020length = 'e',
	eml21__QuantityClassKind__mass_x0020per_x0020volume = 'f',
	eml21__QuantityClassKind__mass_x0020per_x0020volume_x0020per_x0020length = 'g',
	eml21__QuantityClassKind__mass_x0020per_x0020volume_x0020per_x0020pressure = 'h',
	eml21__QuantityClassKind__mass_x0020per_x0020volume_x0020per_x0020temperature = 'i',
	eml21__QuantityClassKind__mobility = 'j',
	eml21__QuantityClassKind__molar_x0020energy = 'k',
	eml21__QuantityClassKind__molar_x0020heat_x0020capacity = 'l',
	eml21__QuantityClassKind__molar_x0020volume = 'm',
	eml21__QuantityClassKind__molecular_x0020weight = 'n',
	eml21__QuantityClassKind__moment_x0020of_x0020force = 'o',
	eml21__QuantityClassKind__moment_x0020of_x0020inertia = 'p',
	eml21__QuantityClassKind__momentum = 'q',
	eml21__QuantityClassKind__normalized_x0020power = 'r',
	eml21__QuantityClassKind__permeability_x0020length = 's',
	eml21__QuantityClassKind__permeability_x0020rock = 't',
	eml21__QuantityClassKind__permittivity = 'u',
	eml21__QuantityClassKind__plane_x0020angle = 'v',
	eml21__QuantityClassKind__potential_x0020difference_x0020per_x0020power_x0020drop = 'w',
	eml21__QuantityClassKind__power = 'x',
	eml21__QuantityClassKind__power_x0020per_x0020area = 'y',
	eml21__QuantityClassKind__power_x0020per_x0020power = 'z',
	eml21__QuantityClassKind__power_x0020per_x0020volume = 123,
	eml21__QuantityClassKind__pressure = 124,
	eml21__QuantityClassKind__pressure_x0020per_x0020pressure = 125,
	eml21__QuantityClassKind__pressure_x0020per_x0020time = 126,
	eml21__QuantityClassKind__pressure_x0020per_x0020volume = 127,
	eml21__QuantityClassKind__pressure_x0020squared = 128,
	eml21__QuantityClassKind__pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 129,
	eml21__QuantityClassKind__pressure_x0020time_x0020per_x0020volume = 130,
	eml21__QuantityClassKind__quantity_x0020of_x0020light = 131,
	eml21__QuantityClassKind__radiance = 132,
	eml21__QuantityClassKind__radiant_x0020intensity = 133,
	eml21__QuantityClassKind__reciprocal_x0020area = 134,
	eml21__QuantityClassKind__reciprocal_x0020electric_x0020potential_x0020difference = 135,
	eml21__QuantityClassKind__reciprocal_x0020force = 136,
	eml21__QuantityClassKind__reciprocal_x0020length = 137,
	eml21__QuantityClassKind__reciprocal_x0020mass = 138,
	eml21__QuantityClassKind__reciprocal_x0020mass_x0020time = 139,
	eml21__QuantityClassKind__reciprocal_x0020pressure = 140,
	eml21__QuantityClassKind__reciprocal_x0020time = 141,
	eml21__QuantityClassKind__reciprocal_x0020volume = 142,
	eml21__QuantityClassKind__reluctance = 143,
	eml21__QuantityClassKind__second_x0020moment_x0020of_x0020area = 144,
	eml21__QuantityClassKind__signaling_x0020event_x0020per_x0020time = 145,
	eml21__QuantityClassKind__solid_x0020angle = 146,
	eml21__QuantityClassKind__specific_x0020heat_x0020capacity = 147,
	eml21__QuantityClassKind__temperature_x0020interval = 148,
	eml21__QuantityClassKind__temperature_x0020interval_x0020per_x0020length = 149,
	eml21__QuantityClassKind__temperature_x0020interval_x0020per_x0020pressure = 150,
	eml21__QuantityClassKind__temperature_x0020interval_x0020per_x0020time = 151,
	eml21__QuantityClassKind__thermal_x0020conductance = 152,
	eml21__QuantityClassKind__thermal_x0020conductivity = 153,
	eml21__QuantityClassKind__thermal_x0020diffusivity = 154,
	eml21__QuantityClassKind__thermal_x0020insulance = 155,
	eml21__QuantityClassKind__thermal_x0020resistance = 156,
	eml21__QuantityClassKind__thermodynamic_x0020temperature = 157,
	eml21__QuantityClassKind__thermodynamic_x0020temperature_x0020per_x0020thermodynamic_x0020temperature = 158,
	eml21__QuantityClassKind__time = 159,
	eml21__QuantityClassKind__time_x0020per_x0020length = 160,
	eml21__QuantityClassKind__time_x0020per_x0020mass = 161,
	eml21__QuantityClassKind__time_x0020per_x0020time = 162,
	eml21__QuantityClassKind__time_x0020per_x0020volume = 163,
	eml21__QuantityClassKind__vertical_x0020coordinate = 164,
	eml21__QuantityClassKind__volume = 165,
	eml21__QuantityClassKind__volume_x0020flow_x0020rate_x0020per_x0020volume_x0020flow_x0020rate = 166,
	eml21__QuantityClassKind__volume_x0020per_x0020area = 167,
	eml21__QuantityClassKind__volume_x0020per_x0020length = 168,
	eml21__QuantityClassKind__volume_x0020per_x0020mass = 169,
	eml21__QuantityClassKind__volume_x0020per_x0020pressure = 170,
	eml21__QuantityClassKind__volume_x0020per_x0020rotation = 171,
	eml21__QuantityClassKind__volume_x0020per_x0020time = 172,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020length = 173,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020area = 174,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020length = 175,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020pressure = 176,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020pressure_x0020length = 177,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020time = 178,
	eml21__QuantityClassKind__volume_x0020per_x0020time_x0020per_x0020volume = 179,
	eml21__QuantityClassKind__volume_x0020per_x0020volume = 180,
	eml21__QuantityClassKind__volumetric_x0020heat_x0020transfer_x0020coefficient = 181,
	eml21__QuantityClassKind__volumetric_x0020thermal_x0020expansion = 182,
	eml21__QuantityClassKind__unitless = 183,
	eml21__QuantityClassKind__not_x0020a_x0020measure = 184
};
#endif

/* eml2_1ForGsoap.h:16731 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceCondition (1173)
/* eml21:ReferenceCondition */
enum eml21__ReferenceCondition {
	eml21__ReferenceCondition__0_x0020degC_x00201_x0020atm = 0,
	eml21__ReferenceCondition__0_x0020degC_x00201_x0020bar = 1,
	eml21__ReferenceCondition__15_x0020degC_x00201_x0020atm = 2,
	eml21__ReferenceCondition__15_x0020degC_x00201_x0020bar = 3,
	eml21__ReferenceCondition__20_x0020degC_x00201_x0020atm = 4,
	eml21__ReferenceCondition__20_x0020degC_x00201_x0020bar = 5,
	eml21__ReferenceCondition__25_x0020degC_x00201_x0020bar = 6,
	eml21__ReferenceCondition__60_x0020degF_x00201_x0020atm = 7,
	eml21__ReferenceCondition__60_x0020degF_x002030_x0020in_x0020Hg = 8,
	eml21__ReferenceCondition__ambient = 9
};
#endif

/* eml2_1ForGsoap.h:16761 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__WellboreDatumReference (1174)
/* eml21:WellboreDatumReference */
enum eml21__WellboreDatumReference {
	eml21__WellboreDatumReference__ground_x0020level = 0,
	eml21__WellboreDatumReference__kelly_x0020bushing = 1,
	eml21__WellboreDatumReference__mean_x0020sea_x0020level = 2,
	eml21__WellboreDatumReference__derrick_x0020floor = 3,
	eml21__WellboreDatumReference__casing_x0020flange = 4,
	eml21__WellboreDatumReference__crown_x0020valve = 5,
	eml21__WellboreDatumReference__rotary_x0020bushing = 6,
	eml21__WellboreDatumReference__rotary_x0020table = 7,
	eml21__WellboreDatumReference__sea_x0020floor = 8,
	eml21__WellboreDatumReference__lowest_x0020astronomical_x0020tide = 9,
	eml21__WellboreDatumReference__mean_x0020higher_x0020high_x0020water = 10,
	eml21__WellboreDatumReference__mean_x0020high_x0020water = 11,
	eml21__WellboreDatumReference__mean_x0020lower_x0020low_x0020water = 12,
	eml21__WellboreDatumReference__mean_x0020low_x0020water = 13,
	eml21__WellboreDatumReference__mean_x0020tide_x0020level = 14,
	eml21__WellboreDatumReference__kickoff_x0020point = 15
};
#endif

/* eml2_1ForGsoap.h:16814 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__WellStatus
#define SOAP_TYPE_gsoap_eml2_1_eml21__WellStatus (1175)
/* eml21:WellStatus */
enum eml21__WellStatus {
	eml21__WellStatus__abandoned = 0,
	eml21__WellStatus__active = 1,
	eml21__WellStatus__active_x0020_x002d__x0020injecting = 2,
	eml21__WellStatus__active_x0020_x002d__x0020producing = 3,
	eml21__WellStatus__completed = 4,
	eml21__WellStatus__drilling = 5,
	eml21__WellStatus__partially_x0020plugged = 6,
	eml21__WellStatus__permitted = 7,
	eml21__WellStatus__plugged_x0020and_x0020abandoned = 8,
	eml21__WellStatus__proposed = 9,
	eml21__WellStatus__sold = 10,
	eml21__WellStatus__suspended = 11,
	eml21__WellStatus__temporarily_x0020abandoned = 12,
	eml21__WellStatus__testing = 13,
	eml21__WellStatus__tight = 14,
	eml21__WellStatus__working_x0020over = 15,
	eml21__WellStatus__unknown = 16
};
#endif

/* eml2_1ForGsoap.h:16894 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressureKind (1176)
/* eml21:ReferencePressureKind */
enum eml21__ReferencePressureKind {
	eml21__ReferencePressureKind__absolute = 0,
	eml21__ReferencePressureKind__ambient = 1,
	eml21__ReferencePressureKind__legal = 2
};
#endif

/* eml2_1ForGsoap.h:28283 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_eml2_1__gml__RelatedTimeType_relativePosition (1608)
/* gml:RelatedTimeType-relativePosition */
enum _gml__RelatedTimeType_relativePosition {
	_gml__RelatedTimeType_relativePosition__Before = 0,
	_gml__RelatedTimeType_relativePosition__After = 1,
	_gml__RelatedTimeType_relativePosition__Begins = 2,
	_gml__RelatedTimeType_relativePosition__Ends = 3,
	_gml__RelatedTimeType_relativePosition__During = 4,
	_gml__RelatedTimeType_relativePosition__Equals = 5,
	_gml__RelatedTimeType_relativePosition__Contains = 6,
	_gml__RelatedTimeType_relativePosition__Overlaps = 7,
	_gml__RelatedTimeType_relativePosition__Meets = 8,
	_gml__RelatedTimeType_relativePosition__OverlappedBy = 9,
	_gml__RelatedTimeType_relativePosition__MetBy = 10,
	_gml__RelatedTimeType_relativePosition__BegunBy = 11,
	_gml__RelatedTimeType_relativePosition__EndedBy = 12
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class prodml2__DasCalibration;	/* eml2_1ForGsoap.h:243 */
class prodml2__DasCalibrationPoint;	/* eml2_1ForGsoap.h:246 */
class prodml2__DasCustom;	/* eml2_1ForGsoap.h:249 */
class prodml2__DasFbe;	/* eml2_1ForGsoap.h:255 */
class prodml2__DasFbeData;	/* eml2_1ForGsoap.h:258 */
class prodml2__DasProcessed;	/* eml2_1ForGsoap.h:264 */
class prodml2__DasRaw;	/* eml2_1ForGsoap.h:267 */
class prodml2__DasRawData;	/* eml2_1ForGsoap.h:270 */
class prodml2__DasSpectra;	/* eml2_1ForGsoap.h:273 */
class prodml2__DasSpectraData;	/* eml2_1ForGsoap.h:276 */
class __prodml2__DasTimeArray_sequence;	/* eml2_1ForGsoap.h:17622 */
class prodml2__DasTimeArray;	/* eml2_1ForGsoap.h:279 */
class prodml2__AbstractDtsEquipment;	/* eml2_1ForGsoap.h:282 */
class __prodml2__DtsPatchCord_sequence;	/* eml2_1ForGsoap.h:17724 */
class prodml2__DtsPatchCord;	/* eml2_1ForGsoap.h:288 */
class prodml2__DtsCalibration;	/* eml2_1ForGsoap.h:294 */
class __prodml2__AbstractDateTimeClass_sequence;	/* eml2_1ForGsoap.h:17811 */
class prodml2__AbstractDateTimeClass;	/* eml2_1ForGsoap.h:300 */
class prodml2__AbstractFluidComponent;	/* eml2_1ForGsoap.h:303 */
class prodml2__BusinessAssociate;	/* eml2_1ForGsoap.h:306 */
class prodml2__CalibrationParameter;	/* eml2_1ForGsoap.h:309 */
class prodml2__DatedComment;	/* eml2_1ForGsoap.h:312 */
class prodml2__EmailQualifierStruct;	/* eml2_1ForGsoap.h:315 */
class prodml2__EndpointQualifiedDate;	/* eml2_1ForGsoap.h:318 */
class prodml2__EndpointQualifiedDateTime;	/* eml2_1ForGsoap.h:321 */
class prodml2__FacilityIdentifier;	/* eml2_1ForGsoap.h:324 */
class prodml2__FacilityIdentifierStruct;	/* eml2_1ForGsoap.h:327 */
class prodml2__FluidComponent;	/* eml2_1ForGsoap.h:330 */
class prodml2__FluidComponentCatalog;	/* eml2_1ForGsoap.h:333 */
class prodml2__GeneralAddress;	/* eml2_1ForGsoap.h:339 */
class prodml2__GeneralMeasureType;	/* eml2_1ForGsoap.h:342 */
class prodml2__GeographicContext;	/* eml2_1ForGsoap.h:348 */
class prodml2__GeologyFeature;	/* eml2_1ForGsoap.h:351 */
class prodml2__IndexedObject;	/* eml2_1ForGsoap.h:354 */
class prodml2__LiquidComposition;	/* eml2_1ForGsoap.h:366 */
class prodml2__NorthSeaOffshore;	/* eml2_1ForGsoap.h:381 */
class prodml2__OffshoreLocation;	/* eml2_1ForGsoap.h:384 */
class prodml2__OverallComposition;	/* eml2_1ForGsoap.h:387 */
class prodml2__PersonName;	/* eml2_1ForGsoap.h:390 */
class prodml2__PhoneNumberStruct;	/* eml2_1ForGsoap.h:393 */
class prodml2__ProductFlowExternalReference;	/* eml2_1ForGsoap.h:399 */
class prodml2__ProductFlowNetwork;	/* eml2_1ForGsoap.h:402 */
class prodml2__VaporComposition;	/* eml2_1ForGsoap.h:420 */
class prodml2__VolumeQualifiedMeasure;	/* eml2_1ForGsoap.h:423 */
class prodml2__WellElevationCoord;	/* eml2_1ForGsoap.h:426 */
class prodml2__WellVerticalDepthCoord;	/* eml2_1ForGsoap.h:429 */
class prodml2__CommonPropertiesProductVolume;	/* eml2_1ForGsoap.h:432 */
union _prodml2__union_AbstractMeasureDataType;	/* eml2_1ForGsoap.h:19147 */
class prodml2__AbstractMeasureDataType;	/* eml2_1ForGsoap.h:435 */
union _prodml2__union_AbstractRefProductFlow;	/* eml2_1ForGsoap.h:19174 */
class prodml2__AbstractRefProductFlow;	/* eml2_1ForGsoap.h:438 */
class prodml2__AbstractRelatedFacilityObject;	/* eml2_1ForGsoap.h:441 */
class prodml2__CurveDefinition;	/* eml2_1ForGsoap.h:447 */
union _prodml2__union_OwnershipBusinessAcct;	/* eml2_1ForGsoap.h:19270 */
class prodml2__OwnershipBusinessAcct;	/* eml2_1ForGsoap.h:459 */
class prodml2__ProductVolumeAlert;	/* eml2_1ForGsoap.h:468 */
class prodml2__ProductVolumeBalanceDetail;	/* eml2_1ForGsoap.h:471 */
class prodml2__ProductVolumeBalanceEvent;	/* eml2_1ForGsoap.h:474 */
class prodml2__ProductVolumeBalanceSet;	/* eml2_1ForGsoap.h:477 */
class prodml2__ProductVolumeBusinessSubUnit;	/* eml2_1ForGsoap.h:480 */
class prodml2__ProductVolumeBusinessUnit;	/* eml2_1ForGsoap.h:483 */
class prodml2__ProductVolumeComponentContent;	/* eml2_1ForGsoap.h:486 */
class prodml2__ProductVolumeDestination;	/* eml2_1ForGsoap.h:489 */
class prodml2__ProductVolumeFacility;	/* eml2_1ForGsoap.h:492 */
class prodml2__ProductVolumeFlow;	/* eml2_1ForGsoap.h:495 */
class prodml2__ProductVolumeParameterSet;	/* eml2_1ForGsoap.h:498 */
class prodml2__ProductVolumeParameterValue;	/* eml2_1ForGsoap.h:501 */
class prodml2__ProductVolumePeriod;	/* eml2_1ForGsoap.h:504 */
class prodml2__ProductVolumePortDifference;	/* eml2_1ForGsoap.h:507 */
class prodml2__ProductVolumeProduct;	/* eml2_1ForGsoap.h:510 */
class __prodml2__ProductVolumeRelatedFacility_sequence;	/* eml2_1ForGsoap.h:20136 */
class prodml2__ProductVolumeRelatedFacility;	/* eml2_1ForGsoap.h:513 */
class prodml2__ConnectedNode;	/* eml2_1ForGsoap.h:522 */
class prodml2__ExpectedFlowQualifier;	/* eml2_1ForGsoap.h:525 */
class prodml2__ProductFlowChangeLog;	/* eml2_1ForGsoap.h:528 */
class prodml2__ProductFlowExpectedUnitProperty;	/* eml2_1ForGsoap.h:531 */
class prodml2__ProductFlowExternalPort;	/* eml2_1ForGsoap.h:534 */
class prodml2__ProductFlowNetworkPlan;	/* eml2_1ForGsoap.h:540 */
class prodml2__ProductFlowPort;	/* eml2_1ForGsoap.h:543 */
class prodml2__ProductFlowUnit;	/* eml2_1ForGsoap.h:549 */
class prodml2__RelativeCoordinate;	/* eml2_1ForGsoap.h:555 */
class prodml2__AbstractAttenuationMeasure;	/* eml2_1ForGsoap.h:558 */
class prodml2__AbstractCable;	/* eml2_1ForGsoap.h:561 */
class prodml2__AbstractFiberFacility;	/* eml2_1ForGsoap.h:564 */
class prodml2__FiberConveyance;	/* eml2_1ForGsoap.h:576 */
class prodml2__FiberFacilityMapping;	/* eml2_1ForGsoap.h:582 */
class prodml2__FiberFacilityMappingPart;	/* eml2_1ForGsoap.h:585 */
class prodml2__FiberOneWayAttenuation;	/* eml2_1ForGsoap.h:594 */
class prodml2__FiberOpticalPathInventory;	/* eml2_1ForGsoap.h:600 */
class prodml2__FiberOpticalPathNetwork;	/* eml2_1ForGsoap.h:603 */
class prodml2__FiberOTDR;	/* eml2_1ForGsoap.h:609 */
class __prodml2__FiberPathDefect_sequence;	/* eml2_1ForGsoap.h:21053 */
class prodml2__FiberPathDefect;	/* eml2_1ForGsoap.h:615 */
class prodml2__FiberPumpActivity;	/* eml2_1ForGsoap.h:618 */
class prodml2__FiberRefractiveIndex;	/* eml2_1ForGsoap.h:621 */
class eml21__AbstractObject;	/* eml2_1ForGsoap.h:645 */
class eml21__Citation;	/* eml2_1ForGsoap.h:648 */
class eml21__CustomData;	/* eml2_1ForGsoap.h:651 */
class eml21__ExtensionNameValue;	/* eml2_1ForGsoap.h:654 */
class eml21__ObjectAlias;	/* eml2_1ForGsoap.h:657 */
class eml21__AbstractValueArray;	/* eml2_1ForGsoap.h:675 */
class eml21__JaggedArray;	/* eml2_1ForGsoap.h:723 */
class eml21__MdInterval;	/* eml2_1ForGsoap.h:726 */
class eml21__TvdInterval;	/* eml2_1ForGsoap.h:738 */
class eml21__DataObjectReference;	/* eml2_1ForGsoap.h:1842 */
class eml21__ExternalDataset;	/* eml2_1ForGsoap.h:1848 */
class eml21__ExternalDatasetPart;	/* eml2_1ForGsoap.h:1851 */
class eml21__AbstractActivityParameter;	/* eml2_1ForGsoap.h:1854 */
class eml21__AbstractParameterKey;	/* eml2_1ForGsoap.h:1857 */
class eml21__ParameterTemplate;	/* eml2_1ForGsoap.h:1878 */
class eml21__GeologicTime;	/* eml2_1ForGsoap.h:1890 */
class eml21__TimeIndex;	/* eml2_1ForGsoap.h:1899 */
class eml21__TimeIndices;	/* eml2_1ForGsoap.h:1902 */
class eml21__TimeSeriesParentage;	/* eml2_1ForGsoap.h:1908 */
class eml21__AbstractPressureValue;	/* eml2_1ForGsoap.h:1914 */
union _eml21__union_AbstractTemperaturePressure;	/* eml2_1ForGsoap.h:21971 */
class eml21__AbstractTemperaturePressure;	/* eml2_1ForGsoap.h:1917 */
class eml21__DensityValue;	/* eml2_1ForGsoap.h:1920 */
class eml21__FlowRateValue;	/* eml2_1ForGsoap.h:1923 */
class eml21__PressureValue;	/* eml2_1ForGsoap.h:1929 */
class eml21__VolumeValue;	/* eml2_1ForGsoap.h:1944 */
class eml21__AbstractGeodeticCrs;	/* eml2_1ForGsoap.h:1947 */
class eml21__AbstractProjectedCrs;	/* eml2_1ForGsoap.h:1950 */
class eml21__AbstractVerticalCrs;	/* eml2_1ForGsoap.h:1953 */
class eml21__FailingRule;	/* eml2_1ForGsoap.h:2013 */
class eml21__IndexRange;	/* eml2_1ForGsoap.h:2016 */
class eml21__AbstractGraphicalInformation;	/* eml2_1ForGsoap.h:2019 */
class gml__AbstractGMLType;	/* eml2_1ForGsoap.h:2040 */
class gml__ReferenceType;	/* eml2_1ForGsoap.h:2046 */
union _gml__union_TimePrimitivePropertyType;	/* eml2_1ForGsoap.h:22354 */
class __gml__TimePrimitivePropertyType_sequence;	/* eml2_1ForGsoap.h:22343 */
class gml__TimePrimitivePropertyType;	/* eml2_1ForGsoap.h:2064 */
class __gml__EllipsoidalCSPropertyType_sequence;	/* eml2_1ForGsoap.h:22413 */
class gml__EllipsoidalCSPropertyType;	/* eml2_1ForGsoap.h:2067 */
class __gml__CoordinateSystemAxisPropertyType_sequence;	/* eml2_1ForGsoap.h:22473 */
class gml__CoordinateSystemAxisPropertyType;	/* eml2_1ForGsoap.h:2076 */
class __gml__CartesianCSPropertyType_sequence;	/* eml2_1ForGsoap.h:22533 */
class gml__CartesianCSPropertyType;	/* eml2_1ForGsoap.h:2082 */
class __gml__SphericalCSPropertyType_sequence;	/* eml2_1ForGsoap.h:22593 */
class gml__SphericalCSPropertyType;	/* eml2_1ForGsoap.h:2088 */
class __gml__GeodeticDatumPropertyType_sequence;	/* eml2_1ForGsoap.h:22653 */
class gml__GeodeticDatumPropertyType;	/* eml2_1ForGsoap.h:2094 */
class __gml__PrimeMeridianPropertyType_sequence;	/* eml2_1ForGsoap.h:22713 */
class gml__PrimeMeridianPropertyType;	/* eml2_1ForGsoap.h:2103 */
class __gml__EllipsoidPropertyType_sequence;	/* eml2_1ForGsoap.h:22773 */
class gml__EllipsoidPropertyType;	/* eml2_1ForGsoap.h:2115 */
union _gml__union_GeneralConversionPropertyType;	/* eml2_1ForGsoap.h:22845 */
class __gml__GeneralConversionPropertyType_sequence;	/* eml2_1ForGsoap.h:22833 */
class gml__GeneralConversionPropertyType;	/* eml2_1ForGsoap.h:2130 */
union _gml__union_CRSPropertyType;	/* eml2_1ForGsoap.h:22911 */
class __gml__CRSPropertyType_sequence;	/* eml2_1ForGsoap.h:22900 */
class gml__CRSPropertyType;	/* eml2_1ForGsoap.h:2139 */
class __gml__GeodeticCRSPropertyType_sequence;	/* eml2_1ForGsoap.h:22966 */
class gml__GeodeticCRSPropertyType;	/* eml2_1ForGsoap.h:2142 */
class __gml__VerticalCSPropertyType_sequence;	/* eml2_1ForGsoap.h:23023 */
class gml__VerticalCSPropertyType;	/* eml2_1ForGsoap.h:2148 */
class __gml__VerticalDatumPropertyType_sequence;	/* eml2_1ForGsoap.h:23083 */
class gml__VerticalDatumPropertyType;	/* eml2_1ForGsoap.h:2154 */
class __gml__domainOfValidity_sequence;	/* eml2_1ForGsoap.h:23144 */
class _gml__domainOfValidity;	/* eml2_1ForGsoap.h:2160 */
class _gml__secondDefiningParameter;	/* eml2_1ForGsoap.h:2163 */
union _gml__union_SecondDefiningParameter;	/* eml2_1ForGsoap.h:23234 */
class _gml__SecondDefiningParameter;	/* eml2_1ForGsoap.h:2166 */
union _gml__union_coordinateOperationAccuracy;	/* eml2_1ForGsoap.h:23266 */
class __gml__coordinateOperationAccuracy_sequence;	/* eml2_1ForGsoap.h:23258 */
class _gml__coordinateOperationAccuracy;	/* eml2_1ForGsoap.h:2169 */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType;	/* eml2_1ForGsoap.h:23342 */
class __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23334 */
class gmd__EX_USCOREGeographicExtent_USCOREPropertyType;	/* eml2_1ForGsoap.h:2175 */
class __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23396 */
class gmd__EX_USCORETemporalExtent_USCOREPropertyType;	/* eml2_1ForGsoap.h:2181 */
class __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23452 */
class gmd__EX_USCOREVerticalExtent_USCOREPropertyType;	/* eml2_1ForGsoap.h:2187 */
class __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23508 */
class gmd__MD_USCOREIdentifier_USCOREPropertyType;	/* eml2_1ForGsoap.h:2199 */
class __gmd__CI_USCORECitation_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23564 */
class gmd__CI_USCORECitation_USCOREPropertyType;	/* eml2_1ForGsoap.h:2205 */
class __gmd__CI_USCOREDate_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23620 */
class gmd__CI_USCOREDate_USCOREPropertyType;	/* eml2_1ForGsoap.h:2211 */
class __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23676 */
class gmd__CI_USCOREDateTypeCode_USCOREPropertyType;	/* eml2_1ForGsoap.h:2217 */
class __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23702 */
class gmd__CI_USCOREResponsibleParty_USCOREPropertyType;	/* eml2_1ForGsoap.h:2220 */
class __gmd__CI_USCOREContact_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23758 */
class gmd__CI_USCOREContact_USCOREPropertyType;	/* eml2_1ForGsoap.h:2226 */
class __gmd__CI_USCORETelephone_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23814 */
class gmd__CI_USCORETelephone_USCOREPropertyType;	/* eml2_1ForGsoap.h:2232 */
class __gmd__CI_USCOREAddress_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23870 */
class gmd__CI_USCOREAddress_USCOREPropertyType;	/* eml2_1ForGsoap.h:2238 */
class __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23926 */
class gmd__CI_USCOREOnlineResource_USCOREPropertyType;	/* eml2_1ForGsoap.h:2244 */
class __gmd__URL_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:23982 */
class gmd__URL_USCOREPropertyType;	/* eml2_1ForGsoap.h:2250 */
class __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24008 */
class gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType;	/* eml2_1ForGsoap.h:2253 */
class __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24034 */
class gmd__CI_USCORERoleCode_USCOREPropertyType;	/* eml2_1ForGsoap.h:2256 */
class __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24060 */
class gmd__CI_USCOREPresentationFormCode_USCOREPropertyType;	/* eml2_1ForGsoap.h:2259 */
class __gmd__CI_USCORESeries_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24086 */
class gmd__CI_USCORESeries_USCOREPropertyType;	/* eml2_1ForGsoap.h:2262 */
class __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24142 */
class gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType;	/* eml2_1ForGsoap.h:2268 */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType;	/* eml2_1ForGsoap.h:24176 */
class __gmd__DQ_USCOREResult_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24168 */
class gmd__DQ_USCOREResult_USCOREPropertyType;	/* eml2_1ForGsoap.h:2271 */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType;	/* eml2_1ForGsoap.h:24249 */
class __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24238 */
class gts__TM_USCOREPrimitive_USCOREPropertyType;	/* eml2_1ForGsoap.h:2277 */
class gco__AbstractObject_USCOREType;	/* eml2_1ForGsoap.h:2280 */
union _gco__union_CharacterString_USCOREPropertyType;	/* eml2_1ForGsoap.h:24363 */
class __gco__CharacterString_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24334 */
class gco__CharacterString_USCOREPropertyType;	/* eml2_1ForGsoap.h:2283 */
class __gco__Boolean_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24387 */
class gco__Boolean_USCOREPropertyType;	/* eml2_1ForGsoap.h:2286 */
class __gco__Real_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24413 */
class gco__Real_USCOREPropertyType;	/* eml2_1ForGsoap.h:2289 */
union _gco__union_Date_USCOREPropertyType;	/* eml2_1ForGsoap.h:24447 */
class gco__Date_USCOREPropertyType;	/* eml2_1ForGsoap.h:2292 */
class __gco__DateTime_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24469 */
class gco__DateTime_USCOREPropertyType;	/* eml2_1ForGsoap.h:2298 */
union _gsr__union_SC_USCORECRS_USCOREPropertyType;	/* eml2_1ForGsoap.h:24514 */
class __gsr__SC_USCORECRS_USCOREPropertyType_sequence;	/* eml2_1ForGsoap.h:24503 */
class gsr__SC_USCORECRS_USCOREPropertyType;	/* eml2_1ForGsoap.h:2301 */
class prodml2__DasAcquisition;	/* eml2_1ForGsoap.h:240 */
class __prodml2__DasExternalDatasetPart_sequence;	/* eml2_1ForGsoap.h:24730 */
class prodml2__DasExternalDatasetPart;	/* eml2_1ForGsoap.h:252 */
class prodml2__DasInstrumentBox;	/* eml2_1ForGsoap.h:261 */
class prodml2__DtsInstrumentBox;	/* eml2_1ForGsoap.h:285 */
class prodml2__Instrument;	/* eml2_1ForGsoap.h:291 */
class prodml2__DtsInstalledSystem;	/* eml2_1ForGsoap.h:297 */
class prodml2__FormationWater;	/* eml2_1ForGsoap.h:336 */
class prodml2__GeneralQualifiedMeasure;	/* eml2_1ForGsoap.h:345 */
class prodml2__IntegerQualifiedCount;	/* eml2_1ForGsoap.h:357 */
class prodml2__KindQualifiedString;	/* eml2_1ForGsoap.h:363 */
class prodml2__NaturalGas;	/* eml2_1ForGsoap.h:378 */
class __prodml2__PlusFluidComponent_sequence;	/* eml2_1ForGsoap.h:25329 */
class prodml2__PlusFluidComponent;	/* eml2_1ForGsoap.h:396 */
class __prodml2__PseudoFluidComponent_sequence;	/* eml2_1ForGsoap.h:25405 */
class prodml2__PseudoFluidComponent;	/* eml2_1ForGsoap.h:405 */
class __prodml2__PureFluidComponent_sequence;	/* eml2_1ForGsoap.h:25496 */
class prodml2__PureFluidComponent;	/* eml2_1ForGsoap.h:408 */
class prodml2__StartEndDate;	/* eml2_1ForGsoap.h:411 */
class prodml2__StartEndTime;	/* eml2_1ForGsoap.h:414 */
class prodml2__StockTankOil;	/* eml2_1ForGsoap.h:417 */
class prodml2__CurveData;	/* eml2_1ForGsoap.h:444 */
class __prodml2__FacilityParent_sequence;	/* eml2_1ForGsoap.h:25760 */
class prodml2__FacilityParent;	/* eml2_1ForGsoap.h:450 */
class __prodml2__FacilityUnitPort_sequence;	/* eml2_1ForGsoap.h:25803 */
class prodml2__FacilityUnitPort;	/* eml2_1ForGsoap.h:453 */
class prodml2__IntegerData;	/* eml2_1ForGsoap.h:456 */
class prodml2__Parentfacility;	/* eml2_1ForGsoap.h:462 */
class prodml2__ProductVolume;	/* eml2_1ForGsoap.h:465 */
class __prodml2__ReferenceFlow_sequence;	/* eml2_1ForGsoap.h:26051 */
class prodml2__ReferenceFlow;	/* eml2_1ForGsoap.h:516 */
class prodml2__StringData;	/* eml2_1ForGsoap.h:519 */
class prodml2__ProductFlowModel;	/* eml2_1ForGsoap.h:537 */
class prodml2__ProductFlowQualifierExpected;	/* eml2_1ForGsoap.h:546 */
class prodml2__Qualifier;	/* eml2_1ForGsoap.h:552 */
class prodml2__FiberCommon;	/* eml2_1ForGsoap.h:567 */
class prodml2__FiberControlLine;	/* eml2_1ForGsoap.h:573 */
class prodml2__FiberFacilityGeneric;	/* eml2_1ForGsoap.h:579 */
class prodml2__FiberFacilityPipeline;	/* eml2_1ForGsoap.h:588 */
class prodml2__FiberFacilityWell;	/* eml2_1ForGsoap.h:591 */
class prodml2__FiberOpticalPath;	/* eml2_1ForGsoap.h:597 */
class prodml2__Frequency;	/* eml2_1ForGsoap.h:633 */
class prodml2__InterventionConveyance;	/* eml2_1ForGsoap.h:636 */
class prodml2__PermanentCable;	/* eml2_1ForGsoap.h:639 */
class prodml2__WaveLength;	/* eml2_1ForGsoap.h:642 */
class eml21__AbstractBooleanArray;	/* eml2_1ForGsoap.h:660 */
class eml21__AbstractNumericArray;	/* eml2_1ForGsoap.h:669 */
class eml21__AbstractStringArray;	/* eml2_1ForGsoap.h:672 */
class eml21__EpcExternalPartReference;	/* eml2_1ForGsoap.h:1845 */
class eml21__Activity;	/* eml2_1ForGsoap.h:1860 */
class eml21__ActivityTemplate;	/* eml2_1ForGsoap.h:1863 */
class eml21__DataObjectParameter;	/* eml2_1ForGsoap.h:1866 */
class eml21__DoubleQuantityParameter;	/* eml2_1ForGsoap.h:1869 */
class eml21__IntegerQuantityParameter;	/* eml2_1ForGsoap.h:1872 */
class eml21__ObjectParameterKey;	/* eml2_1ForGsoap.h:1875 */
class eml21__StringParameter;	/* eml2_1ForGsoap.h:1881 */
class eml21__TimeIndexParameter;	/* eml2_1ForGsoap.h:1884 */
class eml21__TimeIndexParameterKey;	/* eml2_1ForGsoap.h:1887 */
class eml21__PropertyKind;	/* eml2_1ForGsoap.h:1893 */
class eml21__PropertyKindDictionary;	/* eml2_1ForGsoap.h:1896 */
class eml21__TimeSeries;	/* eml2_1ForGsoap.h:1905 */
class eml21__AbsolutePressure;	/* eml2_1ForGsoap.h:1911 */
class eml21__GaugePressure;	/* eml2_1ForGsoap.h:1926 */
union _eml21__union_ReferenceTemperaturePressure_;	/* eml2_1ForGsoap.h:27376 */
class eml21__ReferenceTemperaturePressure;	/* eml2_1ForGsoap.h:1935 */
class eml21__RelativePressure;	/* eml2_1ForGsoap.h:1938 */
class eml21__TemperaturePressure;	/* eml2_1ForGsoap.h:1941 */
class eml21__GeodeticCrs;	/* eml2_1ForGsoap.h:1956 */
class eml21__GeodeticEpsgCrs;	/* eml2_1ForGsoap.h:1959 */
class eml21__GeodeticGmlCrs;	/* eml2_1ForGsoap.h:1962 */
class eml21__GeodeticLocalAuthorityCrs;	/* eml2_1ForGsoap.h:1965 */
class eml21__GeodeticUnknownCrs;	/* eml2_1ForGsoap.h:1968 */
class eml21__GeodeticWktCrs;	/* eml2_1ForGsoap.h:1971 */
class eml21__ProjectedCrs;	/* eml2_1ForGsoap.h:1974 */
class eml21__ProjectedEpsgCrs;	/* eml2_1ForGsoap.h:1977 */
class eml21__ProjectedGmlCrs;	/* eml2_1ForGsoap.h:1980 */
class eml21__ProjectedLocalAuthorityCrs;	/* eml2_1ForGsoap.h:1983 */
class eml21__ProjectedUnknownCrs;	/* eml2_1ForGsoap.h:1986 */
class eml21__ProjectedWktCrs;	/* eml2_1ForGsoap.h:1989 */
class eml21__VerticalCrs;	/* eml2_1ForGsoap.h:1992 */
class eml21__VerticalEpsgCrs;	/* eml2_1ForGsoap.h:1995 */
class eml21__VerticalGmlCrs;	/* eml2_1ForGsoap.h:1998 */
class eml21__VerticalLocalAuthorityCrs;	/* eml2_1ForGsoap.h:2001 */
class eml21__VerticalUnknownCrs;	/* eml2_1ForGsoap.h:2004 */
class eml21__VerticalWktCrs;	/* eml2_1ForGsoap.h:2007 */
class eml21__DataAssuranceRecord;	/* eml2_1ForGsoap.h:2010 */
class eml21__GraphicalInformationSet;	/* eml2_1ForGsoap.h:2022 */
class gml__DefinitionBaseType;	/* eml2_1ForGsoap.h:2037 */
class gml__StringOrRefType;	/* eml2_1ForGsoap.h:2043 */
class gml__CodeType;	/* eml2_1ForGsoap.h:2052 */
class gml__AbstractTimeObjectType;	/* eml2_1ForGsoap.h:2058 */
class gml__RelatedTimeType;	/* eml2_1ForGsoap.h:2061 */
class gml__MeasureType;	/* eml2_1ForGsoap.h:2112 */
class gmd__EX_USCOREExtent_USCOREType;	/* eml2_1ForGsoap.h:2172 */
class gmd__AbstractEX_USCOREGeographicExtent_USCOREType;	/* eml2_1ForGsoap.h:2178 */
class gmd__EX_USCORETemporalExtent_USCOREType;	/* eml2_1ForGsoap.h:2184 */
class gmd__EX_USCOREVerticalExtent_USCOREType;	/* eml2_1ForGsoap.h:2190 */
class gmd__AbstractDQ_USCOREElement_USCOREType;	/* eml2_1ForGsoap.h:2196 */
class gmd__MD_USCOREIdentifier_USCOREType;	/* eml2_1ForGsoap.h:2202 */
class gmd__CI_USCORECitation_USCOREType;	/* eml2_1ForGsoap.h:2208 */
class gmd__CI_USCOREDate_USCOREType;	/* eml2_1ForGsoap.h:2214 */
class gmd__CI_USCOREResponsibleParty_USCOREType;	/* eml2_1ForGsoap.h:2223 */
class gmd__CI_USCOREContact_USCOREType;	/* eml2_1ForGsoap.h:2229 */
class gmd__CI_USCORETelephone_USCOREType;	/* eml2_1ForGsoap.h:2235 */
class gmd__CI_USCOREAddress_USCOREType;	/* eml2_1ForGsoap.h:2241 */
class gmd__CI_USCOREOnlineResource_USCOREType;	/* eml2_1ForGsoap.h:2247 */
class gmd__CI_USCORESeries_USCOREType;	/* eml2_1ForGsoap.h:2265 */
class gmd__AbstractDQ_USCOREResult_USCOREType;	/* eml2_1ForGsoap.h:2274 */
class gco__CodeListValue_USCOREType;	/* eml2_1ForGsoap.h:2295 */
class prodml2__KeywordValueStruct;	/* eml2_1ForGsoap.h:360 */
class prodml2__MeasuredDepthCoord;	/* eml2_1ForGsoap.h:369 */
class prodml2__MeasureOrQuantity;	/* eml2_1ForGsoap.h:372 */
class __prodml2__FiberConnection_sequence;	/* eml2_1ForGsoap.h:29029 */
class prodml2__FiberConnection;	/* eml2_1ForGsoap.h:570 */
class prodml2__FiberOpticalPathSegment;	/* eml2_1ForGsoap.h:606 */
class prodml2__FiberOTDRInstrumentBox;	/* eml2_1ForGsoap.h:612 */
class prodml2__FiberSplice;	/* eml2_1ForGsoap.h:624 */
class prodml2__FiberTerminator;	/* eml2_1ForGsoap.h:627 */
class prodml2__FiberTurnaround;	/* eml2_1ForGsoap.h:630 */
class eml21__AbstractFloatingPointArray;	/* eml2_1ForGsoap.h:663 */
class eml21__AbstractIntegerArray;	/* eml2_1ForGsoap.h:666 */
class eml21__BooleanArrayFromIndexArray;	/* eml2_1ForGsoap.h:681 */
class eml21__BooleanConstantArray;	/* eml2_1ForGsoap.h:684 */
class eml21__BooleanExternalArray;	/* eml2_1ForGsoap.h:687 */
class eml21__GenericMeasure;	/* eml2_1ForGsoap.h:705 */
class eml21__StringConstantArray;	/* eml2_1ForGsoap.h:729 */
class eml21__StringExternalArray;	/* eml2_1ForGsoap.h:732 */
class eml21__AbsorbedDoseMeasure;	/* eml2_1ForGsoap.h:741 */
class eml21__AbsorbedDoseMeasureExt;	/* eml2_1ForGsoap.h:744 */
class eml21__ActivityOfRadioactivityMeasure;	/* eml2_1ForGsoap.h:747 */
class eml21__ActivityOfRadioactivityMeasureExt;	/* eml2_1ForGsoap.h:750 */
class eml21__AmountOfSubstanceMeasure;	/* eml2_1ForGsoap.h:753 */
class eml21__AmountOfSubstanceMeasureExt;	/* eml2_1ForGsoap.h:756 */
class eml21__AmountOfSubstancePerAmountOfSubstanceMeasure;	/* eml2_1ForGsoap.h:759 */
class eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt;	/* eml2_1ForGsoap.h:762 */
class eml21__AmountOfSubstancePerAreaMeasure;	/* eml2_1ForGsoap.h:765 */
class eml21__AmountOfSubstancePerAreaMeasureExt;	/* eml2_1ForGsoap.h:768 */
class eml21__AmountOfSubstancePerTimeMeasure;	/* eml2_1ForGsoap.h:771 */
class eml21__AmountOfSubstancePerTimeMeasureExt;	/* eml2_1ForGsoap.h:774 */
class eml21__AmountOfSubstancePerTimePerAreaMeasure;	/* eml2_1ForGsoap.h:777 */
class eml21__AmountOfSubstancePerTimePerAreaMeasureExt;	/* eml2_1ForGsoap.h:780 */
class eml21__AmountOfSubstancePerVolumeMeasure;	/* eml2_1ForGsoap.h:783 */
class eml21__AmountOfSubstancePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:786 */
class eml21__AnglePerLengthMeasure;	/* eml2_1ForGsoap.h:789 */
class eml21__AnglePerLengthMeasureExt;	/* eml2_1ForGsoap.h:792 */
class eml21__AnglePerVolumeMeasure;	/* eml2_1ForGsoap.h:795 */
class eml21__AnglePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:798 */
class eml21__AngularAccelerationMeasure;	/* eml2_1ForGsoap.h:801 */
class eml21__AngularAccelerationMeasureExt;	/* eml2_1ForGsoap.h:804 */
class eml21__AngularVelocityMeasure;	/* eml2_1ForGsoap.h:807 */
class eml21__AngularVelocityMeasureExt;	/* eml2_1ForGsoap.h:810 */
class eml21__APIGammaRayMeasure;	/* eml2_1ForGsoap.h:813 */
class eml21__APIGammaRayMeasureExt;	/* eml2_1ForGsoap.h:816 */
class eml21__APIGravityMeasure;	/* eml2_1ForGsoap.h:819 */
class eml21__APIGravityMeasureExt;	/* eml2_1ForGsoap.h:822 */
class eml21__APINeutronMeasure;	/* eml2_1ForGsoap.h:825 */
class eml21__APINeutronMeasureExt;	/* eml2_1ForGsoap.h:828 */
class eml21__AreaMeasure;	/* eml2_1ForGsoap.h:831 */
class eml21__AreaMeasureExt;	/* eml2_1ForGsoap.h:834 */
class eml21__AreaPerAmountOfSubstanceMeasure;	/* eml2_1ForGsoap.h:837 */
class eml21__AreaPerAmountOfSubstanceMeasureExt;	/* eml2_1ForGsoap.h:840 */
class eml21__AreaPerAreaMeasure;	/* eml2_1ForGsoap.h:843 */
class eml21__AreaPerAreaMeasureExt;	/* eml2_1ForGsoap.h:846 */
class eml21__AreaPerCountMeasure;	/* eml2_1ForGsoap.h:849 */
class eml21__AreaPerCountMeasureExt;	/* eml2_1ForGsoap.h:852 */
class eml21__AreaPerMassMeasure;	/* eml2_1ForGsoap.h:855 */
class eml21__AreaPerMassMeasureExt;	/* eml2_1ForGsoap.h:858 */
class eml21__AreaPerTimeMeasure;	/* eml2_1ForGsoap.h:861 */
class eml21__AreaPerTimeMeasureExt;	/* eml2_1ForGsoap.h:864 */
class eml21__AreaPerVolumeMeasure;	/* eml2_1ForGsoap.h:867 */
class eml21__AreaPerVolumeMeasureExt;	/* eml2_1ForGsoap.h:870 */
class eml21__AttenuationPerFrequencyIntervalMeasure;	/* eml2_1ForGsoap.h:873 */
class eml21__AttenuationPerFrequencyIntervalMeasureExt;	/* eml2_1ForGsoap.h:876 */
class eml21__CapacitanceMeasure;	/* eml2_1ForGsoap.h:879 */
class eml21__CapacitanceMeasureExt;	/* eml2_1ForGsoap.h:882 */
class eml21__CationExchangeCapacityMeasure;	/* eml2_1ForGsoap.h:885 */
class eml21__CationExchangeCapacityMeasureExt;	/* eml2_1ForGsoap.h:888 */
class eml21__DataTransferSpeedMeasure;	/* eml2_1ForGsoap.h:891 */
class eml21__DataTransferSpeedMeasureExt;	/* eml2_1ForGsoap.h:894 */
class eml21__DiffusionCoefficientMeasure;	/* eml2_1ForGsoap.h:897 */
class eml21__DiffusionCoefficientMeasureExt;	/* eml2_1ForGsoap.h:900 */
class eml21__DiffusiveTimeOfFlightMeasure;	/* eml2_1ForGsoap.h:903 */
class eml21__DiffusiveTimeOfFlightMeasureExt;	/* eml2_1ForGsoap.h:906 */
class eml21__DigitalStorageMeasure;	/* eml2_1ForGsoap.h:909 */
class eml21__DigitalStorageMeasureExt;	/* eml2_1ForGsoap.h:912 */
class eml21__DimensionlessMeasure;	/* eml2_1ForGsoap.h:915 */
class eml21__DimensionlessMeasureExt;	/* eml2_1ForGsoap.h:918 */
class eml21__DipoleMomentMeasure;	/* eml2_1ForGsoap.h:921 */
class eml21__DipoleMomentMeasureExt;	/* eml2_1ForGsoap.h:924 */
class eml21__DoseEquivalentMeasure;	/* eml2_1ForGsoap.h:927 */
class eml21__DoseEquivalentMeasureExt;	/* eml2_1ForGsoap.h:930 */
class eml21__DynamicViscosityMeasure;	/* eml2_1ForGsoap.h:933 */
class eml21__DynamicViscosityMeasureExt;	/* eml2_1ForGsoap.h:936 */
class eml21__ElectricalResistivityMeasure;	/* eml2_1ForGsoap.h:939 */
class eml21__ElectricalResistivityMeasureExt;	/* eml2_1ForGsoap.h:942 */
class eml21__ElectricChargeMeasure;	/* eml2_1ForGsoap.h:945 */
class eml21__ElectricChargeMeasureExt;	/* eml2_1ForGsoap.h:948 */
class eml21__ElectricChargePerAreaMeasure;	/* eml2_1ForGsoap.h:951 */
class eml21__ElectricChargePerAreaMeasureExt;	/* eml2_1ForGsoap.h:954 */
class eml21__ElectricChargePerMassMeasure;	/* eml2_1ForGsoap.h:957 */
class eml21__ElectricChargePerMassMeasureExt;	/* eml2_1ForGsoap.h:960 */
class eml21__ElectricChargePerVolumeMeasure;	/* eml2_1ForGsoap.h:963 */
class eml21__ElectricChargePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:966 */
class eml21__ElectricConductanceMeasure;	/* eml2_1ForGsoap.h:969 */
class eml21__ElectricConductanceMeasureExt;	/* eml2_1ForGsoap.h:972 */
class eml21__ElectricConductivityMeasure;	/* eml2_1ForGsoap.h:975 */
class eml21__ElectricConductivityMeasureExt;	/* eml2_1ForGsoap.h:978 */
class eml21__ElectricCurrentDensityMeasure;	/* eml2_1ForGsoap.h:981 */
class eml21__ElectricCurrentDensityMeasureExt;	/* eml2_1ForGsoap.h:984 */
class eml21__ElectricCurrentMeasure;	/* eml2_1ForGsoap.h:987 */
class eml21__ElectricCurrentMeasureExt;	/* eml2_1ForGsoap.h:990 */
class eml21__ElectricFieldStrengthMeasure;	/* eml2_1ForGsoap.h:993 */
class eml21__ElectricFieldStrengthMeasureExt;	/* eml2_1ForGsoap.h:996 */
class eml21__ElectricPotentialDifferenceMeasure;	/* eml2_1ForGsoap.h:999 */
class eml21__ElectricPotentialDifferenceMeasureExt;	/* eml2_1ForGsoap.h:1002 */
class eml21__ElectricResistanceMeasure;	/* eml2_1ForGsoap.h:1005 */
class eml21__ElectricResistanceMeasureExt;	/* eml2_1ForGsoap.h:1008 */
class eml21__ElectricResistancePerLengthMeasure;	/* eml2_1ForGsoap.h:1011 */
class eml21__ElectricResistancePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1014 */
class eml21__ElectromagneticMomentMeasure;	/* eml2_1ForGsoap.h:1017 */
class eml21__ElectromagneticMomentMeasureExt;	/* eml2_1ForGsoap.h:1020 */
class eml21__EnergyLengthPerAreaMeasure;	/* eml2_1ForGsoap.h:1023 */
class eml21__EnergyLengthPerAreaMeasureExt;	/* eml2_1ForGsoap.h:1026 */
class eml21__EnergyLengthPerTimeAreaTemperatureMeasure;	/* eml2_1ForGsoap.h:1029 */
class eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt;	/* eml2_1ForGsoap.h:1032 */
class eml21__EnergyMeasure;	/* eml2_1ForGsoap.h:1035 */
class eml21__EnergyMeasureExt;	/* eml2_1ForGsoap.h:1038 */
class eml21__EnergyPerAreaMeasure;	/* eml2_1ForGsoap.h:1041 */
class eml21__EnergyPerAreaMeasureExt;	/* eml2_1ForGsoap.h:1044 */
class eml21__EnergyPerLengthMeasure;	/* eml2_1ForGsoap.h:1047 */
class eml21__EnergyPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1050 */
class eml21__EnergyPerMassMeasure;	/* eml2_1ForGsoap.h:1053 */
class eml21__EnergyPerMassMeasureExt;	/* eml2_1ForGsoap.h:1056 */
class eml21__EnergyPerMassPerTimeMeasure;	/* eml2_1ForGsoap.h:1059 */
class eml21__EnergyPerMassPerTimeMeasureExt;	/* eml2_1ForGsoap.h:1062 */
class eml21__EnergyPerVolumeMeasure;	/* eml2_1ForGsoap.h:1065 */
class eml21__EnergyPerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1068 */
class eml21__ForceAreaMeasure;	/* eml2_1ForGsoap.h:1071 */
class eml21__ForceAreaMeasureExt;	/* eml2_1ForGsoap.h:1074 */
class eml21__ForceLengthPerLengthMeasure;	/* eml2_1ForGsoap.h:1077 */
class eml21__ForceLengthPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1080 */
class eml21__ForceMeasure;	/* eml2_1ForGsoap.h:1083 */
class eml21__ForceMeasureExt;	/* eml2_1ForGsoap.h:1086 */
class eml21__ForcePerForceMeasure;	/* eml2_1ForGsoap.h:1089 */
class eml21__ForcePerForceMeasureExt;	/* eml2_1ForGsoap.h:1092 */
class eml21__ForcePerLengthMeasure;	/* eml2_1ForGsoap.h:1095 */
class eml21__ForcePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1098 */
class eml21__ForcePerVolumeMeasure;	/* eml2_1ForGsoap.h:1101 */
class eml21__ForcePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1104 */
class eml21__FrequencyIntervalMeasure;	/* eml2_1ForGsoap.h:1107 */
class eml21__FrequencyIntervalMeasureExt;	/* eml2_1ForGsoap.h:1110 */
class eml21__FrequencyMeasure;	/* eml2_1ForGsoap.h:1113 */
class eml21__FrequencyMeasureExt;	/* eml2_1ForGsoap.h:1116 */
class eml21__HeatCapacityMeasure;	/* eml2_1ForGsoap.h:1119 */
class eml21__HeatCapacityMeasureExt;	/* eml2_1ForGsoap.h:1122 */
class eml21__HeatFlowRateMeasure;	/* eml2_1ForGsoap.h:1125 */
class eml21__HeatFlowRateMeasureExt;	/* eml2_1ForGsoap.h:1128 */
class eml21__HeatTransferCoefficientMeasure;	/* eml2_1ForGsoap.h:1131 */
class eml21__HeatTransferCoefficientMeasureExt;	/* eml2_1ForGsoap.h:1134 */
class eml21__IlluminanceMeasure;	/* eml2_1ForGsoap.h:1137 */
class eml21__IlluminanceMeasureExt;	/* eml2_1ForGsoap.h:1140 */
class eml21__InductanceMeasure;	/* eml2_1ForGsoap.h:1143 */
class eml21__InductanceMeasureExt;	/* eml2_1ForGsoap.h:1146 */
class eml21__IsothermalCompressibilityMeasure;	/* eml2_1ForGsoap.h:1149 */
class eml21__IsothermalCompressibilityMeasureExt;	/* eml2_1ForGsoap.h:1152 */
class eml21__KinematicViscosityMeasure;	/* eml2_1ForGsoap.h:1155 */
class eml21__KinematicViscosityMeasureExt;	/* eml2_1ForGsoap.h:1158 */
class eml21__LengthMeasure;	/* eml2_1ForGsoap.h:1161 */
class eml21__LengthMeasureExt;	/* eml2_1ForGsoap.h:1164 */
class eml21__LengthPerLengthMeasure;	/* eml2_1ForGsoap.h:1167 */
class eml21__LengthPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1170 */
class eml21__LengthPerMassMeasure;	/* eml2_1ForGsoap.h:1173 */
class eml21__LengthPerMassMeasureExt;	/* eml2_1ForGsoap.h:1176 */
class eml21__LengthPerPressureMeasure;	/* eml2_1ForGsoap.h:1179 */
class eml21__LengthPerPressureMeasureExt;	/* eml2_1ForGsoap.h:1182 */
class eml21__LengthPerTemperatureMeasure;	/* eml2_1ForGsoap.h:1185 */
class eml21__LengthPerTemperatureMeasureExt;	/* eml2_1ForGsoap.h:1188 */
class eml21__LengthPerTimeMeasure;	/* eml2_1ForGsoap.h:1191 */
class eml21__LengthPerTimeMeasureExt;	/* eml2_1ForGsoap.h:1194 */
class eml21__LengthPerVolumeMeasure;	/* eml2_1ForGsoap.h:1197 */
class eml21__LengthPerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1200 */
class eml21__LightExposureMeasure;	/* eml2_1ForGsoap.h:1203 */
class eml21__LightExposureMeasureExt;	/* eml2_1ForGsoap.h:1206 */
class eml21__LinearAccelerationMeasure;	/* eml2_1ForGsoap.h:1209 */
class eml21__LinearAccelerationMeasureExt;	/* eml2_1ForGsoap.h:1212 */
class eml21__LinearThermalExpansionMeasure;	/* eml2_1ForGsoap.h:1215 */
class eml21__LinearThermalExpansionMeasureExt;	/* eml2_1ForGsoap.h:1218 */
class eml21__LogarithmicPowerRatioMeasure;	/* eml2_1ForGsoap.h:1221 */
class eml21__LogarithmicPowerRatioMeasureExt;	/* eml2_1ForGsoap.h:1224 */
class eml21__LogarithmicPowerRatioPerLengthMeasure;	/* eml2_1ForGsoap.h:1227 */
class eml21__LogarithmicPowerRatioPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1230 */
class eml21__LuminanceMeasure;	/* eml2_1ForGsoap.h:1233 */
class eml21__LuminanceMeasureExt;	/* eml2_1ForGsoap.h:1236 */
class eml21__LuminousEfficacyMeasure;	/* eml2_1ForGsoap.h:1239 */
class eml21__LuminousEfficacyMeasureExt;	/* eml2_1ForGsoap.h:1242 */
class eml21__LuminousFluxMeasure;	/* eml2_1ForGsoap.h:1245 */
class eml21__LuminousFluxMeasureExt;	/* eml2_1ForGsoap.h:1248 */
class eml21__LuminousIntensityMeasure;	/* eml2_1ForGsoap.h:1251 */
class eml21__LuminousIntensityMeasureExt;	/* eml2_1ForGsoap.h:1254 */
class eml21__MagneticDipoleMomentMeasure;	/* eml2_1ForGsoap.h:1257 */
class eml21__MagneticDipoleMomentMeasureExt;	/* eml2_1ForGsoap.h:1260 */
class eml21__MagneticFieldStrengthMeasure;	/* eml2_1ForGsoap.h:1263 */
class eml21__MagneticFieldStrengthMeasureExt;	/* eml2_1ForGsoap.h:1266 */
class eml21__MagneticFluxDensityMeasure;	/* eml2_1ForGsoap.h:1269 */
class eml21__MagneticFluxDensityMeasureExt;	/* eml2_1ForGsoap.h:1272 */
class eml21__MagneticFluxDensityPerLengthMeasure;	/* eml2_1ForGsoap.h:1275 */
class eml21__MagneticFluxDensityPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1278 */
class eml21__MagneticFluxMeasure;	/* eml2_1ForGsoap.h:1281 */
class eml21__MagneticFluxMeasureExt;	/* eml2_1ForGsoap.h:1284 */
class eml21__MagneticPermeabilityMeasure;	/* eml2_1ForGsoap.h:1287 */
class eml21__MagneticPermeabilityMeasureExt;	/* eml2_1ForGsoap.h:1290 */
class eml21__MagneticVectorPotentialMeasure;	/* eml2_1ForGsoap.h:1293 */
class eml21__MagneticVectorPotentialMeasureExt;	/* eml2_1ForGsoap.h:1296 */
class eml21__MassLengthMeasure;	/* eml2_1ForGsoap.h:1299 */
class eml21__MassLengthMeasureExt;	/* eml2_1ForGsoap.h:1302 */
class eml21__MassMeasure;	/* eml2_1ForGsoap.h:1305 */
class eml21__MassMeasureExt;	/* eml2_1ForGsoap.h:1308 */
class eml21__MassPerAreaMeasure;	/* eml2_1ForGsoap.h:1311 */
class eml21__MassPerAreaMeasureExt;	/* eml2_1ForGsoap.h:1314 */
class eml21__MassPerEnergyMeasure;	/* eml2_1ForGsoap.h:1317 */
class eml21__MassPerEnergyMeasureExt;	/* eml2_1ForGsoap.h:1320 */
class eml21__MassPerLengthMeasure;	/* eml2_1ForGsoap.h:1323 */
class eml21__MassPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1326 */
class eml21__MassPerMassMeasure;	/* eml2_1ForGsoap.h:1329 */
class eml21__MassPerMassMeasureExt;	/* eml2_1ForGsoap.h:1332 */
class eml21__MassPerTimeMeasure;	/* eml2_1ForGsoap.h:1335 */
class eml21__MassPerTimeMeasureExt;	/* eml2_1ForGsoap.h:1338 */
class eml21__MassPerTimePerAreaMeasure;	/* eml2_1ForGsoap.h:1341 */
class eml21__MassPerTimePerAreaMeasureExt;	/* eml2_1ForGsoap.h:1344 */
class eml21__MassPerTimePerLengthMeasure;	/* eml2_1ForGsoap.h:1347 */
class eml21__MassPerTimePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1350 */
class eml21__MassPerVolumeMeasure;	/* eml2_1ForGsoap.h:1353 */
class eml21__MassPerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1356 */
class eml21__MassPerVolumePerLengthMeasure;	/* eml2_1ForGsoap.h:1359 */
class eml21__MassPerVolumePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1362 */
class eml21__MassPerVolumePerPressureMeasure;	/* eml2_1ForGsoap.h:1365 */
class eml21__MassPerVolumePerPressureMeasureExt;	/* eml2_1ForGsoap.h:1368 */
class eml21__MassPerVolumePerTemperatureMeasure;	/* eml2_1ForGsoap.h:1371 */
class eml21__MassPerVolumePerTemperatureMeasureExt;	/* eml2_1ForGsoap.h:1374 */
class eml21__MobilityMeasure;	/* eml2_1ForGsoap.h:1377 */
class eml21__MobilityMeasureExt;	/* eml2_1ForGsoap.h:1380 */
class eml21__MolarEnergyMeasure;	/* eml2_1ForGsoap.h:1383 */
class eml21__MolarEnergyMeasureExt;	/* eml2_1ForGsoap.h:1386 */
class eml21__MolarHeatCapacityMeasure;	/* eml2_1ForGsoap.h:1389 */
class eml21__MolarHeatCapacityMeasureExt;	/* eml2_1ForGsoap.h:1392 */
class eml21__MolarVolumeMeasure;	/* eml2_1ForGsoap.h:1395 */
class eml21__MolarVolumeMeasureExt;	/* eml2_1ForGsoap.h:1398 */
class eml21__MolecularWeightMeasure;	/* eml2_1ForGsoap.h:1401 */
class eml21__MolecularWeightMeasureExt;	/* eml2_1ForGsoap.h:1404 */
class eml21__MomentOfForceMeasure;	/* eml2_1ForGsoap.h:1407 */
class eml21__MomentOfForceMeasureExt;	/* eml2_1ForGsoap.h:1410 */
class eml21__MomentOfInertiaMeasure;	/* eml2_1ForGsoap.h:1413 */
class eml21__MomentOfInertiaMeasureExt;	/* eml2_1ForGsoap.h:1416 */
class eml21__MomentumMeasure;	/* eml2_1ForGsoap.h:1419 */
class eml21__MomentumMeasureExt;	/* eml2_1ForGsoap.h:1422 */
class eml21__NormalizedPowerMeasure;	/* eml2_1ForGsoap.h:1425 */
class eml21__NormalizedPowerMeasureExt;	/* eml2_1ForGsoap.h:1428 */
class eml21__PermeabilityLengthMeasure;	/* eml2_1ForGsoap.h:1431 */
class eml21__PermeabilityLengthMeasureExt;	/* eml2_1ForGsoap.h:1434 */
class eml21__PermeabilityRockMeasure;	/* eml2_1ForGsoap.h:1437 */
class eml21__PermeabilityRockMeasureExt;	/* eml2_1ForGsoap.h:1440 */
class eml21__PermittivityMeasure;	/* eml2_1ForGsoap.h:1443 */
class eml21__PermittivityMeasureExt;	/* eml2_1ForGsoap.h:1446 */
class eml21__PlaneAngleMeasure;	/* eml2_1ForGsoap.h:1449 */
class eml21__PlaneAngleMeasureExt;	/* eml2_1ForGsoap.h:1452 */
class eml21__PotentialDifferencePerPowerDropMeasure;	/* eml2_1ForGsoap.h:1455 */
class eml21__PotentialDifferencePerPowerDropMeasureExt;	/* eml2_1ForGsoap.h:1458 */
class eml21__PowerMeasure;	/* eml2_1ForGsoap.h:1461 */
class eml21__PowerMeasureExt;	/* eml2_1ForGsoap.h:1464 */
class eml21__PowerPerAreaMeasure;	/* eml2_1ForGsoap.h:1467 */
class eml21__PowerPerAreaMeasureExt;	/* eml2_1ForGsoap.h:1470 */
class eml21__PowerPerPowerMeasure;	/* eml2_1ForGsoap.h:1473 */
class eml21__PowerPerPowerMeasureExt;	/* eml2_1ForGsoap.h:1476 */
class eml21__PowerPerVolumeMeasure;	/* eml2_1ForGsoap.h:1479 */
class eml21__PowerPerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1482 */
class eml21__PressureMeasure;	/* eml2_1ForGsoap.h:1485 */
class eml21__PressureMeasureExt;	/* eml2_1ForGsoap.h:1488 */
class eml21__PressurePerPressureMeasure;	/* eml2_1ForGsoap.h:1491 */
class eml21__PressurePerPressureMeasureExt;	/* eml2_1ForGsoap.h:1494 */
class eml21__PressurePerTimeMeasure;	/* eml2_1ForGsoap.h:1497 */
class eml21__PressurePerTimeMeasureExt;	/* eml2_1ForGsoap.h:1500 */
class eml21__PressurePerVolumeMeasure;	/* eml2_1ForGsoap.h:1503 */
class eml21__PressurePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1506 */
class eml21__PressureSquaredMeasure;	/* eml2_1ForGsoap.h:1509 */
class eml21__PressureSquaredMeasureExt;	/* eml2_1ForGsoap.h:1512 */
class eml21__PressureSquaredPerForceTimePerAreaMeasure;	/* eml2_1ForGsoap.h:1515 */
class eml21__PressureSquaredPerForceTimePerAreaMeasureExt;	/* eml2_1ForGsoap.h:1518 */
class eml21__PressureTimePerVolumeMeasure;	/* eml2_1ForGsoap.h:1521 */
class eml21__PressureTimePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1524 */
class eml21__QuantityOfLightMeasure;	/* eml2_1ForGsoap.h:1527 */
class eml21__QuantityOfLightMeasureExt;	/* eml2_1ForGsoap.h:1530 */
class eml21__RadianceMeasure;	/* eml2_1ForGsoap.h:1533 */
class eml21__RadianceMeasureExt;	/* eml2_1ForGsoap.h:1536 */
class eml21__RadiantIntensityMeasure;	/* eml2_1ForGsoap.h:1539 */
class eml21__RadiantIntensityMeasureExt;	/* eml2_1ForGsoap.h:1542 */
class eml21__ReciprocalAreaMeasure;	/* eml2_1ForGsoap.h:1545 */
class eml21__ReciprocalAreaMeasureExt;	/* eml2_1ForGsoap.h:1548 */
class eml21__ReciprocalElectricPotentialDifferenceMeasure;	/* eml2_1ForGsoap.h:1551 */
class eml21__ReciprocalElectricPotentialDifferenceMeasureExt;	/* eml2_1ForGsoap.h:1554 */
class eml21__ReciprocalForceMeasure;	/* eml2_1ForGsoap.h:1557 */
class eml21__ReciprocalForceMeasureExt;	/* eml2_1ForGsoap.h:1560 */
class eml21__ReciprocalLengthMeasure;	/* eml2_1ForGsoap.h:1563 */
class eml21__ReciprocalLengthMeasureExt;	/* eml2_1ForGsoap.h:1566 */
class eml21__ReciprocalMassMeasure;	/* eml2_1ForGsoap.h:1569 */
class eml21__ReciprocalMassMeasureExt;	/* eml2_1ForGsoap.h:1572 */
class eml21__ReciprocalMassTimeMeasure;	/* eml2_1ForGsoap.h:1575 */
class eml21__ReciprocalMassTimeMeasureExt;	/* eml2_1ForGsoap.h:1578 */
class eml21__ReciprocalPressureMeasure;	/* eml2_1ForGsoap.h:1581 */
class eml21__ReciprocalPressureMeasureExt;	/* eml2_1ForGsoap.h:1584 */
class eml21__ReciprocalTimeMeasure;	/* eml2_1ForGsoap.h:1587 */
class eml21__ReciprocalTimeMeasureExt;	/* eml2_1ForGsoap.h:1590 */
class eml21__ReciprocalVolumeMeasure;	/* eml2_1ForGsoap.h:1593 */
class eml21__ReciprocalVolumeMeasureExt;	/* eml2_1ForGsoap.h:1596 */
class eml21__ReluctanceMeasure;	/* eml2_1ForGsoap.h:1599 */
class eml21__ReluctanceMeasureExt;	/* eml2_1ForGsoap.h:1602 */
class eml21__SecondMomentOfAreaMeasure;	/* eml2_1ForGsoap.h:1605 */
class eml21__SecondMomentOfAreaMeasureExt;	/* eml2_1ForGsoap.h:1608 */
class eml21__SignalingEventPerTimeMeasure;	/* eml2_1ForGsoap.h:1611 */
class eml21__SignalingEventPerTimeMeasureExt;	/* eml2_1ForGsoap.h:1614 */
class eml21__SolidAngleMeasure;	/* eml2_1ForGsoap.h:1617 */
class eml21__SolidAngleMeasureExt;	/* eml2_1ForGsoap.h:1620 */
class eml21__SpecificHeatCapacityMeasure;	/* eml2_1ForGsoap.h:1623 */
class eml21__SpecificHeatCapacityMeasureExt;	/* eml2_1ForGsoap.h:1626 */
class eml21__TemperatureIntervalMeasure;	/* eml2_1ForGsoap.h:1629 */
class eml21__TemperatureIntervalMeasureExt;	/* eml2_1ForGsoap.h:1632 */
class eml21__TemperatureIntervalPerLengthMeasure;	/* eml2_1ForGsoap.h:1635 */
class eml21__TemperatureIntervalPerLengthMeasureExt;	/* eml2_1ForGsoap.h:1638 */
class eml21__TemperatureIntervalPerPressureMeasure;	/* eml2_1ForGsoap.h:1641 */
class eml21__TemperatureIntervalPerPressureMeasureExt;	/* eml2_1ForGsoap.h:1644 */
class eml21__TemperatureIntervalPerTimeMeasure;	/* eml2_1ForGsoap.h:1647 */
class eml21__TemperatureIntervalPerTimeMeasureExt;	/* eml2_1ForGsoap.h:1650 */
class eml21__ThermalConductanceMeasure;	/* eml2_1ForGsoap.h:1653 */
class eml21__ThermalConductanceMeasureExt;	/* eml2_1ForGsoap.h:1656 */
class eml21__ThermalConductivityMeasure;	/* eml2_1ForGsoap.h:1659 */
class eml21__ThermalConductivityMeasureExt;	/* eml2_1ForGsoap.h:1662 */
class eml21__ThermalDiffusivityMeasure;	/* eml2_1ForGsoap.h:1665 */
class eml21__ThermalDiffusivityMeasureExt;	/* eml2_1ForGsoap.h:1668 */
class eml21__ThermalInsulanceMeasure;	/* eml2_1ForGsoap.h:1671 */
class eml21__ThermalInsulanceMeasureExt;	/* eml2_1ForGsoap.h:1674 */
class eml21__ThermalResistanceMeasure;	/* eml2_1ForGsoap.h:1677 */
class eml21__ThermalResistanceMeasureExt;	/* eml2_1ForGsoap.h:1680 */
class eml21__ThermodynamicTemperatureMeasure;	/* eml2_1ForGsoap.h:1683 */
class eml21__ThermodynamicTemperatureMeasureExt;	/* eml2_1ForGsoap.h:1686 */
class eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure;	/* eml2_1ForGsoap.h:1689 */
class eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt;	/* eml2_1ForGsoap.h:1692 */
class eml21__TimeMeasure;	/* eml2_1ForGsoap.h:1695 */
class eml21__TimeMeasureExt;	/* eml2_1ForGsoap.h:1698 */
class eml21__TimePerLengthMeasure;	/* eml2_1ForGsoap.h:1701 */
class eml21__TimePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1704 */
class eml21__TimePerMassMeasure;	/* eml2_1ForGsoap.h:1707 */
class eml21__TimePerMassMeasureExt;	/* eml2_1ForGsoap.h:1710 */
class eml21__TimePerTimeMeasure;	/* eml2_1ForGsoap.h:1713 */
class eml21__TimePerTimeMeasureExt;	/* eml2_1ForGsoap.h:1716 */
class eml21__TimePerVolumeMeasure;	/* eml2_1ForGsoap.h:1719 */
class eml21__TimePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1722 */
class eml21__UnitlessMeasure;	/* eml2_1ForGsoap.h:1725 */
class eml21__VerticalCoordinateMeasure;	/* eml2_1ForGsoap.h:1728 */
class eml21__VerticalCoordinateMeasureExt;	/* eml2_1ForGsoap.h:1731 */
class eml21__VolumeFlowRatePerVolumeFlowRateMeasure;	/* eml2_1ForGsoap.h:1734 */
class eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt;	/* eml2_1ForGsoap.h:1737 */
class eml21__VolumeMeasure;	/* eml2_1ForGsoap.h:1740 */
class eml21__VolumeMeasureExt;	/* eml2_1ForGsoap.h:1743 */
class eml21__VolumePerAreaMeasure;	/* eml2_1ForGsoap.h:1746 */
class eml21__VolumePerAreaMeasureExt;	/* eml2_1ForGsoap.h:1749 */
class eml21__VolumePerLengthMeasure;	/* eml2_1ForGsoap.h:1752 */
class eml21__VolumePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1755 */
class eml21__VolumePerMassMeasure;	/* eml2_1ForGsoap.h:1758 */
class eml21__VolumePerMassMeasureExt;	/* eml2_1ForGsoap.h:1761 */
class eml21__VolumePerPressureMeasure;	/* eml2_1ForGsoap.h:1764 */
class eml21__VolumePerPressureMeasureExt;	/* eml2_1ForGsoap.h:1767 */
class eml21__VolumePerRotationMeasure;	/* eml2_1ForGsoap.h:1770 */
class eml21__VolumePerRotationMeasureExt;	/* eml2_1ForGsoap.h:1773 */
class eml21__VolumePerTimeLengthMeasure;	/* eml2_1ForGsoap.h:1776 */
class eml21__VolumePerTimeLengthMeasureExt;	/* eml2_1ForGsoap.h:1779 */
class eml21__VolumePerTimeMeasure;	/* eml2_1ForGsoap.h:1782 */
class eml21__VolumePerTimeMeasureExt;	/* eml2_1ForGsoap.h:1785 */
class eml21__VolumePerTimePerAreaMeasure;	/* eml2_1ForGsoap.h:1788 */
class eml21__VolumePerTimePerAreaMeasureExt;	/* eml2_1ForGsoap.h:1791 */
class eml21__VolumePerTimePerLengthMeasure;	/* eml2_1ForGsoap.h:1794 */
class eml21__VolumePerTimePerLengthMeasureExt;	/* eml2_1ForGsoap.h:1797 */
class eml21__VolumePerTimePerPressureLengthMeasure;	/* eml2_1ForGsoap.h:1800 */
class eml21__VolumePerTimePerPressureLengthMeasureExt;	/* eml2_1ForGsoap.h:1803 */
class eml21__VolumePerTimePerPressureMeasure;	/* eml2_1ForGsoap.h:1806 */
class eml21__VolumePerTimePerPressureMeasureExt;	/* eml2_1ForGsoap.h:1809 */
class eml21__VolumePerTimePerTimeMeasure;	/* eml2_1ForGsoap.h:1812 */
class eml21__VolumePerTimePerTimeMeasureExt;	/* eml2_1ForGsoap.h:1815 */
class eml21__VolumePerTimePerVolumeMeasure;	/* eml2_1ForGsoap.h:1818 */
class eml21__VolumePerTimePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1821 */
class eml21__VolumePerVolumeMeasure;	/* eml2_1ForGsoap.h:1824 */
class eml21__VolumePerVolumeMeasureExt;	/* eml2_1ForGsoap.h:1827 */
class eml21__VolumetricHeatTransferCoefficientMeasure;	/* eml2_1ForGsoap.h:1830 */
class eml21__VolumetricHeatTransferCoefficientMeasureExt;	/* eml2_1ForGsoap.h:1833 */
class eml21__VolumetricThermalExpansionMeasure;	/* eml2_1ForGsoap.h:1836 */
class eml21__VolumetricThermalExpansionMeasureExt;	/* eml2_1ForGsoap.h:1839 */
class eml21__ReferencePressure;	/* eml2_1ForGsoap.h:1932 */
class gml__DefinitionType;	/* eml2_1ForGsoap.h:2034 */
class gml__CodeWithAuthorityType;	/* eml2_1ForGsoap.h:2049 */
class gml__AbstractTimePrimitiveType;	/* eml2_1ForGsoap.h:2055 */
class gml__AngleType;	/* eml2_1ForGsoap.h:2109 */
class gml__LengthType;	/* eml2_1ForGsoap.h:2121 */
class gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType;	/* eml2_1ForGsoap.h:2193 */
class prodml2__NameStruct;	/* eml2_1ForGsoap.h:375 */
class eml21__AuthorityQualifiedName;	/* eml2_1ForGsoap.h:678 */
class eml21__FloatingPointConstantArray;	/* eml2_1ForGsoap.h:696 */
class eml21__FloatingPointExternalArray;	/* eml2_1ForGsoap.h:699 */
class eml21__FloatingPointLatticeArray;	/* eml2_1ForGsoap.h:702 */
class eml21__IntegerArrayFromBooleanMaskArray;	/* eml2_1ForGsoap.h:708 */
class eml21__IntegerConstantArray;	/* eml2_1ForGsoap.h:711 */
class eml21__IntegerExternalArray;	/* eml2_1ForGsoap.h:714 */
class eml21__IntegerLatticeArray;	/* eml2_1ForGsoap.h:717 */
class eml21__IntegerRangeArray;	/* eml2_1ForGsoap.h:720 */
class eml21__StringMeasure;	/* eml2_1ForGsoap.h:735 */
class gml__IdentifiedObjectType;	/* eml2_1ForGsoap.h:2031 */
class eml21__DoubleExternalArray;	/* eml2_1ForGsoap.h:690 */
class eml21__FloatExternalArray;	/* eml2_1ForGsoap.h:693 */
class gml__AbstractCRSType;	/* eml2_1ForGsoap.h:2028 */
class gml__AbstractCoordinateSystemType;	/* eml2_1ForGsoap.h:2073 */
class gml__CoordinateSystemAxisType;	/* eml2_1ForGsoap.h:2079 */
class gml__AbstractDatumType;	/* eml2_1ForGsoap.h:2100 */
class gml__PrimeMeridianType;	/* eml2_1ForGsoap.h:2106 */
class gml__EllipsoidType;	/* eml2_1ForGsoap.h:2118 */
class gml__AbstractCoordinateOperationType;	/* eml2_1ForGsoap.h:2136 */
union _gml__union_GeodeticCRSType;	/* eml2_1ForGsoap.h:38492 */
class gml__GeodeticCRSType;	/* eml2_1ForGsoap.h:2025 */
class gml__EllipsoidalCSType;	/* eml2_1ForGsoap.h:2070 */
class gml__CartesianCSType;	/* eml2_1ForGsoap.h:2085 */
class gml__SphericalCSType;	/* eml2_1ForGsoap.h:2091 */
class gml__GeodeticDatumType;	/* eml2_1ForGsoap.h:2097 */
class gml__AbstractGeneralDerivedCRSType;	/* eml2_1ForGsoap.h:2127 */
class gml__AbstractGeneralConversionType;	/* eml2_1ForGsoap.h:2133 */
class gml__VerticalCRSType;	/* eml2_1ForGsoap.h:2145 */
class gml__VerticalCSType;	/* eml2_1ForGsoap.h:2151 */
class gml__VerticalDatumType;	/* eml2_1ForGsoap.h:2157 */
union _gml__union_ProjectedCRSType;	/* eml2_1ForGsoap.h:38967 */
class gml__ProjectedCRSType;	/* eml2_1ForGsoap.h:2124 */

/* eml2_1ForGsoap.h:243 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration (19)
/* complex XSD type 'prodml2:DasCalibration': */
class SOAP_CMAC prodml2__DasCalibration {
      public:
        /// Optional element 'prodml2:CalibrationIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 *CalibrationIndex;
        /// Required element 'prodml2:NumberOfCalibrationPoints' of XSD type 'xsd:unsignedLong'
        ULONG64 NumberOfCalibrationPoints;
        /// Optional element 'prodml2:CalibrationDescription' of XSD type 'eml21:String2000'
        std::string *CalibrationDescription;
        /// Optional element 'prodml2:CalibrationOpticalPathDistanceUnit' of XSD type 'eml21:String64'
        std::string *CalibrationOpticalPathDistanceUnit;
        /// Optional element 'prodml2:CalibrationFacilityLengthUnit' of XSD type 'eml21:String64'
        std::string *CalibrationFacilityLengthUnit;
        /// Optional element 'prodml2:CalibrationDatum' of XSD type 'eml21:WellboreDatumReference'
        enum eml21__WellboreDatumReference *CalibrationDatum;
        /// Required element 'prodml2:FacilityName' of XSD type 'eml21:String64'
        std::string FacilityName;
        /// Required element 'prodml2:FacilityKind' of XSD type 'prodml2:FacilityKind'
        enum prodml2__FacilityKind FacilityKind;
        /// Required element 'prodml2:CalibrationDataPoints' of XSD type 'prodml2:DasCalibrationPoint'
        std::vector<prodml2__DasCalibrationPoint *> CalibrationDataPoints;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasCalibration, default initialized and not managed by a soap context
        virtual prodml2__DasCalibration *soap_alloc(void) const { return SOAP_NEW(prodml2__DasCalibration); }
      public:
        /// Constructor with initializations
        prodml2__DasCalibration() : CalibrationIndex(), NumberOfCalibrationPoints(), CalibrationDescription(), CalibrationOpticalPathDistanceUnit(), CalibrationFacilityLengthUnit(), CalibrationDatum(), FacilityName(), FacilityKind(), CalibrationDataPoints(), soap() { }
        virtual ~prodml2__DasCalibration() { }
        /// Friend allocator used by soap_new_prodml2__DasCalibration(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasCalibration * SOAP_FMAC2 soap_instantiate_prodml2__DasCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:246 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint (20)
/* complex XSD type 'prodml2:DasCalibrationPoint': */
class SOAP_CMAC prodml2__DasCalibrationPoint {
      public:
        /// Required element 'prodml2:CalibrationLocusIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 CalibrationLocusIndex;
        /// Required element 'prodml2:CalibrationOpticalPathDistance' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *CalibrationOpticalPathDistance;
        /// Required element 'prodml2:CalibrationFacilityLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *CalibrationFacilityLength;
        /// Optional element 'prodml2:CalibrationType' of XSD type 'prodml2:DasCalibrationTypeExt'
        std::string *CalibrationType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasCalibrationPoint, default initialized and not managed by a soap context
        virtual prodml2__DasCalibrationPoint *soap_alloc(void) const { return SOAP_NEW(prodml2__DasCalibrationPoint); }
      public:
        /// Constructor with initializations
        prodml2__DasCalibrationPoint() : CalibrationLocusIndex(), CalibrationOpticalPathDistance(), CalibrationFacilityLength(), CalibrationType(), soap() { }
        virtual ~prodml2__DasCalibrationPoint() { }
        /// Friend allocator used by soap_new_prodml2__DasCalibrationPoint(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasCalibrationPoint * SOAP_FMAC2 soap_instantiate_prodml2__DasCalibrationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:249 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom (21)
/* complex XSD type 'prodml2:DasCustom': */
class SOAP_CMAC prodml2__DasCustom {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasCustom, default initialized and not managed by a soap context
        virtual prodml2__DasCustom *soap_alloc(void) const { return SOAP_NEW(prodml2__DasCustom); }
      public:
        /// Constructor with initializations
        prodml2__DasCustom() : soap() { }
        virtual ~prodml2__DasCustom() { }
        /// Friend allocator used by soap_new_prodml2__DasCustom(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasCustom * SOAP_FMAC2 soap_instantiate_prodml2__DasCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:255 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe (23)
/* complex XSD type 'prodml2:DasFbe': */
class SOAP_CMAC prodml2__DasFbe {
      public:
        /// Optional element 'prodml2:FbeIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 *FbeIndex;
        /// Optional element 'prodml2:FbeDescription' of XSD type 'eml21:String2000'
        std::string *FbeDescription;
        /// Required element 'prodml2:FbeDataUnit' of XSD type 'eml21:String64'
        std::string FbeDataUnit;
        /// Required element 'prodml2:OutputDataRate' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *OutputDataRate;
        /// Required element 'prodml2:StartLocusIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 StartLocusIndex;
        /// Required element 'prodml2:NumberOfLoci' of XSD type 'xsd:unsignedLong'
        ULONG64 NumberOfLoci;
        /// Optional element 'prodml2:SpatialSamplingInterval' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *SpatialSamplingInterval;
        /// Optional element 'prodml2:SpatialSamplingIntervalUnit' of XSD type 'eml21:String64'
        std::string *SpatialSamplingIntervalUnit;
        /// Optional element 'prodml2:FilterType' of XSD type 'eml21:String64'
        std::string *FilterType;
        /// Optional element 'prodml2:WindowSize' of XSD type 'xsd:unsignedLong'
        ULONG64 *WindowSize;
        /// Optional element 'prodml2:WindowOverlap' of XSD type 'xsd:unsignedLong'
        ULONG64 *WindowOverlap;
        /// Optional element 'prodml2:WindowFunction' of XSD type 'eml21:String64'
        std::string *WindowFunction;
        /// Optional element 'prodml2:TransformType' of XSD type 'eml21:String64'
        std::string *TransformType;
        /// Optional element 'prodml2:TransformSize' of XSD type 'xsd:unsignedLong'
        ULONG64 *TransformSize;
        /// Optional element 'prodml2:RawReference' of XSD type 'eml21:UuidString'
        std::string *RawReference;
        /// Optional element 'prodml2:SpectraReference' of XSD type 'eml21:UuidString'
        std::string *SpectraReference;
        /// Required element 'prodml2:FbeData' of XSD type 'prodml2:DasFbeData'
        std::vector<prodml2__DasFbeData *> FbeData;
        /// Required element 'prodml2:FbeDataTime' of XSD type 'prodml2:DasTimeArray'
        prodml2__DasTimeArray *FbeDataTime;
        /// Optional element 'prodml2:Custom' of XSD type 'prodml2:DasCustom'
        prodml2__DasCustom *Custom;
        /// required attribute 'uuid' of XSD type 'eml21:UuidString'
        std::string uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasFbe, default initialized and not managed by a soap context
        virtual prodml2__DasFbe *soap_alloc(void) const { return SOAP_NEW(prodml2__DasFbe); }
      public:
        /// Constructor with initializations
        prodml2__DasFbe() : FbeIndex(), FbeDescription(), FbeDataUnit(), OutputDataRate(), StartLocusIndex(), NumberOfLoci(), SpatialSamplingInterval(), SpatialSamplingIntervalUnit(), FilterType(), WindowSize(), WindowOverlap(), WindowFunction(), TransformType(), TransformSize(), RawReference(), SpectraReference(), FbeData(), FbeDataTime(), Custom(), uuid(), soap() { }
        virtual ~prodml2__DasFbe() { }
        /// Friend allocator used by soap_new_prodml2__DasFbe(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasFbe * SOAP_FMAC2 soap_instantiate_prodml2__DasFbe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:258 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData (24)
/* complex XSD type 'prodml2:DasFbeData': */
class SOAP_CMAC prodml2__DasFbeData {
      public:
        /// Optional element 'prodml2:FbeDataIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 *FbeDataIndex;
        /// Required element 'prodml2:StartFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *StartFrequency;
        /// Required element 'prodml2:EndFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *EndFrequency;
        /// Sequence of 2 to 2 elements 'prodml2:Dimensions' of XSD type 'prodml2:DasDimensions'
        std::vector<enum prodml2__DasDimensions> Dimensions;
        /// Required element 'prodml2:FbeDataArray' of XSD type 'eml21:AbstractNumericArray'
        eml21__AbstractNumericArray *FbeDataArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasFbeData, default initialized and not managed by a soap context
        virtual prodml2__DasFbeData *soap_alloc(void) const { return SOAP_NEW(prodml2__DasFbeData); }
      public:
        /// Constructor with initializations
        prodml2__DasFbeData() : FbeDataIndex(), StartFrequency(), EndFrequency(), Dimensions(), FbeDataArray(), soap() { }
        virtual ~prodml2__DasFbeData() { }
        /// Friend allocator used by soap_new_prodml2__DasFbeData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasFbeData * SOAP_FMAC2 soap_instantiate_prodml2__DasFbeData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:264 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed (26)
/* complex XSD type 'prodml2:DasProcessed': */
class SOAP_CMAC prodml2__DasProcessed {
      public:
        /// Optional element 'prodml2:Fbe' of XSD type 'prodml2:DasFbe'
        std::vector<prodml2__DasFbe *> Fbe;
        /// Optional element 'prodml2:Spectra' of XSD type 'prodml2:DasSpectra'
        std::vector<prodml2__DasSpectra *> Spectra;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasProcessed, default initialized and not managed by a soap context
        virtual prodml2__DasProcessed *soap_alloc(void) const { return SOAP_NEW(prodml2__DasProcessed); }
      public:
        /// Constructor with initializations
        prodml2__DasProcessed() : Fbe(), Spectra(), soap() { }
        virtual ~prodml2__DasProcessed() { }
        /// Friend allocator used by soap_new_prodml2__DasProcessed(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasProcessed * SOAP_FMAC2 soap_instantiate_prodml2__DasProcessed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:267 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw (27)
/* complex XSD type 'prodml2:DasRaw': */
class SOAP_CMAC prodml2__DasRaw {
      public:
        /// Optional element 'prodml2:RawIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 *RawIndex;
        /// Optional element 'prodml2:RawDescription' of XSD type 'eml21:String2000'
        std::string *RawDescription;
        /// Required element 'prodml2:RawDataUnit' of XSD type 'eml21:String64'
        std::string RawDataUnit;
        /// Optional element 'prodml2:OutputDataRate' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *OutputDataRate;
        /// Required element 'prodml2:StartLocusIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 StartLocusIndex;
        /// Required element 'prodml2:NumberOfLoci' of XSD type 'xsd:unsignedLong'
        ULONG64 NumberOfLoci;
        /// Required element 'prodml2:RawData' of XSD type 'prodml2:DasRawData'
        prodml2__DasRawData *RawData;
        /// Required element 'prodml2:RawDataTime' of XSD type 'prodml2:DasTimeArray'
        prodml2__DasTimeArray *RawDataTime;
        /// Optional element 'prodml2:RawDataTriggerTime' of XSD type 'prodml2:DasTimeArray'
        prodml2__DasTimeArray *RawDataTriggerTime;
        /// Optional element 'prodml2:Custom' of XSD type 'prodml2:DasCustom'
        prodml2__DasCustom *Custom;
        /// required attribute 'uuid' of XSD type 'eml21:UuidString'
        std::string uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasRaw, default initialized and not managed by a soap context
        virtual prodml2__DasRaw *soap_alloc(void) const { return SOAP_NEW(prodml2__DasRaw); }
      public:
        /// Constructor with initializations
        prodml2__DasRaw() : RawIndex(), RawDescription(), RawDataUnit(), OutputDataRate(), StartLocusIndex(), NumberOfLoci(), RawData(), RawDataTime(), RawDataTriggerTime(), Custom(), uuid(), soap() { }
        virtual ~prodml2__DasRaw() { }
        /// Friend allocator used by soap_new_prodml2__DasRaw(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasRaw * SOAP_FMAC2 soap_instantiate_prodml2__DasRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:270 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData (28)
/* complex XSD type 'prodml2:DasRawData': */
class SOAP_CMAC prodml2__DasRawData {
      public:
        /// Sequence of 2 to 2 elements 'prodml2:Dimensions' of XSD type 'prodml2:DasDimensions'
        std::vector<enum prodml2__DasDimensions> Dimensions;
        /// Required element 'prodml2:RawDataArray' of XSD type 'eml21:AbstractNumericArray'
        eml21__AbstractNumericArray *RawDataArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasRawData, default initialized and not managed by a soap context
        virtual prodml2__DasRawData *soap_alloc(void) const { return SOAP_NEW(prodml2__DasRawData); }
      public:
        /// Constructor with initializations
        prodml2__DasRawData() : Dimensions(), RawDataArray(), soap() { }
        virtual ~prodml2__DasRawData() { }
        /// Friend allocator used by soap_new_prodml2__DasRawData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasRawData * SOAP_FMAC2 soap_instantiate_prodml2__DasRawData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:273 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra (29)
/* complex XSD type 'prodml2:DasSpectra': */
class SOAP_CMAC prodml2__DasSpectra {
      public:
        /// Optional element 'prodml2:SpectraIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 *SpectraIndex;
        /// Optional element 'prodml2:SpectraDescription' of XSD type 'eml21:String2000'
        std::string *SpectraDescription;
        /// Required element 'prodml2:SpectraDataUnit' of XSD type 'eml21:String64'
        std::string SpectraDataUnit;
        /// Required element 'prodml2:OutputDataRate' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *OutputDataRate;
        /// Required element 'prodml2:StartLocusIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 StartLocusIndex;
        /// Required element 'prodml2:NumberOfLoci' of XSD type 'xsd:unsignedLong'
        ULONG64 NumberOfLoci;
        /// Optional element 'prodml2:SpatialSamplingInterval' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *SpatialSamplingInterval;
        /// Optional element 'prodml2:SpatialSamplingIntervalUnit' of XSD type 'eml21:String64'
        std::string *SpatialSamplingIntervalUnit;
        /// Optional element 'prodml2:FilterType' of XSD type 'eml21:String64'
        std::string *FilterType;
        /// Optional element 'prodml2:WindowSize' of XSD type 'xsd:unsignedLong'
        ULONG64 *WindowSize;
        /// Optional element 'prodml2:WindowOverlap' of XSD type 'xsd:unsignedLong'
        ULONG64 *WindowOverlap;
        /// Optional element 'prodml2:WindowFunction' of XSD type 'eml21:String64'
        std::string *WindowFunction;
        /// Required element 'prodml2:TransformType' of XSD type 'eml21:String64'
        std::string TransformType;
        /// Required element 'prodml2:TransformSize' of XSD type 'xsd:unsignedLong'
        ULONG64 TransformSize;
        /// Optional element 'prodml2:RawReference' of XSD type 'eml21:UuidString'
        std::string *RawReference;
        /// Optional element 'prodml2:FbeReference' of XSD type 'eml21:UuidString'
        std::string *FbeReference;
        /// Required element 'prodml2:SpectraData' of XSD type 'prodml2:DasSpectraData'
        prodml2__DasSpectraData *SpectraData;
        /// Required element 'prodml2:SpectraDataTime' of XSD type 'prodml2:DasTimeArray'
        prodml2__DasTimeArray *SpectraDataTime;
        /// Optional element 'prodml2:Custom' of XSD type 'prodml2:DasCustom'
        prodml2__DasCustom *Custom;
        /// required attribute 'uuid' of XSD type 'eml21:UuidString'
        std::string uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasSpectra, default initialized and not managed by a soap context
        virtual prodml2__DasSpectra *soap_alloc(void) const { return SOAP_NEW(prodml2__DasSpectra); }
      public:
        /// Constructor with initializations
        prodml2__DasSpectra() : SpectraIndex(), SpectraDescription(), SpectraDataUnit(), OutputDataRate(), StartLocusIndex(), NumberOfLoci(), SpatialSamplingInterval(), SpatialSamplingIntervalUnit(), FilterType(), WindowSize(), WindowOverlap(), WindowFunction(), TransformType(), TransformSize(), RawReference(), FbeReference(), SpectraData(), SpectraDataTime(), Custom(), uuid(), soap() { }
        virtual ~prodml2__DasSpectra() { }
        /// Friend allocator used by soap_new_prodml2__DasSpectra(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasSpectra * SOAP_FMAC2 soap_instantiate_prodml2__DasSpectra(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:276 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData (30)
/* complex XSD type 'prodml2:DasSpectraData': */
class SOAP_CMAC prodml2__DasSpectraData {
      public:
        /// Required element 'prodml2:StartFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *StartFrequency;
        /// Required element 'prodml2:EndFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *EndFrequency;
        /// Sequence of 3 to 3 elements 'prodml2:Dimensions' of XSD type 'prodml2:DasDimensions'
        std::vector<enum prodml2__DasDimensions> Dimensions;
        /// Required element 'prodml2:SpectraDataArray' of XSD type 'eml21:AbstractNumericArray'
        eml21__AbstractNumericArray *SpectraDataArray;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasSpectraData, default initialized and not managed by a soap context
        virtual prodml2__DasSpectraData *soap_alloc(void) const { return SOAP_NEW(prodml2__DasSpectraData); }
      public:
        /// Constructor with initializations
        prodml2__DasSpectraData() : StartFrequency(), EndFrequency(), Dimensions(), SpectraDataArray(), soap() { }
        virtual ~prodml2__DasSpectraData() { }
        /// Friend allocator used by soap_new_prodml2__DasSpectraData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasSpectraData * SOAP_FMAC2 soap_instantiate_prodml2__DasSpectraData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:17622 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__DasTimeArray_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__DasTimeArray_sequence (1200)
/* Wrapper: */
class SOAP_CMAC __prodml2__DasTimeArray_sequence {
      public:
        /// Required element 'prodml2:StartTime' of XSD type 'eml21:TimeStamp'
        std::string StartTime;
        /// Optional element 'prodml2:EndTime' of XSD type 'eml21:TimeStamp'
        std::string *EndTime;
        /// Required element 'prodml2:TimeArray' of XSD type 'eml21:IntegerExternalArray'
        eml21__IntegerExternalArray *TimeArray;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__DasTimeArray_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__DasTimeArray_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__DasTimeArray_sequence, default initialized and not managed by a soap context
        virtual __prodml2__DasTimeArray_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__DasTimeArray_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__DasTimeArray_sequence() : StartTime(), EndTime(), TimeArray() { }
        virtual ~__prodml2__DasTimeArray_sequence() { }
        /// Friend allocator used by soap_new___prodml2__DasTimeArray_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__DasTimeArray_sequence * SOAP_FMAC2 soap_instantiate___prodml2__DasTimeArray_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:279 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray (31)
/* complex XSD type 'prodml2:DasTimeArray': */
class SOAP_CMAC prodml2__DasTimeArray {
      public:
        __prodml2__DasTimeArray_sequence *__DasTimeArray_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasTimeArray, default initialized and not managed by a soap context
        virtual prodml2__DasTimeArray *soap_alloc(void) const { return SOAP_NEW(prodml2__DasTimeArray); }
      public:
        /// Constructor with initializations
        prodml2__DasTimeArray() : __DasTimeArray_sequence(), soap() { }
        virtual ~prodml2__DasTimeArray() { }
        /// Friend allocator used by soap_new_prodml2__DasTimeArray(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasTimeArray * SOAP_FMAC2 soap_instantiate_prodml2__DasTimeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:282 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment (32)
/* complex XSD type 'prodml2:AbstractDtsEquipment': */
class SOAP_CMAC prodml2__AbstractDtsEquipment {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:Manufacturer' of XSD type 'eml21:String64'
        std::string *Manufacturer;
        /// Optional element 'prodml2:ManufacturingDate' of XSD type 'xsd:date'
        std::string *ManufacturingDate;
        /// Optional element 'prodml2:Type' of XSD type 'eml21:String64'
        std::string *Type;
        /// Optional element 'prodml2:SupplyDate' of XSD type 'xsd:date'
        std::string *SupplyDate;
        /// Optional element 'prodml2:SupplierModelNumber' of XSD type 'eml21:String64'
        std::string *SupplierModelNumber;
        /// Optional element 'prodml2:SoftwareVersion' of XSD type 'eml21:String64'
        std::string *SoftwareVersion;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:Supplier' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *Supplier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractDtsEquipment, default initialized and not managed by a soap context
        virtual prodml2__AbstractDtsEquipment *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractDtsEquipment); }
      public:
        /// Constructor with initializations
        prodml2__AbstractDtsEquipment() : Name(), Manufacturer(), ManufacturingDate(), Type(), SupplyDate(), SupplierModelNumber(), SoftwareVersion(), Comment(), Supplier(), soap() { }
        virtual ~prodml2__AbstractDtsEquipment() { }
        /// Friend allocator used by soap_new_prodml2__AbstractDtsEquipment(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractDtsEquipment * SOAP_FMAC2 soap_instantiate_prodml2__AbstractDtsEquipment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:17724 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__DtsPatchCord_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__DtsPatchCord_sequence (1206)
/* Wrapper: */
class SOAP_CMAC __prodml2__DtsPatchCord_sequence {
      public:
        /// Optional element 'prodml2:FiberLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *FiberLength;
        /// Required element 'prodml2:Description' of XSD type 'eml21:String2000'
        std::string Description;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__DtsPatchCord_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__DtsPatchCord_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__DtsPatchCord_sequence, default initialized and not managed by a soap context
        virtual __prodml2__DtsPatchCord_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__DtsPatchCord_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__DtsPatchCord_sequence() : FiberLength(), Description() { }
        virtual ~__prodml2__DtsPatchCord_sequence() { }
        /// Friend allocator used by soap_new___prodml2__DtsPatchCord_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__DtsPatchCord_sequence * SOAP_FMAC2 soap_instantiate___prodml2__DtsPatchCord_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:288 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord (34)
/* complex XSD type 'prodml2:DtsPatchCord': */
class SOAP_CMAC prodml2__DtsPatchCord {
      public:
        __prodml2__DtsPatchCord_sequence *__DtsPatchCord_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DtsPatchCord, default initialized and not managed by a soap context
        virtual prodml2__DtsPatchCord *soap_alloc(void) const { return SOAP_NEW(prodml2__DtsPatchCord); }
      public:
        /// Constructor with initializations
        prodml2__DtsPatchCord() : __DtsPatchCord_sequence(), soap() { }
        virtual ~prodml2__DtsPatchCord() { }
        /// Friend allocator used by soap_new_prodml2__DtsPatchCord(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DtsPatchCord * SOAP_FMAC2 soap_instantiate_prodml2__DtsPatchCord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:294 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration (36)
/* complex XSD type 'prodml2:DtsCalibration': */
class SOAP_CMAC prodml2__DtsCalibration {
      public:
        /// Optional element 'prodml2:DTimCalibration' of XSD type 'xsd:date'
        std::string *DTimCalibration;
        /// Optional element 'prodml2:CalibratedBy' of XSD type 'eml21:String64'
        std::string *CalibratedBy;
        /// Optional element 'prodml2:CalibrationProtocol' of XSD type 'eml21:String64'
        std::string *CalibrationProtocol;
        /// Optional element 'prodml2:Parameter' of XSD type 'prodml2:CalibrationParameter'
        std::vector<prodml2__CalibrationParameter *> Parameter;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
        /// Optional element 'prodml2:ExtensionNameValue' of XSD type 'eml21:ExtensionNameValue'
        std::vector<eml21__ExtensionNameValue *> ExtensionNameValue;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DtsCalibration, default initialized and not managed by a soap context
        virtual prodml2__DtsCalibration *soap_alloc(void) const { return SOAP_NEW(prodml2__DtsCalibration); }
      public:
        /// Constructor with initializations
        prodml2__DtsCalibration() : DTimCalibration(), CalibratedBy(), CalibrationProtocol(), Parameter(), Remark(), ExtensionNameValue(), uid(), soap() { }
        virtual ~prodml2__DtsCalibration() { }
        /// Friend allocator used by soap_new_prodml2__DtsCalibration(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DtsCalibration * SOAP_FMAC2 soap_instantiate_prodml2__DtsCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:17811 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__AbstractDateTimeClass_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__AbstractDateTimeClass_sequence (1212)
/* Wrapper: */
class SOAP_CMAC __prodml2__AbstractDateTimeClass_sequence {
      public:
        /// Optional element 'prodml2:DTime' of XSD type 'eml21:TimeStamp'
        std::string *DTime;
        /// Optional element 'prodml2:Date' of XSD type 'xsd:date'
        std::string *Date;
        /// Optional element 'prodml2:Month' of XSD type 'prodml2:CalendarMonth'
        std::string *Month;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__AbstractDateTimeClass_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__AbstractDateTimeClass_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__AbstractDateTimeClass_sequence, default initialized and not managed by a soap context
        virtual __prodml2__AbstractDateTimeClass_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__AbstractDateTimeClass_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__AbstractDateTimeClass_sequence() : DTime(), Date(), Month() { }
        virtual ~__prodml2__AbstractDateTimeClass_sequence() { }
        /// Friend allocator used by soap_new___prodml2__AbstractDateTimeClass_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__AbstractDateTimeClass_sequence * SOAP_FMAC2 soap_instantiate___prodml2__AbstractDateTimeClass_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:300 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass (38)
/* Type prodml2__AbstractDateTimeClass is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractDateTimeClass': */
class SOAP_CMAC prodml2__AbstractDateTimeClass {
      public:
        __prodml2__AbstractDateTimeClass_sequence *__AbstractDateTimeClass_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractDateTimeClass, default initialized and not managed by a soap context
        virtual prodml2__AbstractDateTimeClass *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractDateTimeClass); }
      public:
        /// Constructor with initializations
        prodml2__AbstractDateTimeClass() : __AbstractDateTimeClass_sequence(), soap() { }
        virtual ~prodml2__AbstractDateTimeClass() { }
        /// Friend allocator used by soap_new_prodml2__AbstractDateTimeClass(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractDateTimeClass * SOAP_FMAC2 soap_instantiate_prodml2__AbstractDateTimeClass(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:303 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent (39)
/* Type prodml2__AbstractFluidComponent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractFluidComponent': */
class SOAP_CMAC prodml2__AbstractFluidComponent {
      public:
        /// Optional element 'prodml2:MassFraction' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml2:MoleFraction' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractFluidComponent, default initialized and not managed by a soap context
        virtual prodml2__AbstractFluidComponent *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractFluidComponent); }
      public:
        /// Constructor with initializations
        prodml2__AbstractFluidComponent() : MassFraction(), MoleFraction(), uid(), soap() { }
        virtual ~prodml2__AbstractFluidComponent() { }
        /// Friend allocator used by soap_new_prodml2__AbstractFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractFluidComponent * SOAP_FMAC2 soap_instantiate_prodml2__AbstractFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:306 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate (40)
/* complex XSD type 'prodml2:BusinessAssociate': */
class SOAP_CMAC prodml2__BusinessAssociate {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:Role' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> Role;
        /// Optional element 'prodml2:Alias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> Alias;
        /// Optional element 'prodml2:Address' of XSD type 'prodml2:GeneralAddress'
        prodml2__GeneralAddress *Address;
        /// Optional element 'prodml2:PhoneNumber' of XSD type 'prodml2:PhoneNumberStruct'
        std::vector<prodml2__PhoneNumberStruct *> PhoneNumber;
        /// Optional element 'prodml2:Email' of XSD type 'prodml2:EmailQualifierStruct'
        std::vector<prodml2__EmailQualifierStruct *> Email;
        /// Optional element 'prodml2:AssociatedWith' of XSD type 'eml21:String64'
        std::string *AssociatedWith;
        /// Optional element 'prodml2:Contact' of XSD type 'eml21:String64'
        std::vector<std::string> Contact;
        /// Optional element 'prodml2:PersonnelCount' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *PersonnelCount;
        /// Optional element 'prodml2:PersonName' of XSD type 'prodml2:PersonName'
        prodml2__PersonName *PersonName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__BusinessAssociate, default initialized and not managed by a soap context
        virtual prodml2__BusinessAssociate *soap_alloc(void) const { return SOAP_NEW(prodml2__BusinessAssociate); }
      public:
        /// Constructor with initializations
        prodml2__BusinessAssociate() : Name(), Role(), Alias(), Address(), PhoneNumber(), Email(), AssociatedWith(), Contact(), PersonnelCount(), PersonName(), soap() { }
        virtual ~prodml2__BusinessAssociate() { }
        /// Friend allocator used by soap_new_prodml2__BusinessAssociate(struct soap*, int)
        friend SOAP_FMAC1 prodml2__BusinessAssociate * SOAP_FMAC2 soap_instantiate_prodml2__BusinessAssociate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:309 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter (41)
/* complex XSD type 'prodml2:CalibrationParameter': */
class SOAP_CMAC prodml2__CalibrationParameter {
      public:
        /// optional attribute 'uom' of XSD type 'eml21:UomEnum'
        std::string *uom;
        /// required attribute 'name' of XSD type 'eml21:String64'
        std::string name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__CalibrationParameter, default initialized and not managed by a soap context
        virtual prodml2__CalibrationParameter *soap_alloc(void) const { return SOAP_NEW(prodml2__CalibrationParameter); }
      public:
        /// Constructor with initializations
        prodml2__CalibrationParameter() : uom(), name(), soap() { }
        virtual ~prodml2__CalibrationParameter() { }
        /// Friend allocator used by soap_new_prodml2__CalibrationParameter(struct soap*, int)
        friend SOAP_FMAC1 prodml2__CalibrationParameter * SOAP_FMAC2 soap_instantiate_prodml2__CalibrationParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:312 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment (42)
/* complex XSD type 'prodml2:DatedComment': */
class SOAP_CMAC prodml2__DatedComment {
      public:
        /// Optional element 'prodml2:Who' of XSD type 'eml21:String64'
        std::string *Who;
        /// Optional element 'prodml2:Role' of XSD type 'eml21:String64'
        std::string *Role;
        /// Optional element 'prodml2:StartTime' of XSD type 'xsd:dateTime'
        time_t *StartTime;
        /// Optional element 'prodml2:EndTime' of XSD type 'xsd:dateTime'
        time_t *EndTime;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DatedComment, default initialized and not managed by a soap context
        virtual prodml2__DatedComment *soap_alloc(void) const { return SOAP_NEW(prodml2__DatedComment); }
      public:
        /// Constructor with initializations
        prodml2__DatedComment() : Who(), Role(), StartTime(), EndTime(), Remark(), uid(), soap() { }
        virtual ~prodml2__DatedComment() { }
        /// Friend allocator used by soap_new_prodml2__DatedComment(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DatedComment * SOAP_FMAC2 soap_instantiate_prodml2__DatedComment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:315 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct (43)
/* complex XSD type 'prodml2:EmailQualifierStruct': */
class SOAP_CMAC prodml2__EmailQualifierStruct {
      public:
        /// optional attribute 'qualifier' of XSD type 'prodml2:AddressQualifier'
        enum prodml2__AddressQualifier *qualifier;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__EmailQualifierStruct, default initialized and not managed by a soap context
        virtual prodml2__EmailQualifierStruct *soap_alloc(void) const { return SOAP_NEW(prodml2__EmailQualifierStruct); }
      public:
        /// Constructor with initializations
        prodml2__EmailQualifierStruct() : qualifier(), soap() { }
        virtual ~prodml2__EmailQualifierStruct() { }
        /// Friend allocator used by soap_new_prodml2__EmailQualifierStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__EmailQualifierStruct * SOAP_FMAC2 soap_instantiate_prodml2__EmailQualifierStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:318 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate (44)
/* complex XSD type 'prodml2:EndpointQualifiedDate': */
class SOAP_CMAC prodml2__EndpointQualifiedDate {
      public:
        /// optional attribute 'endpoint' of XSD type 'prodml2:EndpointQualifier'
        enum prodml2__EndpointQualifier *endpoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__EndpointQualifiedDate, default initialized and not managed by a soap context
        virtual prodml2__EndpointQualifiedDate *soap_alloc(void) const { return SOAP_NEW(prodml2__EndpointQualifiedDate); }
      public:
        /// Constructor with initializations
        prodml2__EndpointQualifiedDate() : endpoint(), soap() { }
        virtual ~prodml2__EndpointQualifiedDate() { }
        /// Friend allocator used by soap_new_prodml2__EndpointQualifiedDate(struct soap*, int)
        friend SOAP_FMAC1 prodml2__EndpointQualifiedDate * SOAP_FMAC2 soap_instantiate_prodml2__EndpointQualifiedDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:321 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime (45)
/* complex XSD type 'prodml2:EndpointQualifiedDateTime': */
class SOAP_CMAC prodml2__EndpointQualifiedDateTime {
      public:
        /// optional attribute 'endpoint' of XSD type 'prodml2:EndpointQualifier'
        enum prodml2__EndpointQualifier *endpoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__EndpointQualifiedDateTime, default initialized and not managed by a soap context
        virtual prodml2__EndpointQualifiedDateTime *soap_alloc(void) const { return SOAP_NEW(prodml2__EndpointQualifiedDateTime); }
      public:
        /// Constructor with initializations
        prodml2__EndpointQualifiedDateTime() : endpoint(), soap() { }
        virtual ~prodml2__EndpointQualifiedDateTime() { }
        /// Friend allocator used by soap_new_prodml2__EndpointQualifiedDateTime(struct soap*, int)
        friend SOAP_FMAC1 prodml2__EndpointQualifiedDateTime * SOAP_FMAC2 soap_instantiate_prodml2__EndpointQualifiedDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:324 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier (46)
/* complex XSD type 'prodml2:FacilityIdentifier': */
class SOAP_CMAC prodml2__FacilityIdentifier {
      public:
        /// Required element 'prodml2:Name' of XSD type 'prodml2:NameStruct'
        prodml2__NameStruct *Name;
        /// Optional element 'prodml2:Installation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml2:Kind' of XSD type 'eml21:String64'
        std::string *Kind;
        /// Optional element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *ContextFacility;
        /// Optional element 'prodml2:BusinessUnit' of XSD type 'prodml2:ProductVolumeBusinessUnit'
        prodml2__ProductVolumeBusinessUnit *BusinessUnit;
        /// Optional element 'prodml2:Operator' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *Operator;
        /// Optional element 'prodml2:GeographicContext' of XSD type 'prodml2:GeographicContext'
        prodml2__GeographicContext *GeographicContext;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FacilityIdentifier, default initialized and not managed by a soap context
        virtual prodml2__FacilityIdentifier *soap_alloc(void) const { return SOAP_NEW(prodml2__FacilityIdentifier); }
      public:
        /// Constructor with initializations
        prodml2__FacilityIdentifier() : Name(), Installation(), Kind(), ContextFacility(), BusinessUnit(), Operator(), GeographicContext(), uid(), __mixed(), soap() { }
        virtual ~prodml2__FacilityIdentifier() { }
        /// Friend allocator used by soap_new_prodml2__FacilityIdentifier(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FacilityIdentifier * SOAP_FMAC2 soap_instantiate_prodml2__FacilityIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:327 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct (47)
/* complex XSD type 'prodml2:FacilityIdentifierStruct': */
class SOAP_CMAC prodml2__FacilityIdentifierStruct {
      public:
        /// optional attribute 'kind' of XSD type 'prodml2:ReportingFacility'
        enum prodml2__ReportingFacility *kind;
        /// optional attribute 'siteKind' of XSD type 'eml21:String64'
        std::string *siteKind;
        /// optional attribute 'namingSystem' of XSD type 'eml21:String64'
        std::string *namingSystem;
        /// optional attribute 'uidRef' of XSD type 'eml21:String64'
        std::string *uidRef;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FacilityIdentifierStruct, default initialized and not managed by a soap context
        virtual prodml2__FacilityIdentifierStruct *soap_alloc(void) const { return SOAP_NEW(prodml2__FacilityIdentifierStruct); }
      public:
        /// Constructor with initializations
        prodml2__FacilityIdentifierStruct() : kind(), siteKind(), namingSystem(), uidRef(), __mixed(), soap() { }
        virtual ~prodml2__FacilityIdentifierStruct() { }
        /// Friend allocator used by soap_new_prodml2__FacilityIdentifierStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FacilityIdentifierStruct * SOAP_FMAC2 soap_instantiate_prodml2__FacilityIdentifierStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:330 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent (48)
/* complex XSD type 'prodml2:FluidComponent': */
class SOAP_CMAC prodml2__FluidComponent {
      public:
        /// Optional element 'prodml2:MassFraction' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml2:MoleFraction' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Optional element 'prodml2:KValue' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *KValue;
        /// required attribute 'fluidComponentReference' of XSD type 'eml21:String64'
        std::string fluidComponentReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FluidComponent, default initialized and not managed by a soap context
        virtual prodml2__FluidComponent *soap_alloc(void) const { return SOAP_NEW(prodml2__FluidComponent); }
      public:
        /// Constructor with initializations
        prodml2__FluidComponent() : MassFraction(), MoleFraction(), KValue(), fluidComponentReference(), soap() { }
        virtual ~prodml2__FluidComponent() { }
        /// Friend allocator used by soap_new_prodml2__FluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FluidComponent * SOAP_FMAC2 soap_instantiate_prodml2__FluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:333 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog (49)
/* complex XSD type 'prodml2:FluidComponentCatalog': */
class SOAP_CMAC prodml2__FluidComponentCatalog {
      public:
        /// Optional element 'prodml2:StockTankOil' of XSD type 'prodml2:StockTankOil'
        std::vector<prodml2__StockTankOil *> StockTankOil;
        /// Optional element 'prodml2:NaturalGas' of XSD type 'prodml2:NaturalGas'
        std::vector<prodml2__NaturalGas *> NaturalGas;
        /// Optional element 'prodml2:FormationWater' of XSD type 'prodml2:FormationWater'
        std::vector<prodml2__FormationWater *> FormationWater;
        /// Optional element 'prodml2:PureFluidComponent' of XSD type 'prodml2:PureFluidComponent'
        std::vector<prodml2__PureFluidComponent *> PureFluidComponent;
        /// Optional element 'prodml2:PseudoFluidComponent' of XSD type 'prodml2:PseudoFluidComponent'
        std::vector<prodml2__PseudoFluidComponent *> PseudoFluidComponent;
        /// Optional element 'prodml2:PlusFluidComponent' of XSD type 'prodml2:PlusFluidComponent'
        std::vector<prodml2__PlusFluidComponent *> PlusFluidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FluidComponentCatalog, default initialized and not managed by a soap context
        virtual prodml2__FluidComponentCatalog *soap_alloc(void) const { return SOAP_NEW(prodml2__FluidComponentCatalog); }
      public:
        /// Constructor with initializations
        prodml2__FluidComponentCatalog() : StockTankOil(), NaturalGas(), FormationWater(), PureFluidComponent(), PseudoFluidComponent(), PlusFluidComponent(), soap() { }
        virtual ~prodml2__FluidComponentCatalog() { }
        /// Friend allocator used by soap_new_prodml2__FluidComponentCatalog(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FluidComponentCatalog * SOAP_FMAC2 soap_instantiate_prodml2__FluidComponentCatalog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:339 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress (51)
/* complex XSD type 'prodml2:GeneralAddress': */
class SOAP_CMAC prodml2__GeneralAddress {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Sequence of 1 to 4 elements 'prodml2:Street' of XSD type 'eml21:String64'
        std::vector<std::string> Street;
        /// Required element 'prodml2:City' of XSD type 'eml21:String64'
        std::string City;
        /// Optional element 'prodml2:Country' of XSD type 'eml21:String64'
        std::string *Country;
        /// Required element 'prodml2:County' of XSD type 'eml21:String64'
        std::string County;
        /// Optional element 'prodml2:PostalCode' of XSD type 'eml21:String64'
        std::string *PostalCode;
        /// Required element 'prodml2:State' of XSD type 'eml21:String64'
        std::string State;
        /// Required element 'prodml2:Province' of XSD type 'eml21:String64'
        std::string Province;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// optional attribute 'kind' of XSD type 'prodml2:AddressKindEnum'
        enum prodml2__AddressKindEnum *kind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__GeneralAddress, default initialized and not managed by a soap context
        virtual prodml2__GeneralAddress *soap_alloc(void) const { return SOAP_NEW(prodml2__GeneralAddress); }
      public:
        /// Constructor with initializations
        prodml2__GeneralAddress() : Name(), Street(), City(), Country(), County(), PostalCode(), State(), Province(), uid(), kind(), soap() { }
        virtual ~prodml2__GeneralAddress() { }
        /// Friend allocator used by soap_new_prodml2__GeneralAddress(struct soap*, int)
        friend SOAP_FMAC1 prodml2__GeneralAddress * SOAP_FMAC2 soap_instantiate_prodml2__GeneralAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:342 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType (52)
/* complex XSD type 'prodml2:GeneralMeasureType': */
class SOAP_CMAC prodml2__GeneralMeasureType {
      public:
        /// optional attribute 'uom' of XSD type 'eml21:UomEnum'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__GeneralMeasureType, default initialized and not managed by a soap context
        virtual prodml2__GeneralMeasureType *soap_alloc(void) const { return SOAP_NEW(prodml2__GeneralMeasureType); }
      public:
        /// Constructor with initializations
        prodml2__GeneralMeasureType() : uom(), soap() { }
        virtual ~prodml2__GeneralMeasureType() { }
        /// Friend allocator used by soap_new_prodml2__GeneralMeasureType(struct soap*, int)
        friend SOAP_FMAC1 prodml2__GeneralMeasureType * SOAP_FMAC2 soap_instantiate_prodml2__GeneralMeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:348 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext (54)
/* complex XSD type 'prodml2:GeographicContext': */
class SOAP_CMAC prodml2__GeographicContext {
      public:
        /// Optional element 'prodml2:Country' of XSD type 'eml21:String64'
        std::string *Country;
        /// Optional element 'prodml2:State' of XSD type 'eml21:String64'
        std::string *State;
        /// Optional element 'prodml2:County' of XSD type 'eml21:String64'
        std::string *County;
        /// Optional element 'prodml2:Field' of XSD type 'prodml2:NameStruct'
        prodml2__NameStruct *Field;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:OffshoreLocation' of XSD type 'prodml2:OffshoreLocation'
        prodml2__OffshoreLocation *OffshoreLocation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__GeographicContext, default initialized and not managed by a soap context
        virtual prodml2__GeographicContext *soap_alloc(void) const { return SOAP_NEW(prodml2__GeographicContext); }
      public:
        /// Constructor with initializations
        prodml2__GeographicContext() : Country(), State(), County(), Field(), Comment(), OffshoreLocation(), soap() { }
        virtual ~prodml2__GeographicContext() { }
        /// Friend allocator used by soap_new_prodml2__GeographicContext(struct soap*, int)
        friend SOAP_FMAC1 prodml2__GeographicContext * SOAP_FMAC2 soap_instantiate_prodml2__GeographicContext(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:351 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature (55)
/* complex XSD type 'prodml2:GeologyFeature': */
class SOAP_CMAC prodml2__GeologyFeature {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Optional element 'prodml2:GeologyType' of XSD type 'prodml2:GeologyType'
        enum prodml2__GeologyType *GeologyType;
        /// Optional element 'prodml2:MdTop' of XSD type 'prodml2:MeasuredDepthCoord'
        prodml2__MeasuredDepthCoord *MdTop;
        /// Optional element 'prodml2:MdBottom' of XSD type 'prodml2:MeasuredDepthCoord'
        prodml2__MeasuredDepthCoord *MdBottom;
        /// Optional element 'prodml2:TvdTop' of XSD type 'prodml2:WellVerticalDepthCoord'
        prodml2__WellVerticalDepthCoord *TvdTop;
        /// Optional element 'prodml2:TvdBottom' of XSD type 'prodml2:WellVerticalDepthCoord'
        prodml2__WellVerticalDepthCoord *TvdBottom;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__GeologyFeature, default initialized and not managed by a soap context
        virtual prodml2__GeologyFeature *soap_alloc(void) const { return SOAP_NEW(prodml2__GeologyFeature); }
      public:
        /// Constructor with initializations
        prodml2__GeologyFeature() : Name(), GeologyType(), MdTop(), MdBottom(), TvdTop(), TvdBottom(), uid(), soap() { }
        virtual ~prodml2__GeologyFeature() { }
        /// Friend allocator used by soap_new_prodml2__GeologyFeature(struct soap*, int)
        friend SOAP_FMAC1 prodml2__GeologyFeature * SOAP_FMAC2 soap_instantiate_prodml2__GeologyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:354 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject (56)
/* complex XSD type 'prodml2:IndexedObject': */
class SOAP_CMAC prodml2__IndexedObject {
      public:
        /// optional attribute 'index' of XSD type 'xsd:unsignedLong'
        ULONG64 *index;
        /// optional attribute 'name' of XSD type 'eml21:String64'
        std::string *name;
        /// optional attribute 'uom' of XSD type 'xsd:string'
        std::string *uom;
        /// optional attribute 'description' of XSD type 'eml21:String2000'
        std::string *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__IndexedObject, default initialized and not managed by a soap context
        virtual prodml2__IndexedObject *soap_alloc(void) const { return SOAP_NEW(prodml2__IndexedObject); }
      public:
        /// Constructor with initializations
        prodml2__IndexedObject() : index(), name(), uom(), description(), soap() { }
        virtual ~prodml2__IndexedObject() { }
        /// Friend allocator used by soap_new_prodml2__IndexedObject(struct soap*, int)
        friend SOAP_FMAC1 prodml2__IndexedObject * SOAP_FMAC2 soap_instantiate_prodml2__IndexedObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:366 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition (60)
/* complex XSD type 'prodml2:LiquidComposition': */
class SOAP_CMAC prodml2__LiquidComposition {
      public:
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
        /// Optional element 'prodml2:LiquidComponent' of XSD type 'prodml2:FluidComponent'
        std::vector<prodml2__FluidComponent *> LiquidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__LiquidComposition, default initialized and not managed by a soap context
        virtual prodml2__LiquidComposition *soap_alloc(void) const { return SOAP_NEW(prodml2__LiquidComposition); }
      public:
        /// Constructor with initializations
        prodml2__LiquidComposition() : Remark(), LiquidComponent(), soap() { }
        virtual ~prodml2__LiquidComposition() { }
        /// Friend allocator used by soap_new_prodml2__LiquidComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml2__LiquidComposition * SOAP_FMAC2 soap_instantiate_prodml2__LiquidComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:381 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore (65)
/* complex XSD type 'prodml2:NorthSeaOffshore': */
class SOAP_CMAC prodml2__NorthSeaOffshore {
      public:
        /// Optional element 'prodml2:AreaName' of XSD type 'eml21:String64'
        std::string *AreaName;
        /// Required element 'prodml2:Quadrant' of XSD type 'eml21:String64'
        std::string Quadrant;
        /// Optional element 'prodml2:BlockSuffix' of XSD type 'eml21:String64'
        std::string *BlockSuffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__NorthSeaOffshore, default initialized and not managed by a soap context
        virtual prodml2__NorthSeaOffshore *soap_alloc(void) const { return SOAP_NEW(prodml2__NorthSeaOffshore); }
      public:
        /// Constructor with initializations
        prodml2__NorthSeaOffshore() : AreaName(), Quadrant(), BlockSuffix(), soap() { }
        virtual ~prodml2__NorthSeaOffshore() { }
        /// Friend allocator used by soap_new_prodml2__NorthSeaOffshore(struct soap*, int)
        friend SOAP_FMAC1 prodml2__NorthSeaOffshore * SOAP_FMAC2 soap_instantiate_prodml2__NorthSeaOffshore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:384 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation (66)
/* complex XSD type 'prodml2:OffshoreLocation': */
class SOAP_CMAC prodml2__OffshoreLocation {
      public:
        /// Optional element 'prodml2:AreaName' of XSD type 'eml21:String64'
        std::string *AreaName;
        /// Required element 'prodml2:BlockID' of XSD type 'eml21:String64'
        std::vector<std::string> BlockID;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:NorthSeaOffshore' of XSD type 'prodml2:NorthSeaOffshore'
        prodml2__NorthSeaOffshore *NorthSeaOffshore;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__OffshoreLocation, default initialized and not managed by a soap context
        virtual prodml2__OffshoreLocation *soap_alloc(void) const { return SOAP_NEW(prodml2__OffshoreLocation); }
      public:
        /// Constructor with initializations
        prodml2__OffshoreLocation() : AreaName(), BlockID(), Comment(), NorthSeaOffshore(), soap() { }
        virtual ~prodml2__OffshoreLocation() { }
        /// Friend allocator used by soap_new_prodml2__OffshoreLocation(struct soap*, int)
        friend SOAP_FMAC1 prodml2__OffshoreLocation * SOAP_FMAC2 soap_instantiate_prodml2__OffshoreLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:387 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition (67)
/* complex XSD type 'prodml2:OverallComposition': */
class SOAP_CMAC prodml2__OverallComposition {
      public:
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
        /// Optional element 'prodml2:FluidComponent' of XSD type 'prodml2:FluidComponent'
        std::vector<prodml2__FluidComponent *> FluidComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__OverallComposition, default initialized and not managed by a soap context
        virtual prodml2__OverallComposition *soap_alloc(void) const { return SOAP_NEW(prodml2__OverallComposition); }
      public:
        /// Constructor with initializations
        prodml2__OverallComposition() : Remark(), FluidComponent(), soap() { }
        virtual ~prodml2__OverallComposition() { }
        /// Friend allocator used by soap_new_prodml2__OverallComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml2__OverallComposition * SOAP_FMAC2 soap_instantiate_prodml2__OverallComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:390 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName (68)
/* complex XSD type 'prodml2:PersonName': */
class SOAP_CMAC prodml2__PersonName {
      public:
        /// Optional element 'prodml2:Prefix' of XSD type 'eml21:String64'
        std::string *Prefix;
        /// Required element 'prodml2:First' of XSD type 'eml21:String64'
        std::string First;
        /// Optional element 'prodml2:Middle' of XSD type 'eml21:String64'
        std::string *Middle;
        /// Required element 'prodml2:Last' of XSD type 'eml21:String64'
        std::string Last;
        /// Sequence of 0 to 9 elements 'prodml2:Suffix' of XSD type 'eml21:String64'
        std::vector<std::string> Suffix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PersonName, default initialized and not managed by a soap context
        virtual prodml2__PersonName *soap_alloc(void) const { return SOAP_NEW(prodml2__PersonName); }
      public:
        /// Constructor with initializations
        prodml2__PersonName() : Prefix(), First(), Middle(), Last(), Suffix(), soap() { }
        virtual ~prodml2__PersonName() { }
        /// Friend allocator used by soap_new_prodml2__PersonName(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PersonName * SOAP_FMAC2 soap_instantiate_prodml2__PersonName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:393 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct (69)
/* complex XSD type 'prodml2:PhoneNumberStruct': */
class SOAP_CMAC prodml2__PhoneNumberStruct {
      public:
        /// required attribute 'type' of XSD type 'prodml2:PhoneType'
        enum prodml2__PhoneType type;
        /// optional attribute 'qualifier' of XSD type 'prodml2:AddressQualifier'
        enum prodml2__AddressQualifier *qualifier;
        /// optional attribute 'extension' of XSD type 'eml21:String64'
        std::string *extension;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PhoneNumberStruct, default initialized and not managed by a soap context
        virtual prodml2__PhoneNumberStruct *soap_alloc(void) const { return SOAP_NEW(prodml2__PhoneNumberStruct); }
      public:
        /// Constructor with initializations
        prodml2__PhoneNumberStruct() : type(), qualifier(), extension(), __mixed(), soap() { }
        virtual ~prodml2__PhoneNumberStruct() { }
        /// Friend allocator used by soap_new_prodml2__PhoneNumberStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PhoneNumberStruct * SOAP_FMAC2 soap_instantiate_prodml2__PhoneNumberStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:399 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference (71)
/* complex XSD type 'prodml2:ProductFlowExternalReference': */
class SOAP_CMAC prodml2__ProductFlowExternalReference {
      public:
        /// Required element 'prodml2:PortReference' of XSD type 'eml21:String64'
        std::string PortReference;
        /// Required element 'prodml2:ConnectedPortReference' of XSD type 'eml21:String64'
        std::string ConnectedPortReference;
        /// Required element 'prodml2:ConnectedModelReference' of XSD type 'eml21:String64'
        std::string ConnectedModelReference;
        /// Optional element 'prodml2:ConnectedInstallation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *ConnectedInstallation;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowExternalReference, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowExternalReference *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowExternalReference); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowExternalReference() : PortReference(), ConnectedPortReference(), ConnectedModelReference(), ConnectedInstallation(), uid(), soap() { }
        virtual ~prodml2__ProductFlowExternalReference() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowExternalReference(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowExternalReference * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowExternalReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:402 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork (72)
/* complex XSD type 'prodml2:ProductFlowNetwork': */
class SOAP_CMAC prodml2__ProductFlowNetwork {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:PlanName' of XSD type 'eml21:String64'
        std::string *PlanName;
        /// Optional element 'prodml2:ParentNetworkReference' of XSD type 'eml21:String64'
        std::string *ParentNetworkReference;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:Port' of XSD type 'prodml2:ProductFlowExternalPort'
        std::vector<prodml2__ProductFlowExternalPort *> Port;
        /// Optional element 'prodml2:Plan' of XSD type 'prodml2:ProductFlowNetworkPlan'
        std::vector<prodml2__ProductFlowNetworkPlan *> Plan;
        /// Optional element 'prodml2:ChangeLog' of XSD type 'prodml2:ProductFlowChangeLog'
        std::vector<prodml2__ProductFlowChangeLog *> ChangeLog;
        /// Required element 'prodml2:Unit' of XSD type 'prodml2:ProductFlowUnit'
        std::vector<prodml2__ProductFlowUnit *> Unit;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowNetwork, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowNetwork *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowNetwork); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowNetwork() : Name(), PlanName(), ParentNetworkReference(), Comment(), Port(), Plan(), ChangeLog(), Unit(), uid(), soap() { }
        virtual ~prodml2__ProductFlowNetwork() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowNetwork(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowNetwork * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowNetwork(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:420 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition (78)
/* complex XSD type 'prodml2:VaporComposition': */
class SOAP_CMAC prodml2__VaporComposition {
      public:
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
        /// Optional element 'prodml2:VaporComponent' of XSD type 'prodml2:FluidComponent'
        std::vector<prodml2__FluidComponent *> VaporComponent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__VaporComposition, default initialized and not managed by a soap context
        virtual prodml2__VaporComposition *soap_alloc(void) const { return SOAP_NEW(prodml2__VaporComposition); }
      public:
        /// Constructor with initializations
        prodml2__VaporComposition() : Remark(), VaporComponent(), soap() { }
        virtual ~prodml2__VaporComposition() { }
        /// Friend allocator used by soap_new_prodml2__VaporComposition(struct soap*, int)
        friend SOAP_FMAC1 prodml2__VaporComposition * SOAP_FMAC2 soap_instantiate_prodml2__VaporComposition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:423 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure (79)
/* complex XSD type 'prodml2:VolumeQualifiedMeasure': */
class SOAP_CMAC prodml2__VolumeQualifiedMeasure {
      public:
        /// optional attribute 'status' of XSD type 'prodml2:ValueStatus'
        enum prodml2__ValueStatus *status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__VolumeQualifiedMeasure, default initialized and not managed by a soap context
        virtual prodml2__VolumeQualifiedMeasure *soap_alloc(void) const { return SOAP_NEW(prodml2__VolumeQualifiedMeasure); }
      public:
        /// Constructor with initializations
        prodml2__VolumeQualifiedMeasure() : status(), soap() { }
        virtual ~prodml2__VolumeQualifiedMeasure() { }
        /// Friend allocator used by soap_new_prodml2__VolumeQualifiedMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml2__VolumeQualifiedMeasure * SOAP_FMAC2 soap_instantiate_prodml2__VolumeQualifiedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:426 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord (80)
/* complex XSD type 'prodml2:WellElevationCoord': */
class SOAP_CMAC prodml2__WellElevationCoord {
      public:
        /// required attribute 'uom' of XSD type 'eml21:VerticalCoordinateUom'
        enum eml21__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__WellElevationCoord, default initialized and not managed by a soap context
        virtual prodml2__WellElevationCoord *soap_alloc(void) const { return SOAP_NEW(prodml2__WellElevationCoord); }
      public:
        /// Constructor with initializations
        prodml2__WellElevationCoord() : uom(), soap() { }
        virtual ~prodml2__WellElevationCoord() { }
        /// Friend allocator used by soap_new_prodml2__WellElevationCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml2__WellElevationCoord * SOAP_FMAC2 soap_instantiate_prodml2__WellElevationCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:429 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord (81)
/* complex XSD type 'prodml2:WellVerticalDepthCoord': */
class SOAP_CMAC prodml2__WellVerticalDepthCoord {
      public:
        /// required attribute 'uom' of XSD type 'eml21:VerticalCoordinateUom'
        enum eml21__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__WellVerticalDepthCoord, default initialized and not managed by a soap context
        virtual prodml2__WellVerticalDepthCoord *soap_alloc(void) const { return SOAP_NEW(prodml2__WellVerticalDepthCoord); }
      public:
        /// Constructor with initializations
        prodml2__WellVerticalDepthCoord() : uom(), soap() { }
        virtual ~prodml2__WellVerticalDepthCoord() { }
        /// Friend allocator used by soap_new_prodml2__WellVerticalDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml2__WellVerticalDepthCoord * SOAP_FMAC2 soap_instantiate_prodml2__WellVerticalDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:432 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume (82)
/* complex XSD type 'prodml2:CommonPropertiesProductVolume': */
class SOAP_CMAC prodml2__CommonPropertiesProductVolume {
      public:
        /// Optional element 'prodml2:Gor' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *Gor;
        /// Optional element 'prodml2:GorMTD' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *GorMTD;
        /// Optional element 'prodml2:GasLiquidRatio' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *GasLiquidRatio;
        /// Optional element 'prodml2:WaterConcMass' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *WaterConcMass;
        /// Optional element 'prodml2:WaterConcVol' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *WaterConcVol;
        /// Optional element 'prodml2:Atmosphere' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *Atmosphere;
        /// Optional element 'prodml2:Temp' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *Temp;
        /// Optional element 'prodml2:Pres' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *Pres;
        /// Optional element 'prodml2:AbsoluteMinPres' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *AbsoluteMinPres;
        /// Optional element 'prodml2:Mass' of XSD type 'eml21:MassMeasure'
        eml21__MassMeasure *Mass;
        /// Optional element 'prodml2:Work' of XSD type 'eml21:EnergyMeasure'
        eml21__EnergyMeasure *Work;
        /// Optional element 'prodml2:Efficiency' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *Efficiency;
        /// Optional element 'prodml2:Rvp' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *Rvp;
        /// Optional element 'prodml2:Tvp' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *Tvp;
        /// Optional element 'prodml2:Bsw' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *Bsw;
        /// Optional element 'prodml2:BswPrevious' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *BswPrevious;
        /// Optional element 'prodml2:DensityFlowRate' of XSD type 'eml21:MassPerTimeMeasure'
        eml21__MassPerTimeMeasure *DensityFlowRate;
        /// Optional element 'prodml2:Concentration' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *Concentration;
        /// Optional element 'prodml2:MolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml2:WeightPercent' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *WeightPercent;
        /// Optional element 'prodml2:MolePercent' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *MolePercent;
        /// Optional element 'prodml2:MoleAmt' of XSD type 'eml21:AmountOfSubstanceMeasure'
        eml21__AmountOfSubstanceMeasure *MoleAmt;
        /// Optional element 'prodml2:Sg' of XSD type 'eml21:DimensionlessMeasure'
        eml21__DimensionlessMeasure *Sg;
        /// Optional element 'prodml2:HcDewpoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *HcDewpoint;
        /// Optional element 'prodml2:WaterDewpoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *WaterDewpoint;
        /// Optional element 'prodml2:WobbeIndex' of XSD type 'eml21:IsothermalCompressibilityMeasure'
        eml21__IsothermalCompressibilityMeasure *WobbeIndex;
        /// Optional element 'prodml2:GrossCalorificValueStd' of XSD type 'eml21:EnergyPerVolumeMeasure'
        eml21__EnergyPerVolumeMeasure *GrossCalorificValueStd;
        /// Optional element 'prodml2:RvpStabilizedCrude' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *RvpStabilizedCrude;
        /// Optional element 'prodml2:BswStabilizedCrude' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *BswStabilizedCrude;
        /// Optional element 'prodml2:DensityStabilizedCrude' of XSD type 'eml21:MassPerVolumeMeasure'
        eml21__MassPerVolumeMeasure *DensityStabilizedCrude;
        /// Optional element 'prodml2:DensityValue' of XSD type 'eml21:DensityValue'
        std::vector<eml21__DensityValue *> DensityValue;
        /// Optional element 'prodml2:PortDiff' of XSD type 'prodml2:ProductVolumePortDifference'
        std::vector<prodml2__ProductVolumePortDifference *> PortDiff;
        /// Optional element 'prodml2:VolumeValue' of XSD type 'eml21:VolumeValue'
        std::vector<eml21__VolumeValue *> VolumeValue;
        /// Optional element 'prodml2:FlowRateValue' of XSD type 'eml21:FlowRateValue'
        std::vector<eml21__FlowRateValue *> FlowRateValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__CommonPropertiesProductVolume, default initialized and not managed by a soap context
        virtual prodml2__CommonPropertiesProductVolume *soap_alloc(void) const { return SOAP_NEW(prodml2__CommonPropertiesProductVolume); }
      public:
        /// Constructor with initializations
        prodml2__CommonPropertiesProductVolume() : Gor(), GorMTD(), GasLiquidRatio(), WaterConcMass(), WaterConcVol(), Atmosphere(), Temp(), Pres(), AbsoluteMinPres(), Mass(), Work(), Efficiency(), Rvp(), Tvp(), Bsw(), BswPrevious(), DensityFlowRate(), Concentration(), MolecularWeight(), WeightPercent(), MolePercent(), MoleAmt(), Sg(), HcDewpoint(), WaterDewpoint(), WobbeIndex(), GrossCalorificValueStd(), RvpStabilizedCrude(), BswStabilizedCrude(), DensityStabilizedCrude(), DensityValue(), PortDiff(), VolumeValue(), FlowRateValue(), soap() { }
        virtual ~prodml2__CommonPropertiesProductVolume() { }
        /// Friend allocator used by soap_new_prodml2__CommonPropertiesProductVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml2__CommonPropertiesProductVolume * SOAP_FMAC2 soap_instantiate_prodml2__CommonPropertiesProductVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:19147 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__union_AbstractMeasureDataType
#define SOAP_TYPE_gsoap_eml2_1__prodml2__union_AbstractMeasureDataType (1286)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml2__union_AbstractMeasureDataType
{
};
#endif

/* eml2_1ForGsoap.h:435 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType (83)
/* Type prodml2__AbstractMeasureDataType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Choice: */
class SOAP_CMAC prodml2__AbstractMeasureDataType {
      public:
        /// Union with union _prodml2__union_AbstractMeasureDataType variant selector __union_AbstractMeasureDataType set to one of:
        int __union_AbstractMeasureDataType;
        union _prodml2__union_AbstractMeasureDataType union_AbstractMeasureDataType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractMeasureDataType, default initialized and not managed by a soap context
        virtual prodml2__AbstractMeasureDataType *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractMeasureDataType); }
      public:
        /// Constructor with initializations
        prodml2__AbstractMeasureDataType() : __union_AbstractMeasureDataType(), soap() { }
        virtual ~prodml2__AbstractMeasureDataType() { }
        /// Friend allocator used by soap_new_prodml2__AbstractMeasureDataType(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractMeasureDataType * SOAP_FMAC2 soap_instantiate_prodml2__AbstractMeasureDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:19174 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__union_AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_1__prodml2__union_AbstractRefProductFlow (1287)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml2__union_AbstractRefProductFlow
{
};
#endif

/* eml2_1ForGsoap.h:438 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow (84)
/* Type prodml2__AbstractRefProductFlow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Choice: */
class SOAP_CMAC prodml2__AbstractRefProductFlow {
      public:
        /// Union with union _prodml2__union_AbstractRefProductFlow variant selector __union_AbstractRefProductFlow set to one of:
        int __union_AbstractRefProductFlow;
        union _prodml2__union_AbstractRefProductFlow union_AbstractRefProductFlow;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractRefProductFlow, default initialized and not managed by a soap context
        virtual prodml2__AbstractRefProductFlow *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractRefProductFlow); }
      public:
        /// Constructor with initializations
        prodml2__AbstractRefProductFlow() : __union_AbstractRefProductFlow(), soap() { }
        virtual ~prodml2__AbstractRefProductFlow() { }
        /// Friend allocator used by soap_new_prodml2__AbstractRefProductFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractRefProductFlow * SOAP_FMAC2 soap_instantiate_prodml2__AbstractRefProductFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:441 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject (85)
/* Type prodml2__AbstractRelatedFacilityObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractRelatedFacilityObject': */
class SOAP_CMAC prodml2__AbstractRelatedFacilityObject {
      public:
        /// Required element 'prodml2:FacilityParent' of XSD type 'prodml2:FacilityParent'
        prodml2__FacilityParent *FacilityParent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractRelatedFacilityObject, default initialized and not managed by a soap context
        virtual prodml2__AbstractRelatedFacilityObject *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractRelatedFacilityObject); }
      public:
        /// Constructor with initializations
        prodml2__AbstractRelatedFacilityObject() : FacilityParent(), soap() { }
        virtual ~prodml2__AbstractRelatedFacilityObject() { }
        /// Friend allocator used by soap_new_prodml2__AbstractRelatedFacilityObject(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractRelatedFacilityObject * SOAP_FMAC2 soap_instantiate_prodml2__AbstractRelatedFacilityObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:447 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition (87)
/* complex XSD type 'prodml2:CurveDefinition': */
class SOAP_CMAC prodml2__CurveDefinition {
      public:
        /// Required element 'prodml2:Order' of XSD type 'xsd:unsignedLong'
        ULONG64 Order;
        /// Required element 'prodml2:Parameter' of XSD type 'eml21:String64'
        std::string Parameter;
        /// Optional element 'prodml2:IsIndex' of XSD type 'xsd:boolean'
        bool *IsIndex;
        /// Required element 'prodml2:MeasureClass' of XSD type 'eml21:MeasureClass'
        enum eml21__MeasureClass MeasureClass;
        /// Required element 'prodml2:Unit' of XSD type 'eml21:UomEnum'
        std::string Unit;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__CurveDefinition, default initialized and not managed by a soap context
        virtual prodml2__CurveDefinition *soap_alloc(void) const { return SOAP_NEW(prodml2__CurveDefinition); }
      public:
        /// Constructor with initializations
        prodml2__CurveDefinition() : Order(), Parameter(), IsIndex(), MeasureClass(), Unit(), uid(), soap() { }
        virtual ~prodml2__CurveDefinition() { }
        /// Friend allocator used by soap_new_prodml2__CurveDefinition(struct soap*, int)
        friend SOAP_FMAC1 prodml2__CurveDefinition * SOAP_FMAC2 soap_instantiate_prodml2__CurveDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:19270 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__union_OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_1__prodml2__union_OwnershipBusinessAcct (1291)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _prodml2__union_OwnershipBusinessAcct
{
};
#endif

/* eml2_1ForGsoap.h:459 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct (91)
/* Choice: */
class SOAP_CMAC prodml2__OwnershipBusinessAcct {
      public:
        /// Union with union _prodml2__union_OwnershipBusinessAcct variant selector __union_OwnershipBusinessAcct set to one of:
        int __union_OwnershipBusinessAcct;
        union _prodml2__union_OwnershipBusinessAcct union_OwnershipBusinessAcct;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__OwnershipBusinessAcct, default initialized and not managed by a soap context
        virtual prodml2__OwnershipBusinessAcct *soap_alloc(void) const { return SOAP_NEW(prodml2__OwnershipBusinessAcct); }
      public:
        /// Constructor with initializations
        prodml2__OwnershipBusinessAcct() : __union_OwnershipBusinessAcct(), soap() { }
        virtual ~prodml2__OwnershipBusinessAcct() { }
        /// Friend allocator used by soap_new_prodml2__OwnershipBusinessAcct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__OwnershipBusinessAcct * SOAP_FMAC2 soap_instantiate_prodml2__OwnershipBusinessAcct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:468 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert (94)
/* complex XSD type 'prodml2:ProductVolumeAlert': */
class SOAP_CMAC prodml2__ProductVolumeAlert {
      public:
        /// Optional element 'prodml2:Target' of XSD type 'eml21:String2000'
        std::string *Target;
        /// Optional element 'prodml2:Level' of XSD type 'eml21:String64'
        std::string *Level;
        /// Optional element 'prodml2:Type' of XSD type 'eml21:String64'
        std::string *Type;
        /// Optional element 'prodml2:Description' of XSD type 'eml21:String2000'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeAlert, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeAlert *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeAlert); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeAlert() : Target(), Level(), Type(), Description(), soap() { }
        virtual ~prodml2__ProductVolumeAlert() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeAlert(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeAlert * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeAlert(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:471 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail (95)
/* complex XSD type 'prodml2:ProductVolumeBalanceDetail': */
class SOAP_CMAC prodml2__ProductVolumeBalanceDetail {
      public:
        /// Required element 'prodml2:Owner' of XSD type 'eml21:String64'
        std::string Owner;
        /// Optional element 'prodml2:SourceUnit' of XSD type 'eml21:String64'
        std::string *SourceUnit;
        /// Optional element 'prodml2:Share' of XSD type 'eml21:VolumePerVolumeMeasure'
        eml21__VolumePerVolumeMeasure *Share;
        /// Optional element 'prodml2:AccountNumber' of XSD type 'eml21:String64'
        std::string *AccountNumber;
        /// Optional element 'prodml2:SampleAnalysisResult' of XSD type 'eml21:String64'
        std::vector<std::string> SampleAnalysisResult;
        /// Optional element 'prodml2:ComponentContent' of XSD type 'prodml2:ProductVolumeComponentContent'
        std::vector<prodml2__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml2:Event' of XSD type 'prodml2:ProductVolumeBalanceEvent'
        std::vector<prodml2__ProductVolumeBalanceEvent *> Event;
        /// Optional element 'prodml2:VolumeValue' of XSD type 'eml21:VolumeValue'
        std::vector<eml21__VolumeValue *> VolumeValue;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeBalanceDetail, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeBalanceDetail *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeBalanceDetail); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeBalanceDetail() : Owner(), SourceUnit(), Share(), AccountNumber(), SampleAnalysisResult(), ComponentContent(), Event(), VolumeValue(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeBalanceDetail() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeBalanceDetail(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeBalanceDetail * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeBalanceDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:474 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent (96)
/* complex XSD type 'prodml2:ProductVolumeBalanceEvent': */
class SOAP_CMAC prodml2__ProductVolumeBalanceEvent {
      public:
        /// Required element 'prodml2:Date' of XSD type 'xsd:date'
        std::string Date;
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:BalanceEventKind'
        enum prodml2__BalanceEventKind Kind;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeBalanceEvent, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeBalanceEvent *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeBalanceEvent); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeBalanceEvent() : Date(), Kind(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeBalanceEvent() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeBalanceEvent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeBalanceEvent * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeBalanceEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:477 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet (97)
/* complex XSD type 'prodml2:ProductVolumeBalanceSet': */
class SOAP_CMAC prodml2__ProductVolumeBalanceSet {
      public:
        /// Optional element 'prodml2:Kind' of XSD type 'prodml2:BalanceFlowPart'
        enum prodml2__BalanceFlowPart *Kind;
        /// Optional element 'prodml2:CargoNumber' of XSD type 'eml21:String64'
        std::string *CargoNumber;
        /// Optional element 'prodml2:CargoBatchNumber' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *CargoBatchNumber;
        /// Optional element 'prodml2:Shipper' of XSD type 'eml21:String64'
        std::string *Shipper;
        /// Optional element 'prodml2:BalanceDetail' of XSD type 'prodml2:ProductVolumeBalanceDetail'
        std::vector<prodml2__ProductVolumeBalanceDetail *> BalanceDetail;
        /// Optional element 'prodml2:Destination' of XSD type 'prodml2:ProductVolumeDestination'
        prodml2__ProductVolumeDestination *Destination;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeBalanceSet, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeBalanceSet *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeBalanceSet); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeBalanceSet() : Kind(), CargoNumber(), CargoBatchNumber(), Shipper(), BalanceDetail(), Destination(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeBalanceSet() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeBalanceSet(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeBalanceSet * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeBalanceSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:480 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit (98)
/* complex XSD type 'prodml2:ProductVolumeBusinessSubUnit': */
class SOAP_CMAC prodml2__ProductVolumeBusinessSubUnit {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'eml21:String64'
        std::string Kind;
        /// Required element 'prodml2:OwnershipBusinessAcct' of XSD type 'prodml2:OwnershipBusinessAcct'
        prodml2__OwnershipBusinessAcct *OwnershipBusinessAcct;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeBusinessSubUnit, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeBusinessSubUnit *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeBusinessSubUnit); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeBusinessSubUnit() : Kind(), OwnershipBusinessAcct(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeBusinessSubUnit() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeBusinessSubUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeBusinessSubUnit * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeBusinessSubUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:483 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit (99)
/* complex XSD type 'prodml2:ProductVolumeBusinessUnit': */
class SOAP_CMAC prodml2__ProductVolumeBusinessUnit {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:BusinessUnitKind'
        enum prodml2__BusinessUnitKind Kind;
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Optional element 'prodml2:Description' of XSD type 'eml21:String2000'
        std::string *Description;
        /// Optional element 'prodml2:SubUnit' of XSD type 'prodml2:ProductVolumeBusinessSubUnit'
        std::vector<prodml2__ProductVolumeBusinessSubUnit *> SubUnit;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeBusinessUnit, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeBusinessUnit *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeBusinessUnit); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeBusinessUnit() : Kind(), Name(), Description(), SubUnit(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeBusinessUnit() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeBusinessUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeBusinessUnit * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeBusinessUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:486 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent (100)
/* complex XSD type 'prodml2:ProductVolumeComponentContent': */
class SOAP_CMAC prodml2__ProductVolumeComponentContent {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:ReportingProduct'
        enum prodml2__ReportingProduct Kind;
        /// Optional element 'prodml2:ReferenceKind' of XSD type 'prodml2:ReportingProduct'
        enum prodml2__ReportingProduct *ReferenceKind;
        /// Optional element 'prodml2:Properties' of XSD type 'prodml2:CommonPropertiesProductVolume'
        prodml2__CommonPropertiesProductVolume *Properties;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeComponentContent, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeComponentContent *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeComponentContent); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeComponentContent() : Kind(), ReferenceKind(), Properties(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeComponentContent() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeComponentContent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeComponentContent * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeComponentContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:489 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination (101)
/* complex XSD type 'prodml2:ProductVolumeDestination': */
class SOAP_CMAC prodml2__ProductVolumeDestination {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Optional element 'prodml2:Type' of XSD type 'prodml2:BalanceDestinationType'
        enum prodml2__BalanceDestinationType *Type;
        /// Optional element 'prodml2:Country' of XSD type 'eml21:String64'
        std::string *Country;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeDestination, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeDestination *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeDestination); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeDestination() : Name(), Type(), Country(), soap() { }
        virtual ~prodml2__ProductVolumeDestination() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeDestination(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeDestination * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeDestination(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:492 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility (102)
/* complex XSD type 'prodml2:ProductVolumeFacility': */
class SOAP_CMAC prodml2__ProductVolumeFacility {
      public:
        /// Optional element 'prodml2:FacilityParent' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent;
        /// Optional element 'prodml2:FacilityParent2' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent2;
        /// Optional element 'prodml2:FacilityAlias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> FacilityAlias;
        /// Optional element 'prodml2:Unit' of XSD type 'eml21:String64'
        std::string *Unit;
        /// Optional element 'prodml2:NetWork' of XSD type 'eml21:String64'
        std::string *NetWork;
        /// Required element 'prodml2:Name' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Name;
        /// Optional element 'prodml2:StatusWell' of XSD type 'eml21:WellStatus'
        enum eml21__WellStatus *StatusWell;
        /// Optional element 'prodml2:FluidWell' of XSD type 'prodml2:WellFluid'
        enum prodml2__WellFluid *FluidWell;
        /// Optional element 'prodml2:OperatingMethod' of XSD type 'prodml2:WellOperationMethod'
        enum prodml2__WellOperationMethod *OperatingMethod;
        /// Optional element 'prodml2:WellProducing' of XSD type 'xsd:boolean'
        bool *WellProducing;
        /// Optional element 'prodml2:WellInjecting' of XSD type 'xsd:boolean'
        bool *WellInjecting;
        /// Optional element 'prodml2:Capacity' of XSD type 'eml21:VolumeMeasure'
        eml21__VolumeMeasure *Capacity;
        /// Optional element 'prodml2:OperationTime' of XSD type 'eml21:TimeMeasure'
        eml21__TimeMeasure *OperationTime;
        /// Optional element 'prodml2:Flow' of XSD type 'prodml2:ProductVolumeFlow'
        std::vector<prodml2__ProductVolumeFlow *> Flow;
        /// Optional element 'prodml2:ParameterSet' of XSD type 'prodml2:ProductVolumeParameterSet'
        std::vector<prodml2__ProductVolumeParameterSet *> ParameterSet;
        /// Optional element 'prodml2:DowntimeReason' of XSD type 'prodml2:DatedComment'
        std::vector<prodml2__DatedComment *> DowntimeReason;
        /// Optional element 'prodml2:Comment' of XSD type 'prodml2:DatedComment'
        std::vector<prodml2__DatedComment *> Comment;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeFacility, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeFacility *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeFacility); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeFacility() : FacilityParent(), FacilityParent2(), FacilityAlias(), Unit(), NetWork(), Name(), StatusWell(), FluidWell(), OperatingMethod(), WellProducing(), WellInjecting(), Capacity(), OperationTime(), Flow(), ParameterSet(), DowntimeReason(), Comment(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeFacility() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeFacility(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeFacility * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeFacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:495 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow (103)
/* complex XSD type 'prodml2:ProductVolumeFlow': */
class SOAP_CMAC prodml2__ProductVolumeFlow {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:ReportingFlow'
        enum prodml2__ReportingFlow Kind;
        /// Optional element 'prodml2:Port' of XSD type 'eml21:String64'
        std::string *Port;
        /// Optional element 'prodml2:Direction' of XSD type 'prodml2:ProductFlowPortType'
        enum prodml2__ProductFlowPortType *Direction;
        /// Optional element 'prodml2:Facility' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml2:FacilityAlias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> FacilityAlias;
        /// Optional element 'prodml2:Qualifier' of XSD type 'prodml2:FlowQualifier'
        enum prodml2__FlowQualifier *Qualifier;
        /// Optional element 'prodml2:SubQualifier' of XSD type 'prodml2:FlowSubQualifier'
        enum prodml2__FlowSubQualifier *SubQualifier;
        /// Optional element 'prodml2:Version' of XSD type 'eml21:TimeStamp'
        std::string *Version;
        /// Optional element 'prodml2:VersionSource' of XSD type 'eml21:String64'
        std::string *VersionSource;
        /// Optional element 'prodml2:SourceFlow' of XSD type 'eml21:String64'
        std::string *SourceFlow;
        /// Optional element 'prodml2:RelatedFacility' of XSD type 'prodml2:ProductVolumeRelatedFacility'
        prodml2__ProductVolumeRelatedFacility *RelatedFacility;
        /// Optional element 'prodml2:Product' of XSD type 'prodml2:ProductVolumeProduct'
        std::vector<prodml2__ProductVolumeProduct *> Product;
        /// Optional element 'prodml2:Properties' of XSD type 'prodml2:CommonPropertiesProductVolume'
        prodml2__CommonPropertiesProductVolume *Properties;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeFlow, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeFlow *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeFlow); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeFlow() : Name(), Kind(), Port(), Direction(), Facility(), FacilityAlias(), Qualifier(), SubQualifier(), Version(), VersionSource(), SourceFlow(), RelatedFacility(), Product(), Properties(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeFlow() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeFlow * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:498 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet (104)
/* complex XSD type 'prodml2:ProductVolumeParameterSet': */
class SOAP_CMAC prodml2__ProductVolumeParameterSet {
      public:
        /// Required element 'prodml2:Name' of XSD type 'prodml2:FacilityParameter'
        enum prodml2__FacilityParameter Name;
        /// Optional element 'prodml2:ChildFacilityIdentifier' of XSD type 'prodml2:ProdmlRelativeIdentifier'
        std::string *ChildFacilityIdentifier;
        /// Optional element 'prodml2:Port' of XSD type 'eml21:String64'
        std::string *Port;
        /// Optional element 'prodml2:MeasureClass' of XSD type 'eml21:MeasureClass'
        enum eml21__MeasureClass *MeasureClass;
        /// Optional element 'prodml2:CoordinateReferenceSystem' of XSD type 'eml21:String64'
        std::string *CoordinateReferenceSystem;
        /// Optional element 'prodml2:Qualifier' of XSD type 'prodml2:FlowQualifier'
        enum prodml2__FlowQualifier *Qualifier;
        /// Optional element 'prodml2:SubQualifier' of XSD type 'prodml2:FlowSubQualifier'
        enum prodml2__FlowSubQualifier *SubQualifier;
        /// Optional element 'prodml2:Version' of XSD type 'xsd:dateTime'
        time_t *Version;
        /// Optional element 'prodml2:VersionSource' of XSD type 'eml21:String64'
        std::string *VersionSource;
        /// Optional element 'prodml2:Product' of XSD type 'prodml2:ReportingProduct'
        enum prodml2__ReportingProduct *Product;
        /// Optional element 'prodml2:PeriodKind' of XSD type 'prodml2:ReportingDurationKind'
        enum prodml2__ReportingDurationKind *PeriodKind;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Required element 'prodml2:Parameter' of XSD type 'prodml2:ProductVolumeParameterValue'
        std::vector<prodml2__ProductVolumeParameterValue *> Parameter;
        /// Optional element 'prodml2:CurveDefinition' of XSD type 'prodml2:CurveDefinition'
        std::vector<prodml2__CurveDefinition *> CurveDefinition;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeParameterSet, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeParameterSet *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeParameterSet); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeParameterSet() : Name(), ChildFacilityIdentifier(), Port(), MeasureClass(), CoordinateReferenceSystem(), Qualifier(), SubQualifier(), Version(), VersionSource(), Product(), PeriodKind(), Comment(), Parameter(), CurveDefinition(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeParameterSet() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeParameterSet(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeParameterSet * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeParameterSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:501 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue (105)
/* complex XSD type 'prodml2:ProductVolumeParameterValue': */
class SOAP_CMAC prodml2__ProductVolumeParameterValue {
      public:
        /// Optional element 'prodml2:DTim' of XSD type 'xsd:dateTime'
        time_t *DTim;
        /// Optional element 'prodml2:DTimEnd' of XSD type 'xsd:dateTime'
        time_t *DTimEnd;
        /// Optional element 'prodml2:Port' of XSD type 'eml21:String64'
        std::string *Port;
        /// Optional element 'prodml2:Unit' of XSD type 'eml21:String64'
        std::string *Unit;
        /// Optional element 'prodml2:Alert' of XSD type 'prodml2:ProductVolumeAlert'
        prodml2__ProductVolumeAlert *Alert;
        /// Required element 'prodml2:MeasureDataType' of XSD type 'prodml2:AbstractMeasureDataType'
        std::vector<prodml2__AbstractMeasureDataType *> MeasureDataType;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeParameterValue, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeParameterValue *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeParameterValue); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeParameterValue() : DTim(), DTimEnd(), Port(), Unit(), Alert(), MeasureDataType(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeParameterValue() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeParameterValue(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeParameterValue * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeParameterValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:504 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod (106)
/* complex XSD type 'prodml2:ProductVolumePeriod': */
class SOAP_CMAC prodml2__ProductVolumePeriod {
      public:
        /// Optional element 'prodml2:Kind' of XSD type 'prodml2:ReportingDurationKind'
        enum prodml2__ReportingDurationKind *Kind;
        /// Optional element 'prodml2:Comment' of XSD type 'prodml2:DatedComment'
        std::vector<prodml2__DatedComment *> Comment;
        /// Optional element 'prodml2:BalanceSet' of XSD type 'prodml2:ProductVolumeBalanceSet'
        std::vector<prodml2__ProductVolumeBalanceSet *> BalanceSet;
        /// Optional element 'prodml2:ComponentContent' of XSD type 'prodml2:ProductVolumeComponentContent'
        std::vector<prodml2__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml2:DateTime' of XSD type 'prodml2:AbstractDateTimeClass'
        prodml2__AbstractDateTimeClass *DateTime;
        /// Optional element 'prodml2:Properties' of XSD type 'prodml2:CommonPropertiesProductVolume'
        prodml2__CommonPropertiesProductVolume *Properties;
        /// Optional element 'prodml2:Alert' of XSD type 'prodml2:ProductVolumeAlert'
        prodml2__ProductVolumeAlert *Alert;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumePeriod, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumePeriod *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumePeriod); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumePeriod() : Kind(), Comment(), BalanceSet(), ComponentContent(), DateTime(), Properties(), Alert(), uid(), soap() { }
        virtual ~prodml2__ProductVolumePeriod() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumePeriod(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumePeriod * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumePeriod(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:507 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference (107)
/* complex XSD type 'prodml2:ProductVolumePortDifference': */
class SOAP_CMAC prodml2__ProductVolumePortDifference {
      public:
        /// Optional element 'prodml2:PortReference' of XSD type 'eml21:String64'
        std::string *PortReference;
        /// Optional element 'prodml2:PresDiff' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *PresDiff;
        /// Optional element 'prodml2:TempDiff' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *TempDiff;
        /// Optional element 'prodml2:ChokeSize' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *ChokeSize;
        /// Optional element 'prodml2:ChokeRelative' of XSD type 'eml21:LengthPerLengthMeasure'
        eml21__LengthPerLengthMeasure *ChokeRelative;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumePortDifference, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumePortDifference *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumePortDifference); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumePortDifference() : PortReference(), PresDiff(), TempDiff(), ChokeSize(), ChokeRelative(), uid(), soap() { }
        virtual ~prodml2__ProductVolumePortDifference() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumePortDifference(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumePortDifference * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumePortDifference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:510 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct (108)
/* complex XSD type 'prodml2:ProductVolumeProduct': */
class SOAP_CMAC prodml2__ProductVolumeProduct {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:ReportingProduct'
        enum prodml2__ReportingProduct Kind;
        /// Optional element 'prodml2:Name' of XSD type 'prodml2:NameStruct'
        prodml2__NameStruct *Name;
        /// Optional element 'prodml2:SplitFactor' of XSD type 'prodml2:NonNegativeFraction'
        float *SplitFactor;
        /// Optional element 'prodml2:MassFraction' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *MassFraction;
        /// Optional element 'prodml2:MoleFraction' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure'
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *MoleFraction;
        /// Optional element 'prodml2:ComponentContent' of XSD type 'prodml2:ProductVolumeComponentContent'
        std::vector<prodml2__ProductVolumeComponentContent *> ComponentContent;
        /// Optional element 'prodml2:SourceFlow' of XSD type 'prodml2:AbstractRefProductFlow'
        prodml2__AbstractRefProductFlow *SourceFlow;
        /// Required element 'prodml2:Period' of XSD type 'prodml2:ProductVolumePeriod'
        std::vector<prodml2__ProductVolumePeriod *> Period;
        /// Optional element 'prodml2:Properties' of XSD type 'prodml2:CommonPropertiesProductVolume'
        prodml2__CommonPropertiesProductVolume *Properties;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeProduct, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeProduct *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeProduct); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeProduct() : Kind(), Name(), SplitFactor(), MassFraction(), MoleFraction(), ComponentContent(), SourceFlow(), Period(), Properties(), uid(), soap() { }
        virtual ~prodml2__ProductVolumeProduct() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeProduct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeProduct * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:20136 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__ProductVolumeRelatedFacility_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__ProductVolumeRelatedFacility_sequence (1341)
/* Wrapper: */
class SOAP_CMAC __prodml2__ProductVolumeRelatedFacility_sequence {
      public:
        /// Optional element 'prodml2:Kind' of XSD type 'prodml2:ReportingFacility'
        enum prodml2__ReportingFacility *Kind;
        /// Optional element 'prodml2:RelatedFacilityObject' of XSD type 'prodml2:AbstractRelatedFacilityObject'
        prodml2__AbstractRelatedFacilityObject *RelatedFacilityObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__ProductVolumeRelatedFacility_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__ProductVolumeRelatedFacility_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__ProductVolumeRelatedFacility_sequence, default initialized and not managed by a soap context
        virtual __prodml2__ProductVolumeRelatedFacility_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__ProductVolumeRelatedFacility_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__ProductVolumeRelatedFacility_sequence() : Kind(), RelatedFacilityObject() { }
        virtual ~__prodml2__ProductVolumeRelatedFacility_sequence() { }
        /// Friend allocator used by soap_new___prodml2__ProductVolumeRelatedFacility_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__ProductVolumeRelatedFacility_sequence * SOAP_FMAC2 soap_instantiate___prodml2__ProductVolumeRelatedFacility_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:513 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility (109)
/* complex XSD type 'prodml2:ProductVolumeRelatedFacility': */
class SOAP_CMAC prodml2__ProductVolumeRelatedFacility {
      public:
        __prodml2__ProductVolumeRelatedFacility_sequence *__ProductVolumeRelatedFacility_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolumeRelatedFacility, default initialized and not managed by a soap context
        virtual prodml2__ProductVolumeRelatedFacility *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolumeRelatedFacility); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolumeRelatedFacility() : __ProductVolumeRelatedFacility_sequence(), soap() { }
        virtual ~prodml2__ProductVolumeRelatedFacility() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolumeRelatedFacility(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolumeRelatedFacility * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolumeRelatedFacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:522 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode (112)
/* complex XSD type 'prodml2:ConnectedNode': */
class SOAP_CMAC prodml2__ConnectedNode {
      public:
        /// Required element 'prodml2:Node' of XSD type 'eml21:String64'
        std::string Node;
        /// Optional element 'prodml2:PlanName' of XSD type 'eml21:String64'
        std::string *PlanName;
        /// Optional element 'prodml2:DTimStart' of XSD type 'xsd:dateTime'
        time_t *DTimStart;
        /// Optional element 'prodml2:DTimEnd' of XSD type 'xsd:dateTime'
        time_t *DTimEnd;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ConnectedNode, default initialized and not managed by a soap context
        virtual prodml2__ConnectedNode *soap_alloc(void) const { return SOAP_NEW(prodml2__ConnectedNode); }
      public:
        /// Constructor with initializations
        prodml2__ConnectedNode() : Node(), PlanName(), DTimStart(), DTimEnd(), Comment(), uid(), soap() { }
        virtual ~prodml2__ConnectedNode() { }
        /// Friend allocator used by soap_new_prodml2__ConnectedNode(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ConnectedNode * SOAP_FMAC2 soap_instantiate_prodml2__ConnectedNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:525 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier (113)
/* Type prodml2__ExpectedFlowQualifier is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:ExpectedFlowQualifier': */
class SOAP_CMAC prodml2__ExpectedFlowQualifier {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ExpectedFlowQualifier, default initialized and not managed by a soap context
        virtual prodml2__ExpectedFlowQualifier *soap_alloc(void) const { return SOAP_NEW(prodml2__ExpectedFlowQualifier); }
      public:
        /// Constructor with initializations
        prodml2__ExpectedFlowQualifier() : soap() { }
        virtual ~prodml2__ExpectedFlowQualifier() { }
        /// Friend allocator used by soap_new_prodml2__ExpectedFlowQualifier(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ExpectedFlowQualifier * SOAP_FMAC2 soap_instantiate_prodml2__ExpectedFlowQualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:528 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog (114)
/* complex XSD type 'prodml2:ProductFlowChangeLog': */
class SOAP_CMAC prodml2__ProductFlowChangeLog {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Required element 'prodml2:DTim' of XSD type 'xsd:dateTime'
        time_t DTim;
        /// Optional element 'prodml2:Reason' of XSD type 'eml21:String2000'
        std::string *Reason;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowChangeLog, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowChangeLog *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowChangeLog); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowChangeLog() : Name(), DTim(), Reason(), uid(), soap() { }
        virtual ~prodml2__ProductFlowChangeLog() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowChangeLog(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowChangeLog * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowChangeLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:531 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty (115)
/* complex XSD type 'prodml2:ProductFlowExpectedUnitProperty': */
class SOAP_CMAC prodml2__ProductFlowExpectedUnitProperty {
      public:
        /// Required element 'prodml2:Property' of XSD type 'prodml2:FacilityParameter'
        enum prodml2__FacilityParameter Property;
        /// Optional element 'prodml2:ChildFacilityIdentifier' of XSD type 'prodml2:ProdmlRelativeIdentifier'
        std::string *ChildFacilityIdentifier;
        /// Optional element 'prodml2:TagAlias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> TagAlias;
        /// Optional element 'prodml2:Deadband' of XSD type 'prodml2:GeneralMeasureType'
        prodml2__GeneralMeasureType *Deadband;
        /// Optional element 'prodml2:MaximumFrequency' of XSD type 'eml21:TimeMeasure'
        eml21__TimeMeasure *MaximumFrequency;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:ExpectedFlowQualifier' of XSD type 'prodml2:ExpectedFlowQualifier'
        prodml2__ExpectedFlowQualifier *ExpectedFlowQualifier;
        /// Optional element 'prodml2:ExpectedFlowProduct' of XSD type 'prodml2:ProductFlowQualifierExpected'
        std::vector<prodml2__ProductFlowQualifierExpected *> ExpectedFlowProduct;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowExpectedUnitProperty, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowExpectedUnitProperty *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowExpectedUnitProperty); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowExpectedUnitProperty() : Property(), ChildFacilityIdentifier(), TagAlias(), Deadband(), MaximumFrequency(), Comment(), ExpectedFlowQualifier(), ExpectedFlowProduct(), uid(), soap() { }
        virtual ~prodml2__ProductFlowExpectedUnitProperty() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowExpectedUnitProperty(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowExpectedUnitProperty * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowExpectedUnitProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:534 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort (116)
/* complex XSD type 'prodml2:ProductFlowExternalPort': */
class SOAP_CMAC prodml2__ProductFlowExternalPort {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Required element 'prodml2:Direction' of XSD type 'prodml2:ProductFlowPortType'
        enum prodml2__ProductFlowPortType Direction;
        /// Optional element 'prodml2:Exposed' of XSD type 'xsd:boolean'
        bool *Exposed;
        /// Required element 'prodml2:ConnectedNode' of XSD type 'eml21:String64'
        std::string ConnectedNode;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowExternalPort, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowExternalPort *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowExternalPort); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowExternalPort() : Name(), Direction(), Exposed(), ConnectedNode(), Comment(), uid(), soap() { }
        virtual ~prodml2__ProductFlowExternalPort() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowExternalPort(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowExternalPort * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowExternalPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:540 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan (118)
/* complex XSD type 'prodml2:ProductFlowNetworkPlan': */
class SOAP_CMAC prodml2__ProductFlowNetworkPlan {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Required element 'prodml2:DTimStart' of XSD type 'xsd:dateTime'
        time_t DTimStart;
        /// Optional element 'prodml2:Purpose' of XSD type 'eml21:String2000'
        std::string *Purpose;
        /// Optional element 'prodml2:ChangeLog' of XSD type 'prodml2:ProductFlowChangeLog'
        std::vector<prodml2__ProductFlowChangeLog *> ChangeLog;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowNetworkPlan, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowNetworkPlan *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowNetworkPlan); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowNetworkPlan() : Name(), DTimStart(), Purpose(), ChangeLog(), uid(), soap() { }
        virtual ~prodml2__ProductFlowNetworkPlan() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowNetworkPlan(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowNetworkPlan * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowNetworkPlan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:543 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort (119)
/* complex XSD type 'prodml2:ProductFlowPort': */
class SOAP_CMAC prodml2__ProductFlowPort {
      public:
        /// Required element 'prodml2:Direction' of XSD type 'prodml2:ProductFlowPortType'
        enum prodml2__ProductFlowPortType Direction;
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:PlanName' of XSD type 'eml21:String64'
        std::string *PlanName;
        /// Optional element 'prodml2:Facility' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml2:FacilityAlias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> FacilityAlias;
        /// Optional element 'prodml2:Exposed' of XSD type 'xsd:boolean'
        bool *Exposed;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:ExpectedFlowProperty' of XSD type 'prodml2:ProductFlowExpectedUnitProperty'
        std::vector<prodml2__ProductFlowExpectedUnitProperty *> ExpectedFlowProperty;
        /// Required element 'prodml2:ConnectedNode' of XSD type 'prodml2:ConnectedNode'
        std::vector<prodml2__ConnectedNode *> ConnectedNode;
        /// Optional element 'prodml2:ExpectedFlowProduct' of XSD type 'prodml2:ProductFlowQualifierExpected'
        std::vector<prodml2__ProductFlowQualifierExpected *> ExpectedFlowProduct;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowPort, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowPort *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowPort); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowPort() : Direction(), Name(), PlanName(), Facility(), FacilityAlias(), Exposed(), Comment(), ExpectedFlowProperty(), ConnectedNode(), ExpectedFlowProduct(), uid(), soap() { }
        virtual ~prodml2__ProductFlowPort() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowPort(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowPort * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:549 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit (121)
/* complex XSD type 'prodml2:ProductFlowUnit': */
class SOAP_CMAC prodml2__ProductFlowUnit {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Optional element 'prodml2:PlanName' of XSD type 'eml21:String64'
        std::string *PlanName;
        /// Optional element 'prodml2:InternalNetworkReference' of XSD type 'eml21:String64'
        std::string *InternalNetworkReference;
        /// Optional element 'prodml2:Facility' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Facility;
        /// Optional element 'prodml2:FacilityParent1' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent1;
        /// Optional element 'prodml2:FacilityParent2' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent2;
        /// Optional element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        std::vector<prodml2__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:ExpectedProperty' of XSD type 'prodml2:ProductFlowExpectedUnitProperty'
        std::vector<prodml2__ProductFlowExpectedUnitProperty *> ExpectedProperty;
        /// Optional element 'prodml2:Port' of XSD type 'prodml2:ProductFlowPort'
        std::vector<prodml2__ProductFlowPort *> Port;
        /// Optional element 'prodml2:RelativeCoordinate' of XSD type 'prodml2:RelativeCoordinate'
        prodml2__RelativeCoordinate *RelativeCoordinate;
        /// Optional element 'prodml2:FacilityAlias' of XSD type 'prodml2:NameStruct'
        std::vector<prodml2__NameStruct *> FacilityAlias;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowUnit, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowUnit *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowUnit); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowUnit() : Name(), PlanName(), InternalNetworkReference(), Facility(), FacilityParent1(), FacilityParent2(), ContextFacility(), Comment(), ExpectedProperty(), Port(), RelativeCoordinate(), FacilityAlias(), uid(), soap() { }
        virtual ~prodml2__ProductFlowUnit() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowUnit(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowUnit * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:555 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate (123)
/* complex XSD type 'prodml2:RelativeCoordinate': */
class SOAP_CMAC prodml2__RelativeCoordinate {
      public:
        /// Optional element 'prodml2:X' of XSD type 'eml21:LengthPerLengthMeasure'
        eml21__LengthPerLengthMeasure *X;
        /// Optional element 'prodml2:Y' of XSD type 'eml21:LengthPerLengthMeasure'
        eml21__LengthPerLengthMeasure *Y;
        /// Optional element 'prodml2:Z' of XSD type 'eml21:LengthPerLengthMeasure'
        eml21__LengthPerLengthMeasure *Z;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__RelativeCoordinate, default initialized and not managed by a soap context
        virtual prodml2__RelativeCoordinate *soap_alloc(void) const { return SOAP_NEW(prodml2__RelativeCoordinate); }
      public:
        /// Constructor with initializations
        prodml2__RelativeCoordinate() : X(), Y(), Z(), soap() { }
        virtual ~prodml2__RelativeCoordinate() { }
        /// Friend allocator used by soap_new_prodml2__RelativeCoordinate(struct soap*, int)
        friend SOAP_FMAC1 prodml2__RelativeCoordinate * SOAP_FMAC2 soap_instantiate_prodml2__RelativeCoordinate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:558 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure (124)
/* Type prodml2__AbstractAttenuationMeasure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractAttenuationMeasure': */
class SOAP_CMAC prodml2__AbstractAttenuationMeasure {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractAttenuationMeasure, default initialized and not managed by a soap context
        virtual prodml2__AbstractAttenuationMeasure *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractAttenuationMeasure); }
      public:
        /// Constructor with initializations
        prodml2__AbstractAttenuationMeasure() : soap() { }
        virtual ~prodml2__AbstractAttenuationMeasure() { }
        /// Friend allocator used by soap_new_prodml2__AbstractAttenuationMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractAttenuationMeasure * SOAP_FMAC2 soap_instantiate_prodml2__AbstractAttenuationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:561 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable (125)
/* Type prodml2__AbstractCable is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractCable': */
class SOAP_CMAC prodml2__AbstractCable {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractCable, default initialized and not managed by a soap context
        virtual prodml2__AbstractCable *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractCable); }
      public:
        /// Constructor with initializations
        prodml2__AbstractCable() : soap() { }
        virtual ~prodml2__AbstractCable() { }
        /// Friend allocator used by soap_new_prodml2__AbstractCable(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractCable * SOAP_FMAC2 soap_instantiate_prodml2__AbstractCable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:564 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility (126)
/* Type prodml2__AbstractFiberFacility is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:AbstractFiberFacility': */
class SOAP_CMAC prodml2__AbstractFiberFacility {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__AbstractFiberFacility, default initialized and not managed by a soap context
        virtual prodml2__AbstractFiberFacility *soap_alloc(void) const { return SOAP_NEW(prodml2__AbstractFiberFacility); }
      public:
        /// Constructor with initializations
        prodml2__AbstractFiberFacility() : soap() { }
        virtual ~prodml2__AbstractFiberFacility() { }
        /// Friend allocator used by soap_new_prodml2__AbstractFiberFacility(struct soap*, int)
        friend SOAP_FMAC1 prodml2__AbstractFiberFacility * SOAP_FMAC2 soap_instantiate_prodml2__AbstractFiberFacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:576 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance (130)
/* complex XSD type 'prodml2:FiberConveyance': */
class SOAP_CMAC prodml2__FiberConveyance {
      public:
        /// Required element 'prodml2:Cable' of XSD type 'prodml2:AbstractCable'
        prodml2__AbstractCable *Cable;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberConveyance, default initialized and not managed by a soap context
        virtual prodml2__FiberConveyance *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberConveyance); }
      public:
        /// Constructor with initializations
        prodml2__FiberConveyance() : Cable(), soap() { }
        virtual ~prodml2__FiberConveyance() { }
        /// Friend allocator used by soap_new_prodml2__FiberConveyance(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberConveyance * SOAP_FMAC2 soap_instantiate_prodml2__FiberConveyance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:582 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping (132)
/* complex XSD type 'prodml2:FiberFacilityMapping': */
class SOAP_CMAC prodml2__FiberFacilityMapping {
      public:
        /// Required element 'prodml2:TimeStart' of XSD type 'xsd:dateTime'
        time_t TimeStart;
        /// Optional element 'prodml2:TimeEnd' of XSD type 'xsd:dateTime'
        time_t *TimeEnd;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Required element 'prodml2:FiberFacilityMappingPart' of XSD type 'prodml2:FiberFacilityMappingPart'
        std::vector<prodml2__FiberFacilityMappingPart *> FiberFacilityMappingPart;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberFacilityMapping, default initialized and not managed by a soap context
        virtual prodml2__FiberFacilityMapping *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberFacilityMapping); }
      public:
        /// Constructor with initializations
        prodml2__FiberFacilityMapping() : TimeStart(), TimeEnd(), Comment(), FiberFacilityMappingPart(), uid(), soap() { }
        virtual ~prodml2__FiberFacilityMapping() { }
        /// Friend allocator used by soap_new_prodml2__FiberFacilityMapping(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberFacilityMapping * SOAP_FMAC2 soap_instantiate_prodml2__FiberFacilityMapping(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:585 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart (133)
/* complex XSD type 'prodml2:FiberFacilityMappingPart': */
class SOAP_CMAC prodml2__FiberFacilityMappingPart {
      public:
        /// Required element 'prodml2:OpticalPathDistanceStart' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceStart;
        /// Required element 'prodml2:OpticalPathDistanceEnd' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceEnd;
        /// Required element 'prodml2:FacilityLengthStart' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *FacilityLengthStart;
        /// Required element 'prodml2:FacilityLengthEnd' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *FacilityLengthEnd;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Required element 'prodml2:FiberFacility' of XSD type 'prodml2:AbstractFiberFacility'
        prodml2__AbstractFiberFacility *FiberFacility;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberFacilityMappingPart, default initialized and not managed by a soap context
        virtual prodml2__FiberFacilityMappingPart *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberFacilityMappingPart); }
      public:
        /// Constructor with initializations
        prodml2__FiberFacilityMappingPart() : OpticalPathDistanceStart(), OpticalPathDistanceEnd(), FacilityLengthStart(), FacilityLengthEnd(), Comment(), FiberFacility(), uid(), soap() { }
        virtual ~prodml2__FiberFacilityMappingPart() { }
        /// Friend allocator used by soap_new_prodml2__FiberFacilityMappingPart(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberFacilityMappingPart * SOAP_FMAC2 soap_instantiate_prodml2__FiberFacilityMappingPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:594 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation (136)
/* complex XSD type 'prodml2:FiberOneWayAttenuation': */
class SOAP_CMAC prodml2__FiberOneWayAttenuation {
      public:
        /// Required element 'prodml2:Value' of XSD type 'eml21:LogarithmicPowerRatioPerLengthMeasure'
        eml21__LogarithmicPowerRatioPerLengthMeasure *Value;
        /// Required element 'prodml2:AttenuationMeasure' of XSD type 'prodml2:AbstractAttenuationMeasure'
        prodml2__AbstractAttenuationMeasure *AttenuationMeasure;
        /// required attribute 'uid' of XSD type 'eml21:UuidString'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOneWayAttenuation, default initialized and not managed by a soap context
        virtual prodml2__FiberOneWayAttenuation *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOneWayAttenuation); }
      public:
        /// Constructor with initializations
        prodml2__FiberOneWayAttenuation() : Value(), AttenuationMeasure(), uid(), soap() { }
        virtual ~prodml2__FiberOneWayAttenuation() { }
        /// Friend allocator used by soap_new_prodml2__FiberOneWayAttenuation(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOneWayAttenuation * SOAP_FMAC2 soap_instantiate_prodml2__FiberOneWayAttenuation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:600 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory (138)
/* complex XSD type 'prodml2:FiberOpticalPathInventory': */
class SOAP_CMAC prodml2__FiberOpticalPathInventory {
      public:
        /// Optional element 'prodml2:Connection' of XSD type 'prodml2:FiberConnection'
        std::vector<prodml2__FiberConnection *> Connection;
        /// Optional element 'prodml2:Turnaround' of XSD type 'prodml2:FiberTurnaround'
        std::vector<prodml2__FiberTurnaround *> Turnaround;
        /// Required element 'prodml2:Segment' of XSD type 'prodml2:FiberOpticalPathSegment'
        std::vector<prodml2__FiberOpticalPathSegment *> Segment;
        /// Required element 'prodml2:Terminator' of XSD type 'prodml2:FiberTerminator'
        prodml2__FiberTerminator *Terminator;
        /// Optional element 'prodml2:Splice' of XSD type 'prodml2:FiberSplice'
        std::vector<prodml2__FiberSplice *> Splice;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOpticalPathInventory, default initialized and not managed by a soap context
        virtual prodml2__FiberOpticalPathInventory *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOpticalPathInventory); }
      public:
        /// Constructor with initializations
        prodml2__FiberOpticalPathInventory() : Connection(), Turnaround(), Segment(), Terminator(), Splice(), soap() { }
        virtual ~prodml2__FiberOpticalPathInventory() { }
        /// Friend allocator used by soap_new_prodml2__FiberOpticalPathInventory(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOpticalPathInventory * SOAP_FMAC2 soap_instantiate_prodml2__FiberOpticalPathInventory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:603 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork (139)
/* complex XSD type 'prodml2:FiberOpticalPathNetwork': */
class SOAP_CMAC prodml2__FiberOpticalPathNetwork {
      public:
        /// Optional element 'prodml2:Installation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Installation;
        /// Required element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        std::vector<prodml2__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml2:DTimStart' of XSD type 'xsd:dateTime'
        time_t *DTimStart;
        /// Optional element 'prodml2:DTimeEnd' of XSD type 'xsd:dateTime'
        time_t *DTimeEnd;
        /// Optional element 'prodml2:ExistenceTime' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *ExistenceTime;
        /// Optional element 'prodml2:DTimMin' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMin;
        /// Optional element 'prodml2:DTimMax' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMax;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:ExternalConnect' of XSD type 'prodml2:ProductFlowExternalReference'
        std::vector<prodml2__ProductFlowExternalReference *> ExternalConnect;
        /// Required element 'prodml2:Network' of XSD type 'prodml2:ProductFlowNetwork'
        std::vector<prodml2__ProductFlowNetwork *> Network;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOpticalPathNetwork, default initialized and not managed by a soap context
        virtual prodml2__FiberOpticalPathNetwork *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOpticalPathNetwork); }
      public:
        /// Constructor with initializations
        prodml2__FiberOpticalPathNetwork() : Installation(), ContextFacility(), DTimStart(), DTimeEnd(), ExistenceTime(), DTimMin(), DTimMax(), Comment(), ExternalConnect(), Network(), uid(), soap() { }
        virtual ~prodml2__FiberOpticalPathNetwork() { }
        /// Friend allocator used by soap_new_prodml2__FiberOpticalPathNetwork(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOpticalPathNetwork * SOAP_FMAC2 soap_instantiate_prodml2__FiberOpticalPathNetwork(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:609 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR (141)
/* complex XSD type 'prodml2:FiberOTDR': */
class SOAP_CMAC prodml2__FiberOTDR {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:ReasonForRun' of XSD type 'prodml2:OTDRReason'
        enum prodml2__OTDRReason *ReasonForRun;
        /// Required element 'prodml2:DTimRun' of XSD type 'xsd:dateTime'
        time_t DTimRun;
        /// Optional element 'prodml2:DataInOTDRFile' of XSD type 'eml21:String64'
        std::string *DataInOTDRFile;
        /// Optional element 'prodml2:OTDRImageFile' of XSD type 'eml21:String64'
        std::string *OTDRImageFile;
        /// Required element 'prodml2:OpticalPathDistanceStart' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceStart;
        /// Required element 'prodml2:OpticalPathDistanceEnd' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceEnd;
        /// Required element 'prodml2:Direction' of XSD type 'prodml2:OTDRDirection'
        enum prodml2__OTDRDirection Direction;
        /// Required element 'prodml2:Wavelength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *Wavelength;
        /// Optional element 'prodml2:FiberOTDRInstrumentBox' of XSD type 'prodml2:FiberOTDRInstrumentBox'
        prodml2__FiberOTDRInstrumentBox *FiberOTDRInstrumentBox;
        /// Optional element 'prodml2:MeasurementContact' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *MeasurementContact;
        /// Optional element 'prodml2:ExtensionNameValue' of XSD type 'eml21:ExtensionNameValue'
        std::vector<eml21__ExtensionNameValue *> ExtensionNameValue;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOTDR, default initialized and not managed by a soap context
        virtual prodml2__FiberOTDR *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOTDR); }
      public:
        /// Constructor with initializations
        prodml2__FiberOTDR() : Name(), ReasonForRun(), DTimRun(), DataInOTDRFile(), OTDRImageFile(), OpticalPathDistanceStart(), OpticalPathDistanceEnd(), Direction(), Wavelength(), FiberOTDRInstrumentBox(), MeasurementContact(), ExtensionNameValue(), uid(), soap() { }
        virtual ~prodml2__FiberOTDR() { }
        /// Friend allocator used by soap_new_prodml2__FiberOTDR(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOTDR * SOAP_FMAC2 soap_instantiate_prodml2__FiberOTDR(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:21053 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__FiberPathDefect_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__FiberPathDefect_sequence (1378)
/* Wrapper: */
class SOAP_CMAC __prodml2__FiberPathDefect_sequence {
      public:
        /// Required element 'prodml2:OpticalPathDistanceStart' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceStart;
        /// Optional element 'prodml2:OpticalPathDistanceEnd' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathDistanceEnd;
        /// Required element 'prodml2:DefectType' of XSD type 'prodml2:PathDefectTypes'
        enum prodml2__PathDefectTypes DefectType;
        /// Optional element 'prodml2:TimeStart' of XSD type 'xsd:dateTime'
        time_t *TimeStart;
        /// Optional element 'prodml2:TimeEnd' of XSD type 'xsd:dateTime'
        time_t *TimeEnd;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__FiberPathDefect_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__FiberPathDefect_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__FiberPathDefect_sequence, default initialized and not managed by a soap context
        virtual __prodml2__FiberPathDefect_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__FiberPathDefect_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__FiberPathDefect_sequence() : OpticalPathDistanceStart(), OpticalPathDistanceEnd(), DefectType(), TimeStart(), TimeEnd(), Comment() { }
        virtual ~__prodml2__FiberPathDefect_sequence() { }
        /// Friend allocator used by soap_new___prodml2__FiberPathDefect_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__FiberPathDefect_sequence * SOAP_FMAC2 soap_instantiate___prodml2__FiberPathDefect_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:615 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect (143)
/* complex XSD type 'prodml2:FiberPathDefect': */
class SOAP_CMAC prodml2__FiberPathDefect {
      public:
        std::vector<__prodml2__FiberPathDefect_sequence> __FiberPathDefect_sequence;
        /// required attribute 'defectID' of XSD type 'eml21:String64'
        std::string defectID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberPathDefect, default initialized and not managed by a soap context
        virtual prodml2__FiberPathDefect *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberPathDefect); }
      public:
        /// Constructor with initializations
        prodml2__FiberPathDefect() : __FiberPathDefect_sequence(), defectID(), soap() { }
        virtual ~prodml2__FiberPathDefect() { }
        /// Friend allocator used by soap_new_prodml2__FiberPathDefect(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberPathDefect * SOAP_FMAC2 soap_instantiate_prodml2__FiberPathDefect(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:618 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity (144)
/* complex XSD type 'prodml2:FiberPumpActivity': */
class SOAP_CMAC prodml2__FiberPumpActivity {
      public:
        /// Optional element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string *Name;
        /// Optional element 'prodml2:InstalledFiber' of XSD type 'eml21:String64'
        std::string *InstalledFiber;
        /// Optional element 'prodml2:PumpingDate' of XSD type 'xsd:date'
        std::string *PumpingDate;
        /// Optional element 'prodml2:EngineerName' of XSD type 'eml21:String64'
        std::string *EngineerName;
        /// Optional element 'prodml2:ServiceCompany' of XSD type 'eml21:String64'
        std::string *ServiceCompany;
        /// Optional element 'prodml2:PumpFluidType' of XSD type 'eml21:String64'
        std::string *PumpFluidType;
        /// Optional element 'prodml2:ControlLineFluid' of XSD type 'eml21:String64'
        std::string *ControlLineFluid;
        /// Optional element 'prodml2:PumpDirection' of XSD type 'eml21:String64'
        std::string *PumpDirection;
        /// Optional element 'prodml2:FiberEndSeal' of XSD type 'eml21:String64'
        std::string *FiberEndSeal;
        /// Optional element 'prodml2:CableMeterType' of XSD type 'eml21:String64'
        std::string *CableMeterType;
        /// Optional element 'prodml2:CableMeterSerialNumber' of XSD type 'eml21:String64'
        std::string *CableMeterSerialNumber;
        /// Optional element 'prodml2:CableMeterCalibrationDate' of XSD type 'xsd:date'
        std::string *CableMeterCalibrationDate;
        /// Optional element 'prodml2:ExcessFiberRecovered' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *ExcessFiberRecovered;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberPumpActivity, default initialized and not managed by a soap context
        virtual prodml2__FiberPumpActivity *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberPumpActivity); }
      public:
        /// Constructor with initializations
        prodml2__FiberPumpActivity() : Name(), InstalledFiber(), PumpingDate(), EngineerName(), ServiceCompany(), PumpFluidType(), ControlLineFluid(), PumpDirection(), FiberEndSeal(), CableMeterType(), CableMeterSerialNumber(), CableMeterCalibrationDate(), ExcessFiberRecovered(), Comment(), uid(), soap() { }
        virtual ~prodml2__FiberPumpActivity() { }
        /// Friend allocator used by soap_new_prodml2__FiberPumpActivity(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberPumpActivity * SOAP_FMAC2 soap_instantiate_prodml2__FiberPumpActivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:621 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex (145)
/* complex XSD type 'prodml2:FiberRefractiveIndex': */
class SOAP_CMAC prodml2__FiberRefractiveIndex {
      public:
        /// Required element 'prodml2:Value' of XSD type 'eml21:LogarithmicPowerRatioPerLengthMeasure'
        eml21__LogarithmicPowerRatioPerLengthMeasure *Value;
        /// Optional element 'prodml2:Frequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *Frequency;
        /// Optional element 'prodml2:Wavelength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *Wavelength;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberRefractiveIndex, default initialized and not managed by a soap context
        virtual prodml2__FiberRefractiveIndex *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberRefractiveIndex); }
      public:
        /// Constructor with initializations
        prodml2__FiberRefractiveIndex() : Value(), Frequency(), Wavelength(), uid(), soap() { }
        virtual ~prodml2__FiberRefractiveIndex() { }
        /// Friend allocator used by soap_new_prodml2__FiberRefractiveIndex(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberRefractiveIndex * SOAP_FMAC2 soap_instantiate_prodml2__FiberRefractiveIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:645 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject (153)
/* Type eml21__AbstractObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractObject': */
class SOAP_CMAC eml21__AbstractObject {
      public:
        /// Optional element 'eml21:Aliases' of XSD type 'eml21:ObjectAlias'
        std::vector<eml21__ObjectAlias *> Aliases;
        /// Required element 'eml21:Citation' of XSD type 'eml21:Citation'
        eml21__Citation *Citation;
        /// Optional element 'eml21:CustomData' of XSD type 'eml21:CustomData'
        eml21__CustomData *CustomData;
        /// Optional element 'eml21:ExtensionNameValue' of XSD type 'eml21:ExtensionNameValue'
        std::vector<eml21__ExtensionNameValue *> ExtensionNameValue;
        /// optional attribute 'objectVersion' of XSD type 'eml21:String64'
        std::string *objectVersion;
        /// required attribute 'schemaVersion' of XSD type 'eml21:String64'
        std::string schemaVersion;
        /// required attribute 'uuid' of XSD type 'eml21:UuidString'
        std::string uuid;
        /// optional attribute 'existenceKind' of XSD type 'eml21:ExistenceKind'
        enum eml21__ExistenceKind *existenceKind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractObject, default initialized and not managed by a soap context
        virtual eml21__AbstractObject *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractObject); }
      public:
        /// Constructor with initializations
        eml21__AbstractObject() : Aliases(), Citation(), CustomData(), ExtensionNameValue(), objectVersion(), schemaVersion(), uuid(), existenceKind(), soap() { }
        virtual ~eml21__AbstractObject() { }
        /// Friend allocator used by soap_new_eml21__AbstractObject(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractObject * SOAP_FMAC2 soap_instantiate_eml21__AbstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:648 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__Citation
#define SOAP_TYPE_gsoap_eml2_1_eml21__Citation (154)
/* complex XSD type 'eml21:Citation': */
class SOAP_CMAC eml21__Citation {
      public:
        /// Required element 'eml21:Title' of XSD type 'eml21:String2000'
        std::string Title;
        /// Required element 'eml21:Originator' of XSD type 'eml21:String64'
        std::string Originator;
        /// Required element 'eml21:Creation' of XSD type 'xsd:dateTime'
        time_t Creation;
        /// Required element 'eml21:Format' of XSD type 'eml21:String2000'
        std::string Format;
        /// Optional element 'eml21:Editor' of XSD type 'eml21:String64'
        std::string *Editor;
        /// Optional element 'eml21:LastUpdate' of XSD type 'xsd:dateTime'
        time_t *LastUpdate;
        /// Optional element 'eml21:VersionString' of XSD type 'eml21:String64'
        std::string *VersionString;
        /// Optional element 'eml21:Description' of XSD type 'eml21:String2000'
        std::string *Description;
        /// Optional element 'eml21:DescriptiveKeywords' of XSD type 'eml21:String2000'
        std::string *DescriptiveKeywords;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__Citation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__Citation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__Citation, default initialized and not managed by a soap context
        virtual eml21__Citation *soap_alloc(void) const { return SOAP_NEW(eml21__Citation); }
      public:
        /// Constructor with initializations
        eml21__Citation() : Title(), Originator(), Creation(), Format(), Editor(), LastUpdate(), VersionString(), Description(), DescriptiveKeywords(), soap() { }
        virtual ~eml21__Citation() { }
        /// Friend allocator used by soap_new_eml21__Citation(struct soap*, int)
        friend SOAP_FMAC1 eml21__Citation * SOAP_FMAC2 soap_instantiate_eml21__Citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:651 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CustomData
#define SOAP_TYPE_gsoap_eml2_1_eml21__CustomData (155)
/* complex XSD type 'eml21:CustomData': */
class SOAP_CMAC eml21__CustomData {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__CustomData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__CustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__CustomData, default initialized and not managed by a soap context
        virtual eml21__CustomData *soap_alloc(void) const { return SOAP_NEW(eml21__CustomData); }
      public:
        /// Constructor with initializations
        eml21__CustomData() : __any(), soap() { }
        virtual ~eml21__CustomData() { }
        /// Friend allocator used by soap_new_eml21__CustomData(struct soap*, int)
        friend SOAP_FMAC1 eml21__CustomData * SOAP_FMAC2 soap_instantiate_eml21__CustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:654 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue (156)
/* complex XSD type 'eml21:ExtensionNameValue': */
class SOAP_CMAC eml21__ExtensionNameValue {
      public:
        /// Required element 'eml21:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Required element 'eml21:Value' of XSD type 'eml21:StringMeasure'
        eml21__StringMeasure *Value;
        /// Optional element 'eml21:MeasureClass' of XSD type 'eml21:MeasureClass'
        enum eml21__MeasureClass *MeasureClass;
        /// Optional element 'eml21:DTim' of XSD type 'eml21:TimeStamp'
        std::string *DTim;
        /// Optional element 'eml21:Index' of XSD type 'xsd:int'
        int *Index;
        /// Optional element 'eml21:Description' of XSD type 'eml21:String2000'
        std::string *Description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ExtensionNameValue, default initialized and not managed by a soap context
        virtual eml21__ExtensionNameValue *soap_alloc(void) const { return SOAP_NEW(eml21__ExtensionNameValue); }
      public:
        /// Constructor with initializations
        eml21__ExtensionNameValue() : Name(), Value(), MeasureClass(), DTim(), Index(), Description(), soap() { }
        virtual ~eml21__ExtensionNameValue() { }
        /// Friend allocator used by soap_new_eml21__ExtensionNameValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__ExtensionNameValue * SOAP_FMAC2 soap_instantiate_eml21__ExtensionNameValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:657 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias (157)
/* complex XSD type 'eml21:ObjectAlias': */
class SOAP_CMAC eml21__ObjectAlias {
      public:
        /// Required element 'eml21:Identifier' of XSD type 'eml21:String64'
        std::string Identifier;
        /// Optional element 'eml21:Description' of XSD type 'eml21:String2000'
        std::string *Description;
        /// required attribute 'authority' of XSD type 'eml21:String64'
        std::string authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ObjectAlias, default initialized and not managed by a soap context
        virtual eml21__ObjectAlias *soap_alloc(void) const { return SOAP_NEW(eml21__ObjectAlias); }
      public:
        /// Constructor with initializations
        eml21__ObjectAlias() : Identifier(), Description(), authority(), soap() { }
        virtual ~eml21__ObjectAlias() { }
        /// Friend allocator used by soap_new_eml21__ObjectAlias(struct soap*, int)
        friend SOAP_FMAC1 eml21__ObjectAlias * SOAP_FMAC2 soap_instantiate_eml21__ObjectAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:675 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray (163)
/* Type eml21__AbstractValueArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractValueArray': */
class SOAP_CMAC eml21__AbstractValueArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractValueArray, default initialized and not managed by a soap context
        virtual eml21__AbstractValueArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractValueArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractValueArray() : soap() { }
        virtual ~eml21__AbstractValueArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractValueArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractValueArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:723 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray (179)
/* complex XSD type 'eml21:JaggedArray': */
class SOAP_CMAC eml21__JaggedArray {
      public:
        /// Required element 'eml21:Elements' of XSD type 'eml21:AbstractValueArray'
        eml21__AbstractValueArray *Elements;
        /// Required element 'eml21:CumulativeLength' of XSD type 'eml21:AbstractIntegerArray'
        eml21__AbstractIntegerArray *CumulativeLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__JaggedArray, default initialized and not managed by a soap context
        virtual eml21__JaggedArray *soap_alloc(void) const { return SOAP_NEW(eml21__JaggedArray); }
      public:
        /// Constructor with initializations
        eml21__JaggedArray() : Elements(), CumulativeLength(), soap() { }
        virtual ~eml21__JaggedArray() { }
        /// Friend allocator used by soap_new_eml21__JaggedArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__JaggedArray * SOAP_FMAC2 soap_instantiate_eml21__JaggedArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:726 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval
#define SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval (180)
/* complex XSD type 'eml21:MdInterval': */
class SOAP_CMAC eml21__MdInterval {
      public:
        /// Required element 'eml21:MdTop' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *MdTop;
        /// Required element 'eml21:MdBase' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *MdBase;
        /// required attribute 'datum' of XSD type 'eml21:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MdInterval, default initialized and not managed by a soap context
        virtual eml21__MdInterval *soap_alloc(void) const { return SOAP_NEW(eml21__MdInterval); }
      public:
        /// Constructor with initializations
        eml21__MdInterval() : MdTop(), MdBase(), datum(), soap() { }
        virtual ~eml21__MdInterval() { }
        /// Friend allocator used by soap_new_eml21__MdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml21__MdInterval * SOAP_FMAC2 soap_instantiate_eml21__MdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:738 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval
#define SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval (184)
/* complex XSD type 'eml21:TvdInterval': */
class SOAP_CMAC eml21__TvdInterval {
      public:
        /// Required element 'eml21:TvdTop' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *TvdTop;
        /// Required element 'eml21:TvdBase' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *TvdBase;
        /// required attribute 'datum' of XSD type 'eml21:String64'
        std::string datum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TvdInterval, default initialized and not managed by a soap context
        virtual eml21__TvdInterval *soap_alloc(void) const { return SOAP_NEW(eml21__TvdInterval); }
      public:
        /// Constructor with initializations
        eml21__TvdInterval() : TvdTop(), TvdBase(), datum(), soap() { }
        virtual ~eml21__TvdInterval() { }
        /// Friend allocator used by soap_new_eml21__TvdInterval(struct soap*, int)
        friend SOAP_FMAC1 eml21__TvdInterval * SOAP_FMAC2 soap_instantiate_eml21__TvdInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1842 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference (552)
/* complex XSD type 'eml21:DataObjectReference': */
class SOAP_CMAC eml21__DataObjectReference {
      public:
        /// Required element 'eml21:ContentType' of XSD type 'eml21:String2000'
        std::string ContentType;
        /// Required element 'eml21:Title' of XSD type 'eml21:String2000'
        std::string Title;
        /// Required element 'eml21:Uuid' of XSD type 'eml21:UuidString'
        std::string Uuid;
        /// Optional element 'eml21:UuidAuthority' of XSD type 'eml21:String64'
        std::string *UuidAuthority;
        /// Optional element 'eml21:Uri' of XSD type 'xsd:anyURI'
        std::string *Uri;
        /// Optional element 'eml21:VersionString' of XSD type 'eml21:String64'
        std::string *VersionString;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DataObjectReference, default initialized and not managed by a soap context
        virtual eml21__DataObjectReference *soap_alloc(void) const { return SOAP_NEW(eml21__DataObjectReference); }
      public:
        /// Constructor with initializations
        eml21__DataObjectReference() : ContentType(), Title(), Uuid(), UuidAuthority(), Uri(), VersionString(), soap() { }
        virtual ~eml21__DataObjectReference() { }
        /// Friend allocator used by soap_new_eml21__DataObjectReference(struct soap*, int)
        friend SOAP_FMAC1 eml21__DataObjectReference * SOAP_FMAC2 soap_instantiate_eml21__DataObjectReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1848 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset (554)
/* complex XSD type 'eml21:ExternalDataset': */
class SOAP_CMAC eml21__ExternalDataset {
      public:
        /// Required element 'eml21:ExternalFileProxy' of XSD type 'eml21:ExternalDatasetPart'
        std::vector<eml21__ExternalDatasetPart *> ExternalFileProxy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ExternalDataset, default initialized and not managed by a soap context
        virtual eml21__ExternalDataset *soap_alloc(void) const { return SOAP_NEW(eml21__ExternalDataset); }
      public:
        /// Constructor with initializations
        eml21__ExternalDataset() : ExternalFileProxy(), soap() { }
        virtual ~eml21__ExternalDataset() { }
        /// Friend allocator used by soap_new_eml21__ExternalDataset(struct soap*, int)
        friend SOAP_FMAC1 eml21__ExternalDataset * SOAP_FMAC2 soap_instantiate_eml21__ExternalDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1851 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart (555)
/* Type eml21__ExternalDatasetPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ExternalDatasetPart': */
class SOAP_CMAC eml21__ExternalDatasetPart {
      public:
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
        /// Required element 'eml21:PathInExternalFile' of XSD type 'eml21:String2000'
        std::string PathInExternalFile;
        /// Required element 'eml21:StartIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 StartIndex;
        /// Required element 'eml21:EpcExternalPartReference' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *EpcExternalPartReference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ExternalDatasetPart, default initialized and not managed by a soap context
        virtual eml21__ExternalDatasetPart *soap_alloc(void) const { return SOAP_NEW(eml21__ExternalDatasetPart); }
      public:
        /// Constructor with initializations
        eml21__ExternalDatasetPart() : Count(), PathInExternalFile(), StartIndex(), EpcExternalPartReference(), soap() { }
        virtual ~eml21__ExternalDatasetPart() { }
        /// Friend allocator used by soap_new_eml21__ExternalDatasetPart(struct soap*, int)
        friend SOAP_FMAC1 eml21__ExternalDatasetPart * SOAP_FMAC2 soap_instantiate_eml21__ExternalDatasetPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1854 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter (556)
/* Type eml21__AbstractActivityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractActivityParameter': */
class SOAP_CMAC eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:Title' of XSD type 'eml21:String2000'
        std::string Title;
        /// Optional element 'eml21:Index' of XSD type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'eml21:Selection' of XSD type 'eml21:String2000'
        std::string *Selection;
        /// Optional element 'eml21:Key' of XSD type 'eml21:AbstractParameterKey'
        std::vector<eml21__AbstractParameterKey *> Key;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractActivityParameter, default initialized and not managed by a soap context
        virtual eml21__AbstractActivityParameter *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractActivityParameter); }
      public:
        /// Constructor with initializations
        eml21__AbstractActivityParameter() : Title(), Index(), Selection(), Key(), soap() { }
        virtual ~eml21__AbstractActivityParameter() { }
        /// Friend allocator used by soap_new_eml21__AbstractActivityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractActivityParameter * SOAP_FMAC2 soap_instantiate_eml21__AbstractActivityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1857 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey (557)
/* Type eml21__AbstractParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractParameterKey': */
class SOAP_CMAC eml21__AbstractParameterKey {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractParameterKey, default initialized and not managed by a soap context
        virtual eml21__AbstractParameterKey *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractParameterKey); }
      public:
        /// Constructor with initializations
        eml21__AbstractParameterKey() : soap() { }
        virtual ~eml21__AbstractParameterKey() { }
        /// Friend allocator used by soap_new_eml21__AbstractParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractParameterKey * SOAP_FMAC2 soap_instantiate_eml21__AbstractParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1878 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate (564)
/* complex XSD type 'eml21:ParameterTemplate': */
class SOAP_CMAC eml21__ParameterTemplate {
      public:
        /// Optional element 'eml21:AllowedKind' of XSD type 'eml21:ParameterKind'
        std::vector<enum eml21__ParameterKind> AllowedKind;
        /// Required element 'eml21:IsInput' of XSD type 'xsd:boolean'
        bool IsInput;
        /// Optional element 'eml21:KeyConstraint' of XSD type 'eml21:String2000'
        std::vector<std::string> KeyConstraint;
        /// Required element 'eml21:IsOutput' of XSD type 'xsd:boolean'
        bool IsOutput;
        /// Required element 'eml21:Title' of XSD type 'eml21:String2000'
        std::string Title;
        /// Optional element 'eml21:DataObjectContentType' of XSD type 'eml21:String2000'
        std::string *DataObjectContentType;
        /// Required element 'eml21:MaxOccurs' of XSD type 'xsd:long'
        LONG64 MaxOccurs;
        /// Required element 'eml21:MinOccurs' of XSD type 'xsd:long'
        LONG64 MinOccurs;
        /// Optional element 'eml21:Constraint' of XSD type 'eml21:String2000'
        std::string *Constraint;
        /// Optional element 'eml21:DefaultValue' of XSD type 'eml21:AbstractActivityParameter'
        std::vector<eml21__AbstractActivityParameter *> DefaultValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ParameterTemplate, default initialized and not managed by a soap context
        virtual eml21__ParameterTemplate *soap_alloc(void) const { return SOAP_NEW(eml21__ParameterTemplate); }
      public:
        /// Constructor with initializations
        eml21__ParameterTemplate() : AllowedKind(), IsInput(), KeyConstraint(), IsOutput(), Title(), DataObjectContentType(), MaxOccurs(), MinOccurs(), Constraint(), DefaultValue(), soap() { }
        virtual ~eml21__ParameterTemplate() { }
        /// Friend allocator used by soap_new_eml21__ParameterTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml21__ParameterTemplate * SOAP_FMAC2 soap_instantiate_eml21__ParameterTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1890 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime (568)
/* complex XSD type 'eml21:GeologicTime': */
class SOAP_CMAC eml21__GeologicTime {
      public:
        /// Optional element 'eml21:AgeOffsetAttribute' of XSD type 'xsd:long'
        LONG64 *AgeOffsetAttribute;
        /// Required element 'eml21:DateTime' of XSD type 'xsd:dateTime'
        time_t DateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeologicTime, default initialized and not managed by a soap context
        virtual eml21__GeologicTime *soap_alloc(void) const { return SOAP_NEW(eml21__GeologicTime); }
      public:
        /// Constructor with initializations
        eml21__GeologicTime() : AgeOffsetAttribute(), DateTime(), soap() { }
        virtual ~eml21__GeologicTime() { }
        /// Friend allocator used by soap_new_eml21__GeologicTime(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeologicTime * SOAP_FMAC2 soap_instantiate_eml21__GeologicTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1899 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex (571)
/* complex XSD type 'eml21:TimeIndex': */
class SOAP_CMAC eml21__TimeIndex {
      public:
        /// Required element 'eml21:Index' of XSD type 'xsd:unsignedLong'
        ULONG64 Index;
        /// Required element 'eml21:TimeSeries' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeIndex, default initialized and not managed by a soap context
        virtual eml21__TimeIndex *soap_alloc(void) const { return SOAP_NEW(eml21__TimeIndex); }
      public:
        /// Constructor with initializations
        eml21__TimeIndex() : Index(), TimeSeries(), soap() { }
        virtual ~eml21__TimeIndex() { }
        /// Friend allocator used by soap_new_eml21__TimeIndex(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeIndex * SOAP_FMAC2 soap_instantiate_eml21__TimeIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1902 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices (572)
/* complex XSD type 'eml21:TimeIndices': */
class SOAP_CMAC eml21__TimeIndices {
      public:
        /// Required element 'eml21:TimeIndexCount' of XSD type 'xsd:unsignedLong'
        ULONG64 TimeIndexCount;
        /// Optional element 'eml21:TimeIndexStart' of XSD type 'xsd:unsignedLong'
        ULONG64 *TimeIndexStart;
        /// Optional element 'eml21:SimulatorTimeStep' of XSD type 'eml21:AbstractIntegerArray'
        eml21__AbstractIntegerArray *SimulatorTimeStep;
        /// Required element 'eml21:UseInterval' of XSD type 'xsd:boolean'
        bool UseInterval;
        /// Required element 'eml21:TimeSeries' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeIndices, default initialized and not managed by a soap context
        virtual eml21__TimeIndices *soap_alloc(void) const { return SOAP_NEW(eml21__TimeIndices); }
      public:
        /// Constructor with initializations
        eml21__TimeIndices() : TimeIndexCount(), TimeIndexStart(), SimulatorTimeStep(), UseInterval(), TimeSeries(), soap() { }
        virtual ~eml21__TimeIndices() { }
        /// Friend allocator used by soap_new_eml21__TimeIndices(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeIndices * SOAP_FMAC2 soap_instantiate_eml21__TimeIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1908 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage (574)
/* complex XSD type 'eml21:TimeSeriesParentage': */
class SOAP_CMAC eml21__TimeSeriesParentage {
      public:
        /// Required element 'eml21:HasOverlap' of XSD type 'xsd:boolean'
        bool HasOverlap;
        /// Required element 'eml21:ParentTimeIndex' of XSD type 'eml21:TimeIndex'
        eml21__TimeIndex *ParentTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeSeriesParentage, default initialized and not managed by a soap context
        virtual eml21__TimeSeriesParentage *soap_alloc(void) const { return SOAP_NEW(eml21__TimeSeriesParentage); }
      public:
        /// Constructor with initializations
        eml21__TimeSeriesParentage() : HasOverlap(), ParentTimeIndex(), soap() { }
        virtual ~eml21__TimeSeriesParentage() { }
        /// Friend allocator used by soap_new_eml21__TimeSeriesParentage(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeSeriesParentage * SOAP_FMAC2 soap_instantiate_eml21__TimeSeriesParentage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1914 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue (576)
/* Type eml21__AbstractPressureValue is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractPressureValue': */
class SOAP_CMAC eml21__AbstractPressureValue {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractPressureValue, default initialized and not managed by a soap context
        virtual eml21__AbstractPressureValue *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractPressureValue); }
      public:
        /// Constructor with initializations
        eml21__AbstractPressureValue() : soap() { }
        virtual ~eml21__AbstractPressureValue() { }
        /// Friend allocator used by soap_new_eml21__AbstractPressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractPressureValue * SOAP_FMAC2 soap_instantiate_eml21__AbstractPressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:21971 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__union_AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1__eml21__union_AbstractTemperaturePressure (1402)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml21__union_AbstractTemperaturePressure
{
};
#endif

/* eml2_1ForGsoap.h:1917 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure (577)
/* Type eml21__AbstractTemperaturePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* Choice: */
class SOAP_CMAC eml21__AbstractTemperaturePressure {
      public:
        /// Union with union _eml21__union_AbstractTemperaturePressure variant selector __union_AbstractTemperaturePressure set to one of:
        int __union_AbstractTemperaturePressure;
        union _eml21__union_AbstractTemperaturePressure union_AbstractTemperaturePressure;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractTemperaturePressure, default initialized and not managed by a soap context
        virtual eml21__AbstractTemperaturePressure *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractTemperaturePressure); }
      public:
        /// Constructor with initializations
        eml21__AbstractTemperaturePressure() : __union_AbstractTemperaturePressure(), soap() { }
        virtual ~eml21__AbstractTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml21__AbstractTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml21__AbstractTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1920 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue (578)
/* complex XSD type 'eml21:DensityValue': */
class SOAP_CMAC eml21__DensityValue {
      public:
        /// Required element 'eml21:Density' of XSD type 'eml21:MassPerVolumeMeasureExt'
        eml21__MassPerVolumeMeasureExt *Density;
        /// Required element 'eml21:MeasurementPressureTemperature' of XSD type 'eml21:AbstractTemperaturePressure'
        eml21__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DensityValue, default initialized and not managed by a soap context
        virtual eml21__DensityValue *soap_alloc(void) const { return SOAP_NEW(eml21__DensityValue); }
      public:
        /// Constructor with initializations
        eml21__DensityValue() : Density(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml21__DensityValue() { }
        /// Friend allocator used by soap_new_eml21__DensityValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__DensityValue * SOAP_FMAC2 soap_instantiate_eml21__DensityValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1923 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue (579)
/* complex XSD type 'eml21:FlowRateValue': */
class SOAP_CMAC eml21__FlowRateValue {
      public:
        /// Required element 'eml21:FlowRate' of XSD type 'eml21:VolumePerTimeMeasureExt'
        eml21__VolumePerTimeMeasureExt *FlowRate;
        /// Required element 'eml21:MeasurementPressureTemperature' of XSD type 'eml21:AbstractTemperaturePressure'
        eml21__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FlowRateValue, default initialized and not managed by a soap context
        virtual eml21__FlowRateValue *soap_alloc(void) const { return SOAP_NEW(eml21__FlowRateValue); }
      public:
        /// Constructor with initializations
        eml21__FlowRateValue() : FlowRate(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml21__FlowRateValue() { }
        /// Friend allocator used by soap_new_eml21__FlowRateValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__FlowRateValue * SOAP_FMAC2 soap_instantiate_eml21__FlowRateValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1929 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue (581)
/* complex XSD type 'eml21:PressureValue': */
class SOAP_CMAC eml21__PressureValue {
      public:
        /// Required element 'eml21:AbstractPressureValue' of XSD type 'eml21:AbstractPressureValue'
        eml21__AbstractPressureValue *AbstractPressureValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureValue, default initialized and not managed by a soap context
        virtual eml21__PressureValue *soap_alloc(void) const { return SOAP_NEW(eml21__PressureValue); }
      public:
        /// Constructor with initializations
        eml21__PressureValue() : AbstractPressureValue(), soap() { }
        virtual ~eml21__PressureValue() { }
        /// Friend allocator used by soap_new_eml21__PressureValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureValue * SOAP_FMAC2 soap_instantiate_eml21__PressureValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1944 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue (586)
/* complex XSD type 'eml21:VolumeValue': */
class SOAP_CMAC eml21__VolumeValue {
      public:
        /// Required element 'eml21:Volume' of XSD type 'eml21:VolumeMeasureExt'
        eml21__VolumeMeasureExt *Volume;
        /// Required element 'eml21:MeasurementPressureTemperature' of XSD type 'eml21:AbstractTemperaturePressure'
        eml21__AbstractTemperaturePressure *MeasurementPressureTemperature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumeValue, default initialized and not managed by a soap context
        virtual eml21__VolumeValue *soap_alloc(void) const { return SOAP_NEW(eml21__VolumeValue); }
      public:
        /// Constructor with initializations
        eml21__VolumeValue() : Volume(), MeasurementPressureTemperature(), soap() { }
        virtual ~eml21__VolumeValue() { }
        /// Friend allocator used by soap_new_eml21__VolumeValue(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumeValue * SOAP_FMAC2 soap_instantiate_eml21__VolumeValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1947 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs (587)
/* Type eml21__AbstractGeodeticCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractGeodeticCrs': */
class SOAP_CMAC eml21__AbstractGeodeticCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractGeodeticCrs, default initialized and not managed by a soap context
        virtual eml21__AbstractGeodeticCrs *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractGeodeticCrs); }
      public:
        /// Constructor with initializations
        eml21__AbstractGeodeticCrs() : soap() { }
        virtual ~eml21__AbstractGeodeticCrs() { }
        /// Friend allocator used by soap_new_eml21__AbstractGeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractGeodeticCrs * SOAP_FMAC2 soap_instantiate_eml21__AbstractGeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1950 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs (588)
/* Type eml21__AbstractProjectedCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractProjectedCrs': */
class SOAP_CMAC eml21__AbstractProjectedCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractProjectedCrs, default initialized and not managed by a soap context
        virtual eml21__AbstractProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractProjectedCrs); }
      public:
        /// Constructor with initializations
        eml21__AbstractProjectedCrs() : soap() { }
        virtual ~eml21__AbstractProjectedCrs() { }
        /// Friend allocator used by soap_new_eml21__AbstractProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractProjectedCrs * SOAP_FMAC2 soap_instantiate_eml21__AbstractProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1953 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs (589)
/* Type eml21__AbstractVerticalCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractVerticalCrs': */
class SOAP_CMAC eml21__AbstractVerticalCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractVerticalCrs, default initialized and not managed by a soap context
        virtual eml21__AbstractVerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractVerticalCrs); }
      public:
        /// Constructor with initializations
        eml21__AbstractVerticalCrs() : soap() { }
        virtual ~eml21__AbstractVerticalCrs() { }
        /// Friend allocator used by soap_new_eml21__AbstractVerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractVerticalCrs * SOAP_FMAC2 soap_instantiate_eml21__AbstractVerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2013 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule
#define SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule (609)
/* complex XSD type 'eml21:FailingRule': */
class SOAP_CMAC eml21__FailingRule {
      public:
        /// Required element 'eml21:RuleId' of XSD type 'eml21:String64'
        std::string RuleId;
        /// Optional element 'eml21:RuleName' of XSD type 'eml21:String2000'
        std::string *RuleName;
        /// Optional element 'eml21:Severity' of XSD type 'eml21:String64'
        std::string *Severity;
        /// Optional element 'eml21:FailingRuleExtensions' of XSD type 'eml21:ExtensionNameValue'
        std::vector<eml21__ExtensionNameValue *> FailingRuleExtensions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FailingRule, default initialized and not managed by a soap context
        virtual eml21__FailingRule *soap_alloc(void) const { return SOAP_NEW(eml21__FailingRule); }
      public:
        /// Constructor with initializations
        eml21__FailingRule() : RuleId(), RuleName(), Severity(), FailingRuleExtensions(), soap() { }
        virtual ~eml21__FailingRule() { }
        /// Friend allocator used by soap_new_eml21__FailingRule(struct soap*, int)
        friend SOAP_FMAC1 eml21__FailingRule * SOAP_FMAC2 soap_instantiate_eml21__FailingRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2016 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange
#define SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange (610)
/* complex XSD type 'eml21:IndexRange': */
class SOAP_CMAC eml21__IndexRange {
      public:
        /// Required element 'eml21:IndexMinimum' of XSD type 'eml21:String64'
        std::string IndexMinimum;
        /// Required element 'eml21:IndexMaximum' of XSD type 'eml21:String64'
        std::string IndexMaximum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IndexRange, default initialized and not managed by a soap context
        virtual eml21__IndexRange *soap_alloc(void) const { return SOAP_NEW(eml21__IndexRange); }
      public:
        /// Constructor with initializations
        eml21__IndexRange() : IndexMinimum(), IndexMaximum(), soap() { }
        virtual ~eml21__IndexRange() { }
        /// Friend allocator used by soap_new_eml21__IndexRange(struct soap*, int)
        friend SOAP_FMAC1 eml21__IndexRange * SOAP_FMAC2 soap_instantiate_eml21__IndexRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2019 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation (611)
/* complex XSD type 'eml21:AbstractGraphicalInformation': */
class SOAP_CMAC eml21__AbstractGraphicalInformation {
      public:
        /// Required element 'eml21:TargetObject' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *TargetObject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractGraphicalInformation, default initialized and not managed by a soap context
        virtual eml21__AbstractGraphicalInformation *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractGraphicalInformation); }
      public:
        /// Constructor with initializations
        eml21__AbstractGraphicalInformation() : TargetObject(), soap() { }
        virtual ~eml21__AbstractGraphicalInformation() { }
        /// Friend allocator used by soap_new_eml21__AbstractGraphicalInformation(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractGraphicalInformation * SOAP_FMAC2 soap_instantiate_eml21__AbstractGraphicalInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2040 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType (618)
/* Type gml__AbstractGMLType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractGMLType': */
class SOAP_CMAC gml__AbstractGMLType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Optional element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGMLType, default initialized and not managed by a soap context
        virtual gml__AbstractGMLType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGMLType); }
      public:
        /// Constructor with initializations
        gml__AbstractGMLType() : description(), descriptionReference(), identifier(), name(), gml__id(), soap() { }
        virtual ~gml__AbstractGMLType() { }
        /// Friend allocator used by soap_new_gml__AbstractGMLType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGMLType * SOAP_FMAC2 soap_instantiate_gml__AbstractGMLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2046 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType (620)
/* complex XSD type 'gml:ReferenceType': */
class SOAP_CMAC gml__ReferenceType {
      public:
        /// optional attribute 'owns' of XSD type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ReferenceType, default initialized and not managed by a soap context
        virtual gml__ReferenceType *soap_alloc(void) const { return SOAP_NEW(gml__ReferenceType); }
      public:
        /// Constructor with initializations
        gml__ReferenceType() : owns((bool)0), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__ReferenceType() { }
        /// Friend allocator used by soap_new_gml__ReferenceType(struct soap*, int)
        friend SOAP_FMAC1 gml__ReferenceType * SOAP_FMAC2 soap_instantiate_gml__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22354 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_eml2_1__gml__union_TimePrimitivePropertyType (1417)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePrimitivePropertyType
{
};
#endif

/* eml2_1ForGsoap.h:22343 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__TimePrimitivePropertyType_sequence (1416)
/* Wrapper: */
class SOAP_CMAC __gml__TimePrimitivePropertyType_sequence {
      public:
        /// Union with union _gml__union_TimePrimitivePropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gml__union_TimePrimitivePropertyType union_TimePrimitivePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__TimePrimitivePropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__TimePrimitivePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimePrimitivePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimePrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__TimePrimitivePropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__TimePrimitivePropertyType_sequence() : __unionAbstractTimePrimitive() { }
        virtual ~__gml__TimePrimitivePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimePrimitivePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimePrimitivePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimePrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2064 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType (626)
/* Type gml__TimePrimitivePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:TimePrimitivePropertyType': */
class SOAP_CMAC gml__TimePrimitivePropertyType {
      public:
        __gml__TimePrimitivePropertyType_sequence *__TimePrimitivePropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// optional attribute 'owns' of XSD type 'xsd:boolean'
        bool owns;	///< initialized with default value = (bool)0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePrimitivePropertyType, default initialized and not managed by a soap context
        virtual gml__TimePrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW(gml__TimePrimitivePropertyType); }
      public:
        /// Constructor with initializations
        gml__TimePrimitivePropertyType() : __TimePrimitivePropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), owns((bool)0), soap() { }
        virtual ~gml__TimePrimitivePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimePrimitivePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePrimitivePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimePrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22413 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidalCSPropertyType_sequence (1419)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidalCSPropertyType_sequence {
      public:
        /// Required element 'gml:EllipsoidalCS' of XSD type 'gml:EllipsoidalCSType'
        gml__EllipsoidalCSType *EllipsoidalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__EllipsoidalCSPropertyType_sequence() : EllipsoidalCS() { }
        virtual ~__gml__EllipsoidalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2067 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType (627)
/* complex XSD type 'gml:EllipsoidalCSPropertyType': */
class SOAP_CMAC gml__EllipsoidalCSPropertyType {
      public:
        __gml__EllipsoidalCSPropertyType_sequence *__EllipsoidalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidalCSPropertyType() : __EllipsoidalCSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__EllipsoidalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22473 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__CoordinateSystemAxisPropertyType_sequence (1422)
/* Wrapper: */
class SOAP_CMAC __gml__CoordinateSystemAxisPropertyType_sequence {
      public:
        /// Required element 'gml:CoordinateSystemAxis' of XSD type 'gml:CoordinateSystemAxisType'
        gml__CoordinateSystemAxisType *CoordinateSystemAxis;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__CoordinateSystemAxisPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__CoordinateSystemAxisPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CoordinateSystemAxisPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CoordinateSystemAxisPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CoordinateSystemAxisPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CoordinateSystemAxisPropertyType_sequence() : CoordinateSystemAxis() { }
        virtual ~__gml__CoordinateSystemAxisPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CoordinateSystemAxisPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2076 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType (630)
/* complex XSD type 'gml:CoordinateSystemAxisPropertyType': */
class SOAP_CMAC gml__CoordinateSystemAxisPropertyType {
      public:
        __gml__CoordinateSystemAxisPropertyType_sequence *__CoordinateSystemAxisPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisPropertyType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisPropertyType); }
      public:
        /// Constructor with initializations
        gml__CoordinateSystemAxisPropertyType() : __CoordinateSystemAxisPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__CoordinateSystemAxisPropertyType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisPropertyType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22533 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__CartesianCSPropertyType_sequence (1425)
/* Wrapper: */
class SOAP_CMAC __gml__CartesianCSPropertyType_sequence {
      public:
        /// Required element 'gml:CartesianCS' of XSD type 'gml:CartesianCSType'
        gml__CartesianCSType *CartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__CartesianCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__CartesianCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CartesianCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CartesianCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CartesianCSPropertyType_sequence() : CartesianCS() { }
        virtual ~__gml__CartesianCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CartesianCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CartesianCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2082 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType (632)
/* complex XSD type 'gml:CartesianCSPropertyType': */
class SOAP_CMAC gml__CartesianCSPropertyType {
      public:
        __gml__CartesianCSPropertyType_sequence *__CartesianCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSPropertyType, default initialized and not managed by a soap context
        virtual gml__CartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__CartesianCSPropertyType() : __CartesianCSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__CartesianCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22593 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__SphericalCSPropertyType_sequence (1428)
/* Wrapper: */
class SOAP_CMAC __gml__SphericalCSPropertyType_sequence {
      public:
        /// Required element 'gml:SphericalCS' of XSD type 'gml:SphericalCSType'
        gml__SphericalCSType *SphericalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__SphericalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__SphericalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SphericalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SphericalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__SphericalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__SphericalCSPropertyType_sequence() : SphericalCS() { }
        virtual ~__gml__SphericalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SphericalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SphericalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SphericalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2088 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType (634)
/* complex XSD type 'gml:SphericalCSPropertyType': */
class SOAP_CMAC gml__SphericalCSPropertyType {
      public:
        __gml__SphericalCSPropertyType_sequence *__SphericalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__SphericalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__SphericalCSPropertyType() : __SphericalCSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__SphericalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22653 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__GeodeticDatumPropertyType_sequence (1431)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticDatumPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticDatum' of XSD type 'gml:GeodeticDatumType'
        gml__GeodeticDatumType *GeodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__GeodeticDatumPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__GeodeticDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticDatumPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeodeticDatumPropertyType_sequence() : GeodeticDatum() { }
        virtual ~__gml__GeodeticDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2094 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType (636)
/* complex XSD type 'gml:GeodeticDatumPropertyType': */
class SOAP_CMAC gml__GeodeticDatumPropertyType {
      public:
        __gml__GeodeticDatumPropertyType_sequence *__GeodeticDatumPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeodeticDatumPropertyType() : __GeodeticDatumPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__GeodeticDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22713 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__PrimeMeridianPropertyType_sequence (1434)
/* Wrapper: */
class SOAP_CMAC __gml__PrimeMeridianPropertyType_sequence {
      public:
        /// Required element 'gml:PrimeMeridian' of XSD type 'gml:PrimeMeridianType'
        gml__PrimeMeridianType *PrimeMeridian;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__PrimeMeridianPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__PrimeMeridianPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PrimeMeridianPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PrimeMeridianPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__PrimeMeridianPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__PrimeMeridianPropertyType_sequence() : PrimeMeridian() { }
        virtual ~__gml__PrimeMeridianPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PrimeMeridianPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PrimeMeridianPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PrimeMeridianPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2103 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType (639)
/* complex XSD type 'gml:PrimeMeridianPropertyType': */
class SOAP_CMAC gml__PrimeMeridianPropertyType {
      public:
        __gml__PrimeMeridianPropertyType_sequence *__PrimeMeridianPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianPropertyType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianPropertyType); }
      public:
        /// Constructor with initializations
        gml__PrimeMeridianPropertyType() : __PrimeMeridianPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__PrimeMeridianPropertyType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianPropertyType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22773 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidPropertyType_sequence (1437)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidPropertyType_sequence {
      public:
        /// Required element 'gml:Ellipsoid' of XSD type 'gml:EllipsoidType'
        gml__EllipsoidType *Ellipsoid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__EllipsoidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__EllipsoidPropertyType_sequence() : Ellipsoid() { }
        virtual ~__gml__EllipsoidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2115 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType (643)
/* complex XSD type 'gml:EllipsoidPropertyType': */
class SOAP_CMAC gml__EllipsoidPropertyType {
      public:
        __gml__EllipsoidPropertyType_sequence *__EllipsoidPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidPropertyType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidPropertyType() : __EllipsoidPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__EllipsoidPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22845 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gml__union_GeneralConversionPropertyType (1441)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeneralConversionPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:22833 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__GeneralConversionPropertyType_sequence (1440)
/* Wrapper: */
class SOAP_CMAC __gml__GeneralConversionPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeneralConversionPropertyType variant selector __unionAbstractGeneralConversion set to one of:
        int __unionAbstractGeneralConversion;
        union _gml__union_GeneralConversionPropertyType union_GeneralConversionPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__GeneralConversionPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__GeneralConversionPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeneralConversionPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeneralConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeneralConversionPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeneralConversionPropertyType_sequence() : __unionAbstractGeneralConversion() { }
        virtual ~__gml__GeneralConversionPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeneralConversionPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeneralConversionPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeneralConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2130 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType (648)
/* complex XSD type 'gml:GeneralConversionPropertyType': */
class SOAP_CMAC gml__GeneralConversionPropertyType {
      public:
        __gml__GeneralConversionPropertyType_sequence *__GeneralConversionPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeneralConversionPropertyType, default initialized and not managed by a soap context
        virtual gml__GeneralConversionPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeneralConversionPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeneralConversionPropertyType() : __GeneralConversionPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__GeneralConversionPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeneralConversionPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeneralConversionPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeneralConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22911 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_CRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gml__union_CRSPropertyType (1444)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CRSPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:22900 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__CRSPropertyType_sequence (1443)
/* Wrapper: */
class SOAP_CMAC __gml__CRSPropertyType_sequence {
      public:
        /// Union with union _gml__union_CRSPropertyType variant selector __unionAbstractCRS set to one of:
        int __unionAbstractCRS;
        union _gml__union_CRSPropertyType union_CRSPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__CRSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__CRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CRSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CRSPropertyType_sequence() : __unionAbstractCRS() { }
        virtual ~__gml__CRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2139 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType (651)
/* complex XSD type 'gml:CRSPropertyType': */
class SOAP_CMAC gml__CRSPropertyType {
      public:
        __gml__CRSPropertyType_sequence *__CRSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CRSPropertyType, default initialized and not managed by a soap context
        virtual gml__CRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CRSPropertyType); }
      public:
        /// Constructor with initializations
        gml__CRSPropertyType() : __CRSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__CRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:22966 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__GeodeticCRSPropertyType_sequence (1446)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticCRSPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticCRS' of XSD type 'gml:GeodeticCRSType'
        gml__GeodeticCRSType *GeodeticCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__GeodeticCRSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__GeodeticCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticCRSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeodeticCRSPropertyType_sequence() : GeodeticCRS() { }
        virtual ~__gml__GeodeticCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2142 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType (652)
/* complex XSD type 'gml:GeodeticCRSPropertyType': */
class SOAP_CMAC gml__GeodeticCRSPropertyType {
      public:
        __gml__GeodeticCRSPropertyType_sequence *__GeodeticCRSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeodeticCRSPropertyType() : __GeodeticCRSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__GeodeticCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23023 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__VerticalCSPropertyType_sequence (1449)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalCSPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalCS' of XSD type 'gml:VerticalCSType'
        gml__VerticalCSType *VerticalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__VerticalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__VerticalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__VerticalCSPropertyType_sequence() : VerticalCS() { }
        virtual ~__gml__VerticalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2148 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType (654)
/* complex XSD type 'gml:VerticalCSPropertyType': */
class SOAP_CMAC gml__VerticalCSPropertyType {
      public:
        __gml__VerticalCSPropertyType_sequence *__VerticalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__VerticalCSPropertyType() : __VerticalCSPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__VerticalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23083 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__VerticalDatumPropertyType_sequence (1452)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalDatumPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalDatum' of XSD type 'gml:VerticalDatumType'
        gml__VerticalDatumType *VerticalDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__VerticalDatumPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__VerticalDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalDatumPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__VerticalDatumPropertyType_sequence() : VerticalDatum() { }
        virtual ~__gml__VerticalDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2154 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType (656)
/* complex XSD type 'gml:VerticalDatumPropertyType': */
class SOAP_CMAC gml__VerticalDatumPropertyType {
      public:
        __gml__VerticalDatumPropertyType_sequence *__VerticalDatumPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumPropertyType); }
      public:
        /// Constructor with initializations
        gml__VerticalDatumPropertyType() : __VerticalDatumPropertyType_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__VerticalDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23144 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__domainOfValidity_sequence (1455)
/* Wrapper: */
class SOAP_CMAC __gml__domainOfValidity_sequence {
      public:
        /// Required element 'gmd:EX_Extent' of XSD type 'gmd:EX_Extent_Type'
        gmd__EX_USCOREExtent_USCOREType *gmd__EX_USCOREExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__domainOfValidity_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__domainOfValidity_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__domainOfValidity_sequence, default initialized and not managed by a soap context
        virtual __gml__domainOfValidity_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__domainOfValidity_sequence); }
      public:
        /// Constructor with initializations
        __gml__domainOfValidity_sequence() : gmd__EX_USCOREExtent() { }
        virtual ~__gml__domainOfValidity_sequence() { }
        /// Friend allocator used by soap_new___gml__domainOfValidity_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__domainOfValidity_sequence * SOAP_FMAC2 soap_instantiate___gml__domainOfValidity_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2160 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity (658)
/* complex XSD type 'gml:domainOfValidity': */
class SOAP_CMAC _gml__domainOfValidity {
      public:
        __gml__domainOfValidity_sequence *__domainOfValidity_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__domainOfValidity, default initialized and not managed by a soap context
        virtual _gml__domainOfValidity *soap_alloc(void) const { return SOAP_NEW(_gml__domainOfValidity); }
      public:
        /// Constructor with initializations
        _gml__domainOfValidity() : __domainOfValidity_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~_gml__domainOfValidity() { }
        /// Friend allocator used by soap_new__gml__domainOfValidity(struct soap*, int)
        friend SOAP_FMAC1 _gml__domainOfValidity * SOAP_FMAC2 soap_instantiate__gml__domainOfValidity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2163 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter (659)
/* complex XSD type 'gml:secondDefiningParameter': */
class SOAP_CMAC _gml__secondDefiningParameter {
      public:
        /// Required element 'gml:SecondDefiningParameter' of XSD type 'gml:SecondDefiningParameter'
        _gml__SecondDefiningParameter *SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__secondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__secondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__secondDefiningParameter); }
      public:
        /// Constructor with initializations
        _gml__secondDefiningParameter() : SecondDefiningParameter(), soap() { }
        virtual ~_gml__secondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__secondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__secondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__secondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23234 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_SecondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1__gml__union_SecondDefiningParameter (1461)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SecondDefiningParameter
{
        #define SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_inverseFlattening	(1)	/**< union variant selector value for member inverseFlattening */
        gml__MeasureType *inverseFlattening;
        #define SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_semiMinorAxis	(2)	/**< union variant selector value for member semiMinorAxis */
        gml__LengthType *semiMinorAxis;
        #define SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_isSphere	(3)	/**< union variant selector value for member isSphere */
        bool isSphere;
};
#endif

/* eml2_1ForGsoap.h:2166 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter (660)
/* Choice: */
class SOAP_CMAC _gml__SecondDefiningParameter {
      public:
        /// Union with union _gml__union_SecondDefiningParameter variant selector __union_SecondDefiningParameter set to one of: SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_inverseFlattening SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_semiMinorAxis SOAP_UNION_gsoap_eml2_1__gml__union_SecondDefiningParameter_isSphere
        int __union_SecondDefiningParameter;
        union _gml__union_SecondDefiningParameter union_SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__SecondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__SecondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__SecondDefiningParameter); }
      public:
        /// Constructor with initializations
        _gml__SecondDefiningParameter() : __union_SecondDefiningParameter(), soap() { }
        virtual ~_gml__SecondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__SecondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__SecondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__SecondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23266 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_eml2_1__gml__union_coordinateOperationAccuracy (1463)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_coordinateOperationAccuracy
{
};
#endif

/* eml2_1ForGsoap.h:23258 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_eml2_1___gml__coordinateOperationAccuracy_sequence (1462)
/* Wrapper: */
class SOAP_CMAC __gml__coordinateOperationAccuracy_sequence {
      public:
        /// Union with union _gml__union_coordinateOperationAccuracy variant selector __unionAbstractDQ_USCOREPositionalAccuracy set to one of:
        int __unionAbstractDQ_USCOREPositionalAccuracy;
        union _gml__union_coordinateOperationAccuracy union_coordinateOperationAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gml__coordinateOperationAccuracy_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gml__coordinateOperationAccuracy_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__coordinateOperationAccuracy_sequence, default initialized and not managed by a soap context
        virtual __gml__coordinateOperationAccuracy_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__coordinateOperationAccuracy_sequence); }
      public:
        /// Constructor with initializations
        __gml__coordinateOperationAccuracy_sequence() : __unionAbstractDQ_USCOREPositionalAccuracy() { }
        virtual ~__gml__coordinateOperationAccuracy_sequence() { }
        /// Friend allocator used by soap_new___gml__coordinateOperationAccuracy_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__coordinateOperationAccuracy_sequence * SOAP_FMAC2 soap_instantiate___gml__coordinateOperationAccuracy_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2169 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy (661)
/* complex XSD type 'gml:coordinateOperationAccuracy': */
class SOAP_CMAC _gml__coordinateOperationAccuracy {
      public:
        __gml__coordinateOperationAccuracy_sequence *__coordinateOperationAccuracy_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__coordinateOperationAccuracy, default initialized and not managed by a soap context
        virtual _gml__coordinateOperationAccuracy *soap_alloc(void) const { return SOAP_NEW(_gml__coordinateOperationAccuracy); }
      public:
        /// Constructor with initializations
        _gml__coordinateOperationAccuracy() : __coordinateOperationAccuracy_sequence(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~_gml__coordinateOperationAccuracy() { }
        /// Friend allocator used by soap_new__gml__coordinateOperationAccuracy(struct soap*, int)
        friend SOAP_FMAC1 _gml__coordinateOperationAccuracy * SOAP_FMAC2 soap_instantiate__gml__coordinateOperationAccuracy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23342 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType (1466)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:23334 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (1465)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence {
      public:
        /// Union with union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType variant selector __unionAbstractEX_USCOREGeographicExtent set to one of:
        int __unionAbstractEX_USCOREGeographicExtent;
        union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType union_EX_USCOREGeographicExtent_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() : __unionAbstractEX_USCOREGeographicExtent() { }
        virtual ~__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2175 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (663)
/* complex XSD type 'gmd:EX_GeographicExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCOREGeographicExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREGeographicExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREGeographicExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREGeographicExtent_USCOREPropertyType() : __EX_USCOREGeographicExtent_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREGeographicExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23396 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (1468)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_TemporalExtent' of XSD type 'gmd:EX_TemporalExtent_Type'
        gmd__EX_USCORETemporalExtent_USCOREType *EX_USCORETemporalExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() : EX_USCORETemporalExtent() { }
        virtual ~__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2181 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (665)
/* complex XSD type 'gmd:EX_TemporalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *__EX_USCORETemporalExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCORETemporalExtent_USCOREPropertyType() : __EX_USCORETemporalExtent_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__EX_USCORETemporalExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCORETemporalExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23452 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (1471)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_VerticalExtent' of XSD type 'gmd:EX_VerticalExtent_Type'
        gmd__EX_USCOREVerticalExtent_USCOREType *EX_USCOREVerticalExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() : EX_USCOREVerticalExtent() { }
        virtual ~__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2187 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (667)
/* complex XSD type 'gmd:EX_VerticalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREVerticalExtent_USCOREPropertyType() : __EX_USCOREVerticalExtent_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREVerticalExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23508 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (1474)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Identifier' of XSD type 'gmd:MD_Identifier_Type'
        gmd__MD_USCOREIdentifier_USCOREType *MD_USCOREIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() : MD_USCOREIdentifier() { }
        virtual ~__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2199 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (671)
/* Type gmd__MD_USCOREIdentifier_USCOREPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:MD_Identifier_PropertyType': */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREPropertyType {
      public:
        __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *__MD_USCOREIdentifier_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_USCOREIdentifier_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__MD_USCOREIdentifier_USCOREPropertyType() : __MD_USCOREIdentifier_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__MD_USCOREIdentifier_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_USCOREIdentifier_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23564 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (1477)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORECitation_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Citation' of XSD type 'gmd:CI_Citation_Type'
        gmd__CI_USCORECitation_USCOREType *CI_USCORECitation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORECitation_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORECitation_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORECitation_USCOREPropertyType_sequence() : CI_USCORECitation() { }
        virtual ~__gmd__CI_USCORECitation_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORECitation_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2205 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType (673)
/* complex XSD type 'gmd:CI_Citation_PropertyType': */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREPropertyType {
      public:
        __gmd__CI_USCORECitation_USCOREPropertyType_sequence *__CI_USCORECitation_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORECitation_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORECitation_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORECitation_USCOREPropertyType() : __CI_USCORECitation_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCORECitation_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORECitation_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23620 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (1480)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDate_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Date' of XSD type 'gmd:CI_Date_Type'
        gmd__CI_USCOREDate_USCOREType *CI_USCOREDate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREDate_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDate_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREDate_USCOREPropertyType_sequence() : CI_USCOREDate() { }
        virtual ~__gmd__CI_USCOREDate_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREDate_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2211 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType (675)
/* complex XSD type 'gmd:CI_Date_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREPropertyType {
      public:
        __gmd__CI_USCOREDate_USCOREPropertyType_sequence *__CI_USCOREDate_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDate_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDate_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDate_USCOREPropertyType() : __CI_USCOREDate_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCOREDate_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDate_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23676 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (1483)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_DateTypeCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREDateTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() : CI_USCOREDateTypeCode() { }
        virtual ~__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2217 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (677)
/* complex XSD type 'gmd:CI_DateTypeCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREDateTypeCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDateTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDateTypeCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDateTypeCode_USCOREPropertyType() : __CI_USCOREDateTypeCode_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDateTypeCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23702 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (1486)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_ResponsibleParty' of XSD type 'gmd:CI_ResponsibleParty_Type'
        gmd__CI_USCOREResponsibleParty_USCOREType *CI_USCOREResponsibleParty;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() : CI_USCOREResponsibleParty() { }
        virtual ~__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2220 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (678)
/* complex XSD type 'gmd:CI_ResponsibleParty_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREPropertyType {
      public:
        __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREResponsibleParty_USCOREPropertyType() : __CI_USCOREResponsibleParty_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREResponsibleParty_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23758 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (1489)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREContact_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Contact' of XSD type 'gmd:CI_Contact_Type'
        gmd__CI_USCOREContact_USCOREType *CI_USCOREContact;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREContact_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREContact_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREContact_USCOREPropertyType_sequence() : CI_USCOREContact() { }
        virtual ~__gmd__CI_USCOREContact_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREContact_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2226 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType (680)
/* complex XSD type 'gmd:CI_Contact_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREPropertyType {
      public:
        __gmd__CI_USCOREContact_USCOREPropertyType_sequence *__CI_USCOREContact_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREContact_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREContact_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREContact_USCOREPropertyType() : __CI_USCOREContact_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCOREContact_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREContact_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23814 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (1492)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORETelephone_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Telephone' of XSD type 'gmd:CI_Telephone_Type'
        gmd__CI_USCORETelephone_USCOREType *CI_USCORETelephone;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORETelephone_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORETelephone_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORETelephone_USCOREPropertyType_sequence() : CI_USCORETelephone() { }
        virtual ~__gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORETelephone_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2232 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType (682)
/* complex XSD type 'gmd:CI_Telephone_PropertyType': */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREPropertyType {
      public:
        __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *__CI_USCORETelephone_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORETelephone_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORETelephone_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORETelephone_USCOREPropertyType() : __CI_USCORETelephone_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCORETelephone_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORETelephone_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23870 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (1495)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREAddress_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Address' of XSD type 'gmd:CI_Address_Type'
        gmd__CI_USCOREAddress_USCOREType *CI_USCOREAddress;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREAddress_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREAddress_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREAddress_USCOREPropertyType_sequence() : CI_USCOREAddress() { }
        virtual ~__gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREAddress_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2238 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType (684)
/* complex XSD type 'gmd:CI_Address_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREPropertyType {
      public:
        __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *__CI_USCOREAddress_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREAddress_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREAddress_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREAddress_USCOREPropertyType() : __CI_USCOREAddress_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCOREAddress_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREAddress_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23926 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (1498)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnlineResource' of XSD type 'gmd:CI_OnlineResource_Type'
        gmd__CI_USCOREOnlineResource_USCOREType *CI_USCOREOnlineResource;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() : CI_USCOREOnlineResource() { }
        virtual ~__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2244 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (686)
/* complex XSD type 'gmd:CI_OnlineResource_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREPropertyType {
      public:
        __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *__CI_USCOREOnlineResource_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnlineResource_USCOREPropertyType() : __CI_USCOREOnlineResource_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCOREOnlineResource_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnlineResource_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:23982 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__URL_USCOREPropertyType_sequence (1501)
/* Wrapper: */
class SOAP_CMAC __gmd__URL_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:URL' of XSD type 'xsd:anyURI'
        std::string URL;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__URL_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__URL_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__URL_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__URL_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__URL_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__URL_USCOREPropertyType_sequence() : URL() { }
        virtual ~__gmd__URL_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__URL_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__URL_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__URL_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2250 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType (688)
/* complex XSD type 'gmd:URL_PropertyType': */
class SOAP_CMAC gmd__URL_USCOREPropertyType {
      public:
        __gmd__URL_USCOREPropertyType_sequence *__URL_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__URL_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__URL_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__URL_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__URL_USCOREPropertyType() : __URL_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__URL_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__URL_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__URL_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__URL_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24008 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (1503)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnLineFunctionCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREOnLineFunctionCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() : CI_USCOREOnLineFunctionCode() { }
        virtual ~__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2253 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (689)
/* complex XSD type 'gmd:CI_OnLineFunctionCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() : __CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24034 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (1505)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_RoleCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCORERoleCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() : CI_USCORERoleCode() { }
        virtual ~__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2256 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType (690)
/* complex XSD type 'gmd:CI_RoleCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCORERoleCode_USCOREPropertyType {
      public:
        __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *__CI_USCORERoleCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORERoleCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORERoleCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORERoleCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORERoleCode_USCOREPropertyType() : __CI_USCORERoleCode_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__CI_USCORERoleCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORERoleCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24060 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (1507)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_PresentationFormCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREPresentationFormCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() : CI_USCOREPresentationFormCode() { }
        virtual ~__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2259 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (691)
/* complex XSD type 'gmd:CI_PresentationFormCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREPresentationFormCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREPresentationFormCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREPresentationFormCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() : __CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREPresentationFormCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24086 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (1509)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORESeries_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Series' of XSD type 'gmd:CI_Series_Type'
        gmd__CI_USCORESeries_USCOREType *CI_USCORESeries;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORESeries_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORESeries_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORESeries_USCOREPropertyType_sequence() : CI_USCORESeries() { }
        virtual ~__gmd__CI_USCORESeries_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORESeries_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2262 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType (692)
/* complex XSD type 'gmd:CI_Series_PropertyType': */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREPropertyType {
      public:
        __gmd__CI_USCORESeries_USCOREPropertyType_sequence *__CI_USCORESeries_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORESeries_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORESeries_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORESeries_USCOREPropertyType() : __CI_USCORESeries_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__CI_USCORESeries_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORESeries_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24142 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (1512)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_EvaluationMethodTypeCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *DQ_USCOREEvaluationMethodTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() : DQ_USCOREEvaluationMethodTypeCode() { }
        virtual ~__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2268 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (694)
/* complex XSD type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType': */
class SOAP_CMAC gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType {
      public:
        __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() : __DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24176 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__union_DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gmd__union_DQ_USCOREResult_USCOREPropertyType (1515)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:24168 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (1514)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREResult_USCOREPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_USCOREResult_USCOREPropertyType variant selector __unionAbstractDQ_USCOREResult set to one of:
        int __unionAbstractDQ_USCOREResult;
        union _gmd__union_DQ_USCOREResult_USCOREPropertyType union_DQ_USCOREResult_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_USCOREResult_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREResult_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__DQ_USCOREResult_USCOREPropertyType_sequence() : __unionAbstractDQ_USCOREResult() { }
        virtual ~__gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_USCOREResult_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2271 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType (695)
/* complex XSD type 'gmd:DQ_Result_PropertyType': */
class SOAP_CMAC gmd__DQ_USCOREResult_USCOREPropertyType {
      public:
        __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *__DQ_USCOREResult_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_USCOREResult_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_USCOREResult_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREResult_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__DQ_USCOREResult_USCOREPropertyType() : __DQ_USCOREResult_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gmd__DQ_USCOREResult_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_USCOREResult_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24249 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType (1518)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:24238 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (1517)
/* Wrapper: */
class SOAP_CMAC __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence {
      public:
        /// Union with union _gts__union_TM_USCOREPrimitive_USCOREPropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gts__union_TM_USCOREPrimitive_USCOREPropertyType union_TM_USCOREPrimitive_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() : __unionAbstractTimePrimitive() { }
        virtual ~__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2277 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType (697)
/* complex XSD type 'gts:TM_Primitive_PropertyType': */
class SOAP_CMAC gts__TM_USCOREPrimitive_USCOREPropertyType {
      public:
        __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *__TM_USCOREPrimitive_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gts__TM_USCOREPrimitive_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gts__TM_USCOREPrimitive_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gts__TM_USCOREPrimitive_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gts__TM_USCOREPrimitive_USCOREPropertyType() : __TM_USCOREPrimitive_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gts__TM_USCOREPrimitive_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gts__TM_USCOREPrimitive_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2280 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType (698)
/* Type gco__AbstractObject_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gco:AbstractObject_Type': */
class SOAP_CMAC gco__AbstractObject_USCOREType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:ID'
        std::string *id;
        /// optional attribute 'uuid' of XSD type 'xsd:string'
        std::string *uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__AbstractObject_USCOREType, default initialized and not managed by a soap context
        virtual gco__AbstractObject_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__AbstractObject_USCOREType); }
      public:
        /// Constructor with initializations
        gco__AbstractObject_USCOREType() : id(), uuid(), soap() { }
        virtual ~gco__AbstractObject_USCOREType() { }
        /// Friend allocator used by soap_new_gco__AbstractObject_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gco__AbstractObject_USCOREType * SOAP_FMAC2 soap_instantiate_gco__AbstractObject_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24363 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType (1522)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_CharacterString_USCOREPropertyType
{
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_CharacterString	(1)	/**< union variant selector value for member CharacterString */
        std::string *CharacterString;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode	(2)	/**< union variant selector value for member gmd__CI_USCOREDateTypeCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_	(3)	/**< union variant selector value for member gmd__CI_USCOREDateTypeCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode_;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode	(4)	/**< union variant selector value for member gmd__CI_USCOREOnLineFunctionCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_	(5)	/**< union variant selector value for member gmd__CI_USCOREOnLineFunctionCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode_;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode	(6)	/**< union variant selector value for member gmd__CI_USCORERoleCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_	(7)	/**< union variant selector value for member gmd__CI_USCORERoleCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode_;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode	(8)	/**< union variant selector value for member gmd__CI_USCOREPresentationFormCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_	(9)	/**< union variant selector value for member gmd__CI_USCOREPresentationFormCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode_;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode	(10)	/**< union variant selector value for member gmd__DQ_USCOREEvaluationMethodTypeCode */
        gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_	(11)	/**< union variant selector value for member gmd__DQ_USCOREEvaluationMethodTypeCode_ */
        gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode_;
};
#endif

/* eml2_1ForGsoap.h:24334 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gco__CharacterString_USCOREPropertyType_sequence (1521)
/* Wrapper: */
class SOAP_CMAC __gco__CharacterString_USCOREPropertyType_sequence {
      public:
        /// Union with union _gco__union_CharacterString_USCOREPropertyType variant selector __unionCharacterString set to one of: SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_CharacterString SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_ SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_ SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_ SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_ SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode SOAP_UNION_gsoap_eml2_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_
        int __unionCharacterString;
        union _gco__union_CharacterString_USCOREPropertyType union_CharacterString_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gco__CharacterString_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gco__CharacterString_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__CharacterString_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__CharacterString_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__CharacterString_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__CharacterString_USCOREPropertyType_sequence() : __unionCharacterString() { }
        virtual ~__gco__CharacterString_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__CharacterString_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2283 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType (699)
/* complex XSD type 'gco:CharacterString_PropertyType': */
class SOAP_CMAC gco__CharacterString_USCOREPropertyType {
      public:
        __gco__CharacterString_USCOREPropertyType_sequence *__CharacterString_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CharacterString_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__CharacterString_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__CharacterString_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__CharacterString_USCOREPropertyType() : __CharacterString_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gco__CharacterString_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__CharacterString_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__CharacterString_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__CharacterString_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24387 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gco__Boolean_USCOREPropertyType_sequence (1524)
/* Wrapper: */
class SOAP_CMAC __gco__Boolean_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:Boolean' of XSD type 'xsd:boolean'
        bool Boolean;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gco__Boolean_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gco__Boolean_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Boolean_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Boolean_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Boolean_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__Boolean_USCOREPropertyType_sequence() : Boolean() { }
        virtual ~__gco__Boolean_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Boolean_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2286 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType (700)
/* complex XSD type 'gco:Boolean_PropertyType': */
class SOAP_CMAC gco__Boolean_USCOREPropertyType {
      public:
        __gco__Boolean_USCOREPropertyType_sequence *__Boolean_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Boolean_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Boolean_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Boolean_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Boolean_USCOREPropertyType() : __Boolean_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gco__Boolean_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Boolean_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Boolean_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Boolean_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24413 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gco__Real_USCOREPropertyType_sequence (1526)
/* Wrapper: */
class SOAP_CMAC __gco__Real_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:Real' of XSD type 'xsd:double'
        double Real;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gco__Real_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gco__Real_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Real_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Real_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Real_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__Real_USCOREPropertyType_sequence() : Real() { }
        virtual ~__gco__Real_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Real_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Real_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Real_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2289 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType (701)
/* complex XSD type 'gco:Real_PropertyType': */
class SOAP_CMAC gco__Real_USCOREPropertyType {
      public:
        __gco__Real_USCOREPropertyType_sequence *__Real_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Real_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Real_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Real_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Real_USCOREPropertyType() : __Real_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gco__Real_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Real_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Real_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Real_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24447 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__union_Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gco__union_Date_USCOREPropertyType (1529)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Date_USCOREPropertyType
{
        #define SOAP_UNION_gsoap_eml2_1__gco__union_Date_USCOREPropertyType_Date	(1)	/**< union variant selector value for member Date */
        std::string *Date;
        #define SOAP_UNION_gsoap_eml2_1__gco__union_Date_USCOREPropertyType_DateTime	(2)	/**< union variant selector value for member DateTime */
        time_t DateTime;
};
#endif

/* eml2_1ForGsoap.h:2292 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType (702)
/* complex XSD type 'gco:Date_PropertyType': */
class SOAP_CMAC gco__Date_USCOREPropertyType {
      public:
        /// Union with union _gco__union_Date_USCOREPropertyType variant selector __union_Date_USCOREPropertyType set to one of: SOAP_UNION_gsoap_eml2_1__gco__union_Date_USCOREPropertyType_Date SOAP_UNION_gsoap_eml2_1__gco__union_Date_USCOREPropertyType_DateTime
        int __union_Date_USCOREPropertyType;
        union _gco__union_Date_USCOREPropertyType union_Date_USCOREPropertyType;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Date_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Date_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Date_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Date_USCOREPropertyType() : __union_Date_USCOREPropertyType(), gco__nilReason(), soap() { }
        virtual ~gco__Date_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Date_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Date_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Date_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24469 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gco__DateTime_USCOREPropertyType_sequence (1530)
/* Wrapper: */
class SOAP_CMAC __gco__DateTime_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:DateTime' of XSD type 'xsd:dateTime'
        time_t DateTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gco__DateTime_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gco__DateTime_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__DateTime_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__DateTime_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__DateTime_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__DateTime_USCOREPropertyType_sequence() : DateTime() { }
        virtual ~__gco__DateTime_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__DateTime_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2298 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType (704)
/* complex XSD type 'gco:DateTime_PropertyType': */
class SOAP_CMAC gco__DateTime_USCOREPropertyType {
      public:
        __gco__DateTime_USCOREPropertyType_sequence *__DateTime_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__DateTime_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__DateTime_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__DateTime_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__DateTime_USCOREPropertyType() : __DateTime_USCOREPropertyType_sequence(), gco__nilReason(), soap() { }
        virtual ~gco__DateTime_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__DateTime_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__DateTime_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__DateTime_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24514 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gsr__union_SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1__gsr__union_SC_USCORECRS_USCOREPropertyType (1533)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gsr__union_SC_USCORECRS_USCOREPropertyType
{
};
#endif

/* eml2_1ForGsoap.h:24503 */
#ifndef SOAP_TYPE_gsoap_eml2_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (1532)
/* Wrapper: */
class SOAP_CMAC __gsr__SC_USCORECRS_USCOREPropertyType_sequence {
      public:
        /// Union with union _gsr__union_SC_USCORECRS_USCOREPropertyType variant selector __unionAbstractCRS set to one of:
        int __unionAbstractCRS;
        union _gsr__union_SC_USCORECRS_USCOREPropertyType union_SC_USCORECRS_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gsr__SC_USCORECRS_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gsr__SC_USCORECRS_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gsr__SC_USCORECRS_USCOREPropertyType_sequence() : __unionAbstractCRS() { }
        virtual ~__gsr__SC_USCORECRS_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gsr__SC_USCORECRS_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2301 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType (705)
/* complex XSD type 'gsr:SC_CRS_PropertyType': */
class SOAP_CMAC gsr__SC_USCORECRS_USCOREPropertyType {
      public:
        __gsr__SC_USCORECRS_USCOREPropertyType_sequence *__SC_USCORECRS_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gsr__SC_USCORECRS_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gsr__SC_USCORECRS_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gsr__SC_USCORECRS_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gsr__SC_USCORECRS_USCOREPropertyType() : __SC_USCORECRS_USCOREPropertyType_sequence(), gco__nilReason(), uuidref(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gsr__SC_USCORECRS_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gsr__SC_USCORECRS_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:240 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition (18)
/* Type prodml2__DasAcquisition is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:DasAcquisition': */
class SOAP_CMAC prodml2__DasAcquisition : public eml21__AbstractObject {
      public:
        /// Required element 'prodml2:AcquisitionId' of XSD type 'eml21:UuidString'
        std::string AcquisitionId;
        /// Optional element 'prodml2:AcquisitionDescription' of XSD type 'eml21:String2000'
        std::string *AcquisitionDescription;
        /// Required element 'prodml2:OpticalPath' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *OpticalPath;
        /// Required element 'prodml2:DasInstrumentBox' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *DasInstrumentBox;
        /// Required element 'prodml2:FacilityId' of XSD type 'eml21:String64'
        std::vector<std::string> FacilityId;
        /// Required element 'prodml2:VendorCode' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *VendorCode;
        /// Required element 'prodml2:PulseRate' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *PulseRate;
        /// Required element 'prodml2:PulseWidth' of XSD type 'eml21:TimeMeasure'
        eml21__TimeMeasure *PulseWidth;
        /// Required element 'prodml2:GaugeLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *GaugeLength;
        /// Optional element 'prodml2:GaugeLengthUnit' of XSD type 'eml21:String64'
        std::string *GaugeLengthUnit;
        /// Required element 'prodml2:SpatialSamplingInterval' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *SpatialSamplingInterval;
        /// Optional element 'prodml2:SpatialSamplingIntervalUnit' of XSD type 'eml21:String64'
        std::string *SpatialSamplingIntervalUnit;
        /// Required element 'prodml2:MinimumFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *MinimumFrequency;
        /// Required element 'prodml2:MaximumFrequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *MaximumFrequency;
        /// Required element 'prodml2:NumberOfLoci' of XSD type 'xsd:unsignedLong'
        ULONG64 NumberOfLoci;
        /// Required element 'prodml2:StartLocusIndex' of XSD type 'xsd:unsignedLong'
        ULONG64 StartLocusIndex;
        /// Required element 'prodml2:MeasurementStartTime' of XSD type 'eml21:TimeStamp'
        std::string MeasurementStartTime;
        /// Required element 'prodml2:TriggeredMeasurement' of XSD type 'xsd:boolean'
        bool TriggeredMeasurement;
        /// Optional element 'prodml2:PulseWidthUnit' of XSD type 'eml21:String64'
        std::string *PulseWidthUnit;
        /// Optional element 'prodml2:Raw' of XSD type 'prodml2:DasRaw'
        std::vector<prodml2__DasRaw *> Raw;
        /// Optional element 'prodml2:Custom' of XSD type 'prodml2:DasCustom'
        prodml2__DasCustom *Custom;
        /// Optional element 'prodml2:Calibration' of XSD type 'prodml2:DasCalibration'
        std::vector<prodml2__DasCalibration *> Calibration;
        /// Optional element 'prodml2:Processed' of XSD type 'prodml2:DasProcessed'
        prodml2__DasProcessed *Processed;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasAcquisition, default initialized and not managed by a soap context
        virtual prodml2__DasAcquisition *soap_alloc(void) const { return SOAP_NEW(prodml2__DasAcquisition); }
      public:
        /// Constructor with initializations
        prodml2__DasAcquisition() : AcquisitionId(), AcquisitionDescription(), OpticalPath(), DasInstrumentBox(), FacilityId(), VendorCode(), PulseRate(), PulseWidth(), GaugeLength(), GaugeLengthUnit(), SpatialSamplingInterval(), SpatialSamplingIntervalUnit(), MinimumFrequency(), MaximumFrequency(), NumberOfLoci(), StartLocusIndex(), MeasurementStartTime(), TriggeredMeasurement(), PulseWidthUnit(), Raw(), Custom(), Calibration(), Processed() { }
        virtual ~prodml2__DasAcquisition() { }
        /// Friend allocator used by soap_new_prodml2__DasAcquisition(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasAcquisition * SOAP_FMAC2 soap_instantiate_prodml2__DasAcquisition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:24730 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__DasExternalDatasetPart_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__DasExternalDatasetPart_sequence (1540)
/* Wrapper: */
class SOAP_CMAC __prodml2__DasExternalDatasetPart_sequence {
      public:
        /// Optional element 'prodml2:PartStartTime' of XSD type 'eml21:TimeStamp'
        std::string *PartStartTime;
        /// Optional element 'prodml2:PartEndTime' of XSD type 'eml21:TimeStamp'
        std::string *PartEndTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__DasExternalDatasetPart_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__DasExternalDatasetPart_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__DasExternalDatasetPart_sequence, default initialized and not managed by a soap context
        virtual __prodml2__DasExternalDatasetPart_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__DasExternalDatasetPart_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__DasExternalDatasetPart_sequence() : PartStartTime(), PartEndTime() { }
        virtual ~__prodml2__DasExternalDatasetPart_sequence() { }
        /// Friend allocator used by soap_new___prodml2__DasExternalDatasetPart_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__DasExternalDatasetPart_sequence * SOAP_FMAC2 soap_instantiate___prodml2__DasExternalDatasetPart_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:252 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart (22)
/* Type prodml2__DasExternalDatasetPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:DasExternalDatasetPart': */
class SOAP_CMAC prodml2__DasExternalDatasetPart : public eml21__ExternalDatasetPart {
      public:
        __prodml2__DasExternalDatasetPart_sequence *__DasExternalDatasetPart_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasExternalDatasetPart, default initialized and not managed by a soap context
        virtual prodml2__DasExternalDatasetPart *soap_alloc(void) const { return SOAP_NEW(prodml2__DasExternalDatasetPart); }
      public:
        /// Constructor with initializations
        prodml2__DasExternalDatasetPart() : __DasExternalDatasetPart_sequence() { }
        virtual ~prodml2__DasExternalDatasetPart() { }
        /// Friend allocator used by soap_new_prodml2__DasExternalDatasetPart(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasExternalDatasetPart * SOAP_FMAC2 soap_instantiate_prodml2__DasExternalDatasetPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:261 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox (25)
/* Type prodml2__DasInstrumentBox is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:DasInstrumentBox': */
class SOAP_CMAC prodml2__DasInstrumentBox : public eml21__AbstractObject {
      public:
        /// Optional element 'prodml2:SerialNumber' of XSD type 'eml21:String64'
        std::string *SerialNumber;
        /// Optional element 'prodml2:Parameter' of XSD type 'prodml2:IndexedObject'
        std::vector<prodml2__IndexedObject *> Parameter;
        /// Optional element 'prodml2:FacilityIdentifier' of XSD type 'prodml2:FacilityIdentifier'
        prodml2__FacilityIdentifier *FacilityIdentifier;
        /// Required element 'prodml2:Instrument' of XSD type 'prodml2:Instrument'
        prodml2__Instrument *Instrument;
        /// Required element 'prodml2:FirmwareVersion' of XSD type 'eml21:String64'
        std::string FirmwareVersion;
        /// Optional element 'prodml2:PatchCord' of XSD type 'prodml2:DtsPatchCord'
        prodml2__DtsPatchCord *PatchCord;
        /// Optional element 'prodml2:InstrumentBoxDescription' of XSD type 'eml21:String2000'
        std::string *InstrumentBoxDescription;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DasInstrumentBox, default initialized and not managed by a soap context
        virtual prodml2__DasInstrumentBox *soap_alloc(void) const { return SOAP_NEW(prodml2__DasInstrumentBox); }
      public:
        /// Constructor with initializations
        prodml2__DasInstrumentBox() : SerialNumber(), Parameter(), FacilityIdentifier(), Instrument(), FirmwareVersion(), PatchCord(), InstrumentBoxDescription() { }
        virtual ~prodml2__DasInstrumentBox() { }
        /// Friend allocator used by soap_new_prodml2__DasInstrumentBox(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DasInstrumentBox * SOAP_FMAC2 soap_instantiate_prodml2__DasInstrumentBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:285 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox (33)
/* Type prodml2__DtsInstrumentBox is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:DtsInstrumentBox': */
class SOAP_CMAC prodml2__DtsInstrumentBox : public eml21__AbstractObject {
      public:
        /// Optional element 'prodml2:SerialNumber' of XSD type 'eml21:String64'
        std::string *SerialNumber;
        /// Optional element 'prodml2:InternalOvenLocationNear' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *InternalOvenLocationNear;
        /// Optional element 'prodml2:InternalOvenLocationFar' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *InternalOvenLocationFar;
        /// Optional element 'prodml2:ReferenceCoilTemperature' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *ReferenceCoilTemperature;
        /// Optional element 'prodml2:Parameter' of XSD type 'prodml2:IndexedObject'
        std::vector<prodml2__IndexedObject *> Parameter;
        /// Optional element 'prodml2:WarmupTime' of XSD type 'eml21:TimeMeasure'
        eml21__TimeMeasure *WarmupTime;
        /// Optional element 'prodml2:StartupTime' of XSD type 'eml21:TimeMeasure'
        eml21__TimeMeasure *StartupTime;
        /// Optional element 'prodml2:FacilityIdentifier' of XSD type 'prodml2:FacilityIdentifier'
        prodml2__FacilityIdentifier *FacilityIdentifier;
        /// Optional element 'prodml2:DtsPatchCord' of XSD type 'prodml2:DtsPatchCord'
        prodml2__DtsPatchCord *DtsPatchCord;
        /// Optional element 'prodml2:InstrumentCalibration' of XSD type 'prodml2:DtsCalibration'
        std::vector<prodml2__DtsCalibration *> InstrumentCalibration;
        /// Required element 'prodml2:Instrument' of XSD type 'prodml2:Instrument'
        prodml2__Instrument *Instrument;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DtsInstrumentBox, default initialized and not managed by a soap context
        virtual prodml2__DtsInstrumentBox *soap_alloc(void) const { return SOAP_NEW(prodml2__DtsInstrumentBox); }
      public:
        /// Constructor with initializations
        prodml2__DtsInstrumentBox() : SerialNumber(), InternalOvenLocationNear(), InternalOvenLocationFar(), ReferenceCoilTemperature(), Parameter(), WarmupTime(), StartupTime(), FacilityIdentifier(), DtsPatchCord(), InstrumentCalibration(), Instrument() { }
        virtual ~prodml2__DtsInstrumentBox() { }
        /// Friend allocator used by soap_new_prodml2__DtsInstrumentBox(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DtsInstrumentBox * SOAP_FMAC2 soap_instantiate_prodml2__DtsInstrumentBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:291 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument (35)
/* Type prodml2__Instrument is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:Instrument': */
class SOAP_CMAC prodml2__Instrument : public prodml2__AbstractDtsEquipment {
      public:
        /// Optional element 'prodml2:InstrumentVendor' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *InstrumentVendor;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__Instrument, default initialized and not managed by a soap context
        virtual prodml2__Instrument *soap_alloc(void) const { return SOAP_NEW(prodml2__Instrument); }
      public:
        /// Constructor with initializations
        prodml2__Instrument() : InstrumentVendor() { }
        virtual ~prodml2__Instrument() { }
        /// Friend allocator used by soap_new_prodml2__Instrument(struct soap*, int)
        friend SOAP_FMAC1 prodml2__Instrument * SOAP_FMAC2 soap_instantiate_prodml2__Instrument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:297 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem (37)
/* Type prodml2__DtsInstalledSystem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:DtsInstalledSystem': */
class SOAP_CMAC prodml2__DtsInstalledSystem : public eml21__AbstractObject {
      public:
        /// Required element 'prodml2:DateMin' of XSD type 'xsd:dateTime'
        time_t DateMin;
        /// Optional element 'prodml2:DateMax' of XSD type 'xsd:dateTime'
        time_t *DateMax;
        /// Optional element 'prodml2:OpticalPathLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OpticalPathLength;
        /// Optional element 'prodml2:OpticalBudget' of XSD type 'xsd:double'
        double *OpticalBudget;
        /// Required element 'prodml2:OpticalPathReference' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *OpticalPathReference;
        /// Required element 'prodml2:InstrumentBoxReference' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *InstrumentBoxReference;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:FacilityIdentifier' of XSD type 'prodml2:FacilityIdentifier'
        prodml2__FacilityIdentifier *FacilityIdentifier;
        /// Optional element 'prodml2:DtsCalibration' of XSD type 'prodml2:DtsCalibration'
        std::vector<prodml2__DtsCalibration *> DtsCalibration;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__DtsInstalledSystem, default initialized and not managed by a soap context
        virtual prodml2__DtsInstalledSystem *soap_alloc(void) const { return SOAP_NEW(prodml2__DtsInstalledSystem); }
      public:
        /// Constructor with initializations
        prodml2__DtsInstalledSystem() : DateMin(), DateMax(), OpticalPathLength(), OpticalBudget(), OpticalPathReference(), InstrumentBoxReference(), Comment(), FacilityIdentifier(), DtsCalibration() { }
        virtual ~prodml2__DtsInstalledSystem() { }
        /// Friend allocator used by soap_new_prodml2__DtsInstalledSystem(struct soap*, int)
        friend SOAP_FMAC1 prodml2__DtsInstalledSystem * SOAP_FMAC2 soap_instantiate_prodml2__DtsInstalledSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:336 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater (50)
/* Type prodml2__FormationWater is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FormationWater': */
class SOAP_CMAC prodml2__FormationWater : public prodml2__AbstractFluidComponent {
      public:
        /// Optional element 'prodml2:SpecificGravity' of XSD type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml2:Salinity' of XSD type 'eml21:MassPerMassMeasure'
        eml21__MassPerMassMeasure *Salinity;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FormationWater, default initialized and not managed by a soap context
        virtual prodml2__FormationWater *soap_alloc(void) const { return SOAP_NEW(prodml2__FormationWater); }
      public:
        /// Constructor with initializations
        prodml2__FormationWater() : SpecificGravity(), Salinity(), Remark() { }
        virtual ~prodml2__FormationWater() { }
        /// Friend allocator used by soap_new_prodml2__FormationWater(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FormationWater * SOAP_FMAC2 soap_instantiate_prodml2__FormationWater(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:345 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure (53)
/* Type prodml2__GeneralQualifiedMeasure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:GeneralQualifiedMeasure': */
class SOAP_CMAC prodml2__GeneralQualifiedMeasure : public prodml2__AbstractMeasureDataType {
      public:
        /// optional attribute 'status' of XSD type 'prodml2:ValueStatus'
        enum prodml2__ValueStatus *status;
        /// optional attribute 'componentReference' of XSD type 'eml21:String64'
        std::string *componentReference;
        /// required attribute 'uom' of XSD type 'eml21:UomEnum'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__GeneralQualifiedMeasure, default initialized and not managed by a soap context
        virtual prodml2__GeneralQualifiedMeasure *soap_alloc(void) const { return SOAP_NEW(prodml2__GeneralQualifiedMeasure); }
      public:
        /// Constructor with initializations
        prodml2__GeneralQualifiedMeasure() : status(), componentReference(), uom() { }
        virtual ~prodml2__GeneralQualifiedMeasure() { }
        /// Friend allocator used by soap_new_prodml2__GeneralQualifiedMeasure(struct soap*, int)
        friend SOAP_FMAC1 prodml2__GeneralQualifiedMeasure * SOAP_FMAC2 soap_instantiate_prodml2__GeneralQualifiedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:357 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount (57)
/* Type prodml2__IntegerQualifiedCount is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:IntegerQualifiedCount': */
class SOAP_CMAC prodml2__IntegerQualifiedCount : public prodml2__AbstractMeasureDataType {
      public:
        /// optional attribute 'status' of XSD type 'prodml2:ValueStatus'
        enum prodml2__ValueStatus *status;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__IntegerQualifiedCount, default initialized and not managed by a soap context
        virtual prodml2__IntegerQualifiedCount *soap_alloc(void) const { return SOAP_NEW(prodml2__IntegerQualifiedCount); }
      public:
        /// Constructor with initializations
        prodml2__IntegerQualifiedCount() : status() { }
        virtual ~prodml2__IntegerQualifiedCount() { }
        /// Friend allocator used by soap_new_prodml2__IntegerQualifiedCount(struct soap*, int)
        friend SOAP_FMAC1 prodml2__IntegerQualifiedCount * SOAP_FMAC2 soap_instantiate_prodml2__IntegerQualifiedCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:363 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString (59)
/* Type prodml2__KindQualifiedString is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:KindQualifiedString': */
class SOAP_CMAC prodml2__KindQualifiedString : public prodml2__AbstractMeasureDataType {
      public:
        /// optional attribute 'status' of XSD type 'prodml2:ValueStatus'
        enum prodml2__ValueStatus *status;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__KindQualifiedString, default initialized and not managed by a soap context
        virtual prodml2__KindQualifiedString *soap_alloc(void) const { return SOAP_NEW(prodml2__KindQualifiedString); }
      public:
        /// Constructor with initializations
        prodml2__KindQualifiedString() : status() { }
        virtual ~prodml2__KindQualifiedString() { }
        /// Friend allocator used by soap_new_prodml2__KindQualifiedString(struct soap*, int)
        friend SOAP_FMAC1 prodml2__KindQualifiedString * SOAP_FMAC2 soap_instantiate_prodml2__KindQualifiedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:378 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas (64)
/* Type prodml2__NaturalGas is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:NaturalGas': */
class SOAP_CMAC prodml2__NaturalGas : public prodml2__AbstractFluidComponent {
      public:
        /// Optional element 'prodml2:GasGravity' of XSD type 'xsd:double'
        double *GasGravity;
        /// Optional element 'prodml2:MolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml2:GrossEnergyContentPerUnitMass' of XSD type 'eml21:EnergyPerMassMeasure'
        eml21__EnergyPerMassMeasure *GrossEnergyContentPerUnitMass;
        /// Optional element 'prodml2:NetEnergyContentPerUnitMass' of XSD type 'eml21:EnergyPerMassMeasure'
        eml21__EnergyPerMassMeasure *NetEnergyContentPerUnitMass;
        /// Optional element 'prodml2:GrossEnergyContentPerUnitVolume' of XSD type 'eml21:EnergyPerVolumeMeasure'
        eml21__EnergyPerVolumeMeasure *GrossEnergyContentPerUnitVolume;
        /// Optional element 'prodml2:NetEnergyContentPerUnitVolume' of XSD type 'eml21:EnergyPerVolumeMeasure'
        eml21__EnergyPerVolumeMeasure *NetEnergyContentPerUnitVolume;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__NaturalGas, default initialized and not managed by a soap context
        virtual prodml2__NaturalGas *soap_alloc(void) const { return SOAP_NEW(prodml2__NaturalGas); }
      public:
        /// Constructor with initializations
        prodml2__NaturalGas() : GasGravity(), MolecularWeight(), GrossEnergyContentPerUnitMass(), NetEnergyContentPerUnitMass(), GrossEnergyContentPerUnitVolume(), NetEnergyContentPerUnitVolume(), Remark() { }
        virtual ~prodml2__NaturalGas() { }
        /// Friend allocator used by soap_new_prodml2__NaturalGas(struct soap*, int)
        friend SOAP_FMAC1 prodml2__NaturalGas * SOAP_FMAC2 soap_instantiate_prodml2__NaturalGas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:25329 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__PlusFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__PlusFluidComponent_sequence (1551)
/* Wrapper: */
class SOAP_CMAC __prodml2__PlusFluidComponent_sequence {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:PlusComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml2:SpecificGravity' of XSD type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml2:StartingCarbonNumber' of XSD type 'xsd:unsignedLong'
        ULONG64 *StartingCarbonNumber;
        /// Optional element 'prodml2:StartingBoilingPoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *StartingBoilingPoint;
        /// Optional element 'prodml2:AvgDensity' of XSD type 'eml21:MassPerVolumeMeasure'
        eml21__MassPerVolumeMeasure *AvgDensity;
        /// Optional element 'prodml2:AvgMolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *AvgMolecularWeight;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__PlusFluidComponent_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__PlusFluidComponent_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__PlusFluidComponent_sequence, default initialized and not managed by a soap context
        virtual __prodml2__PlusFluidComponent_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__PlusFluidComponent_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__PlusFluidComponent_sequence() : Kind(), SpecificGravity(), StartingCarbonNumber(), StartingBoilingPoint(), AvgDensity(), AvgMolecularWeight(), Remark() { }
        virtual ~__prodml2__PlusFluidComponent_sequence() { }
        /// Friend allocator used by soap_new___prodml2__PlusFluidComponent_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__PlusFluidComponent_sequence * SOAP_FMAC2 soap_instantiate___prodml2__PlusFluidComponent_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:396 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent (70)
/* Type prodml2__PlusFluidComponent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:PlusFluidComponent': */
class SOAP_CMAC prodml2__PlusFluidComponent : public prodml2__AbstractFluidComponent {
      public:
        __prodml2__PlusFluidComponent_sequence *__PlusFluidComponent_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PlusFluidComponent, default initialized and not managed by a soap context
        virtual prodml2__PlusFluidComponent *soap_alloc(void) const { return SOAP_NEW(prodml2__PlusFluidComponent); }
      public:
        /// Constructor with initializations
        prodml2__PlusFluidComponent() : __PlusFluidComponent_sequence() { }
        virtual ~prodml2__PlusFluidComponent() { }
        /// Friend allocator used by soap_new_prodml2__PlusFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PlusFluidComponent * SOAP_FMAC2 soap_instantiate_prodml2__PlusFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:25405 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__PseudoFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__PseudoFluidComponent_sequence (1553)
/* Wrapper: */
class SOAP_CMAC __prodml2__PseudoFluidComponent_sequence {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:PseudoComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml2:SpecificGravity' of XSD type 'xsd:double'
        double *SpecificGravity;
        /// Optional element 'prodml2:StartingCarbonNumber' of XSD type 'xsd:unsignedLong'
        ULONG64 *StartingCarbonNumber;
        /// Optional element 'prodml2:EndingCarbonNumber' of XSD type 'xsd:unsignedLong'
        ULONG64 *EndingCarbonNumber;
        /// Optional element 'prodml2:AvgMolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *AvgMolecularWeight;
        /// Optional element 'prodml2:AvgDensity' of XSD type 'eml21:MassPerVolumeMeasure'
        eml21__MassPerVolumeMeasure *AvgDensity;
        /// Optional element 'prodml2:StartingBoilingPoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *StartingBoilingPoint;
        /// Optional element 'prodml2:EndingBoilingPoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *EndingBoilingPoint;
        /// Optional element 'prodml2:AvgBoilingPoint' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *AvgBoilingPoint;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__PseudoFluidComponent_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__PseudoFluidComponent_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__PseudoFluidComponent_sequence, default initialized and not managed by a soap context
        virtual __prodml2__PseudoFluidComponent_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__PseudoFluidComponent_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__PseudoFluidComponent_sequence() : Kind(), SpecificGravity(), StartingCarbonNumber(), EndingCarbonNumber(), AvgMolecularWeight(), AvgDensity(), StartingBoilingPoint(), EndingBoilingPoint(), AvgBoilingPoint(), Remark() { }
        virtual ~__prodml2__PseudoFluidComponent_sequence() { }
        /// Friend allocator used by soap_new___prodml2__PseudoFluidComponent_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__PseudoFluidComponent_sequence * SOAP_FMAC2 soap_instantiate___prodml2__PseudoFluidComponent_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:405 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent (73)
/* Type prodml2__PseudoFluidComponent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:PseudoFluidComponent': */
class SOAP_CMAC prodml2__PseudoFluidComponent : public prodml2__AbstractFluidComponent {
      public:
        __prodml2__PseudoFluidComponent_sequence *__PseudoFluidComponent_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PseudoFluidComponent, default initialized and not managed by a soap context
        virtual prodml2__PseudoFluidComponent *soap_alloc(void) const { return SOAP_NEW(prodml2__PseudoFluidComponent); }
      public:
        /// Constructor with initializations
        prodml2__PseudoFluidComponent() : __PseudoFluidComponent_sequence() { }
        virtual ~prodml2__PseudoFluidComponent() { }
        /// Friend allocator used by soap_new_prodml2__PseudoFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PseudoFluidComponent * SOAP_FMAC2 soap_instantiate_prodml2__PseudoFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:25496 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__PureFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__PureFluidComponent_sequence (1555)
/* Wrapper: */
class SOAP_CMAC __prodml2__PureFluidComponent_sequence {
      public:
        /// Required element 'prodml2:Kind' of XSD type 'prodml2:PureComponentEnumExt'
        std::string Kind;
        /// Optional element 'prodml2:MolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *MolecularWeight;
        /// Required element 'prodml2:HydrocarbonFlag' of XSD type 'xsd:boolean'
        bool HydrocarbonFlag;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__PureFluidComponent_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__PureFluidComponent_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__PureFluidComponent_sequence, default initialized and not managed by a soap context
        virtual __prodml2__PureFluidComponent_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__PureFluidComponent_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__PureFluidComponent_sequence() : Kind(), MolecularWeight(), HydrocarbonFlag(), Remark() { }
        virtual ~__prodml2__PureFluidComponent_sequence() { }
        /// Friend allocator used by soap_new___prodml2__PureFluidComponent_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__PureFluidComponent_sequence * SOAP_FMAC2 soap_instantiate___prodml2__PureFluidComponent_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:408 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent (74)
/* Type prodml2__PureFluidComponent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:PureFluidComponent': */
class SOAP_CMAC prodml2__PureFluidComponent : public prodml2__AbstractFluidComponent {
      public:
        __prodml2__PureFluidComponent_sequence *__PureFluidComponent_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PureFluidComponent, default initialized and not managed by a soap context
        virtual prodml2__PureFluidComponent *soap_alloc(void) const { return SOAP_NEW(prodml2__PureFluidComponent); }
      public:
        /// Constructor with initializations
        prodml2__PureFluidComponent() : __PureFluidComponent_sequence() { }
        virtual ~prodml2__PureFluidComponent() { }
        /// Friend allocator used by soap_new_prodml2__PureFluidComponent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PureFluidComponent * SOAP_FMAC2 soap_instantiate_prodml2__PureFluidComponent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:411 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate (75)
/* Type prodml2__StartEndDate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:StartEndDate': */
class SOAP_CMAC prodml2__StartEndDate : public prodml2__AbstractDateTimeClass {
      public:
        /// Optional element 'prodml2:DateStart' of XSD type 'xsd:date'
        std::string *DateStart;
        /// Optional element 'prodml2:DateEnd' of XSD type 'xsd:date'
        std::string *DateEnd;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__StartEndDate, default initialized and not managed by a soap context
        virtual prodml2__StartEndDate *soap_alloc(void) const { return SOAP_NEW(prodml2__StartEndDate); }
      public:
        /// Constructor with initializations
        prodml2__StartEndDate() : DateStart(), DateEnd() { }
        virtual ~prodml2__StartEndDate() { }
        /// Friend allocator used by soap_new_prodml2__StartEndDate(struct soap*, int)
        friend SOAP_FMAC1 prodml2__StartEndDate * SOAP_FMAC2 soap_instantiate_prodml2__StartEndDate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:414 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime (76)
/* Type prodml2__StartEndTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:StartEndTime': */
class SOAP_CMAC prodml2__StartEndTime : public prodml2__AbstractDateTimeClass {
      public:
        /// Optional element 'prodml2:DTimStart' of XSD type 'eml21:TimeStamp'
        std::string *DTimStart;
        /// Optional element 'prodml2:DTimEnd' of XSD type 'eml21:TimeStamp'
        std::string *DTimEnd;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__StartEndTime, default initialized and not managed by a soap context
        virtual prodml2__StartEndTime *soap_alloc(void) const { return SOAP_NEW(prodml2__StartEndTime); }
      public:
        /// Constructor with initializations
        prodml2__StartEndTime() : DTimStart(), DTimEnd() { }
        virtual ~prodml2__StartEndTime() { }
        /// Friend allocator used by soap_new_prodml2__StartEndTime(struct soap*, int)
        friend SOAP_FMAC1 prodml2__StartEndTime * SOAP_FMAC2 soap_instantiate_prodml2__StartEndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:417 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil (77)
/* Type prodml2__StockTankOil is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:StockTankOil': */
class SOAP_CMAC prodml2__StockTankOil : public prodml2__AbstractFluidComponent {
      public:
        /// Optional element 'prodml2:APIGravity' of XSD type 'eml21:APIGravityMeasure'
        eml21__APIGravityMeasure *APIGravity;
        /// Optional element 'prodml2:MolecularWeight' of XSD type 'eml21:MolecularWeightMeasure'
        eml21__MolecularWeightMeasure *MolecularWeight;
        /// Optional element 'prodml2:GrossEnergyContentPerUnitMass' of XSD type 'eml21:EnergyPerMassMeasure'
        eml21__EnergyPerMassMeasure *GrossEnergyContentPerUnitMass;
        /// Optional element 'prodml2:NetEnergyContentPerUnitMass' of XSD type 'eml21:EnergyPerMassMeasure'
        eml21__EnergyPerMassMeasure *NetEnergyContentPerUnitMass;
        /// Optional element 'prodml2:GrossEnergyContentPerUnitVolume' of XSD type 'eml21:EnergyPerVolumeMeasure'
        eml21__EnergyPerVolumeMeasure *GrossEnergyContentPerUnitVolume;
        /// Optional element 'prodml2:NetEnergyContentPerUnitVolume' of XSD type 'eml21:EnergyPerVolumeMeasure'
        eml21__EnergyPerVolumeMeasure *NetEnergyContentPerUnitVolume;
        /// Optional element 'prodml2:Remark' of XSD type 'eml21:String2000'
        std::string *Remark;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__StockTankOil, default initialized and not managed by a soap context
        virtual prodml2__StockTankOil *soap_alloc(void) const { return SOAP_NEW(prodml2__StockTankOil); }
      public:
        /// Constructor with initializations
        prodml2__StockTankOil() : APIGravity(), MolecularWeight(), GrossEnergyContentPerUnitMass(), NetEnergyContentPerUnitMass(), GrossEnergyContentPerUnitVolume(), NetEnergyContentPerUnitVolume(), Remark() { }
        virtual ~prodml2__StockTankOil() { }
        /// Friend allocator used by soap_new_prodml2__StockTankOil(struct soap*, int)
        friend SOAP_FMAC1 prodml2__StockTankOil * SOAP_FMAC2 soap_instantiate_prodml2__StockTankOil(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:444 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData (86)
/* Type prodml2__CurveData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:CurveData': */
class SOAP_CMAC prodml2__CurveData : public prodml2__AbstractMeasureDataType {
      public:
        /// Required element 'prodml2:Index' of XSD type 'xsd:unsignedLong'
        std::vector<ULONG64> Index;
        /// Required element 'prodml2:Value' of XSD type 'xsd:double'
        std::vector<double> Value;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__CurveData, default initialized and not managed by a soap context
        virtual prodml2__CurveData *soap_alloc(void) const { return SOAP_NEW(prodml2__CurveData); }
      public:
        /// Constructor with initializations
        prodml2__CurveData() : Index(), Value(), uid() { }
        virtual ~prodml2__CurveData() { }
        /// Friend allocator used by soap_new_prodml2__CurveData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__CurveData * SOAP_FMAC2 soap_instantiate_prodml2__CurveData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:25760 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityParent_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityParent_sequence (1560)
/* Wrapper: */
class SOAP_CMAC __prodml2__FacilityParent_sequence {
      public:
        /// Required element 'prodml2:Name' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Name;
        /// Optional element 'prodml2:FacilityParent1' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent1;
        /// Optional element 'prodml2:FacilityParent2' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *FacilityParent2;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityParent_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityParent_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__FacilityParent_sequence, default initialized and not managed by a soap context
        virtual __prodml2__FacilityParent_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__FacilityParent_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__FacilityParent_sequence() : Name(), FacilityParent1(), FacilityParent2() { }
        virtual ~__prodml2__FacilityParent_sequence() { }
        /// Friend allocator used by soap_new___prodml2__FacilityParent_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__FacilityParent_sequence * SOAP_FMAC2 soap_instantiate___prodml2__FacilityParent_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:450 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent (88)
/* Type prodml2__FacilityParent is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FacilityParent': */
class SOAP_CMAC prodml2__FacilityParent : public prodml2__AbstractRelatedFacilityObject {
      public:
        __prodml2__FacilityParent_sequence *__FacilityParent_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FacilityParent, default initialized and not managed by a soap context
        virtual prodml2__FacilityParent *soap_alloc(void) const { return SOAP_NEW(prodml2__FacilityParent); }
      public:
        /// Constructor with initializations
        prodml2__FacilityParent() : __FacilityParent_sequence() { }
        virtual ~prodml2__FacilityParent() { }
        /// Friend allocator used by soap_new_prodml2__FacilityParent(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FacilityParent * SOAP_FMAC2 soap_instantiate_prodml2__FacilityParent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:25803 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityUnitPort_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityUnitPort_sequence (1562)
/* Wrapper: */
class SOAP_CMAC __prodml2__FacilityUnitPort_sequence {
      public:
        /// Required element 'prodml2:PortReference' of XSD type 'eml21:String64'
        std::string PortReference;
        /// Required element 'prodml2:UnitReference' of XSD type 'eml21:String64'
        std::string UnitReference;
        /// Optional element 'prodml2:NetworkReference' of XSD type 'eml21:String64'
        std::string *NetworkReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityUnitPort_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__FacilityUnitPort_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__FacilityUnitPort_sequence, default initialized and not managed by a soap context
        virtual __prodml2__FacilityUnitPort_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__FacilityUnitPort_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__FacilityUnitPort_sequence() : PortReference(), UnitReference(), NetworkReference() { }
        virtual ~__prodml2__FacilityUnitPort_sequence() { }
        /// Friend allocator used by soap_new___prodml2__FacilityUnitPort_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__FacilityUnitPort_sequence * SOAP_FMAC2 soap_instantiate___prodml2__FacilityUnitPort_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:453 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort (89)
/* Type prodml2__FacilityUnitPort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FacilityUnitPort': */
class SOAP_CMAC prodml2__FacilityUnitPort : public prodml2__AbstractRelatedFacilityObject {
      public:
        __prodml2__FacilityUnitPort_sequence *__FacilityUnitPort_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FacilityUnitPort, default initialized and not managed by a soap context
        virtual prodml2__FacilityUnitPort *soap_alloc(void) const { return SOAP_NEW(prodml2__FacilityUnitPort); }
      public:
        /// Constructor with initializations
        prodml2__FacilityUnitPort() : __FacilityUnitPort_sequence() { }
        virtual ~prodml2__FacilityUnitPort() { }
        /// Friend allocator used by soap_new_prodml2__FacilityUnitPort(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FacilityUnitPort * SOAP_FMAC2 soap_instantiate_prodml2__FacilityUnitPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:456 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData (90)
/* Type prodml2__IntegerData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:IntegerData': */
class SOAP_CMAC prodml2__IntegerData : public prodml2__AbstractMeasureDataType {
      public:
        /// Required element 'prodml2:IntegerValue' of XSD type 'prodml2:IntegerQualifiedCount'
        prodml2__IntegerQualifiedCount *IntegerValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__IntegerData, default initialized and not managed by a soap context
        virtual prodml2__IntegerData *soap_alloc(void) const { return SOAP_NEW(prodml2__IntegerData); }
      public:
        /// Constructor with initializations
        prodml2__IntegerData() : IntegerValue() { }
        virtual ~prodml2__IntegerData() { }
        /// Friend allocator used by soap_new_prodml2__IntegerData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__IntegerData * SOAP_FMAC2 soap_instantiate_prodml2__IntegerData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:462 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility (92)
/* Type prodml2__Parentfacility is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:Parentfacility': */
class SOAP_CMAC prodml2__Parentfacility : public prodml2__AbstractRefProductFlow {
      public:
        /// Required element 'prodml2:ParentfacilityReference' of XSD type 'eml21:String64'
        std::string ParentfacilityReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__Parentfacility, default initialized and not managed by a soap context
        virtual prodml2__Parentfacility *soap_alloc(void) const { return SOAP_NEW(prodml2__Parentfacility); }
      public:
        /// Constructor with initializations
        prodml2__Parentfacility() : ParentfacilityReference() { }
        virtual ~prodml2__Parentfacility() { }
        /// Friend allocator used by soap_new_prodml2__Parentfacility(struct soap*, int)
        friend SOAP_FMAC1 prodml2__Parentfacility * SOAP_FMAC2 soap_instantiate_prodml2__Parentfacility(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:465 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume (93)
/* Type prodml2__ProductVolume is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:ProductVolume': */
class SOAP_CMAC prodml2__ProductVolume : public eml21__AbstractObject {
      public:
        /// Optional element 'prodml2:Installation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        std::vector<prodml2__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml2:Kind' of XSD type 'eml21:String64'
        std::string *Kind;
        /// Optional element 'prodml2:PeriodKind' of XSD type 'prodml2:ReportingDurationKind'
        enum prodml2__ReportingDurationKind *PeriodKind;
        /// Optional element 'prodml2:DTimMin' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMin;
        /// Optional element 'prodml2:DTimMax' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMax;
        /// Optional element 'prodml2:DTimCurrent' of XSD type 'xsd:dateTime'
        time_t *DTimCurrent;
        /// Optional element 'prodml2:CalculationMethod' of XSD type 'prodml2:CalculationMethod'
        enum prodml2__CalculationMethod *CalculationMethod;
        /// Optional element 'prodml2:Operator' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *Operator;
        /// Optional element 'prodml2:Title' of XSD type 'prodml2:NameStruct'
        prodml2__NameStruct *Title;
        /// Optional element 'prodml2:GeographicContext' of XSD type 'prodml2:GeographicContext'
        prodml2__GeographicContext *GeographicContext;
        /// Optional element 'prodml2:IssueDate' of XSD type 'xsd:date'
        std::string *IssueDate;
        /// Optional element 'prodml2:IssuedBy' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *IssuedBy;
        /// Optional element 'prodml2:ApprovalDate' of XSD type 'xsd:date'
        std::string *ApprovalDate;
        /// Optional element 'prodml2:Approver' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *Approver;
        /// Optional element 'prodml2:StandardTempPres' of XSD type 'eml21:ReferenceCondition'
        enum eml21__ReferenceCondition *StandardTempPres;
        /// Optional element 'prodml2:ProductFlowModel' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *ProductFlowModel;
        /// Optional element 'prodml2:DateTime' of XSD type 'prodml2:AbstractDateTimeClass'
        prodml2__AbstractDateTimeClass *DateTime;
        /// Required element 'prodml2:Facility' of XSD type 'prodml2:ProductVolumeFacility'
        std::vector<prodml2__ProductVolumeFacility *> Facility;
        /// Optional element 'prodml2:BusinessUnit' of XSD type 'prodml2:ProductVolumeBusinessUnit'
        std::vector<prodml2__ProductVolumeBusinessUnit *> BusinessUnit;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductVolume, default initialized and not managed by a soap context
        virtual prodml2__ProductVolume *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductVolume); }
      public:
        /// Constructor with initializations
        prodml2__ProductVolume() : Installation(), ContextFacility(), Kind(), PeriodKind(), DTimMin(), DTimMax(), DTimCurrent(), CalculationMethod(), Operator(), Title(), GeographicContext(), IssueDate(), IssuedBy(), ApprovalDate(), Approver(), StandardTempPres(), ProductFlowModel(), DateTime(), Facility(), BusinessUnit() { }
        virtual ~prodml2__ProductVolume() { }
        /// Friend allocator used by soap_new_prodml2__ProductVolume(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductVolume * SOAP_FMAC2 soap_instantiate_prodml2__ProductVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:26051 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__ReferenceFlow_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__ReferenceFlow_sequence (1570)
/* Wrapper: */
class SOAP_CMAC __prodml2__ReferenceFlow_sequence {
      public:
        /// Required element 'prodml2:FlowReference' of XSD type 'eml21:String64'
        std::string FlowReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__ReferenceFlow_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__ReferenceFlow_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__ReferenceFlow_sequence, default initialized and not managed by a soap context
        virtual __prodml2__ReferenceFlow_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__ReferenceFlow_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__ReferenceFlow_sequence() : FlowReference() { }
        virtual ~__prodml2__ReferenceFlow_sequence() { }
        /// Friend allocator used by soap_new___prodml2__ReferenceFlow_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__ReferenceFlow_sequence * SOAP_FMAC2 soap_instantiate___prodml2__ReferenceFlow_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:516 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow (110)
/* Type prodml2__ReferenceFlow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:ReferenceFlow': */
class SOAP_CMAC prodml2__ReferenceFlow : public prodml2__AbstractRefProductFlow {
      public:
        __prodml2__ReferenceFlow_sequence *__ReferenceFlow_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ReferenceFlow, default initialized and not managed by a soap context
        virtual prodml2__ReferenceFlow *soap_alloc(void) const { return SOAP_NEW(prodml2__ReferenceFlow); }
      public:
        /// Constructor with initializations
        prodml2__ReferenceFlow() : __ReferenceFlow_sequence() { }
        virtual ~prodml2__ReferenceFlow() { }
        /// Friend allocator used by soap_new_prodml2__ReferenceFlow(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ReferenceFlow * SOAP_FMAC2 soap_instantiate_prodml2__ReferenceFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:519 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StringData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StringData (111)
/* Type prodml2__StringData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:StringData': */
class SOAP_CMAC prodml2__StringData : public prodml2__AbstractMeasureDataType {
      public:
        /// Required element 'prodml2:StringValue' of XSD type 'prodml2:KindQualifiedString'
        prodml2__KindQualifiedString *StringValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__StringData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__StringData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__StringData, default initialized and not managed by a soap context
        virtual prodml2__StringData *soap_alloc(void) const { return SOAP_NEW(prodml2__StringData); }
      public:
        /// Constructor with initializations
        prodml2__StringData() : StringValue() { }
        virtual ~prodml2__StringData() { }
        /// Friend allocator used by soap_new_prodml2__StringData(struct soap*, int)
        friend SOAP_FMAC1 prodml2__StringData * SOAP_FMAC2 soap_instantiate_prodml2__StringData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:537 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel (117)
/* Type prodml2__ProductFlowModel is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:ProductFlowModel': */
class SOAP_CMAC prodml2__ProductFlowModel : public eml21__AbstractObject {
      public:
        /// Optional element 'prodml2:Installation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        std::vector<prodml2__FacilityIdentifierStruct *> ContextFacility;
        /// Optional element 'prodml2:DTimStart' of XSD type 'xsd:dateTime'
        time_t *DTimStart;
        /// Optional element 'prodml2:DTimEnd' of XSD type 'xsd:dateTime'
        time_t *DTimEnd;
        /// Optional element 'prodml2:ExistenceTime' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *ExistenceTime;
        /// Optional element 'prodml2:DTimMin' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMin;
        /// Optional element 'prodml2:DTimMax' of XSD type 'prodml2:EndpointQualifiedDateTime'
        prodml2__EndpointQualifiedDateTime *DTimMax;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:ExternalConnect' of XSD type 'prodml2:ProductFlowExternalReference'
        std::vector<prodml2__ProductFlowExternalReference *> ExternalConnect;
        /// Required element 'prodml2:Network' of XSD type 'prodml2:ProductFlowNetwork'
        std::vector<prodml2__ProductFlowNetwork *> Network;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowModel, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowModel *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowModel); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowModel() : Installation(), ContextFacility(), DTimStart(), DTimEnd(), ExistenceTime(), DTimMin(), DTimMax(), Comment(), ExternalConnect(), Network() { }
        virtual ~prodml2__ProductFlowModel() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowModel(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowModel * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:546 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected (120)
/* Type prodml2__ProductFlowQualifierExpected is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:ProductFlowQualifierExpected': */
class SOAP_CMAC prodml2__ProductFlowQualifierExpected : public prodml2__ExpectedFlowQualifier {
      public:
        /// Required element 'prodml2:Flow' of XSD type 'prodml2:ReportingFlow'
        enum prodml2__ReportingFlow Flow;
        /// Optional element 'prodml2:Product' of XSD type 'prodml2:ReportingProduct'
        enum prodml2__ReportingProduct *Product;
        /// Optional element 'prodml2:Qualifier' of XSD type 'prodml2:FlowQualifier'
        std::vector<enum prodml2__FlowQualifier> Qualifier;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__ProductFlowQualifierExpected, default initialized and not managed by a soap context
        virtual prodml2__ProductFlowQualifierExpected *soap_alloc(void) const { return SOAP_NEW(prodml2__ProductFlowQualifierExpected); }
      public:
        /// Constructor with initializations
        prodml2__ProductFlowQualifierExpected() : Flow(), Product(), Qualifier(), uid() { }
        virtual ~prodml2__ProductFlowQualifierExpected() { }
        /// Friend allocator used by soap_new_prodml2__ProductFlowQualifierExpected(struct soap*, int)
        friend SOAP_FMAC1 prodml2__ProductFlowQualifierExpected * SOAP_FMAC2 soap_instantiate_prodml2__ProductFlowQualifierExpected(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:552 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier (122)
/* Type prodml2__Qualifier is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:Qualifier': */
class SOAP_CMAC prodml2__Qualifier : public prodml2__ExpectedFlowQualifier {
      public:
        /// Optional element 'prodml2:Qualifier' of XSD type 'prodml2:FlowQualifier'
        std::vector<enum prodml2__FlowQualifier> Qualifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__Qualifier, default initialized and not managed by a soap context
        virtual prodml2__Qualifier *soap_alloc(void) const { return SOAP_NEW(prodml2__Qualifier); }
      public:
        /// Constructor with initializations
        prodml2__Qualifier() : Qualifier() { }
        virtual ~prodml2__Qualifier() { }
        /// Friend allocator used by soap_new_prodml2__Qualifier(struct soap*, int)
        friend SOAP_FMAC1 prodml2__Qualifier * SOAP_FMAC2 soap_instantiate_prodml2__Qualifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:567 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon (127)
/* Type prodml2__FiberCommon is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberCommon': */
class SOAP_CMAC prodml2__FiberCommon : public prodml2__AbstractDtsEquipment {
      public:
        /// Optional element 'prodml2:Reflectance' of XSD type 'eml21:DimensionlessMeasure'
        eml21__DimensionlessMeasure *Reflectance;
        /// Optional element 'prodml2:Loss' of XSD type 'eml21:DimensionlessMeasure'
        eml21__DimensionlessMeasure *Loss;
        /// Optional element 'prodml2:ReasonForDecommissioning' of XSD type 'eml21:String2000'
        std::string *ReasonForDecommissioning;
        /// required attribute 'uid' of XSD type 'eml21:String64'
        std::string uid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberCommon, default initialized and not managed by a soap context
        virtual prodml2__FiberCommon *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberCommon); }
      public:
        /// Constructor with initializations
        prodml2__FiberCommon() : Reflectance(), Loss(), ReasonForDecommissioning(), uid() { }
        virtual ~prodml2__FiberCommon() { }
        /// Friend allocator used by soap_new_prodml2__FiberCommon(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberCommon * SOAP_FMAC2 soap_instantiate_prodml2__FiberCommon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:573 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine (129)
/* Type prodml2__FiberControlLine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberControlLine': */
class SOAP_CMAC prodml2__FiberControlLine : public prodml2__AbstractCable {
      public:
        /// Required element 'prodml2:Size' of XSD type 'prodml2:ControlLineSize'
        enum prodml2__ControlLineSize Size;
        /// Required element 'prodml2:Material' of XSD type 'prodml2:ControlLineMaterial'
        enum prodml2__ControlLineMaterial Material;
        /// Required element 'prodml2:EncapsulationType' of XSD type 'prodml2:ControlLineEncapsulationType'
        enum prodml2__ControlLineEncapsulationType EncapsulationType;
        /// Required element 'prodml2:EncapsulationSize' of XSD type 'prodml2:ControlLineEncapsulationSize'
        enum prodml2__ControlLineEncapsulationSize EncapsulationSize;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
        /// Optional element 'prodml2:PumpActivity' of XSD type 'prodml2:FiberPumpActivity'
        std::vector<prodml2__FiberPumpActivity *> PumpActivity;
        /// required attribute 'downholeControlLineReference' of XSD type 'eml21:String64'
        std::string downholeControlLineReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberControlLine, default initialized and not managed by a soap context
        virtual prodml2__FiberControlLine *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberControlLine); }
      public:
        /// Constructor with initializations
        prodml2__FiberControlLine() : Size(), Material(), EncapsulationType(), EncapsulationSize(), Comment(), PumpActivity(), downholeControlLineReference() { }
        virtual ~prodml2__FiberControlLine() { }
        /// Friend allocator used by soap_new_prodml2__FiberControlLine(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberControlLine * SOAP_FMAC2 soap_instantiate_prodml2__FiberControlLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:579 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric (131)
/* Type prodml2__FiberFacilityGeneric is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberFacilityGeneric': */
class SOAP_CMAC prodml2__FiberFacilityGeneric : public prodml2__AbstractFiberFacility {
      public:
        /// Required element 'prodml2:FacilityName' of XSD type 'eml21:String64'
        std::string FacilityName;
        /// Required element 'prodml2:FacilityKind' of XSD type 'eml21:String64'
        std::string FacilityKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberFacilityGeneric, default initialized and not managed by a soap context
        virtual prodml2__FiberFacilityGeneric *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberFacilityGeneric); }
      public:
        /// Constructor with initializations
        prodml2__FiberFacilityGeneric() : FacilityName(), FacilityKind() { }
        virtual ~prodml2__FiberFacilityGeneric() { }
        /// Friend allocator used by soap_new_prodml2__FiberFacilityGeneric(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberFacilityGeneric * SOAP_FMAC2 soap_instantiate_prodml2__FiberFacilityGeneric(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:588 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline (134)
/* Type prodml2__FiberFacilityPipeline is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberFacilityPipeline': */
class SOAP_CMAC prodml2__FiberFacilityPipeline : public prodml2__AbstractFiberFacility {
      public:
        /// Required element 'prodml2:Name' of XSD type 'prodml2:NameStruct'
        prodml2__NameStruct *Name;
        /// Optional element 'prodml2:DatumPortReference' of XSD type 'eml21:String64'
        std::string *DatumPortReference;
        /// Optional element 'prodml2:Installation' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *Installation;
        /// Optional element 'prodml2:Kind' of XSD type 'eml21:String64'
        std::string *Kind;
        /// Optional element 'prodml2:ContextFacility' of XSD type 'prodml2:FacilityIdentifierStruct'
        prodml2__FacilityIdentifierStruct *ContextFacility;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberFacilityPipeline, default initialized and not managed by a soap context
        virtual prodml2__FiberFacilityPipeline *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberFacilityPipeline); }
      public:
        /// Constructor with initializations
        prodml2__FiberFacilityPipeline() : Name(), DatumPortReference(), Installation(), Kind(), ContextFacility() { }
        virtual ~prodml2__FiberFacilityPipeline() { }
        /// Friend allocator used by soap_new_prodml2__FiberFacilityPipeline(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberFacilityPipeline * SOAP_FMAC2 soap_instantiate_prodml2__FiberFacilityPipeline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:591 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell (135)
/* Type prodml2__FiberFacilityWell is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberFacilityWell': */
class SOAP_CMAC prodml2__FiberFacilityWell : public prodml2__AbstractFiberFacility {
      public:
        /// Required element 'prodml2:Name' of XSD type 'eml21:String64'
        std::string Name;
        /// Optional element 'prodml2:WellDatum' of XSD type 'eml21:WellboreDatumReference'
        enum eml21__WellboreDatumReference *WellDatum;
        /// Required element 'prodml2:WellboreReference' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *WellboreReference;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberFacilityWell, default initialized and not managed by a soap context
        virtual prodml2__FiberFacilityWell *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberFacilityWell); }
      public:
        /// Constructor with initializations
        prodml2__FiberFacilityWell() : Name(), WellDatum(), WellboreReference() { }
        virtual ~prodml2__FiberFacilityWell() { }
        /// Friend allocator used by soap_new_prodml2__FiberFacilityWell(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberFacilityWell * SOAP_FMAC2 soap_instantiate_prodml2__FiberFacilityWell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:597 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath (137)
/* Type prodml2__FiberOpticalPath is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberOpticalPath': */
class SOAP_CMAC prodml2__FiberOpticalPath : public eml21__AbstractObject {
      public:
        /// Required element 'prodml2:Inventory' of XSD type 'prodml2:FiberOpticalPathInventory'
        prodml2__FiberOpticalPathInventory *Inventory;
        /// Optional element 'prodml2:OpticalPathNetwork' of XSD type 'prodml2:FiberOpticalPathNetwork'
        std::vector<prodml2__FiberOpticalPathNetwork *> OpticalPathNetwork;
        /// Optional element 'prodml2:FacilityMapping' of XSD type 'prodml2:FiberFacilityMapping'
        std::vector<prodml2__FiberFacilityMapping *> FacilityMapping;
        /// Optional element 'prodml2:Defect' of XSD type 'prodml2:FiberPathDefect'
        std::vector<prodml2__FiberPathDefect *> Defect;
        /// Optional element 'prodml2:Otdr' of XSD type 'prodml2:FiberOTDR'
        std::vector<prodml2__FiberOTDR *> Otdr;
        /// Optional element 'prodml2:InstallingVendor' of XSD type 'prodml2:BusinessAssociate'
        prodml2__BusinessAssociate *InstallingVendor;
        /// Optional element 'prodml2:FacilityIdentifier' of XSD type 'prodml2:FacilityIdentifier'
        prodml2__FacilityIdentifier *FacilityIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOpticalPath, default initialized and not managed by a soap context
        virtual prodml2__FiberOpticalPath *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOpticalPath); }
      public:
        /// Constructor with initializations
        prodml2__FiberOpticalPath() : Inventory(), OpticalPathNetwork(), FacilityMapping(), Defect(), Otdr(), InstallingVendor(), FacilityIdentifier() { }
        virtual ~prodml2__FiberOpticalPath() { }
        /// Friend allocator used by soap_new_prodml2__FiberOpticalPath(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOpticalPath * SOAP_FMAC2 soap_instantiate_prodml2__FiberOpticalPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:633 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency (149)
/* Type prodml2__Frequency is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:Frequency': */
class SOAP_CMAC prodml2__Frequency : public prodml2__AbstractAttenuationMeasure {
      public:
        /// Required element 'prodml2:Frequency' of XSD type 'eml21:FrequencyMeasure'
        eml21__FrequencyMeasure *Frequency;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__Frequency, default initialized and not managed by a soap context
        virtual prodml2__Frequency *soap_alloc(void) const { return SOAP_NEW(prodml2__Frequency); }
      public:
        /// Constructor with initializations
        prodml2__Frequency() : Frequency() { }
        virtual ~prodml2__Frequency() { }
        /// Friend allocator used by soap_new_prodml2__Frequency(struct soap*, int)
        friend SOAP_FMAC1 prodml2__Frequency * SOAP_FMAC2 soap_instantiate_prodml2__Frequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:636 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance
#define SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance (150)
/* Type prodml2__InterventionConveyance is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:InterventionConveyance': */
class SOAP_CMAC prodml2__InterventionConveyance : public prodml2__AbstractCable {
      public:
        /// Required element 'prodml2:InterventionConveyanceType' of XSD type 'prodml2:InterventionConveyanceType'
        enum prodml2__InterventionConveyanceType InterventionConveyanceType;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__InterventionConveyance, default initialized and not managed by a soap context
        virtual prodml2__InterventionConveyance *soap_alloc(void) const { return SOAP_NEW(prodml2__InterventionConveyance); }
      public:
        /// Constructor with initializations
        prodml2__InterventionConveyance() : InterventionConveyanceType(), Comment() { }
        virtual ~prodml2__InterventionConveyance() { }
        /// Friend allocator used by soap_new_prodml2__InterventionConveyance(struct soap*, int)
        friend SOAP_FMAC1 prodml2__InterventionConveyance * SOAP_FMAC2 soap_instantiate_prodml2__InterventionConveyance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:639 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable (151)
/* Type prodml2__PermanentCable is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:PermanentCable': */
class SOAP_CMAC prodml2__PermanentCable : public prodml2__AbstractCable {
      public:
        /// Required element 'prodml2:PermanentCableInstallationType' of XSD type 'prodml2:PermanentCableInstallationType'
        enum prodml2__PermanentCableInstallationType PermanentCableInstallationType;
        /// Optional element 'prodml2:Comment' of XSD type 'eml21:String2000'
        std::string *Comment;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__PermanentCable, default initialized and not managed by a soap context
        virtual prodml2__PermanentCable *soap_alloc(void) const { return SOAP_NEW(prodml2__PermanentCable); }
      public:
        /// Constructor with initializations
        prodml2__PermanentCable() : PermanentCableInstallationType(), Comment() { }
        virtual ~prodml2__PermanentCable() { }
        /// Friend allocator used by soap_new_prodml2__PermanentCable(struct soap*, int)
        friend SOAP_FMAC1 prodml2__PermanentCable * SOAP_FMAC2 soap_instantiate_prodml2__PermanentCable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:642 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength (152)
/* Type prodml2__WaveLength is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:WaveLength': */
class SOAP_CMAC prodml2__WaveLength : public prodml2__AbstractAttenuationMeasure {
      public:
        /// Required element 'prodml2:WaveLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *WaveLength;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__WaveLength, default initialized and not managed by a soap context
        virtual prodml2__WaveLength *soap_alloc(void) const { return SOAP_NEW(prodml2__WaveLength); }
      public:
        /// Constructor with initializations
        prodml2__WaveLength() : WaveLength() { }
        virtual ~prodml2__WaveLength() { }
        /// Friend allocator used by soap_new_prodml2__WaveLength(struct soap*, int)
        friend SOAP_FMAC1 prodml2__WaveLength * SOAP_FMAC2 soap_instantiate_prodml2__WaveLength(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:660 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray (158)
/* Type eml21__AbstractBooleanArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractBooleanArray': */
class SOAP_CMAC eml21__AbstractBooleanArray : public eml21__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractBooleanArray, default initialized and not managed by a soap context
        virtual eml21__AbstractBooleanArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractBooleanArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractBooleanArray() { }
        virtual ~eml21__AbstractBooleanArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractBooleanArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractBooleanArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractBooleanArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:669 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray (161)
/* Type eml21__AbstractNumericArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractNumericArray': */
class SOAP_CMAC eml21__AbstractNumericArray : public eml21__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractNumericArray, default initialized and not managed by a soap context
        virtual eml21__AbstractNumericArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractNumericArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractNumericArray() { }
        virtual ~eml21__AbstractNumericArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractNumericArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractNumericArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractNumericArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:672 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray (162)
/* Type eml21__AbstractStringArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractStringArray': */
class SOAP_CMAC eml21__AbstractStringArray : public eml21__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractStringArray, default initialized and not managed by a soap context
        virtual eml21__AbstractStringArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractStringArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractStringArray() { }
        virtual ~eml21__AbstractStringArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractStringArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractStringArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractStringArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1845 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference (553)
/* Type eml21__EpcExternalPartReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:EpcExternalPartReference': */
class SOAP_CMAC eml21__EpcExternalPartReference : public eml21__AbstractObject {
      public:
        /// Optional element 'eml21:Filename' of XSD type 'eml21:String2000'
        std::string *Filename;
        /// Optional element 'eml21:MimeType' of XSD type 'eml21:String2000'
        std::string *MimeType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EpcExternalPartReference, default initialized and not managed by a soap context
        virtual eml21__EpcExternalPartReference *soap_alloc(void) const { return SOAP_NEW(eml21__EpcExternalPartReference); }
      public:
        /// Constructor with initializations
        eml21__EpcExternalPartReference() : Filename(), MimeType() { }
        virtual ~eml21__EpcExternalPartReference() { }
        /// Friend allocator used by soap_new_eml21__EpcExternalPartReference(struct soap*, int)
        friend SOAP_FMAC1 eml21__EpcExternalPartReference * SOAP_FMAC2 soap_instantiate_eml21__EpcExternalPartReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1860 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__Activity
#define SOAP_TYPE_gsoap_eml2_1_eml21__Activity (558)
/* Type eml21__Activity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:Activity': */
class SOAP_CMAC eml21__Activity : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:ActivityDescriptor' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *ActivityDescriptor;
        /// Optional element 'eml21:Parent' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *Parent;
        /// Required element 'eml21:Parameter' of XSD type 'eml21:AbstractActivityParameter'
        std::vector<eml21__AbstractActivityParameter *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__Activity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__Activity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__Activity, default initialized and not managed by a soap context
        virtual eml21__Activity *soap_alloc(void) const { return SOAP_NEW(eml21__Activity); }
      public:
        /// Constructor with initializations
        eml21__Activity() : ActivityDescriptor(), Parent(), Parameter() { }
        virtual ~eml21__Activity() { }
        /// Friend allocator used by soap_new_eml21__Activity(struct soap*, int)
        friend SOAP_FMAC1 eml21__Activity * SOAP_FMAC2 soap_instantiate_eml21__Activity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1863 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate (559)
/* Type eml21__ActivityTemplate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ActivityTemplate': */
class SOAP_CMAC eml21__ActivityTemplate : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:Parameter' of XSD type 'eml21:ParameterTemplate'
        std::vector<eml21__ParameterTemplate *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ActivityTemplate, default initialized and not managed by a soap context
        virtual eml21__ActivityTemplate *soap_alloc(void) const { return SOAP_NEW(eml21__ActivityTemplate); }
      public:
        /// Constructor with initializations
        eml21__ActivityTemplate() : Parameter() { }
        virtual ~eml21__ActivityTemplate() { }
        /// Friend allocator used by soap_new_eml21__ActivityTemplate(struct soap*, int)
        friend SOAP_FMAC1 eml21__ActivityTemplate * SOAP_FMAC2 soap_instantiate_eml21__ActivityTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1866 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter (560)
/* Type eml21__DataObjectParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:DataObjectParameter': */
class SOAP_CMAC eml21__DataObjectParameter : public eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:DataObject' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DataObjectParameter, default initialized and not managed by a soap context
        virtual eml21__DataObjectParameter *soap_alloc(void) const { return SOAP_NEW(eml21__DataObjectParameter); }
      public:
        /// Constructor with initializations
        eml21__DataObjectParameter() : DataObject() { }
        virtual ~eml21__DataObjectParameter() { }
        /// Friend allocator used by soap_new_eml21__DataObjectParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__DataObjectParameter * SOAP_FMAC2 soap_instantiate_eml21__DataObjectParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1869 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter (561)
/* Type eml21__DoubleQuantityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:DoubleQuantityParameter': */
class SOAP_CMAC eml21__DoubleQuantityParameter : public eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:Value' of XSD type 'xsd:double'
        double Value;
        /// Required element 'eml21:Uom' of XSD type 'eml21:UnitOfMeasureExt'
        std::string Uom;
        /// Optional element 'eml21:CustomUnitDictionary' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *CustomUnitDictionary;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DoubleQuantityParameter, default initialized and not managed by a soap context
        virtual eml21__DoubleQuantityParameter *soap_alloc(void) const { return SOAP_NEW(eml21__DoubleQuantityParameter); }
      public:
        /// Constructor with initializations
        eml21__DoubleQuantityParameter() : Value(), Uom(), CustomUnitDictionary() { }
        virtual ~eml21__DoubleQuantityParameter() { }
        /// Friend allocator used by soap_new_eml21__DoubleQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__DoubleQuantityParameter * SOAP_FMAC2 soap_instantiate_eml21__DoubleQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1872 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter (562)
/* Type eml21__IntegerQuantityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerQuantityParameter': */
class SOAP_CMAC eml21__IntegerQuantityParameter : public eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:Value' of XSD type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerQuantityParameter, default initialized and not managed by a soap context
        virtual eml21__IntegerQuantityParameter *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerQuantityParameter); }
      public:
        /// Constructor with initializations
        eml21__IntegerQuantityParameter() : Value() { }
        virtual ~eml21__IntegerQuantityParameter() { }
        /// Friend allocator used by soap_new_eml21__IntegerQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerQuantityParameter * SOAP_FMAC2 soap_instantiate_eml21__IntegerQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1875 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey (563)
/* Type eml21__ObjectParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ObjectParameterKey': */
class SOAP_CMAC eml21__ObjectParameterKey : public eml21__AbstractParameterKey {
      public:
        /// Required element 'eml21:DataObject' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ObjectParameterKey, default initialized and not managed by a soap context
        virtual eml21__ObjectParameterKey *soap_alloc(void) const { return SOAP_NEW(eml21__ObjectParameterKey); }
      public:
        /// Constructor with initializations
        eml21__ObjectParameterKey() : DataObject() { }
        virtual ~eml21__ObjectParameterKey() { }
        /// Friend allocator used by soap_new_eml21__ObjectParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml21__ObjectParameterKey * SOAP_FMAC2 soap_instantiate_eml21__ObjectParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1881 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter (565)
/* Type eml21__StringParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:StringParameter': */
class SOAP_CMAC eml21__StringParameter : public eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:Value' of XSD type 'eml21:String2000'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__StringParameter, default initialized and not managed by a soap context
        virtual eml21__StringParameter *soap_alloc(void) const { return SOAP_NEW(eml21__StringParameter); }
      public:
        /// Constructor with initializations
        eml21__StringParameter() : Value() { }
        virtual ~eml21__StringParameter() { }
        /// Friend allocator used by soap_new_eml21__StringParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__StringParameter * SOAP_FMAC2 soap_instantiate_eml21__StringParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1884 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter (566)
/* Type eml21__TimeIndexParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:TimeIndexParameter': */
class SOAP_CMAC eml21__TimeIndexParameter : public eml21__AbstractActivityParameter {
      public:
        /// Required element 'eml21:TimeIndex' of XSD type 'eml21:TimeIndex'
        eml21__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeIndexParameter, default initialized and not managed by a soap context
        virtual eml21__TimeIndexParameter *soap_alloc(void) const { return SOAP_NEW(eml21__TimeIndexParameter); }
      public:
        /// Constructor with initializations
        eml21__TimeIndexParameter() : TimeIndex() { }
        virtual ~eml21__TimeIndexParameter() { }
        /// Friend allocator used by soap_new_eml21__TimeIndexParameter(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeIndexParameter * SOAP_FMAC2 soap_instantiate_eml21__TimeIndexParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1887 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey (567)
/* Type eml21__TimeIndexParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:TimeIndexParameterKey': */
class SOAP_CMAC eml21__TimeIndexParameterKey : public eml21__AbstractParameterKey {
      public:
        /// Required element 'eml21:TimeIndex' of XSD type 'eml21:TimeIndex'
        eml21__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeIndexParameterKey, default initialized and not managed by a soap context
        virtual eml21__TimeIndexParameterKey *soap_alloc(void) const { return SOAP_NEW(eml21__TimeIndexParameterKey); }
      public:
        /// Constructor with initializations
        eml21__TimeIndexParameterKey() : TimeIndex() { }
        virtual ~eml21__TimeIndexParameterKey() { }
        /// Friend allocator used by soap_new_eml21__TimeIndexParameterKey(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeIndexParameterKey * SOAP_FMAC2 soap_instantiate_eml21__TimeIndexParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1893 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind (569)
/* Type eml21__PropertyKind is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:PropertyKind': */
class SOAP_CMAC eml21__PropertyKind : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:IsAbstract' of XSD type 'xsd:boolean'
        bool IsAbstract;
        /// Optional element 'eml21:DeprecationDate' of XSD type 'eml21:TimeStamp'
        std::string *DeprecationDate;
        /// Required element 'eml21:QuantityClass' of XSD type 'eml21:QuantityClassKindExt'
        std::string QuantityClass;
        /// Optional element 'eml21:Parent' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *Parent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PropertyKind, default initialized and not managed by a soap context
        virtual eml21__PropertyKind *soap_alloc(void) const { return SOAP_NEW(eml21__PropertyKind); }
      public:
        /// Constructor with initializations
        eml21__PropertyKind() : IsAbstract(), DeprecationDate(), QuantityClass(), Parent() { }
        virtual ~eml21__PropertyKind() { }
        /// Friend allocator used by soap_new_eml21__PropertyKind(struct soap*, int)
        friend SOAP_FMAC1 eml21__PropertyKind * SOAP_FMAC2 soap_instantiate_eml21__PropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1896 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary (570)
/* Type eml21__PropertyKindDictionary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:PropertyKindDictionary': */
class SOAP_CMAC eml21__PropertyKindDictionary : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:PropertyKind' of XSD type 'eml21:PropertyKind'
        std::vector<eml21__PropertyKind *> PropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PropertyKindDictionary, default initialized and not managed by a soap context
        virtual eml21__PropertyKindDictionary *soap_alloc(void) const { return SOAP_NEW(eml21__PropertyKindDictionary); }
      public:
        /// Constructor with initializations
        eml21__PropertyKindDictionary() : PropertyKind() { }
        virtual ~eml21__PropertyKindDictionary() { }
        /// Friend allocator used by soap_new_eml21__PropertyKindDictionary(struct soap*, int)
        friend SOAP_FMAC1 eml21__PropertyKindDictionary * SOAP_FMAC2 soap_instantiate_eml21__PropertyKindDictionary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1905 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries (573)
/* Type eml21__TimeSeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:TimeSeries': */
class SOAP_CMAC eml21__TimeSeries : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:Time' of XSD type 'eml21:GeologicTime'
        std::vector<eml21__GeologicTime *> Time;
        /// Optional element 'eml21:TimeSeriesParentage' of XSD type 'eml21:TimeSeriesParentage'
        eml21__TimeSeriesParentage *TimeSeriesParentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeSeries, default initialized and not managed by a soap context
        virtual eml21__TimeSeries *soap_alloc(void) const { return SOAP_NEW(eml21__TimeSeries); }
      public:
        /// Constructor with initializations
        eml21__TimeSeries() : Time(), TimeSeriesParentage() { }
        virtual ~eml21__TimeSeries() { }
        /// Friend allocator used by soap_new_eml21__TimeSeries(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeSeries * SOAP_FMAC2 soap_instantiate_eml21__TimeSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1911 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure (575)
/* Type eml21__AbsolutePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbsolutePressure': */
class SOAP_CMAC eml21__AbsolutePressure : public eml21__AbstractPressureValue {
      public:
        /// Required element 'eml21:AbsolutePressure' of XSD type 'eml21:PressureMeasureExt'
        eml21__PressureMeasureExt *AbsolutePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbsolutePressure, default initialized and not managed by a soap context
        virtual eml21__AbsolutePressure *soap_alloc(void) const { return SOAP_NEW(eml21__AbsolutePressure); }
      public:
        /// Constructor with initializations
        eml21__AbsolutePressure() : AbsolutePressure() { }
        virtual ~eml21__AbsolutePressure() { }
        /// Friend allocator used by soap_new_eml21__AbsolutePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbsolutePressure * SOAP_FMAC2 soap_instantiate_eml21__AbsolutePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1926 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure (580)
/* Type eml21__GaugePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GaugePressure': */
class SOAP_CMAC eml21__GaugePressure : public eml21__AbstractPressureValue {
      public:
        /// Required element 'eml21:GaugePressure' of XSD type 'eml21:PressureMeasureExt'
        eml21__PressureMeasureExt *GaugePressure;
        /// Optional element 'eml21:ReferencePressure' of XSD type 'eml21:ReferencePressure'
        eml21__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GaugePressure, default initialized and not managed by a soap context
        virtual eml21__GaugePressure *soap_alloc(void) const { return SOAP_NEW(eml21__GaugePressure); }
      public:
        /// Constructor with initializations
        eml21__GaugePressure() : GaugePressure(), ReferencePressure() { }
        virtual ~eml21__GaugePressure() { }
        /// Friend allocator used by soap_new_eml21__GaugePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__GaugePressure * SOAP_FMAC2 soap_instantiate_eml21__GaugePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:27376 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__union_ReferenceTemperaturePressure_
#define SOAP_TYPE_gsoap_eml2_1__eml21__union_ReferenceTemperaturePressure_ (1595)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _eml21__union_ReferenceTemperaturePressure_
{
        #define SOAP_UNION_gsoap_eml2_1__eml21__union_ReferenceTemperaturePressure__ReferenceTempPres	(1)	/**< union variant selector value for member ReferenceTempPres */
        std::string *ReferenceTempPres;
};
#endif

/* eml2_1ForGsoap.h:1935 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure (583)
/* Type eml21__ReferenceTemperaturePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ReferenceTemperaturePressure': */
class SOAP_CMAC eml21__ReferenceTemperaturePressure : public eml21__AbstractTemperaturePressure {
      public:
        /// Union with union _eml21__union_ReferenceTemperaturePressure_ variant selector __union_ReferenceTemperaturePressure_ set to one of: SOAP_UNION_gsoap_eml2_1__eml21__union_ReferenceTemperaturePressure__ReferenceTempPres
        int __union_ReferenceTemperaturePressure_;
        union _eml21__union_ReferenceTemperaturePressure_ union_ReferenceTemperaturePressure_;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReferenceTemperaturePressure, default initialized and not managed by a soap context
        virtual eml21__ReferenceTemperaturePressure *soap_alloc(void) const { return SOAP_NEW(eml21__ReferenceTemperaturePressure); }
      public:
        /// Constructor with initializations
        eml21__ReferenceTemperaturePressure() : __union_ReferenceTemperaturePressure_() { }
        virtual ~eml21__ReferenceTemperaturePressure() { }
        /// Friend allocator used by soap_new_eml21__ReferenceTemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReferenceTemperaturePressure * SOAP_FMAC2 soap_instantiate_eml21__ReferenceTemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1938 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure (584)
/* Type eml21__RelativePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:RelativePressure': */
class SOAP_CMAC eml21__RelativePressure : public eml21__AbstractPressureValue {
      public:
        /// Required element 'eml21:RelativePressure' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *RelativePressure;
        /// Required element 'eml21:ReferencePressure' of XSD type 'eml21:ReferencePressure'
        eml21__ReferencePressure *ReferencePressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__RelativePressure, default initialized and not managed by a soap context
        virtual eml21__RelativePressure *soap_alloc(void) const { return SOAP_NEW(eml21__RelativePressure); }
      public:
        /// Constructor with initializations
        eml21__RelativePressure() : RelativePressure(), ReferencePressure() { }
        virtual ~eml21__RelativePressure() { }
        /// Friend allocator used by soap_new_eml21__RelativePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__RelativePressure * SOAP_FMAC2 soap_instantiate_eml21__RelativePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1941 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure (585)
/* Type eml21__TemperaturePressure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:TemperaturePressure': */
class SOAP_CMAC eml21__TemperaturePressure : public eml21__AbstractTemperaturePressure {
      public:
        /// Required element 'eml21:Temperature' of XSD type 'eml21:ThermodynamicTemperatureMeasure'
        eml21__ThermodynamicTemperatureMeasure *Temperature;
        /// Required element 'eml21:Pressure' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *Pressure;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperaturePressure, default initialized and not managed by a soap context
        virtual eml21__TemperaturePressure *soap_alloc(void) const { return SOAP_NEW(eml21__TemperaturePressure); }
      public:
        /// Constructor with initializations
        eml21__TemperaturePressure() : Temperature(), Pressure() { }
        virtual ~eml21__TemperaturePressure() { }
        /// Friend allocator used by soap_new_eml21__TemperaturePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperaturePressure * SOAP_FMAC2 soap_instantiate_eml21__TemperaturePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1956 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs (590)
/* Type eml21__GeodeticCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticCrs': */
class SOAP_CMAC eml21__GeodeticCrs : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:AbstractGeodeticCrs' of XSD type 'eml21:AbstractGeodeticCrs'
        eml21__AbstractGeodeticCrs *AbstractGeodeticCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticCrs() : AbstractGeodeticCrs() { }
        virtual ~eml21__GeodeticCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1959 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs (591)
/* Type eml21__GeodeticEpsgCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticEpsgCrs': */
class SOAP_CMAC eml21__GeodeticEpsgCrs : public eml21__AbstractGeodeticCrs {
      public:
        /// Required element 'eml21:EpsgCode' of XSD type 'xsd:unsignedLong'
        ULONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticEpsgCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticEpsgCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticEpsgCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticEpsgCrs() : EpsgCode() { }
        virtual ~eml21__GeodeticEpsgCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticEpsgCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1962 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs (592)
/* Type eml21__GeodeticGmlCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticGmlCrs': */
class SOAP_CMAC eml21__GeodeticGmlCrs : public eml21__AbstractGeodeticCrs {
      public:
        /// Required element 'eml21:GmlProjectedCrsDefinition' of XSD type 'gml:GeodeticCRSType'
        gml__GeodeticCRSType *GmlProjectedCrsDefinition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticGmlCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticGmlCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticGmlCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticGmlCrs() : GmlProjectedCrsDefinition() { }
        virtual ~eml21__GeodeticGmlCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticGmlCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticGmlCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticGmlCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1965 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs (593)
/* Type eml21__GeodeticLocalAuthorityCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticLocalAuthorityCrs': */
class SOAP_CMAC eml21__GeodeticLocalAuthorityCrs : public eml21__AbstractGeodeticCrs {
      public:
        /// Required element 'eml21:LocalAuthorityCrsName' of XSD type 'eml21:AuthorityQualifiedName'
        eml21__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticLocalAuthorityCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml21__GeodeticLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1968 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs (594)
/* Type eml21__GeodeticUnknownCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticUnknownCrs': */
class SOAP_CMAC eml21__GeodeticUnknownCrs : public eml21__AbstractGeodeticCrs {
      public:
        /// Required element 'eml21:Unknown' of XSD type 'eml21:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticUnknownCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticUnknownCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticUnknownCrs() : Unknown() { }
        virtual ~eml21__GeodeticUnknownCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticUnknownCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1971 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs (595)
/* Type eml21__GeodeticWktCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GeodeticWktCrs': */
class SOAP_CMAC eml21__GeodeticWktCrs : public eml21__AbstractGeodeticCrs {
      public:
        /// Required element 'eml21:WellKnownText' of XSD type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GeodeticWktCrs, default initialized and not managed by a soap context
        virtual eml21__GeodeticWktCrs *soap_alloc(void) const { return SOAP_NEW(eml21__GeodeticWktCrs); }
      public:
        /// Constructor with initializations
        eml21__GeodeticWktCrs() : WellKnownText() { }
        virtual ~eml21__GeodeticWktCrs() { }
        /// Friend allocator used by soap_new_eml21__GeodeticWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__GeodeticWktCrs * SOAP_FMAC2 soap_instantiate_eml21__GeodeticWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1974 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs (596)
/* Type eml21__ProjectedCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedCrs': */
class SOAP_CMAC eml21__ProjectedCrs : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:AxisOrder' of XSD type 'eml21:AxisOrder2d'
        enum eml21__AxisOrder2d AxisOrder;
        /// Required element 'eml21:AbstractProjectedCrs' of XSD type 'eml21:AbstractProjectedCrs'
        eml21__AbstractProjectedCrs *AbstractProjectedCrs;
        /// optional attribute 'uom' of XSD type 'eml21:LengthUomExt'
        std::string *uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedCrs() : AxisOrder(), AbstractProjectedCrs(), uom() { }
        virtual ~eml21__ProjectedCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1977 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs (597)
/* Type eml21__ProjectedEpsgCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedEpsgCrs': */
class SOAP_CMAC eml21__ProjectedEpsgCrs : public eml21__AbstractProjectedCrs {
      public:
        /// Required element 'eml21:EpsgCode' of XSD type 'xsd:unsignedLong'
        ULONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedEpsgCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedEpsgCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedEpsgCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedEpsgCrs() : EpsgCode() { }
        virtual ~eml21__ProjectedEpsgCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedEpsgCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1980 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs (598)
/* Type eml21__ProjectedGmlCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedGmlCrs': */
class SOAP_CMAC eml21__ProjectedGmlCrs : public eml21__AbstractProjectedCrs {
      public:
        /// Required element 'eml21:GmlProjectedCrsDefinition' of XSD type 'gml:ProjectedCRSType'
        gml__ProjectedCRSType *GmlProjectedCrsDefinition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedGmlCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedGmlCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedGmlCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedGmlCrs() : GmlProjectedCrsDefinition() { }
        virtual ~eml21__ProjectedGmlCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedGmlCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedGmlCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedGmlCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1983 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs (599)
/* Type eml21__ProjectedLocalAuthorityCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedLocalAuthorityCrs': */
class SOAP_CMAC eml21__ProjectedLocalAuthorityCrs : public eml21__AbstractProjectedCrs {
      public:
        /// Required element 'eml21:LocalAuthorityCrsName' of XSD type 'eml21:AuthorityQualifiedName'
        eml21__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedLocalAuthorityCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml21__ProjectedLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1986 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs (600)
/* Type eml21__ProjectedUnknownCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedUnknownCrs': */
class SOAP_CMAC eml21__ProjectedUnknownCrs : public eml21__AbstractProjectedCrs {
      public:
        /// Required element 'eml21:Unknown' of XSD type 'eml21:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedUnknownCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedUnknownCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedUnknownCrs() : Unknown() { }
        virtual ~eml21__ProjectedUnknownCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedUnknownCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1989 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs (601)
/* Type eml21__ProjectedWktCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:ProjectedWktCrs': */
class SOAP_CMAC eml21__ProjectedWktCrs : public eml21__AbstractProjectedCrs {
      public:
        /// Required element 'eml21:WellKnownText' of XSD type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ProjectedWktCrs, default initialized and not managed by a soap context
        virtual eml21__ProjectedWktCrs *soap_alloc(void) const { return SOAP_NEW(eml21__ProjectedWktCrs); }
      public:
        /// Constructor with initializations
        eml21__ProjectedWktCrs() : WellKnownText() { }
        virtual ~eml21__ProjectedWktCrs() { }
        /// Friend allocator used by soap_new_eml21__ProjectedWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__ProjectedWktCrs * SOAP_FMAC2 soap_instantiate_eml21__ProjectedWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1992 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs (602)
/* Type eml21__VerticalCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalCrs': */
class SOAP_CMAC eml21__VerticalCrs : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:Direction' of XSD type 'eml21:VerticalDirection'
        enum eml21__VerticalDirection Direction;
        /// Required element 'eml21:AbstractVerticalCrs' of XSD type 'eml21:AbstractVerticalCrs'
        eml21__AbstractVerticalCrs *AbstractVerticalCrs;
        /// required attribute 'uom' of XSD type 'eml21:LengthUomExt'
        std::string uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalCrs() : Direction(), AbstractVerticalCrs(), uom() { }
        virtual ~eml21__VerticalCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1995 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs (603)
/* Type eml21__VerticalEpsgCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalEpsgCrs': */
class SOAP_CMAC eml21__VerticalEpsgCrs : public eml21__AbstractVerticalCrs {
      public:
        /// Required element 'eml21:EpsgCode' of XSD type 'xsd:unsignedLong'
        ULONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalEpsgCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalEpsgCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalEpsgCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalEpsgCrs() : EpsgCode() { }
        virtual ~eml21__VerticalEpsgCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalEpsgCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalEpsgCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalEpsgCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1998 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs (604)
/* Type eml21__VerticalGmlCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalGmlCrs': */
class SOAP_CMAC eml21__VerticalGmlCrs : public eml21__AbstractVerticalCrs {
      public:
        /// Required element 'eml21:GmlVerticalCrsDefinition' of XSD type 'gml:VerticalCRSType'
        gml__VerticalCRSType *GmlVerticalCrsDefinition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalGmlCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalGmlCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalGmlCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalGmlCrs() : GmlVerticalCrsDefinition() { }
        virtual ~eml21__VerticalGmlCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalGmlCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalGmlCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalGmlCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2001 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs (605)
/* Type eml21__VerticalLocalAuthorityCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalLocalAuthorityCrs': */
class SOAP_CMAC eml21__VerticalLocalAuthorityCrs : public eml21__AbstractVerticalCrs {
      public:
        /// Required element 'eml21:LocalAuthorityCrsName' of XSD type 'eml21:AuthorityQualifiedName'
        eml21__AuthorityQualifiedName *LocalAuthorityCrsName;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalLocalAuthorityCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalLocalAuthorityCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalLocalAuthorityCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalLocalAuthorityCrs() : LocalAuthorityCrsName() { }
        virtual ~eml21__VerticalLocalAuthorityCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalLocalAuthorityCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalLocalAuthorityCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalLocalAuthorityCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2004 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs (606)
/* Type eml21__VerticalUnknownCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalUnknownCrs': */
class SOAP_CMAC eml21__VerticalUnknownCrs : public eml21__AbstractVerticalCrs {
      public:
        /// Required element 'eml21:Unknown' of XSD type 'eml21:String2000'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalUnknownCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalUnknownCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalUnknownCrs() : Unknown() { }
        virtual ~eml21__VerticalUnknownCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalUnknownCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2007 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs (607)
/* Type eml21__VerticalWktCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:VerticalWktCrs': */
class SOAP_CMAC eml21__VerticalWktCrs : public eml21__AbstractVerticalCrs {
      public:
        /// Required element 'eml21:WellKnownText' of XSD type 'xsd:string'
        std::string WellKnownText;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalWktCrs, default initialized and not managed by a soap context
        virtual eml21__VerticalWktCrs *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalWktCrs); }
      public:
        /// Constructor with initializations
        eml21__VerticalWktCrs() : WellKnownText() { }
        virtual ~eml21__VerticalWktCrs() { }
        /// Friend allocator used by soap_new_eml21__VerticalWktCrs(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalWktCrs * SOAP_FMAC2 soap_instantiate_eml21__VerticalWktCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2010 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord (608)
/* Type eml21__DataAssuranceRecord is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:DataAssuranceRecord': */
class SOAP_CMAC eml21__DataAssuranceRecord : public eml21__AbstractObject {
      public:
        /// Required element 'eml21:PolicyId' of XSD type 'eml21:String64'
        std::string PolicyId;
        /// Optional element 'eml21:PolicyName' of XSD type 'eml21:String2000'
        std::string *PolicyName;
        /// Optional element 'eml21:ReferencedElementName' of XSD type 'eml21:String64'
        std::string *ReferencedElementName;
        /// Optional element 'eml21:ReferencedElementUid' of XSD type 'eml21:String64'
        std::string *ReferencedElementUid;
        /// Required element 'eml21:Origin' of XSD type 'xsd:string'
        std::string Origin;
        /// Required element 'eml21:Conformance' of XSD type 'xsd:boolean'
        bool Conformance;
        /// Required element 'eml21:Date' of XSD type 'eml21:TimeStamp'
        std::string Date;
        /// Optional element 'eml21:Comment' of XSD type 'xsd:string'
        std::string *Comment;
        /// Optional element 'eml21:FailingRules' of XSD type 'eml21:FailingRule'
        std::vector<eml21__FailingRule *> FailingRules;
        /// Optional element 'eml21:IndexRange' of XSD type 'eml21:IndexRange'
        eml21__IndexRange *IndexRange;
        /// Required element 'eml21:ReferencedData' of XSD type 'eml21:DataObjectReference'
        eml21__DataObjectReference *ReferencedData;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DataAssuranceRecord, default initialized and not managed by a soap context
        virtual eml21__DataAssuranceRecord *soap_alloc(void) const { return SOAP_NEW(eml21__DataAssuranceRecord); }
      public:
        /// Constructor with initializations
        eml21__DataAssuranceRecord() : PolicyId(), PolicyName(), ReferencedElementName(), ReferencedElementUid(), Origin(), Conformance(), Date(), Comment(), FailingRules(), IndexRange(), ReferencedData() { }
        virtual ~eml21__DataAssuranceRecord() { }
        /// Friend allocator used by soap_new_eml21__DataAssuranceRecord(struct soap*, int)
        friend SOAP_FMAC1 eml21__DataAssuranceRecord * SOAP_FMAC2 soap_instantiate_eml21__DataAssuranceRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2022 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet (612)
/* Type eml21__GraphicalInformationSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:GraphicalInformationSet': */
class SOAP_CMAC eml21__GraphicalInformationSet : public eml21__AbstractObject {
      public:
        /// Optional element 'eml21:GraphicalInformation' of XSD type 'eml21:AbstractGraphicalInformation'
        std::vector<eml21__AbstractGraphicalInformation *> GraphicalInformation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GraphicalInformationSet, default initialized and not managed by a soap context
        virtual eml21__GraphicalInformationSet *soap_alloc(void) const { return SOAP_NEW(eml21__GraphicalInformationSet); }
      public:
        /// Constructor with initializations
        eml21__GraphicalInformationSet() : GraphicalInformation() { }
        virtual ~eml21__GraphicalInformationSet() { }
        /// Friend allocator used by soap_new_eml21__GraphicalInformationSet(struct soap*, int)
        friend SOAP_FMAC1 eml21__GraphicalInformationSet * SOAP_FMAC2 soap_instantiate_eml21__GraphicalInformationSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2037 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType (617)
/* Type gml__DefinitionBaseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:DefinitionBaseType': */
class SOAP_CMAC gml__DefinitionBaseType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionBaseType, default initialized and not managed by a soap context
        virtual gml__DefinitionBaseType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionBaseType); }
      public:
        /// Constructor with initializations
        gml__DefinitionBaseType() : description(), descriptionReference(), identifier(), name(), gml__id(), soap() { }
        virtual ~gml__DefinitionBaseType() { }
        /// Friend allocator used by soap_new_gml__DefinitionBaseType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionBaseType * SOAP_FMAC2 soap_instantiate_gml__DefinitionBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2043 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType (619)
/* simple XSD type 'gml:StringOrRefType': */
class SOAP_CMAC gml__StringOrRefType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string xlink__type;	///< initialized with fixed value = "simple"
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__StringOrRefType, default initialized and not managed by a soap context
        virtual gml__StringOrRefType *soap_alloc(void) const { return SOAP_NEW(gml__StringOrRefType); }
      public:
        /// Constructor with initializations
        gml__StringOrRefType() : __item(), nilReason(), xlink__type("simple"), xlink__href(), xlink__role(), xlink__arcrole(), xlink__title(), xlink__show(), xlink__actuate(), soap() { }
        virtual ~gml__StringOrRefType() { }
        /// Friend allocator used by soap_new_gml__StringOrRefType(struct soap*, int)
        friend SOAP_FMAC1 gml__StringOrRefType * SOAP_FMAC2 soap_instantiate_gml__StringOrRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2052 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CodeType
#define SOAP_TYPE_gsoap_eml2_1_gml__CodeType (622)
/* simple XSD type 'gml:CodeType': */
class SOAP_CMAC gml__CodeType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CodeType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeType, default initialized and not managed by a soap context
        virtual gml__CodeType *soap_alloc(void) const { return SOAP_NEW(gml__CodeType); }
      public:
        /// Constructor with initializations
        gml__CodeType() : __item(), codeSpace(), soap() { }
        virtual ~gml__CodeType() { }
        /// Friend allocator used by soap_new_gml__CodeType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeType * SOAP_FMAC2 soap_instantiate_gml__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2058 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType (624)
/* Type gml__AbstractTimeObjectType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractTimeObjectType': */
class SOAP_CMAC gml__AbstractTimeObjectType : public gml__AbstractGMLType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeObjectType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeObjectType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimeObjectType); }
      public:
        /// Constructor with initializations
        gml__AbstractTimeObjectType() { }
        virtual ~gml__AbstractTimeObjectType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeObjectType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2061 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType (625)
/* Type gml__RelatedTimeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:RelatedTimeType': */
class SOAP_CMAC gml__RelatedTimeType : public gml__TimePrimitivePropertyType {
      public:
        /// optional attribute 'relativePosition' of XSD type 'gml:RelatedTimeType-relativePosition'
        enum _gml__RelatedTimeType_relativePosition *relativePosition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RelatedTimeType, default initialized and not managed by a soap context
        virtual gml__RelatedTimeType *soap_alloc(void) const { return SOAP_NEW(gml__RelatedTimeType); }
      public:
        /// Constructor with initializations
        gml__RelatedTimeType() : relativePosition() { }
        virtual ~gml__RelatedTimeType() { }
        /// Friend allocator used by soap_new_gml__RelatedTimeType(struct soap*, int)
        friend SOAP_FMAC1 gml__RelatedTimeType * SOAP_FMAC2 soap_instantiate_gml__RelatedTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2112 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__MeasureType
#define SOAP_TYPE_gsoap_eml2_1_gml__MeasureType (642)
/* Type gml__MeasureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:MeasureType': */
class SOAP_CMAC gml__MeasureType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__MeasureType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MeasureType, default initialized and not managed by a soap context
        virtual gml__MeasureType *soap_alloc(void) const { return SOAP_NEW(gml__MeasureType); }
      public:
        /// Constructor with initializations
        gml__MeasureType() : __item(), soap() { }
        virtual ~gml__MeasureType() { }
        /// Friend allocator used by soap_new_gml__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 gml__MeasureType * SOAP_FMAC2 soap_instantiate_gml__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2172 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType (662)
/* Type gmd__EX_USCOREExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_Extent_Type': */
class SOAP_CMAC gmd__EX_USCOREExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:description' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *description;
        /// Optional element 'gmd:geographicElement' of XSD type 'gmd:EX_GeographicExtent_PropertyType'
        std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *> geographicElement;
        /// Optional element 'gmd:temporalElement' of XSD type 'gmd:EX_TemporalExtent_PropertyType'
        std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *> temporalElement;
        /// Optional element 'gmd:verticalElement' of XSD type 'gmd:EX_VerticalExtent_PropertyType'
        std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *> verticalElement;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREExtent_USCOREType() : description(), geographicElement(), temporalElement(), verticalElement() { }
        virtual ~gmd__EX_USCOREExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2178 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (664)
/* Type gmd__AbstractEX_USCOREGeographicExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractEX_GeographicExtent_Type': */
class SOAP_CMAC gmd__AbstractEX_USCOREGeographicExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:extentTypeCode' of XSD type 'gco:Boolean_PropertyType'
        gco__Boolean_USCOREPropertyType *extentTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractEX_USCOREGeographicExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractEX_USCOREGeographicExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractEX_USCOREGeographicExtent_USCOREType() : extentTypeCode() { }
        virtual ~gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractEX_USCOREGeographicExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2184 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType (666)
/* Type gmd__EX_USCORETemporalExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_TemporalExtent_Type': */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:extent' of XSD type 'gts:TM_Primitive_PropertyType'
        gts__TM_USCOREPrimitive_USCOREPropertyType *extent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCORETemporalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCORETemporalExtent_USCOREType() : extent() { }
        virtual ~gmd__EX_USCORETemporalExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCORETemporalExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2190 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType (668)
/* Type gmd__EX_USCOREVerticalExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_VerticalExtent_Type': */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:minimumValue' of XSD type 'gco:Real_PropertyType'
        gco__Real_USCOREPropertyType *minimumValue;
        /// Required element 'gmd:maximumValue' of XSD type 'gco:Real_PropertyType'
        gco__Real_USCOREPropertyType *maximumValue;
        /// Required element 'gmd:verticalCRS' of XSD type 'gsr:SC_CRS_PropertyType'
        gsr__SC_USCORECRS_USCOREPropertyType *verticalCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREVerticalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREVerticalExtent_USCOREType() : minimumValue(), maximumValue(), verticalCRS() { }
        virtual ~gmd__EX_USCOREVerticalExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREVerticalExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2196 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType (670)
/* Type gmd__AbstractDQ_USCOREElement_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_Element_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREElement_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:nameOfMeasure' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> nameOfMeasure;
        /// Optional element 'gmd:measureIdentification' of XSD type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_USCOREIdentifier_USCOREPropertyType *measureIdentification;
        /// Optional element 'gmd:measureDescription' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *measureDescription;
        /// Optional element 'gmd:evaluationMethodType' of XSD type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType'
        gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *evaluationMethodType;
        /// Optional element 'gmd:evaluationMethodDescription' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *evaluationMethodDescription;
        /// Optional element 'gmd:evaluationProcedure' of XSD type 'gmd:CI_Citation_PropertyType'
        gmd__CI_USCORECitation_USCOREPropertyType *evaluationProcedure;
        /// Optional element 'gmd:dateTime' of XSD type 'gco:DateTime_PropertyType'
        std::vector<gco__DateTime_USCOREPropertyType *> dateTime;
        /// Sequence of 1 to 2 elements 'gmd:result' of XSD type 'gmd:DQ_Result_PropertyType'
        std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *> result;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREElement_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREElement_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREElement_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREElement_USCOREType() : nameOfMeasure(), measureIdentification(), measureDescription(), evaluationMethodType(), evaluationMethodDescription(), evaluationProcedure(), dateTime(), result() { }
        virtual ~gmd__AbstractDQ_USCOREElement_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREElement_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2202 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType (672)
/* Type gmd__MD_USCOREIdentifier_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:MD_Identifier_Type': */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:authority' of XSD type 'gmd:CI_Citation_PropertyType'
        gmd__CI_USCORECitation_USCOREPropertyType *authority;
        /// Required element 'gmd:code' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *code;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_USCOREIdentifier_USCOREType, default initialized and not managed by a soap context
        virtual gmd__MD_USCOREIdentifier_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__MD_USCOREIdentifier_USCOREType() : authority(), code() { }
        virtual ~gmd__MD_USCOREIdentifier_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_USCOREIdentifier_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2208 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType (674)
/* Type gmd__CI_USCORECitation_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Citation_Type': */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:title' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *title;
        /// Optional element 'gmd:alternateTitle' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> alternateTitle;
        /// Required element 'gmd:date' of XSD type 'gmd:CI_Date_PropertyType'
        std::vector<gmd__CI_USCOREDate_USCOREPropertyType *> date;
        /// Optional element 'gmd:edition' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *edition;
        /// Optional element 'gmd:editionDate' of XSD type 'gco:Date_PropertyType'
        gco__Date_USCOREPropertyType *editionDate;
        /// Optional element 'gmd:identifier' of XSD type 'gmd:MD_Identifier_PropertyType'
        std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *> identifier;
        /// Optional element 'gmd:citedResponsibleParty' of XSD type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *> citedResponsibleParty;
        /// Optional element 'gmd:presentationForm' of XSD type 'gmd:CI_PresentationFormCode_PropertyType'
        std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *> presentationForm;
        /// Optional element 'gmd:series' of XSD type 'gmd:CI_Series_PropertyType'
        gmd__CI_USCORESeries_USCOREPropertyType *series;
        /// Optional element 'gmd:otherCitationDetails' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *otherCitationDetails;
        /// Optional element 'gmd:collectiveTitle' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *collectiveTitle;
        /// Optional element 'gmd:ISBN' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *ISBN;
        /// Optional element 'gmd:ISSN' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *ISSN;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORECitation_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORECitation_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORECitation_USCOREType() : title(), alternateTitle(), date(), edition(), editionDate(), identifier(), citedResponsibleParty(), presentationForm(), series(), otherCitationDetails(), collectiveTitle(), ISBN(), ISSN() { }
        virtual ~gmd__CI_USCORECitation_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORECitation_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORECitation_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORECitation_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2214 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType (676)
/* Type gmd__CI_USCOREDate_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Date_Type': */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:date' of XSD type 'gco:Date_PropertyType'
        gco__Date_USCOREPropertyType *date;
        /// Required element 'gmd:dateType' of XSD type 'gmd:CI_DateTypeCode_PropertyType'
        gmd__CI_USCOREDateTypeCode_USCOREPropertyType *dateType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDate_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDate_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDate_USCOREType() : date(), dateType() { }
        virtual ~gmd__CI_USCOREDate_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDate_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDate_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDate_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2223 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType (679)
/* Type gmd__CI_USCOREResponsibleParty_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_ResponsibleParty_Type': */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:individualName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *individualName;
        /// Optional element 'gmd:organisationName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *organisationName;
        /// Optional element 'gmd:positionName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *positionName;
        /// Optional element 'gmd:contactInfo' of XSD type 'gmd:CI_Contact_PropertyType'
        gmd__CI_USCOREContact_USCOREPropertyType *contactInfo;
        /// Required element 'gmd:role' of XSD type 'gmd:CI_RoleCode_PropertyType'
        gmd__CI_USCORERoleCode_USCOREPropertyType *role;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREResponsibleParty_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREResponsibleParty_USCOREType() : individualName(), organisationName(), positionName(), contactInfo(), role() { }
        virtual ~gmd__CI_USCOREResponsibleParty_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREResponsibleParty_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2229 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType (681)
/* Type gmd__CI_USCOREContact_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Contact_Type': */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:phone' of XSD type 'gmd:CI_Telephone_PropertyType'
        gmd__CI_USCORETelephone_USCOREPropertyType *phone;
        /// Optional element 'gmd:address' of XSD type 'gmd:CI_Address_PropertyType'
        gmd__CI_USCOREAddress_USCOREPropertyType *address;
        /// Optional element 'gmd:onlineResource' of XSD type 'gmd:CI_OnlineResource_PropertyType'
        gmd__CI_USCOREOnlineResource_USCOREPropertyType *onlineResource;
        /// Optional element 'gmd:hoursOfService' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *hoursOfService;
        /// Optional element 'gmd:contactInstructions' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *contactInstructions;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREContact_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREContact_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREContact_USCOREType() : phone(), address(), onlineResource(), hoursOfService(), contactInstructions() { }
        virtual ~gmd__CI_USCOREContact_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREContact_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREContact_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREContact_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2235 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType (683)
/* Type gmd__CI_USCORETelephone_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Telephone_Type': */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:voice' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> voice;
        /// Optional element 'gmd:facsimile' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> facsimile;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORETelephone_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORETelephone_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORETelephone_USCOREType() : voice(), facsimile() { }
        virtual ~gmd__CI_USCORETelephone_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORETelephone_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORETelephone_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORETelephone_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2241 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType (685)
/* Type gmd__CI_USCOREAddress_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Address_Type': */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:deliveryPoint' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> deliveryPoint;
        /// Optional element 'gmd:city' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *city;
        /// Optional element 'gmd:administrativeArea' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *administrativeArea;
        /// Optional element 'gmd:postalCode' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *postalCode;
        /// Optional element 'gmd:country' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *country;
        /// Optional element 'gmd:electronicMailAddress' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> electronicMailAddress;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREAddress_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREAddress_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREAddress_USCOREType() : deliveryPoint(), city(), administrativeArea(), postalCode(), country(), electronicMailAddress() { }
        virtual ~gmd__CI_USCOREAddress_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREAddress_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREAddress_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREAddress_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2247 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType (687)
/* Type gmd__CI_USCOREOnlineResource_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_OnlineResource_Type': */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:linkage' of XSD type 'gmd:URL_PropertyType'
        gmd__URL_USCOREPropertyType *linkage;
        /// Optional element 'gmd:protocol' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *protocol;
        /// Optional element 'gmd:applicationProfile' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *applicationProfile;
        /// Optional element 'gmd:name' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *name;
        /// Optional element 'gmd:description' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *description;
        /// Optional element 'gmd:function' of XSD type 'gmd:CI_OnLineFunctionCode_PropertyType'
        gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *function;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnlineResource_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnlineResource_USCOREType() : linkage(), protocol(), applicationProfile(), name(), description(), function() { }
        virtual ~gmd__CI_USCOREOnlineResource_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnlineResource_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2265 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType (693)
/* Type gmd__CI_USCORESeries_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Series_Type': */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:name' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *name;
        /// Optional element 'gmd:issueIdentification' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *issueIdentification;
        /// Optional element 'gmd:page' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *page;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORESeries_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORESeries_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORESeries_USCOREType() : name(), issueIdentification(), page() { }
        virtual ~gmd__CI_USCORESeries_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORESeries_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORESeries_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORESeries_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2274 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType (696)
/* Type gmd__AbstractDQ_USCOREResult_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_Result_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREResult_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREResult_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREResult_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREResult_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREResult_USCOREType() { }
        virtual ~gmd__AbstractDQ_USCOREResult_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREResult_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2295 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType (703)
/* simple XSD type 'gco:CodeListValue_Type': */
class SOAP_CMAC gco__CodeListValue_USCOREType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'codeList' of XSD type 'xsd:anyURI'
        std::string codeList;
        /// required attribute 'codeListValue' of XSD type 'xsd:anyURI'
        std::string codeListValue;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CodeListValue_USCOREType, default initialized and not managed by a soap context
        virtual gco__CodeListValue_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__CodeListValue_USCOREType); }
      public:
        /// Constructor with initializations
        gco__CodeListValue_USCOREType() : __item(), codeList(), codeListValue(), codeSpace(), soap() { }
        virtual ~gco__CodeListValue_USCOREType() { }
        /// Friend allocator used by soap_new_gco__CodeListValue_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gco__CodeListValue_USCOREType * SOAP_FMAC2 soap_instantiate_gco__CodeListValue_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:360 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct (58)
/* simple XSD type 'prodml2:KeywordValueStruct': */
class SOAP_CMAC prodml2__KeywordValueStruct {
      public:
        /// Simple content of XSD type 'eml21:AbstractString' wrapped by this struct
        std::string __item;
        /// required attribute 'keyword' of XSD type 'prodml2:TimeSeriesKeyword'
        enum prodml2__TimeSeriesKeyword keyword;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__KeywordValueStruct, default initialized and not managed by a soap context
        virtual prodml2__KeywordValueStruct *soap_alloc(void) const { return SOAP_NEW(prodml2__KeywordValueStruct); }
      public:
        /// Constructor with initializations
        prodml2__KeywordValueStruct() : __item(), keyword(), soap() { }
        virtual ~prodml2__KeywordValueStruct() { }
        /// Friend allocator used by soap_new_prodml2__KeywordValueStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__KeywordValueStruct * SOAP_FMAC2 soap_instantiate_prodml2__KeywordValueStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:369 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord (61)
/* simple XSD type 'prodml2:MeasuredDepthCoord': */
class SOAP_CMAC prodml2__MeasuredDepthCoord {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VerticalCoordinateUom'
        enum eml21__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__MeasuredDepthCoord, default initialized and not managed by a soap context
        virtual prodml2__MeasuredDepthCoord *soap_alloc(void) const { return SOAP_NEW(prodml2__MeasuredDepthCoord); }
      public:
        /// Constructor with initializations
        prodml2__MeasuredDepthCoord() : __item(), uom(), soap() { }
        virtual ~prodml2__MeasuredDepthCoord() { }
        /// Friend allocator used by soap_new_prodml2__MeasuredDepthCoord(struct soap*, int)
        friend SOAP_FMAC1 prodml2__MeasuredDepthCoord * SOAP_FMAC2 soap_instantiate_prodml2__MeasuredDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:372 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity
#define SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity (62)
/* simple XSD type 'prodml2:MeasureOrQuantity': */
class SOAP_CMAC prodml2__MeasureOrQuantity {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// optional attribute 'uom' of XSD type 'eml21:UomEnum'
        std::string *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__MeasureOrQuantity, default initialized and not managed by a soap context
        virtual prodml2__MeasureOrQuantity *soap_alloc(void) const { return SOAP_NEW(prodml2__MeasureOrQuantity); }
      public:
        /// Constructor with initializations
        prodml2__MeasureOrQuantity() : __item(), uom(), soap() { }
        virtual ~prodml2__MeasureOrQuantity() { }
        /// Friend allocator used by soap_new_prodml2__MeasureOrQuantity(struct soap*, int)
        friend SOAP_FMAC1 prodml2__MeasureOrQuantity * SOAP_FMAC2 soap_instantiate_prodml2__MeasureOrQuantity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:29029 */
#ifndef SOAP_TYPE_gsoap_eml2_1___prodml2__FiberConnection_sequence
#define SOAP_TYPE_gsoap_eml2_1___prodml2__FiberConnection_sequence (1646)
/* Wrapper: */
class SOAP_CMAC __prodml2__FiberConnection_sequence {
      public:
        /// Required element 'prodml2:ConnectorType' of XSD type 'prodml2:FiberConnectorTypes'
        enum prodml2__FiberConnectorTypes ConnectorType;
        /// Optional element 'prodml2:EndType' of XSD type 'prodml2:FiberEndType'
        enum prodml2__FiberEndType *EndType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1___prodml2__FiberConnection_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1___prodml2__FiberConnection_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __prodml2__FiberConnection_sequence, default initialized and not managed by a soap context
        virtual __prodml2__FiberConnection_sequence *soap_alloc(void) const { return SOAP_NEW(__prodml2__FiberConnection_sequence); }
      public:
        /// Constructor with initializations
        __prodml2__FiberConnection_sequence() : ConnectorType(), EndType() { }
        virtual ~__prodml2__FiberConnection_sequence() { }
        /// Friend allocator used by soap_new___prodml2__FiberConnection_sequence(struct soap*, int)
        friend SOAP_FMAC1 __prodml2__FiberConnection_sequence * SOAP_FMAC2 soap_instantiate___prodml2__FiberConnection_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:570 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection (128)
/* Type prodml2__FiberConnection is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberConnection': */
class SOAP_CMAC prodml2__FiberConnection : public prodml2__FiberCommon {
      public:
        std::vector<__prodml2__FiberConnection_sequence> __FiberConnection_sequence;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberConnection, default initialized and not managed by a soap context
        virtual prodml2__FiberConnection *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberConnection); }
      public:
        /// Constructor with initializations
        prodml2__FiberConnection() : __FiberConnection_sequence() { }
        virtual ~prodml2__FiberConnection() { }
        /// Friend allocator used by soap_new_prodml2__FiberConnection(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberConnection * SOAP_FMAC2 soap_instantiate_prodml2__FiberConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:606 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment (140)
/* Type prodml2__FiberOpticalPathSegment is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberOpticalPathSegment': */
class SOAP_CMAC prodml2__FiberOpticalPathSegment : public prodml2__FiberCommon {
      public:
        /// Required element 'prodml2:FiberLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *FiberLength;
        /// Optional element 'prodml2:OverStuffing' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OverStuffing;
        /// Optional element 'prodml2:CoreDiameter' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *CoreDiameter;
        /// Optional element 'prodml2:CladdedDiameter' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *CladdedDiameter;
        /// Optional element 'prodml2:OutsideDiameter' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *OutsideDiameter;
        /// Optional element 'prodml2:Mode' of XSD type 'prodml2:FiberMode'
        enum prodml2__FiberMode *Mode;
        /// Optional element 'prodml2:Coating' of XSD type 'eml21:String64'
        std::string *Coating;
        /// Optional element 'prodml2:Jacket' of XSD type 'eml21:String64'
        std::string *Jacket;
        /// Optional element 'prodml2:CoreType' of XSD type 'eml21:String64'
        std::string *CoreType;
        /// Optional element 'prodml2:Parameter' of XSD type 'prodml2:IndexedObject'
        std::vector<prodml2__IndexedObject *> Parameter;
        /// Optional element 'prodml2:SpoolNumberTag' of XSD type 'eml21:String64'
        std::string *SpoolNumberTag;
        /// Optional element 'prodml2:SpoolLength' of XSD type 'eml21:LengthMeasure'
        eml21__LengthMeasure *SpoolLength;
        /// Optional element 'prodml2:CableType' of XSD type 'prodml2:CableType'
        enum prodml2__CableType *CableType;
        /// Optional element 'prodml2:RefractiveIndex' of XSD type 'prodml2:FiberRefractiveIndex'
        std::vector<prodml2__FiberRefractiveIndex *> RefractiveIndex;
        /// Optional element 'prodml2:FiberConveyance' of XSD type 'prodml2:FiberConveyance'
        prodml2__FiberConveyance *FiberConveyance;
        /// Optional element 'prodml2:OneWayAttenuation' of XSD type 'prodml2:FiberOneWayAttenuation'
        std::vector<prodml2__FiberOneWayAttenuation *> OneWayAttenuation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOpticalPathSegment, default initialized and not managed by a soap context
        virtual prodml2__FiberOpticalPathSegment *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOpticalPathSegment); }
      public:
        /// Constructor with initializations
        prodml2__FiberOpticalPathSegment() : FiberLength(), OverStuffing(), CoreDiameter(), CladdedDiameter(), OutsideDiameter(), Mode(), Coating(), Jacket(), CoreType(), Parameter(), SpoolNumberTag(), SpoolLength(), CableType(), RefractiveIndex(), FiberConveyance(), OneWayAttenuation() { }
        virtual ~prodml2__FiberOpticalPathSegment() { }
        /// Friend allocator used by soap_new_prodml2__FiberOpticalPathSegment(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOpticalPathSegment * SOAP_FMAC2 soap_instantiate_prodml2__FiberOpticalPathSegment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:612 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox (142)
/* Type prodml2__FiberOTDRInstrumentBox is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberOTDRInstrumentBox': */
class SOAP_CMAC prodml2__FiberOTDRInstrumentBox : public prodml2__Instrument {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberOTDRInstrumentBox, default initialized and not managed by a soap context
        virtual prodml2__FiberOTDRInstrumentBox *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberOTDRInstrumentBox); }
      public:
        /// Constructor with initializations
        prodml2__FiberOTDRInstrumentBox() { }
        virtual ~prodml2__FiberOTDRInstrumentBox() { }
        /// Friend allocator used by soap_new_prodml2__FiberOTDRInstrumentBox(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberOTDRInstrumentBox * SOAP_FMAC2 soap_instantiate_prodml2__FiberOTDRInstrumentBox(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:624 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice (146)
/* Type prodml2__FiberSplice is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberSplice': */
class SOAP_CMAC prodml2__FiberSplice : public prodml2__FiberCommon {
      public:
        /// Optional element 'prodml2:SpliceEquipmentUsedReference' of XSD type 'eml21:String64'
        std::string *SpliceEquipmentUsedReference;
        /// Optional element 'prodml2:StrippingType' of XSD type 'eml21:String64'
        std::string *StrippingType;
        /// Optional element 'prodml2:ProtectorType' of XSD type 'eml21:String64'
        std::string *ProtectorType;
        /// Required element 'prodml2:FiberSpliceType' of XSD type 'prodml2:FiberSpliceTypes'
        enum prodml2__FiberSpliceTypes FiberSpliceType;
        /// Optional element 'prodml2:PressureRating' of XSD type 'eml21:PressureMeasure'
        eml21__PressureMeasure *PressureRating;
        /// Optional element 'prodml2:BendAngle' of XSD type 'eml21:PlaneAngleUom'
        enum eml21__PlaneAngleUom *BendAngle;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberSplice, default initialized and not managed by a soap context
        virtual prodml2__FiberSplice *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberSplice); }
      public:
        /// Constructor with initializations
        prodml2__FiberSplice() : SpliceEquipmentUsedReference(), StrippingType(), ProtectorType(), FiberSpliceType(), PressureRating(), BendAngle() { }
        virtual ~prodml2__FiberSplice() { }
        /// Friend allocator used by soap_new_prodml2__FiberSplice(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberSplice * SOAP_FMAC2 soap_instantiate_prodml2__FiberSplice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:627 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator (147)
/* Type prodml2__FiberTerminator is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberTerminator': */
class SOAP_CMAC prodml2__FiberTerminator : public prodml2__FiberCommon {
      public:
        /// Required element 'prodml2:TerminationType' of XSD type 'prodml2:TerminationType'
        enum prodml2__TerminationType TerminationType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberTerminator, default initialized and not managed by a soap context
        virtual prodml2__FiberTerminator *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberTerminator); }
      public:
        /// Constructor with initializations
        prodml2__FiberTerminator() : TerminationType() { }
        virtual ~prodml2__FiberTerminator() { }
        /// Friend allocator used by soap_new_prodml2__FiberTerminator(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberTerminator * SOAP_FMAC2 soap_instantiate_prodml2__FiberTerminator(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:630 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround (148)
/* Type prodml2__FiberTurnaround is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'prodml2:FiberTurnaround': */
class SOAP_CMAC prodml2__FiberTurnaround : public prodml2__FiberCommon {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__FiberTurnaround, default initialized and not managed by a soap context
        virtual prodml2__FiberTurnaround *soap_alloc(void) const { return SOAP_NEW(prodml2__FiberTurnaround); }
      public:
        /// Constructor with initializations
        prodml2__FiberTurnaround() { }
        virtual ~prodml2__FiberTurnaround() { }
        /// Friend allocator used by soap_new_prodml2__FiberTurnaround(struct soap*, int)
        friend SOAP_FMAC1 prodml2__FiberTurnaround * SOAP_FMAC2 soap_instantiate_prodml2__FiberTurnaround(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:663 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray (159)
/* Type eml21__AbstractFloatingPointArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractFloatingPointArray': */
class SOAP_CMAC eml21__AbstractFloatingPointArray : public eml21__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractFloatingPointArray, default initialized and not managed by a soap context
        virtual eml21__AbstractFloatingPointArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractFloatingPointArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractFloatingPointArray() { }
        virtual ~eml21__AbstractFloatingPointArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractFloatingPointArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractFloatingPointArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractFloatingPointArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:666 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray (160)
/* Type eml21__AbstractIntegerArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:AbstractIntegerArray': */
class SOAP_CMAC eml21__AbstractIntegerArray : public eml21__AbstractNumericArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbstractIntegerArray, default initialized and not managed by a soap context
        virtual eml21__AbstractIntegerArray *soap_alloc(void) const { return SOAP_NEW(eml21__AbstractIntegerArray); }
      public:
        /// Constructor with initializations
        eml21__AbstractIntegerArray() { }
        virtual ~eml21__AbstractIntegerArray() { }
        /// Friend allocator used by soap_new_eml21__AbstractIntegerArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbstractIntegerArray * SOAP_FMAC2 soap_instantiate_eml21__AbstractIntegerArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:681 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray (165)
/* Type eml21__BooleanArrayFromIndexArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:BooleanArrayFromIndexArray': */
class SOAP_CMAC eml21__BooleanArrayFromIndexArray : public eml21__AbstractBooleanArray {
      public:
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
        /// Required element 'eml21:Indices' of XSD type 'eml21:AbstractIntegerArray'
        eml21__AbstractIntegerArray *Indices;
        /// Required element 'eml21:IndexIsTrue' of XSD type 'xsd:boolean'
        bool IndexIsTrue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__BooleanArrayFromIndexArray, default initialized and not managed by a soap context
        virtual eml21__BooleanArrayFromIndexArray *soap_alloc(void) const { return SOAP_NEW(eml21__BooleanArrayFromIndexArray); }
      public:
        /// Constructor with initializations
        eml21__BooleanArrayFromIndexArray() : Count(), Indices(), IndexIsTrue() { }
        virtual ~eml21__BooleanArrayFromIndexArray() { }
        /// Friend allocator used by soap_new_eml21__BooleanArrayFromIndexArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__BooleanArrayFromIndexArray * SOAP_FMAC2 soap_instantiate_eml21__BooleanArrayFromIndexArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:684 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray (166)
/* Type eml21__BooleanConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:BooleanConstantArray': */
class SOAP_CMAC eml21__BooleanConstantArray : public eml21__AbstractBooleanArray {
      public:
        /// Required element 'eml21:Value' of XSD type 'xsd:boolean'
        bool Value;
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__BooleanConstantArray, default initialized and not managed by a soap context
        virtual eml21__BooleanConstantArray *soap_alloc(void) const { return SOAP_NEW(eml21__BooleanConstantArray); }
      public:
        /// Constructor with initializations
        eml21__BooleanConstantArray() : Value(), Count() { }
        virtual ~eml21__BooleanConstantArray() { }
        /// Friend allocator used by soap_new_eml21__BooleanConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__BooleanConstantArray * SOAP_FMAC2 soap_instantiate_eml21__BooleanConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:687 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray (167)
/* Type eml21__BooleanExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:BooleanExternalArray': */
class SOAP_CMAC eml21__BooleanExternalArray : public eml21__AbstractBooleanArray {
      public:
        /// Required element 'eml21:Values' of XSD type 'eml21:ExternalDataset'
        eml21__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__BooleanExternalArray, default initialized and not managed by a soap context
        virtual eml21__BooleanExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__BooleanExternalArray); }
      public:
        /// Constructor with initializations
        eml21__BooleanExternalArray() : Values() { }
        virtual ~eml21__BooleanExternalArray() { }
        /// Friend allocator used by soap_new_eml21__BooleanExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__BooleanExternalArray * SOAP_FMAC2 soap_instantiate_eml21__BooleanExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:705 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure (173)
/* simple XSD type 'eml21:GenericMeasure': */
class SOAP_CMAC eml21__GenericMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:UomEnum'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__GenericMeasure, default initialized and not managed by a soap context
        virtual eml21__GenericMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__GenericMeasure); }
      public:
        /// Constructor with initializations
        eml21__GenericMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__GenericMeasure() { }
        /// Friend allocator used by soap_new_eml21__GenericMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__GenericMeasure * SOAP_FMAC2 soap_instantiate_eml21__GenericMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:729 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray (181)
/* Type eml21__StringConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:StringConstantArray': */
class SOAP_CMAC eml21__StringConstantArray : public eml21__AbstractStringArray {
      public:
        /// Required element 'eml21:Value' of XSD type 'eml21:String2000'
        std::string Value;
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__StringConstantArray, default initialized and not managed by a soap context
        virtual eml21__StringConstantArray *soap_alloc(void) const { return SOAP_NEW(eml21__StringConstantArray); }
      public:
        /// Constructor with initializations
        eml21__StringConstantArray() : Value(), Count() { }
        virtual ~eml21__StringConstantArray() { }
        /// Friend allocator used by soap_new_eml21__StringConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__StringConstantArray * SOAP_FMAC2 soap_instantiate_eml21__StringConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:732 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray (182)
/* Type eml21__StringExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:StringExternalArray': */
class SOAP_CMAC eml21__StringExternalArray : public eml21__AbstractStringArray {
      public:
        /// Required element 'eml21:Values' of XSD type 'eml21:ExternalDataset'
        eml21__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__StringExternalArray, default initialized and not managed by a soap context
        virtual eml21__StringExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__StringExternalArray); }
      public:
        /// Constructor with initializations
        eml21__StringExternalArray() : Values() { }
        virtual ~eml21__StringExternalArray() { }
        /// Friend allocator used by soap_new_eml21__StringExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__StringExternalArray * SOAP_FMAC2 soap_instantiate_eml21__StringExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:741 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure (185)
/* simple XSD type 'eml21:AbsorbedDoseMeasure': */
class SOAP_CMAC eml21__AbsorbedDoseMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AbsorbedDoseUom'
        enum eml21__AbsorbedDoseUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbsorbedDoseMeasure, default initialized and not managed by a soap context
        virtual eml21__AbsorbedDoseMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AbsorbedDoseMeasure); }
      public:
        /// Constructor with initializations
        eml21__AbsorbedDoseMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AbsorbedDoseMeasure() { }
        /// Friend allocator used by soap_new_eml21__AbsorbedDoseMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbsorbedDoseMeasure * SOAP_FMAC2 soap_instantiate_eml21__AbsorbedDoseMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:744 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt (186)
/* simple XSD type 'eml21:AbsorbedDoseMeasureExt': */
class SOAP_CMAC eml21__AbsorbedDoseMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AbsorbedDoseUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AbsorbedDoseMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AbsorbedDoseMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AbsorbedDoseMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AbsorbedDoseMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AbsorbedDoseMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AbsorbedDoseMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AbsorbedDoseMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AbsorbedDoseMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:747 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure (187)
/* simple XSD type 'eml21:ActivityOfRadioactivityMeasure': */
class SOAP_CMAC eml21__ActivityOfRadioactivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ActivityOfRadioactivityUom'
        enum eml21__ActivityOfRadioactivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ActivityOfRadioactivityMeasure, default initialized and not managed by a soap context
        virtual eml21__ActivityOfRadioactivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ActivityOfRadioactivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ActivityOfRadioactivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ActivityOfRadioactivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ActivityOfRadioactivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ActivityOfRadioactivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ActivityOfRadioactivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:750 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt (188)
/* simple XSD type 'eml21:ActivityOfRadioactivityMeasureExt': */
class SOAP_CMAC eml21__ActivityOfRadioactivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ActivityOfRadioactivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ActivityOfRadioactivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ActivityOfRadioactivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ActivityOfRadioactivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ActivityOfRadioactivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ActivityOfRadioactivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ActivityOfRadioactivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ActivityOfRadioactivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ActivityOfRadioactivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:753 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure (189)
/* simple XSD type 'eml21:AmountOfSubstanceMeasure': */
class SOAP_CMAC eml21__AmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstanceUom'
        enum eml21__AmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:756 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt (190)
/* simple XSD type 'eml21:AmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:759 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure (191)
/* simple XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml21__AmountOfSubstancePerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceUom'
        enum eml21__AmountOfSubstancePerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:762 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt (192)
/* simple XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:765 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure (193)
/* simple XSD type 'eml21:AmountOfSubstancePerAreaMeasure': */
class SOAP_CMAC eml21__AmountOfSubstancePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerAreaUom'
        enum eml21__AmountOfSubstancePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:768 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt (194)
/* simple XSD type 'eml21:AmountOfSubstancePerAreaMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstancePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:771 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure (195)
/* simple XSD type 'eml21:AmountOfSubstancePerTimeMeasure': */
class SOAP_CMAC eml21__AmountOfSubstancePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerTimeUom'
        enum eml21__AmountOfSubstancePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:774 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt (196)
/* simple XSD type 'eml21:AmountOfSubstancePerTimeMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstancePerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:777 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure (197)
/* simple XSD type 'eml21:AmountOfSubstancePerTimePerAreaMeasure': */
class SOAP_CMAC eml21__AmountOfSubstancePerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerTimePerAreaUom'
        enum eml21__AmountOfSubstancePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:780 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt (198)
/* simple XSD type 'eml21:AmountOfSubstancePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstancePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:783 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure (199)
/* simple XSD type 'eml21:AmountOfSubstancePerVolumeMeasure': */
class SOAP_CMAC eml21__AmountOfSubstancePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerVolumeUom'
        enum eml21__AmountOfSubstancePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:786 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt (200)
/* simple XSD type 'eml21:AmountOfSubstancePerVolumeMeasureExt': */
class SOAP_CMAC eml21__AmountOfSubstancePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AmountOfSubstancePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AmountOfSubstancePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AmountOfSubstancePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AmountOfSubstancePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AmountOfSubstancePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AmountOfSubstancePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AmountOfSubstancePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AmountOfSubstancePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:789 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure (201)
/* simple XSD type 'eml21:AnglePerLengthMeasure': */
class SOAP_CMAC eml21__AnglePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AnglePerLengthUom'
        enum eml21__AnglePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AnglePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__AnglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AnglePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__AnglePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AnglePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__AnglePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AnglePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__AnglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:792 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt (202)
/* simple XSD type 'eml21:AnglePerLengthMeasureExt': */
class SOAP_CMAC eml21__AnglePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AnglePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AnglePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AnglePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AnglePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AnglePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AnglePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AnglePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AnglePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AnglePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:795 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure (203)
/* simple XSD type 'eml21:AnglePerVolumeMeasure': */
class SOAP_CMAC eml21__AnglePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AnglePerVolumeUom'
        enum eml21__AnglePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AnglePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__AnglePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AnglePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__AnglePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AnglePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__AnglePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AnglePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__AnglePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:798 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt (204)
/* simple XSD type 'eml21:AnglePerVolumeMeasureExt': */
class SOAP_CMAC eml21__AnglePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AnglePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AnglePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AnglePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AnglePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AnglePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AnglePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AnglePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AnglePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AnglePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:801 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure (205)
/* simple XSD type 'eml21:AngularAccelerationMeasure': */
class SOAP_CMAC eml21__AngularAccelerationMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AngularAccelerationUom'
        enum eml21__AngularAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AngularAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml21__AngularAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AngularAccelerationMeasure); }
      public:
        /// Constructor with initializations
        eml21__AngularAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AngularAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml21__AngularAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AngularAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml21__AngularAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:804 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt (206)
/* simple XSD type 'eml21:AngularAccelerationMeasureExt': */
class SOAP_CMAC eml21__AngularAccelerationMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AngularAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AngularAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AngularAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AngularAccelerationMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AngularAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AngularAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AngularAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AngularAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AngularAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:807 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure (207)
/* simple XSD type 'eml21:AngularVelocityMeasure': */
class SOAP_CMAC eml21__AngularVelocityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AngularVelocityUom'
        enum eml21__AngularVelocityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AngularVelocityMeasure, default initialized and not managed by a soap context
        virtual eml21__AngularVelocityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AngularVelocityMeasure); }
      public:
        /// Constructor with initializations
        eml21__AngularVelocityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AngularVelocityMeasure() { }
        /// Friend allocator used by soap_new_eml21__AngularVelocityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AngularVelocityMeasure * SOAP_FMAC2 soap_instantiate_eml21__AngularVelocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:810 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt (208)
/* simple XSD type 'eml21:AngularVelocityMeasureExt': */
class SOAP_CMAC eml21__AngularVelocityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AngularVelocityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AngularVelocityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AngularVelocityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AngularVelocityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AngularVelocityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AngularVelocityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AngularVelocityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AngularVelocityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AngularVelocityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:813 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure (209)
/* simple XSD type 'eml21:APIGammaRayMeasure': */
class SOAP_CMAC eml21__APIGammaRayMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APIGammaRayUom'
        enum eml21__APIGammaRayUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APIGammaRayMeasure, default initialized and not managed by a soap context
        virtual eml21__APIGammaRayMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__APIGammaRayMeasure); }
      public:
        /// Constructor with initializations
        eml21__APIGammaRayMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__APIGammaRayMeasure() { }
        /// Friend allocator used by soap_new_eml21__APIGammaRayMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__APIGammaRayMeasure * SOAP_FMAC2 soap_instantiate_eml21__APIGammaRayMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:816 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt (210)
/* simple XSD type 'eml21:APIGammaRayMeasureExt': */
class SOAP_CMAC eml21__APIGammaRayMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APIGammaRayUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APIGammaRayMeasureExt, default initialized and not managed by a soap context
        virtual eml21__APIGammaRayMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__APIGammaRayMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__APIGammaRayMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__APIGammaRayMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__APIGammaRayMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__APIGammaRayMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__APIGammaRayMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:819 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure (211)
/* simple XSD type 'eml21:APIGravityMeasure': */
class SOAP_CMAC eml21__APIGravityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APIGravityUom'
        enum eml21__APIGravityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APIGravityMeasure, default initialized and not managed by a soap context
        virtual eml21__APIGravityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__APIGravityMeasure); }
      public:
        /// Constructor with initializations
        eml21__APIGravityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__APIGravityMeasure() { }
        /// Friend allocator used by soap_new_eml21__APIGravityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__APIGravityMeasure * SOAP_FMAC2 soap_instantiate_eml21__APIGravityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:822 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt (212)
/* simple XSD type 'eml21:APIGravityMeasureExt': */
class SOAP_CMAC eml21__APIGravityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APIGravityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APIGravityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__APIGravityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__APIGravityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__APIGravityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__APIGravityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__APIGravityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__APIGravityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__APIGravityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:825 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure (213)
/* simple XSD type 'eml21:APINeutronMeasure': */
class SOAP_CMAC eml21__APINeutronMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APINeutronUom'
        enum eml21__APINeutronUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APINeutronMeasure, default initialized and not managed by a soap context
        virtual eml21__APINeutronMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__APINeutronMeasure); }
      public:
        /// Constructor with initializations
        eml21__APINeutronMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__APINeutronMeasure() { }
        /// Friend allocator used by soap_new_eml21__APINeutronMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__APINeutronMeasure * SOAP_FMAC2 soap_instantiate_eml21__APINeutronMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:828 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt (214)
/* simple XSD type 'eml21:APINeutronMeasureExt': */
class SOAP_CMAC eml21__APINeutronMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:APINeutronUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__APINeutronMeasureExt, default initialized and not managed by a soap context
        virtual eml21__APINeutronMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__APINeutronMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__APINeutronMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__APINeutronMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__APINeutronMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__APINeutronMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__APINeutronMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:831 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure (215)
/* simple XSD type 'eml21:AreaMeasure': */
class SOAP_CMAC eml21__AreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaUom'
        enum eml21__AreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:834 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt (216)
/* simple XSD type 'eml21:AreaMeasureExt': */
class SOAP_CMAC eml21__AreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:837 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure (217)
/* simple XSD type 'eml21:AreaPerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml21__AreaPerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerAmountOfSubstanceUom'
        enum eml21__AreaPerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerAmountOfSubstanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:840 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt (218)
/* simple XSD type 'eml21:AreaPerAmountOfSubstanceMeasureExt': */
class SOAP_CMAC eml21__AreaPerAmountOfSubstanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerAmountOfSubstanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerAmountOfSubstanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerAmountOfSubstanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerAmountOfSubstanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerAmountOfSubstanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerAmountOfSubstanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerAmountOfSubstanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerAmountOfSubstanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:843 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure (219)
/* simple XSD type 'eml21:AreaPerAreaMeasure': */
class SOAP_CMAC eml21__AreaPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerAreaUom'
        enum eml21__AreaPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:846 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt (220)
/* simple XSD type 'eml21:AreaPerAreaMeasureExt': */
class SOAP_CMAC eml21__AreaPerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:849 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure (221)
/* simple XSD type 'eml21:AreaPerCountMeasure': */
class SOAP_CMAC eml21__AreaPerCountMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerCountUom'
        enum eml21__AreaPerCountUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerCountMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerCountMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerCountMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerCountMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerCountMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerCountMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerCountMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerCountMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:852 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt (222)
/* simple XSD type 'eml21:AreaPerCountMeasureExt': */
class SOAP_CMAC eml21__AreaPerCountMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerCountUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerCountMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerCountMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerCountMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerCountMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerCountMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerCountMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerCountMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerCountMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:855 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure (223)
/* simple XSD type 'eml21:AreaPerMassMeasure': */
class SOAP_CMAC eml21__AreaPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerMassUom'
        enum eml21__AreaPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:858 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt (224)
/* simple XSD type 'eml21:AreaPerMassMeasureExt': */
class SOAP_CMAC eml21__AreaPerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:861 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure (225)
/* simple XSD type 'eml21:AreaPerTimeMeasure': */
class SOAP_CMAC eml21__AreaPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerTimeUom'
        enum eml21__AreaPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:864 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt (226)
/* simple XSD type 'eml21:AreaPerTimeMeasureExt': */
class SOAP_CMAC eml21__AreaPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:867 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure (227)
/* simple XSD type 'eml21:AreaPerVolumeMeasure': */
class SOAP_CMAC eml21__AreaPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerVolumeUom'
        enum eml21__AreaPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__AreaPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__AreaPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__AreaPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__AreaPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:870 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt (228)
/* simple XSD type 'eml21:AreaPerVolumeMeasureExt': */
class SOAP_CMAC eml21__AreaPerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AreaPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AreaPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AreaPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AreaPerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AreaPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AreaPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AreaPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AreaPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AreaPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:873 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure (229)
/* simple XSD type 'eml21:AttenuationPerFrequencyIntervalMeasure': */
class SOAP_CMAC eml21__AttenuationPerFrequencyIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AttenuationPerFrequencyIntervalUom'
        enum eml21__AttenuationPerFrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AttenuationPerFrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml21__AttenuationPerFrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__AttenuationPerFrequencyIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml21__AttenuationPerFrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__AttenuationPerFrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml21__AttenuationPerFrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__AttenuationPerFrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml21__AttenuationPerFrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:876 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt (230)
/* simple XSD type 'eml21:AttenuationPerFrequencyIntervalMeasureExt': */
class SOAP_CMAC eml21__AttenuationPerFrequencyIntervalMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:AttenuationPerFrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AttenuationPerFrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml21__AttenuationPerFrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__AttenuationPerFrequencyIntervalMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__AttenuationPerFrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__AttenuationPerFrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__AttenuationPerFrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__AttenuationPerFrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:879 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure (231)
/* simple XSD type 'eml21:CapacitanceMeasure': */
class SOAP_CMAC eml21__CapacitanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:CapacitanceUom'
        enum eml21__CapacitanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__CapacitanceMeasure, default initialized and not managed by a soap context
        virtual eml21__CapacitanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__CapacitanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__CapacitanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__CapacitanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__CapacitanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__CapacitanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__CapacitanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:882 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt (232)
/* simple XSD type 'eml21:CapacitanceMeasureExt': */
class SOAP_CMAC eml21__CapacitanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:CapacitanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__CapacitanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__CapacitanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__CapacitanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__CapacitanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__CapacitanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__CapacitanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__CapacitanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__CapacitanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:885 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure (233)
/* simple XSD type 'eml21:CationExchangeCapacityMeasure': */
class SOAP_CMAC eml21__CationExchangeCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:CationExchangeCapacityUom'
        enum eml21__CationExchangeCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__CationExchangeCapacityMeasure, default initialized and not managed by a soap context
        virtual eml21__CationExchangeCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__CationExchangeCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml21__CationExchangeCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__CationExchangeCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml21__CationExchangeCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__CationExchangeCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml21__CationExchangeCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:888 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt (234)
/* simple XSD type 'eml21:CationExchangeCapacityMeasureExt': */
class SOAP_CMAC eml21__CationExchangeCapacityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:CationExchangeCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__CationExchangeCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__CationExchangeCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__CationExchangeCapacityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__CationExchangeCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__CationExchangeCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__CationExchangeCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__CationExchangeCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__CationExchangeCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:891 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure (235)
/* simple XSD type 'eml21:DataTransferSpeedMeasure': */
class SOAP_CMAC eml21__DataTransferSpeedMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DataTransferSpeedUom'
        enum eml21__DataTransferSpeedUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DataTransferSpeedMeasure, default initialized and not managed by a soap context
        virtual eml21__DataTransferSpeedMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DataTransferSpeedMeasure); }
      public:
        /// Constructor with initializations
        eml21__DataTransferSpeedMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DataTransferSpeedMeasure() { }
        /// Friend allocator used by soap_new_eml21__DataTransferSpeedMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DataTransferSpeedMeasure * SOAP_FMAC2 soap_instantiate_eml21__DataTransferSpeedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:894 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt (236)
/* simple XSD type 'eml21:DataTransferSpeedMeasureExt': */
class SOAP_CMAC eml21__DataTransferSpeedMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DataTransferSpeedUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DataTransferSpeedMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DataTransferSpeedMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DataTransferSpeedMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DataTransferSpeedMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DataTransferSpeedMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DataTransferSpeedMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DataTransferSpeedMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DataTransferSpeedMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:897 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure (237)
/* simple XSD type 'eml21:DiffusionCoefficientMeasure': */
class SOAP_CMAC eml21__DiffusionCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DiffusionCoefficientUom'
        enum eml21__DiffusionCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DiffusionCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml21__DiffusionCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DiffusionCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml21__DiffusionCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DiffusionCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml21__DiffusionCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DiffusionCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml21__DiffusionCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:900 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt (238)
/* simple XSD type 'eml21:DiffusionCoefficientMeasureExt': */
class SOAP_CMAC eml21__DiffusionCoefficientMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DiffusionCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DiffusionCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DiffusionCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DiffusionCoefficientMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DiffusionCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DiffusionCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DiffusionCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DiffusionCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DiffusionCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:903 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure (239)
/* simple XSD type 'eml21:DiffusiveTimeOfFlightMeasure': */
class SOAP_CMAC eml21__DiffusiveTimeOfFlightMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DiffusiveTimeOfFlightUom'
        enum eml21__DiffusiveTimeOfFlightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DiffusiveTimeOfFlightMeasure, default initialized and not managed by a soap context
        virtual eml21__DiffusiveTimeOfFlightMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DiffusiveTimeOfFlightMeasure); }
      public:
        /// Constructor with initializations
        eml21__DiffusiveTimeOfFlightMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DiffusiveTimeOfFlightMeasure() { }
        /// Friend allocator used by soap_new_eml21__DiffusiveTimeOfFlightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DiffusiveTimeOfFlightMeasure * SOAP_FMAC2 soap_instantiate_eml21__DiffusiveTimeOfFlightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:906 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt (240)
/* simple XSD type 'eml21:DiffusiveTimeOfFlightMeasureExt': */
class SOAP_CMAC eml21__DiffusiveTimeOfFlightMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DiffusiveTimeOfFlightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DiffusiveTimeOfFlightMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DiffusiveTimeOfFlightMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DiffusiveTimeOfFlightMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DiffusiveTimeOfFlightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DiffusiveTimeOfFlightMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DiffusiveTimeOfFlightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DiffusiveTimeOfFlightMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DiffusiveTimeOfFlightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:909 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure (241)
/* simple XSD type 'eml21:DigitalStorageMeasure': */
class SOAP_CMAC eml21__DigitalStorageMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DigitalStorageUom'
        enum eml21__DigitalStorageUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DigitalStorageMeasure, default initialized and not managed by a soap context
        virtual eml21__DigitalStorageMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DigitalStorageMeasure); }
      public:
        /// Constructor with initializations
        eml21__DigitalStorageMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DigitalStorageMeasure() { }
        /// Friend allocator used by soap_new_eml21__DigitalStorageMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DigitalStorageMeasure * SOAP_FMAC2 soap_instantiate_eml21__DigitalStorageMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:912 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt (242)
/* simple XSD type 'eml21:DigitalStorageMeasureExt': */
class SOAP_CMAC eml21__DigitalStorageMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DigitalStorageUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DigitalStorageMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DigitalStorageMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DigitalStorageMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DigitalStorageMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DigitalStorageMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DigitalStorageMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DigitalStorageMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DigitalStorageMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:915 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure (243)
/* simple XSD type 'eml21:DimensionlessMeasure': */
class SOAP_CMAC eml21__DimensionlessMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DimensionlessUom'
        enum eml21__DimensionlessUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DimensionlessMeasure, default initialized and not managed by a soap context
        virtual eml21__DimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DimensionlessMeasure); }
      public:
        /// Constructor with initializations
        eml21__DimensionlessMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DimensionlessMeasure() { }
        /// Friend allocator used by soap_new_eml21__DimensionlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DimensionlessMeasure * SOAP_FMAC2 soap_instantiate_eml21__DimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:918 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt (244)
/* simple XSD type 'eml21:DimensionlessMeasureExt': */
class SOAP_CMAC eml21__DimensionlessMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DimensionlessUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DimensionlessMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DimensionlessMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DimensionlessMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DimensionlessMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DimensionlessMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DimensionlessMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DimensionlessMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DimensionlessMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:921 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure (245)
/* simple XSD type 'eml21:DipoleMomentMeasure': */
class SOAP_CMAC eml21__DipoleMomentMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DipoleMomentUom'
        enum eml21__DipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml21__DipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DipoleMomentMeasure); }
      public:
        /// Constructor with initializations
        eml21__DipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml21__DipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml21__DipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:924 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt (246)
/* simple XSD type 'eml21:DipoleMomentMeasureExt': */
class SOAP_CMAC eml21__DipoleMomentMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DipoleMomentMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:927 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure (247)
/* simple XSD type 'eml21:DoseEquivalentMeasure': */
class SOAP_CMAC eml21__DoseEquivalentMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DoseEquivalentUom'
        enum eml21__DoseEquivalentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DoseEquivalentMeasure, default initialized and not managed by a soap context
        virtual eml21__DoseEquivalentMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DoseEquivalentMeasure); }
      public:
        /// Constructor with initializations
        eml21__DoseEquivalentMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DoseEquivalentMeasure() { }
        /// Friend allocator used by soap_new_eml21__DoseEquivalentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DoseEquivalentMeasure * SOAP_FMAC2 soap_instantiate_eml21__DoseEquivalentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:930 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt (248)
/* simple XSD type 'eml21:DoseEquivalentMeasureExt': */
class SOAP_CMAC eml21__DoseEquivalentMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DoseEquivalentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DoseEquivalentMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DoseEquivalentMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DoseEquivalentMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DoseEquivalentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DoseEquivalentMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DoseEquivalentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DoseEquivalentMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DoseEquivalentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:933 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure (249)
/* simple XSD type 'eml21:DynamicViscosityMeasure': */
class SOAP_CMAC eml21__DynamicViscosityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DynamicViscosityUom'
        enum eml21__DynamicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DynamicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml21__DynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__DynamicViscosityMeasure); }
      public:
        /// Constructor with initializations
        eml21__DynamicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__DynamicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml21__DynamicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__DynamicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml21__DynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:936 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt (250)
/* simple XSD type 'eml21:DynamicViscosityMeasureExt': */
class SOAP_CMAC eml21__DynamicViscosityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:DynamicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DynamicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__DynamicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__DynamicViscosityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__DynamicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__DynamicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__DynamicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__DynamicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__DynamicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:939 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure (251)
/* simple XSD type 'eml21:ElectricalResistivityMeasure': */
class SOAP_CMAC eml21__ElectricalResistivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricalResistivityUom'
        enum eml21__ElectricalResistivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricalResistivityMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricalResistivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricalResistivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricalResistivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricalResistivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricalResistivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricalResistivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricalResistivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:942 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt (252)
/* simple XSD type 'eml21:ElectricalResistivityMeasureExt': */
class SOAP_CMAC eml21__ElectricalResistivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricalResistivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricalResistivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricalResistivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricalResistivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricalResistivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricalResistivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricalResistivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricalResistivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricalResistivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:945 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure (253)
/* simple XSD type 'eml21:ElectricChargeMeasure': */
class SOAP_CMAC eml21__ElectricChargeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargeUom'
        enum eml21__ElectricChargeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargeMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricChargeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:948 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt (254)
/* simple XSD type 'eml21:ElectricChargeMeasureExt': */
class SOAP_CMAC eml21__ElectricChargeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricChargeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:951 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure (255)
/* simple XSD type 'eml21:ElectricChargePerAreaMeasure': */
class SOAP_CMAC eml21__ElectricChargePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerAreaUom'
        enum eml21__ElectricChargePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:954 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt (256)
/* simple XSD type 'eml21:ElectricChargePerAreaMeasureExt': */
class SOAP_CMAC eml21__ElectricChargePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:957 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure (257)
/* simple XSD type 'eml21:ElectricChargePerMassMeasure': */
class SOAP_CMAC eml21__ElectricChargePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerMassUom'
        enum eml21__ElectricChargePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:960 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt (258)
/* simple XSD type 'eml21:ElectricChargePerMassMeasureExt': */
class SOAP_CMAC eml21__ElectricChargePerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:963 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure (259)
/* simple XSD type 'eml21:ElectricChargePerVolumeMeasure': */
class SOAP_CMAC eml21__ElectricChargePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerVolumeUom'
        enum eml21__ElectricChargePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:966 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt (260)
/* simple XSD type 'eml21:ElectricChargePerVolumeMeasureExt': */
class SOAP_CMAC eml21__ElectricChargePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricChargePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricChargePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricChargePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricChargePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricChargePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricChargePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricChargePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricChargePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricChargePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:969 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure (261)
/* simple XSD type 'eml21:ElectricConductanceMeasure': */
class SOAP_CMAC eml21__ElectricConductanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricConductanceUom'
        enum eml21__ElectricConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricConductanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricConductanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:972 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt (262)
/* simple XSD type 'eml21:ElectricConductanceMeasureExt': */
class SOAP_CMAC eml21__ElectricConductanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricConductanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:975 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure (263)
/* simple XSD type 'eml21:ElectricConductivityMeasure': */
class SOAP_CMAC eml21__ElectricConductivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricConductivityUom'
        enum eml21__ElectricConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricConductivityMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricConductivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:978 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt (264)
/* simple XSD type 'eml21:ElectricConductivityMeasureExt': */
class SOAP_CMAC eml21__ElectricConductivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricConductivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:981 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure (265)
/* simple XSD type 'eml21:ElectricCurrentDensityMeasure': */
class SOAP_CMAC eml21__ElectricCurrentDensityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricCurrentDensityUom'
        enum eml21__ElectricCurrentDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricCurrentDensityMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricCurrentDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricCurrentDensityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricCurrentDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricCurrentDensityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricCurrentDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricCurrentDensityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricCurrentDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:984 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt (266)
/* simple XSD type 'eml21:ElectricCurrentDensityMeasureExt': */
class SOAP_CMAC eml21__ElectricCurrentDensityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricCurrentDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricCurrentDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricCurrentDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricCurrentDensityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricCurrentDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricCurrentDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricCurrentDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricCurrentDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricCurrentDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:987 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure (267)
/* simple XSD type 'eml21:ElectricCurrentMeasure': */
class SOAP_CMAC eml21__ElectricCurrentMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricCurrentUom'
        enum eml21__ElectricCurrentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricCurrentMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricCurrentMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricCurrentMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricCurrentMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricCurrentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricCurrentMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:990 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt (268)
/* simple XSD type 'eml21:ElectricCurrentMeasureExt': */
class SOAP_CMAC eml21__ElectricCurrentMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricCurrentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricCurrentMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricCurrentMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricCurrentMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricCurrentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricCurrentMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricCurrentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricCurrentMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricCurrentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:993 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure (269)
/* simple XSD type 'eml21:ElectricFieldStrengthMeasure': */
class SOAP_CMAC eml21__ElectricFieldStrengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricFieldStrengthUom'
        enum eml21__ElectricFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricFieldStrengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:996 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt (270)
/* simple XSD type 'eml21:ElectricFieldStrengthMeasureExt': */
class SOAP_CMAC eml21__ElectricFieldStrengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricFieldStrengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:999 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure (271)
/* simple XSD type 'eml21:ElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml21__ElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricPotentialDifferenceUom'
        enum eml21__ElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1002 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt (272)
/* simple XSD type 'eml21:ElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml21__ElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1005 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure (273)
/* simple XSD type 'eml21:ElectricResistanceMeasure': */
class SOAP_CMAC eml21__ElectricResistanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricResistanceUom'
        enum eml21__ElectricResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricResistanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricResistanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1008 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt (274)
/* simple XSD type 'eml21:ElectricResistanceMeasureExt': */
class SOAP_CMAC eml21__ElectricResistanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricResistanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1011 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure (275)
/* simple XSD type 'eml21:ElectricResistancePerLengthMeasure': */
class SOAP_CMAC eml21__ElectricResistancePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricResistancePerLengthUom'
        enum eml21__ElectricResistancePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricResistancePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectricResistancePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricResistancePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectricResistancePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricResistancePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectricResistancePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricResistancePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectricResistancePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1014 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt (276)
/* simple XSD type 'eml21:ElectricResistancePerLengthMeasureExt': */
class SOAP_CMAC eml21__ElectricResistancePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectricResistancePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectricResistancePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectricResistancePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectricResistancePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectricResistancePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectricResistancePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectricResistancePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectricResistancePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectricResistancePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1017 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure (277)
/* simple XSD type 'eml21:ElectromagneticMomentMeasure': */
class SOAP_CMAC eml21__ElectromagneticMomentMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectromagneticMomentUom'
        enum eml21__ElectromagneticMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectromagneticMomentMeasure, default initialized and not managed by a soap context
        virtual eml21__ElectromagneticMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ElectromagneticMomentMeasure); }
      public:
        /// Constructor with initializations
        eml21__ElectromagneticMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ElectromagneticMomentMeasure() { }
        /// Friend allocator used by soap_new_eml21__ElectromagneticMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectromagneticMomentMeasure * SOAP_FMAC2 soap_instantiate_eml21__ElectromagneticMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1020 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt (278)
/* simple XSD type 'eml21:ElectromagneticMomentMeasureExt': */
class SOAP_CMAC eml21__ElectromagneticMomentMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ElectromagneticMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ElectromagneticMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ElectromagneticMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ElectromagneticMomentMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ElectromagneticMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ElectromagneticMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ElectromagneticMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ElectromagneticMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ElectromagneticMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1023 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure (279)
/* simple XSD type 'eml21:EnergyLengthPerAreaMeasure': */
class SOAP_CMAC eml21__EnergyLengthPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyLengthPerAreaUom'
        enum eml21__EnergyLengthPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyLengthPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyLengthPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyLengthPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyLengthPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyLengthPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyLengthPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyLengthPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyLengthPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1026 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt (280)
/* simple XSD type 'eml21:EnergyLengthPerAreaMeasureExt': */
class SOAP_CMAC eml21__EnergyLengthPerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyLengthPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyLengthPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyLengthPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyLengthPerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyLengthPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyLengthPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyLengthPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyLengthPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyLengthPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1029 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure (281)
/* simple XSD type 'eml21:EnergyLengthPerTimeAreaTemperatureMeasure': */
class SOAP_CMAC eml21__EnergyLengthPerTimeAreaTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyLengthPerTimeAreaTemperatureUom'
        enum eml21__EnergyLengthPerTimeAreaTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyLengthPerTimeAreaTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyLengthPerTimeAreaTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyLengthPerTimeAreaTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyLengthPerTimeAreaTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyLengthPerTimeAreaTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyLengthPerTimeAreaTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1032 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt (282)
/* simple XSD type 'eml21:EnergyLengthPerTimeAreaTemperatureMeasureExt': */
class SOAP_CMAC eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyLengthPerTimeAreaTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1035 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure (283)
/* simple XSD type 'eml21:EnergyMeasure': */
class SOAP_CMAC eml21__EnergyMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyUom'
        enum eml21__EnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1038 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt (284)
/* simple XSD type 'eml21:EnergyMeasureExt': */
class SOAP_CMAC eml21__EnergyMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1041 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure (285)
/* simple XSD type 'eml21:EnergyPerAreaMeasure': */
class SOAP_CMAC eml21__EnergyPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerAreaUom'
        enum eml21__EnergyPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1044 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt (286)
/* simple XSD type 'eml21:EnergyPerAreaMeasureExt': */
class SOAP_CMAC eml21__EnergyPerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1047 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure (287)
/* simple XSD type 'eml21:EnergyPerLengthMeasure': */
class SOAP_CMAC eml21__EnergyPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerLengthUom'
        enum eml21__EnergyPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1050 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt (288)
/* simple XSD type 'eml21:EnergyPerLengthMeasureExt': */
class SOAP_CMAC eml21__EnergyPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1053 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure (289)
/* simple XSD type 'eml21:EnergyPerMassMeasure': */
class SOAP_CMAC eml21__EnergyPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerMassUom'
        enum eml21__EnergyPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1056 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt (290)
/* simple XSD type 'eml21:EnergyPerMassMeasureExt': */
class SOAP_CMAC eml21__EnergyPerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1059 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure (291)
/* simple XSD type 'eml21:EnergyPerMassPerTimeMeasure': */
class SOAP_CMAC eml21__EnergyPerMassPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerMassPerTimeUom'
        enum eml21__EnergyPerMassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerMassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyPerMassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerMassPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerMassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerMassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerMassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerMassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerMassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1062 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt (292)
/* simple XSD type 'eml21:EnergyPerMassPerTimeMeasureExt': */
class SOAP_CMAC eml21__EnergyPerMassPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerMassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerMassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyPerMassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerMassPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerMassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerMassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerMassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerMassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerMassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1065 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure (293)
/* simple XSD type 'eml21:EnergyPerVolumeMeasure': */
class SOAP_CMAC eml21__EnergyPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerVolumeUom'
        enum eml21__EnergyPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__EnergyPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1068 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt (294)
/* simple XSD type 'eml21:EnergyPerVolumeMeasureExt': */
class SOAP_CMAC eml21__EnergyPerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:EnergyPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__EnergyPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__EnergyPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__EnergyPerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__EnergyPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__EnergyPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__EnergyPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__EnergyPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__EnergyPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1071 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure (295)
/* simple XSD type 'eml21:ForceAreaMeasure': */
class SOAP_CMAC eml21__ForceAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceAreaUom'
        enum eml21__ForceAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__ForceAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForceAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForceAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForceAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForceAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForceAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1074 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt (296)
/* simple XSD type 'eml21:ForceAreaMeasureExt': */
class SOAP_CMAC eml21__ForceAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForceAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForceAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForceAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForceAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForceAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForceAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1077 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure (297)
/* simple XSD type 'eml21:ForceLengthPerLengthMeasure': */
class SOAP_CMAC eml21__ForceLengthPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceLengthPerLengthUom'
        enum eml21__ForceLengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceLengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__ForceLengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForceLengthPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForceLengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForceLengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForceLengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceLengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForceLengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1080 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt (298)
/* simple XSD type 'eml21:ForceLengthPerLengthMeasureExt': */
class SOAP_CMAC eml21__ForceLengthPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceLengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceLengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForceLengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForceLengthPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForceLengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForceLengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForceLengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceLengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForceLengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1083 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure (299)
/* simple XSD type 'eml21:ForceMeasure': */
class SOAP_CMAC eml21__ForceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceUom'
        enum eml21__ForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceMeasure, default initialized and not managed by a soap context
        virtual eml21__ForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1086 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt (300)
/* simple XSD type 'eml21:ForceMeasureExt': */
class SOAP_CMAC eml21__ForceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1089 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure (301)
/* simple XSD type 'eml21:ForcePerForceMeasure': */
class SOAP_CMAC eml21__ForcePerForceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerForceUom'
        enum eml21__ForcePerForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerForceMeasure, default initialized and not managed by a soap context
        virtual eml21__ForcePerForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerForceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForcePerForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerForceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForcePerForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerForceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForcePerForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1092 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt (302)
/* simple XSD type 'eml21:ForcePerForceMeasureExt': */
class SOAP_CMAC eml21__ForcePerForceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerForceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForcePerForceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerForceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForcePerForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForcePerForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForcePerForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1095 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure (303)
/* simple XSD type 'eml21:ForcePerLengthMeasure': */
class SOAP_CMAC eml21__ForcePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerLengthUom'
        enum eml21__ForcePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__ForcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForcePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForcePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1098 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt (304)
/* simple XSD type 'eml21:ForcePerLengthMeasureExt': */
class SOAP_CMAC eml21__ForcePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForcePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForcePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForcePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForcePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1101 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure (305)
/* simple XSD type 'eml21:ForcePerVolumeMeasure': */
class SOAP_CMAC eml21__ForcePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerVolumeUom'
        enum eml21__ForcePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__ForcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ForcePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ForcePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ForcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1104 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt (306)
/* simple XSD type 'eml21:ForcePerVolumeMeasureExt': */
class SOAP_CMAC eml21__ForcePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ForcePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ForcePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ForcePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ForcePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ForcePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ForcePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ForcePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ForcePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ForcePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1107 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure (307)
/* simple XSD type 'eml21:FrequencyIntervalMeasure': */
class SOAP_CMAC eml21__FrequencyIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:FrequencyIntervalUom'
        enum eml21__FrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml21__FrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__FrequencyIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml21__FrequencyIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__FrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml21__FrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__FrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml21__FrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1110 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt (308)
/* simple XSD type 'eml21:FrequencyIntervalMeasureExt': */
class SOAP_CMAC eml21__FrequencyIntervalMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:FrequencyIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FrequencyIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml21__FrequencyIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__FrequencyIntervalMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__FrequencyIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__FrequencyIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__FrequencyIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__FrequencyIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__FrequencyIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1113 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure (309)
/* simple XSD type 'eml21:FrequencyMeasure': */
class SOAP_CMAC eml21__FrequencyMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:FrequencyUom'
        enum eml21__FrequencyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FrequencyMeasure, default initialized and not managed by a soap context
        virtual eml21__FrequencyMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__FrequencyMeasure); }
      public:
        /// Constructor with initializations
        eml21__FrequencyMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__FrequencyMeasure() { }
        /// Friend allocator used by soap_new_eml21__FrequencyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__FrequencyMeasure * SOAP_FMAC2 soap_instantiate_eml21__FrequencyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1116 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt (310)
/* simple XSD type 'eml21:FrequencyMeasureExt': */
class SOAP_CMAC eml21__FrequencyMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:FrequencyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FrequencyMeasureExt, default initialized and not managed by a soap context
        virtual eml21__FrequencyMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__FrequencyMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__FrequencyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__FrequencyMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__FrequencyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__FrequencyMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__FrequencyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1119 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure (311)
/* simple XSD type 'eml21:HeatCapacityMeasure': */
class SOAP_CMAC eml21__HeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatCapacityUom'
        enum eml21__HeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml21__HeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__HeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml21__HeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__HeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml21__HeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml21__HeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1122 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt (312)
/* simple XSD type 'eml21:HeatCapacityMeasureExt': */
class SOAP_CMAC eml21__HeatCapacityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__HeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__HeatCapacityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__HeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__HeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__HeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__HeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1125 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure (313)
/* simple XSD type 'eml21:HeatFlowRateMeasure': */
class SOAP_CMAC eml21__HeatFlowRateMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatFlowRateUom'
        enum eml21__HeatFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml21__HeatFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__HeatFlowRateMeasure); }
      public:
        /// Constructor with initializations
        eml21__HeatFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__HeatFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml21__HeatFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml21__HeatFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1128 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt (314)
/* simple XSD type 'eml21:HeatFlowRateMeasureExt': */
class SOAP_CMAC eml21__HeatFlowRateMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml21__HeatFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__HeatFlowRateMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__HeatFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__HeatFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__HeatFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__HeatFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1131 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure (315)
/* simple XSD type 'eml21:HeatTransferCoefficientMeasure': */
class SOAP_CMAC eml21__HeatTransferCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatTransferCoefficientUom'
        enum eml21__HeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml21__HeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__HeatTransferCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml21__HeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__HeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml21__HeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml21__HeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1134 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt (316)
/* simple XSD type 'eml21:HeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml21__HeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:HeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__HeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml21__HeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__HeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__HeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__HeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__HeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__HeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__HeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1137 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure (317)
/* simple XSD type 'eml21:IlluminanceMeasure': */
class SOAP_CMAC eml21__IlluminanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:IlluminanceUom'
        enum eml21__IlluminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IlluminanceMeasure, default initialized and not managed by a soap context
        virtual eml21__IlluminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__IlluminanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__IlluminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__IlluminanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__IlluminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__IlluminanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__IlluminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1140 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt (318)
/* simple XSD type 'eml21:IlluminanceMeasureExt': */
class SOAP_CMAC eml21__IlluminanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:IlluminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IlluminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__IlluminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__IlluminanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__IlluminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__IlluminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__IlluminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__IlluminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__IlluminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1143 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure (319)
/* simple XSD type 'eml21:InductanceMeasure': */
class SOAP_CMAC eml21__InductanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:InductanceUom'
        enum eml21__InductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__InductanceMeasure, default initialized and not managed by a soap context
        virtual eml21__InductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__InductanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__InductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__InductanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__InductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__InductanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__InductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1146 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt (320)
/* simple XSD type 'eml21:InductanceMeasureExt': */
class SOAP_CMAC eml21__InductanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:InductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__InductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__InductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__InductanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__InductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__InductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__InductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__InductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__InductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1149 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure (321)
/* simple XSD type 'eml21:IsothermalCompressibilityMeasure': */
class SOAP_CMAC eml21__IsothermalCompressibilityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:IsothermalCompressibilityUom'
        enum eml21__IsothermalCompressibilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IsothermalCompressibilityMeasure, default initialized and not managed by a soap context
        virtual eml21__IsothermalCompressibilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__IsothermalCompressibilityMeasure); }
      public:
        /// Constructor with initializations
        eml21__IsothermalCompressibilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__IsothermalCompressibilityMeasure() { }
        /// Friend allocator used by soap_new_eml21__IsothermalCompressibilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__IsothermalCompressibilityMeasure * SOAP_FMAC2 soap_instantiate_eml21__IsothermalCompressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1152 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt (322)
/* simple XSD type 'eml21:IsothermalCompressibilityMeasureExt': */
class SOAP_CMAC eml21__IsothermalCompressibilityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:IsothermalCompressibilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IsothermalCompressibilityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__IsothermalCompressibilityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__IsothermalCompressibilityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__IsothermalCompressibilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__IsothermalCompressibilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__IsothermalCompressibilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__IsothermalCompressibilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__IsothermalCompressibilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1155 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure (323)
/* simple XSD type 'eml21:KinematicViscosityMeasure': */
class SOAP_CMAC eml21__KinematicViscosityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:KinematicViscosityUom'
        enum eml21__KinematicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__KinematicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml21__KinematicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__KinematicViscosityMeasure); }
      public:
        /// Constructor with initializations
        eml21__KinematicViscosityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__KinematicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml21__KinematicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__KinematicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml21__KinematicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1158 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt (324)
/* simple XSD type 'eml21:KinematicViscosityMeasureExt': */
class SOAP_CMAC eml21__KinematicViscosityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:KinematicViscosityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__KinematicViscosityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__KinematicViscosityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__KinematicViscosityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__KinematicViscosityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__KinematicViscosityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__KinematicViscosityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__KinematicViscosityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__KinematicViscosityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1161 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure (325)
/* simple XSD type 'eml21:LengthMeasure': */
class SOAP_CMAC eml21__LengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthUom'
        enum eml21__LengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1164 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt (326)
/* simple XSD type 'eml21:LengthMeasureExt': */
class SOAP_CMAC eml21__LengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1167 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure (327)
/* simple XSD type 'eml21:LengthPerLengthMeasure': */
class SOAP_CMAC eml21__LengthPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerLengthUom'
        enum eml21__LengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1170 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt (328)
/* simple XSD type 'eml21:LengthPerLengthMeasureExt': */
class SOAP_CMAC eml21__LengthPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1173 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure (329)
/* simple XSD type 'eml21:LengthPerMassMeasure': */
class SOAP_CMAC eml21__LengthPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerMassUom'
        enum eml21__LengthPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1176 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt (330)
/* simple XSD type 'eml21:LengthPerMassMeasureExt': */
class SOAP_CMAC eml21__LengthPerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1179 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure (331)
/* simple XSD type 'eml21:LengthPerPressureMeasure': */
class SOAP_CMAC eml21__LengthPerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerPressureUom'
        enum eml21__LengthPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1182 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt (332)
/* simple XSD type 'eml21:LengthPerPressureMeasureExt': */
class SOAP_CMAC eml21__LengthPerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1185 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure (333)
/* simple XSD type 'eml21:LengthPerTemperatureMeasure': */
class SOAP_CMAC eml21__LengthPerTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerTemperatureUom'
        enum eml21__LengthPerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1188 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt (334)
/* simple XSD type 'eml21:LengthPerTemperatureMeasureExt': */
class SOAP_CMAC eml21__LengthPerTemperatureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerTemperatureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1191 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure (335)
/* simple XSD type 'eml21:LengthPerTimeMeasure': */
class SOAP_CMAC eml21__LengthPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerTimeUom'
        enum eml21__LengthPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1194 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt (336)
/* simple XSD type 'eml21:LengthPerTimeMeasureExt': */
class SOAP_CMAC eml21__LengthPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1197 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure (337)
/* simple XSD type 'eml21:LengthPerVolumeMeasure': */
class SOAP_CMAC eml21__LengthPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerVolumeUom'
        enum eml21__LengthPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__LengthPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__LengthPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__LengthPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__LengthPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1200 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt (338)
/* simple XSD type 'eml21:LengthPerVolumeMeasureExt': */
class SOAP_CMAC eml21__LengthPerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LengthPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LengthPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LengthPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LengthPerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LengthPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LengthPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LengthPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LengthPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LengthPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1203 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure (339)
/* simple XSD type 'eml21:LightExposureMeasure': */
class SOAP_CMAC eml21__LightExposureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LightExposureUom'
        enum eml21__LightExposureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LightExposureMeasure, default initialized and not managed by a soap context
        virtual eml21__LightExposureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LightExposureMeasure); }
      public:
        /// Constructor with initializations
        eml21__LightExposureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LightExposureMeasure() { }
        /// Friend allocator used by soap_new_eml21__LightExposureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LightExposureMeasure * SOAP_FMAC2 soap_instantiate_eml21__LightExposureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1206 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt (340)
/* simple XSD type 'eml21:LightExposureMeasureExt': */
class SOAP_CMAC eml21__LightExposureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LightExposureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LightExposureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LightExposureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LightExposureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LightExposureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LightExposureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LightExposureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LightExposureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LightExposureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1209 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure (341)
/* simple XSD type 'eml21:LinearAccelerationMeasure': */
class SOAP_CMAC eml21__LinearAccelerationMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LinearAccelerationUom'
        enum eml21__LinearAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LinearAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml21__LinearAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LinearAccelerationMeasure); }
      public:
        /// Constructor with initializations
        eml21__LinearAccelerationMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LinearAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml21__LinearAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LinearAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml21__LinearAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1212 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt (342)
/* simple XSD type 'eml21:LinearAccelerationMeasureExt': */
class SOAP_CMAC eml21__LinearAccelerationMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LinearAccelerationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LinearAccelerationMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LinearAccelerationMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LinearAccelerationMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LinearAccelerationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LinearAccelerationMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LinearAccelerationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LinearAccelerationMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LinearAccelerationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1215 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure (343)
/* simple XSD type 'eml21:LinearThermalExpansionMeasure': */
class SOAP_CMAC eml21__LinearThermalExpansionMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LinearThermalExpansionUom'
        enum eml21__LinearThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LinearThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml21__LinearThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LinearThermalExpansionMeasure); }
      public:
        /// Constructor with initializations
        eml21__LinearThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LinearThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml21__LinearThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LinearThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml21__LinearThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1218 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt (344)
/* simple XSD type 'eml21:LinearThermalExpansionMeasureExt': */
class SOAP_CMAC eml21__LinearThermalExpansionMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LinearThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LinearThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LinearThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LinearThermalExpansionMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LinearThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LinearThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LinearThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LinearThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LinearThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1221 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure (345)
/* simple XSD type 'eml21:LogarithmicPowerRatioMeasure': */
class SOAP_CMAC eml21__LogarithmicPowerRatioMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LogarithmicPowerRatioUom'
        enum eml21__LogarithmicPowerRatioUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LogarithmicPowerRatioMeasure, default initialized and not managed by a soap context
        virtual eml21__LogarithmicPowerRatioMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LogarithmicPowerRatioMeasure); }
      public:
        /// Constructor with initializations
        eml21__LogarithmicPowerRatioMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LogarithmicPowerRatioMeasure() { }
        /// Friend allocator used by soap_new_eml21__LogarithmicPowerRatioMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LogarithmicPowerRatioMeasure * SOAP_FMAC2 soap_instantiate_eml21__LogarithmicPowerRatioMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1224 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt (346)
/* simple XSD type 'eml21:LogarithmicPowerRatioMeasureExt': */
class SOAP_CMAC eml21__LogarithmicPowerRatioMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LogarithmicPowerRatioUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LogarithmicPowerRatioMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LogarithmicPowerRatioMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LogarithmicPowerRatioMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LogarithmicPowerRatioMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LogarithmicPowerRatioMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LogarithmicPowerRatioMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LogarithmicPowerRatioMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LogarithmicPowerRatioMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1227 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure (347)
/* simple XSD type 'eml21:LogarithmicPowerRatioPerLengthMeasure': */
class SOAP_CMAC eml21__LogarithmicPowerRatioPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LogarithmicPowerRatioPerLengthUom'
        enum eml21__LogarithmicPowerRatioPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LogarithmicPowerRatioPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__LogarithmicPowerRatioPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LogarithmicPowerRatioPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__LogarithmicPowerRatioPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LogarithmicPowerRatioPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LogarithmicPowerRatioPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1230 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt (348)
/* simple XSD type 'eml21:LogarithmicPowerRatioPerLengthMeasureExt': */
class SOAP_CMAC eml21__LogarithmicPowerRatioPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LogarithmicPowerRatioPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LogarithmicPowerRatioPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LogarithmicPowerRatioPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LogarithmicPowerRatioPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LogarithmicPowerRatioPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LogarithmicPowerRatioPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LogarithmicPowerRatioPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LogarithmicPowerRatioPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1233 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure (349)
/* simple XSD type 'eml21:LuminanceMeasure': */
class SOAP_CMAC eml21__LuminanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminanceUom'
        enum eml21__LuminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminanceMeasure, default initialized and not managed by a soap context
        virtual eml21__LuminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LuminanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__LuminanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LuminanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__LuminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__LuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1236 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt (350)
/* simple XSD type 'eml21:LuminanceMeasureExt': */
class SOAP_CMAC eml21__LuminanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LuminanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LuminanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LuminanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LuminanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LuminanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LuminanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1239 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure (351)
/* simple XSD type 'eml21:LuminousEfficacyMeasure': */
class SOAP_CMAC eml21__LuminousEfficacyMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousEfficacyUom'
        enum eml21__LuminousEfficacyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousEfficacyMeasure, default initialized and not managed by a soap context
        virtual eml21__LuminousEfficacyMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousEfficacyMeasure); }
      public:
        /// Constructor with initializations
        eml21__LuminousEfficacyMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousEfficacyMeasure() { }
        /// Friend allocator used by soap_new_eml21__LuminousEfficacyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousEfficacyMeasure * SOAP_FMAC2 soap_instantiate_eml21__LuminousEfficacyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1242 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt (352)
/* simple XSD type 'eml21:LuminousEfficacyMeasureExt': */
class SOAP_CMAC eml21__LuminousEfficacyMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousEfficacyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousEfficacyMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LuminousEfficacyMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousEfficacyMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LuminousEfficacyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousEfficacyMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LuminousEfficacyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousEfficacyMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LuminousEfficacyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1245 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure (353)
/* simple XSD type 'eml21:LuminousFluxMeasure': */
class SOAP_CMAC eml21__LuminousFluxMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousFluxUom'
        enum eml21__LuminousFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousFluxMeasure, default initialized and not managed by a soap context
        virtual eml21__LuminousFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousFluxMeasure); }
      public:
        /// Constructor with initializations
        eml21__LuminousFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousFluxMeasure() { }
        /// Friend allocator used by soap_new_eml21__LuminousFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousFluxMeasure * SOAP_FMAC2 soap_instantiate_eml21__LuminousFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1248 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt (354)
/* simple XSD type 'eml21:LuminousFluxMeasureExt': */
class SOAP_CMAC eml21__LuminousFluxMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LuminousFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousFluxMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LuminousFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LuminousFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LuminousFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1251 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure (355)
/* simple XSD type 'eml21:LuminousIntensityMeasure': */
class SOAP_CMAC eml21__LuminousIntensityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousIntensityUom'
        enum eml21__LuminousIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousIntensityMeasure, default initialized and not managed by a soap context
        virtual eml21__LuminousIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousIntensityMeasure); }
      public:
        /// Constructor with initializations
        eml21__LuminousIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml21__LuminousIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml21__LuminousIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1254 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt (356)
/* simple XSD type 'eml21:LuminousIntensityMeasureExt': */
class SOAP_CMAC eml21__LuminousIntensityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:LuminousIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__LuminousIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__LuminousIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__LuminousIntensityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__LuminousIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__LuminousIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__LuminousIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__LuminousIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__LuminousIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1257 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure (357)
/* simple XSD type 'eml21:MagneticDipoleMomentMeasure': */
class SOAP_CMAC eml21__MagneticDipoleMomentMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticDipoleMomentUom'
        enum eml21__MagneticDipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticDipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticDipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticDipoleMomentMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticDipoleMomentMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticDipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticDipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticDipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticDipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1260 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt (358)
/* simple XSD type 'eml21:MagneticDipoleMomentMeasureExt': */
class SOAP_CMAC eml21__MagneticDipoleMomentMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticDipoleMomentUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticDipoleMomentMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticDipoleMomentMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticDipoleMomentMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticDipoleMomentMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticDipoleMomentMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticDipoleMomentMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticDipoleMomentMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticDipoleMomentMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1263 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure (359)
/* simple XSD type 'eml21:MagneticFieldStrengthMeasure': */
class SOAP_CMAC eml21__MagneticFieldStrengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFieldStrengthUom'
        enum eml21__MagneticFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFieldStrengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticFieldStrengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1266 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt (360)
/* simple XSD type 'eml21:MagneticFieldStrengthMeasureExt': */
class SOAP_CMAC eml21__MagneticFieldStrengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFieldStrengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFieldStrengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticFieldStrengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFieldStrengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticFieldStrengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFieldStrengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticFieldStrengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFieldStrengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticFieldStrengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1269 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure (361)
/* simple XSD type 'eml21:MagneticFluxDensityMeasure': */
class SOAP_CMAC eml21__MagneticFluxDensityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxDensityUom'
        enum eml21__MagneticFluxDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxDensityMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxDensityMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxDensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxDensityMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxDensityMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1272 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt (362)
/* simple XSD type 'eml21:MagneticFluxDensityMeasureExt': */
class SOAP_CMAC eml21__MagneticFluxDensityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxDensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxDensityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxDensityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxDensityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxDensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxDensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxDensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxDensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxDensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1275 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure (363)
/* simple XSD type 'eml21:MagneticFluxDensityPerLengthMeasure': */
class SOAP_CMAC eml21__MagneticFluxDensityPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxDensityPerLengthUom'
        enum eml21__MagneticFluxDensityPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxDensityPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxDensityPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxDensityPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxDensityPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxDensityPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxDensityPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxDensityPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxDensityPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1278 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt (364)
/* simple XSD type 'eml21:MagneticFluxDensityPerLengthMeasureExt': */
class SOAP_CMAC eml21__MagneticFluxDensityPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxDensityPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxDensityPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxDensityPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxDensityPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxDensityPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxDensityPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxDensityPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxDensityPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1281 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure (365)
/* simple XSD type 'eml21:MagneticFluxMeasure': */
class SOAP_CMAC eml21__MagneticFluxMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxUom'
        enum eml21__MagneticFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1284 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt (366)
/* simple XSD type 'eml21:MagneticFluxMeasureExt': */
class SOAP_CMAC eml21__MagneticFluxMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticFluxUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticFluxMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticFluxMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticFluxMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticFluxMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticFluxMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticFluxMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticFluxMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticFluxMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1287 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure (367)
/* simple XSD type 'eml21:MagneticPermeabilityMeasure': */
class SOAP_CMAC eml21__MagneticPermeabilityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticPermeabilityUom'
        enum eml21__MagneticPermeabilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticPermeabilityMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticPermeabilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticPermeabilityMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticPermeabilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticPermeabilityMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticPermeabilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticPermeabilityMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticPermeabilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1290 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt (368)
/* simple XSD type 'eml21:MagneticPermeabilityMeasureExt': */
class SOAP_CMAC eml21__MagneticPermeabilityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticPermeabilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticPermeabilityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticPermeabilityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticPermeabilityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticPermeabilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticPermeabilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticPermeabilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticPermeabilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticPermeabilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1293 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure (369)
/* simple XSD type 'eml21:MagneticVectorPotentialMeasure': */
class SOAP_CMAC eml21__MagneticVectorPotentialMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticVectorPotentialUom'
        enum eml21__MagneticVectorPotentialUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticVectorPotentialMeasure, default initialized and not managed by a soap context
        virtual eml21__MagneticVectorPotentialMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticVectorPotentialMeasure); }
      public:
        /// Constructor with initializations
        eml21__MagneticVectorPotentialMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticVectorPotentialMeasure() { }
        /// Friend allocator used by soap_new_eml21__MagneticVectorPotentialMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticVectorPotentialMeasure * SOAP_FMAC2 soap_instantiate_eml21__MagneticVectorPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1296 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt (370)
/* simple XSD type 'eml21:MagneticVectorPotentialMeasureExt': */
class SOAP_CMAC eml21__MagneticVectorPotentialMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MagneticVectorPotentialUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MagneticVectorPotentialMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MagneticVectorPotentialMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MagneticVectorPotentialMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MagneticVectorPotentialMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MagneticVectorPotentialMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MagneticVectorPotentialMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MagneticVectorPotentialMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MagneticVectorPotentialMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1299 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure (371)
/* simple XSD type 'eml21:MassLengthMeasure': */
class SOAP_CMAC eml21__MassLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassLengthUom'
        enum eml21__MassLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MassLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1302 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt (372)
/* simple XSD type 'eml21:MassLengthMeasureExt': */
class SOAP_CMAC eml21__MassLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1305 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure (373)
/* simple XSD type 'eml21:MassMeasure': */
class SOAP_CMAC eml21__MassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassUom'
        enum eml21__MassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassMeasure, default initialized and not managed by a soap context
        virtual eml21__MassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1308 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt (374)
/* simple XSD type 'eml21:MassMeasureExt': */
class SOAP_CMAC eml21__MassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1311 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure (375)
/* simple XSD type 'eml21:MassPerAreaMeasure': */
class SOAP_CMAC eml21__MassPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerAreaUom'
        enum eml21__MassPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1314 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt (376)
/* simple XSD type 'eml21:MassPerAreaMeasureExt': */
class SOAP_CMAC eml21__MassPerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1317 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure (377)
/* simple XSD type 'eml21:MassPerEnergyMeasure': */
class SOAP_CMAC eml21__MassPerEnergyMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerEnergyUom'
        enum eml21__MassPerEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerEnergyMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerEnergyMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1320 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt (378)
/* simple XSD type 'eml21:MassPerEnergyMeasureExt': */
class SOAP_CMAC eml21__MassPerEnergyMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerEnergyMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1323 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure (379)
/* simple XSD type 'eml21:MassPerLengthMeasure': */
class SOAP_CMAC eml21__MassPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerLengthUom'
        enum eml21__MassPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1326 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt (380)
/* simple XSD type 'eml21:MassPerLengthMeasureExt': */
class SOAP_CMAC eml21__MassPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1329 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure (381)
/* simple XSD type 'eml21:MassPerMassMeasure': */
class SOAP_CMAC eml21__MassPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerMassUom'
        enum eml21__MassPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1332 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt (382)
/* simple XSD type 'eml21:MassPerMassMeasureExt': */
class SOAP_CMAC eml21__MassPerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1335 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure (383)
/* simple XSD type 'eml21:MassPerTimeMeasure': */
class SOAP_CMAC eml21__MassPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimeUom'
        enum eml21__MassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1338 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt (384)
/* simple XSD type 'eml21:MassPerTimeMeasureExt': */
class SOAP_CMAC eml21__MassPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1341 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure (385)
/* simple XSD type 'eml21:MassPerTimePerAreaMeasure': */
class SOAP_CMAC eml21__MassPerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimePerAreaUom'
        enum eml21__MassPerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1344 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt (386)
/* simple XSD type 'eml21:MassPerTimePerAreaMeasureExt': */
class SOAP_CMAC eml21__MassPerTimePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1347 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure (387)
/* simple XSD type 'eml21:MassPerTimePerLengthMeasure': */
class SOAP_CMAC eml21__MassPerTimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimePerLengthUom'
        enum eml21__MassPerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1350 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt (388)
/* simple XSD type 'eml21:MassPerTimePerLengthMeasureExt': */
class SOAP_CMAC eml21__MassPerTimePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerTimePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1353 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure (389)
/* simple XSD type 'eml21:MassPerVolumeMeasure': */
class SOAP_CMAC eml21__MassPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumeUom'
        enum eml21__MassPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1356 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt (390)
/* simple XSD type 'eml21:MassPerVolumeMeasureExt': */
class SOAP_CMAC eml21__MassPerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1359 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure (391)
/* simple XSD type 'eml21:MassPerVolumePerLengthMeasure': */
class SOAP_CMAC eml21__MassPerVolumePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerLengthUom'
        enum eml21__MassPerVolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1362 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt (392)
/* simple XSD type 'eml21:MassPerVolumePerLengthMeasureExt': */
class SOAP_CMAC eml21__MassPerVolumePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1365 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure (393)
/* simple XSD type 'eml21:MassPerVolumePerPressureMeasure': */
class SOAP_CMAC eml21__MassPerVolumePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerPressureUom'
        enum eml21__MassPerVolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1368 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt (394)
/* simple XSD type 'eml21:MassPerVolumePerPressureMeasureExt': */
class SOAP_CMAC eml21__MassPerVolumePerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1371 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure (395)
/* simple XSD type 'eml21:MassPerVolumePerTemperatureMeasure': */
class SOAP_CMAC eml21__MassPerVolumePerTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerTemperatureUom'
        enum eml21__MassPerVolumePerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1374 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt (396)
/* simple XSD type 'eml21:MassPerVolumePerTemperatureMeasureExt': */
class SOAP_CMAC eml21__MassPerVolumePerTemperatureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MassPerVolumePerTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MassPerVolumePerTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MassPerVolumePerTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MassPerVolumePerTemperatureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MassPerVolumePerTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MassPerVolumePerTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MassPerVolumePerTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MassPerVolumePerTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MassPerVolumePerTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1377 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure (397)
/* simple XSD type 'eml21:MobilityMeasure': */
class SOAP_CMAC eml21__MobilityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MobilityUom'
        enum eml21__MobilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MobilityMeasure, default initialized and not managed by a soap context
        virtual eml21__MobilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MobilityMeasure); }
      public:
        /// Constructor with initializations
        eml21__MobilityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MobilityMeasure() { }
        /// Friend allocator used by soap_new_eml21__MobilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MobilityMeasure * SOAP_FMAC2 soap_instantiate_eml21__MobilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1380 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt (398)
/* simple XSD type 'eml21:MobilityMeasureExt': */
class SOAP_CMAC eml21__MobilityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MobilityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MobilityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MobilityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MobilityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MobilityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MobilityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MobilityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MobilityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MobilityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1383 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure (399)
/* simple XSD type 'eml21:MolarEnergyMeasure': */
class SOAP_CMAC eml21__MolarEnergyMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarEnergyUom'
        enum eml21__MolarEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarEnergyMeasure, default initialized and not managed by a soap context
        virtual eml21__MolarEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MolarEnergyMeasure); }
      public:
        /// Constructor with initializations
        eml21__MolarEnergyMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MolarEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml21__MolarEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml21__MolarEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1386 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt (400)
/* simple XSD type 'eml21:MolarEnergyMeasureExt': */
class SOAP_CMAC eml21__MolarEnergyMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarEnergyUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarEnergyMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MolarEnergyMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MolarEnergyMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MolarEnergyMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MolarEnergyMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MolarEnergyMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarEnergyMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MolarEnergyMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1389 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure (401)
/* simple XSD type 'eml21:MolarHeatCapacityMeasure': */
class SOAP_CMAC eml21__MolarHeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarHeatCapacityUom'
        enum eml21__MolarHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml21__MolarHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MolarHeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml21__MolarHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MolarHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml21__MolarHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml21__MolarHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1392 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt (402)
/* simple XSD type 'eml21:MolarHeatCapacityMeasureExt': */
class SOAP_CMAC eml21__MolarHeatCapacityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MolarHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MolarHeatCapacityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MolarHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MolarHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MolarHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MolarHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1395 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure (403)
/* simple XSD type 'eml21:MolarVolumeMeasure': */
class SOAP_CMAC eml21__MolarVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarVolumeUom'
        enum eml21__MolarVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__MolarVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MolarVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__MolarVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MolarVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__MolarVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__MolarVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1398 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt (404)
/* simple XSD type 'eml21:MolarVolumeMeasureExt': */
class SOAP_CMAC eml21__MolarVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolarVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolarVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MolarVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MolarVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MolarVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MolarVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MolarVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolarVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MolarVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1401 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure (405)
/* simple XSD type 'eml21:MolecularWeightMeasure': */
class SOAP_CMAC eml21__MolecularWeightMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolecularWeightUom'
        enum eml21__MolecularWeightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolecularWeightMeasure, default initialized and not managed by a soap context
        virtual eml21__MolecularWeightMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MolecularWeightMeasure); }
      public:
        /// Constructor with initializations
        eml21__MolecularWeightMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MolecularWeightMeasure() { }
        /// Friend allocator used by soap_new_eml21__MolecularWeightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolecularWeightMeasure * SOAP_FMAC2 soap_instantiate_eml21__MolecularWeightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1404 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt (406)
/* simple XSD type 'eml21:MolecularWeightMeasureExt': */
class SOAP_CMAC eml21__MolecularWeightMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MolecularWeightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MolecularWeightMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MolecularWeightMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MolecularWeightMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MolecularWeightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MolecularWeightMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MolecularWeightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MolecularWeightMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MolecularWeightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1407 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure (407)
/* simple XSD type 'eml21:MomentOfForceMeasure': */
class SOAP_CMAC eml21__MomentOfForceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentOfForceUom'
        enum eml21__MomentOfForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentOfForceMeasure, default initialized and not managed by a soap context
        virtual eml21__MomentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MomentOfForceMeasure); }
      public:
        /// Constructor with initializations
        eml21__MomentOfForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MomentOfForceMeasure() { }
        /// Friend allocator used by soap_new_eml21__MomentOfForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentOfForceMeasure * SOAP_FMAC2 soap_instantiate_eml21__MomentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1410 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt (408)
/* simple XSD type 'eml21:MomentOfForceMeasureExt': */
class SOAP_CMAC eml21__MomentOfForceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentOfForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentOfForceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MomentOfForceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MomentOfForceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MomentOfForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MomentOfForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MomentOfForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentOfForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MomentOfForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1413 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure (409)
/* simple XSD type 'eml21:MomentOfInertiaMeasure': */
class SOAP_CMAC eml21__MomentOfInertiaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentOfInertiaUom'
        enum eml21__MomentOfInertiaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentOfInertiaMeasure, default initialized and not managed by a soap context
        virtual eml21__MomentOfInertiaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MomentOfInertiaMeasure); }
      public:
        /// Constructor with initializations
        eml21__MomentOfInertiaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MomentOfInertiaMeasure() { }
        /// Friend allocator used by soap_new_eml21__MomentOfInertiaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentOfInertiaMeasure * SOAP_FMAC2 soap_instantiate_eml21__MomentOfInertiaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1416 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt (410)
/* simple XSD type 'eml21:MomentOfInertiaMeasureExt': */
class SOAP_CMAC eml21__MomentOfInertiaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentOfInertiaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentOfInertiaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MomentOfInertiaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MomentOfInertiaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MomentOfInertiaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MomentOfInertiaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MomentOfInertiaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentOfInertiaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MomentOfInertiaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1419 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure (411)
/* simple XSD type 'eml21:MomentumMeasure': */
class SOAP_CMAC eml21__MomentumMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentumUom'
        enum eml21__MomentumUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentumMeasure, default initialized and not managed by a soap context
        virtual eml21__MomentumMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__MomentumMeasure); }
      public:
        /// Constructor with initializations
        eml21__MomentumMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__MomentumMeasure() { }
        /// Friend allocator used by soap_new_eml21__MomentumMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentumMeasure * SOAP_FMAC2 soap_instantiate_eml21__MomentumMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1422 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt (412)
/* simple XSD type 'eml21:MomentumMeasureExt': */
class SOAP_CMAC eml21__MomentumMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:MomentumUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__MomentumMeasureExt, default initialized and not managed by a soap context
        virtual eml21__MomentumMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__MomentumMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__MomentumMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__MomentumMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__MomentumMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__MomentumMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__MomentumMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1425 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure (413)
/* simple XSD type 'eml21:NormalizedPowerMeasure': */
class SOAP_CMAC eml21__NormalizedPowerMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:NormalizedPowerUom'
        enum eml21__NormalizedPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__NormalizedPowerMeasure, default initialized and not managed by a soap context
        virtual eml21__NormalizedPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__NormalizedPowerMeasure); }
      public:
        /// Constructor with initializations
        eml21__NormalizedPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__NormalizedPowerMeasure() { }
        /// Friend allocator used by soap_new_eml21__NormalizedPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__NormalizedPowerMeasure * SOAP_FMAC2 soap_instantiate_eml21__NormalizedPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1428 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt (414)
/* simple XSD type 'eml21:NormalizedPowerMeasureExt': */
class SOAP_CMAC eml21__NormalizedPowerMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:NormalizedPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__NormalizedPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml21__NormalizedPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__NormalizedPowerMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__NormalizedPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__NormalizedPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__NormalizedPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__NormalizedPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__NormalizedPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1431 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure (415)
/* simple XSD type 'eml21:PermeabilityLengthMeasure': */
class SOAP_CMAC eml21__PermeabilityLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermeabilityLengthUom'
        enum eml21__PermeabilityLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermeabilityLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__PermeabilityLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PermeabilityLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__PermeabilityLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PermeabilityLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__PermeabilityLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermeabilityLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__PermeabilityLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1434 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt (416)
/* simple XSD type 'eml21:PermeabilityLengthMeasureExt': */
class SOAP_CMAC eml21__PermeabilityLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermeabilityLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermeabilityLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PermeabilityLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PermeabilityLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PermeabilityLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PermeabilityLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PermeabilityLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermeabilityLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PermeabilityLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1437 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure (417)
/* simple XSD type 'eml21:PermeabilityRockMeasure': */
class SOAP_CMAC eml21__PermeabilityRockMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermeabilityRockUom'
        enum eml21__PermeabilityRockUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermeabilityRockMeasure, default initialized and not managed by a soap context
        virtual eml21__PermeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PermeabilityRockMeasure); }
      public:
        /// Constructor with initializations
        eml21__PermeabilityRockMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PermeabilityRockMeasure() { }
        /// Friend allocator used by soap_new_eml21__PermeabilityRockMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermeabilityRockMeasure * SOAP_FMAC2 soap_instantiate_eml21__PermeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1440 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt (418)
/* simple XSD type 'eml21:PermeabilityRockMeasureExt': */
class SOAP_CMAC eml21__PermeabilityRockMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermeabilityRockUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermeabilityRockMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PermeabilityRockMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PermeabilityRockMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PermeabilityRockMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PermeabilityRockMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PermeabilityRockMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermeabilityRockMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PermeabilityRockMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1443 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure (419)
/* simple XSD type 'eml21:PermittivityMeasure': */
class SOAP_CMAC eml21__PermittivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermittivityUom'
        enum eml21__PermittivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermittivityMeasure, default initialized and not managed by a soap context
        virtual eml21__PermittivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PermittivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__PermittivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PermittivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__PermittivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermittivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__PermittivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1446 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt (420)
/* simple XSD type 'eml21:PermittivityMeasureExt': */
class SOAP_CMAC eml21__PermittivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PermittivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PermittivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PermittivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PermittivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PermittivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PermittivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PermittivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PermittivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PermittivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1449 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure (421)
/* simple XSD type 'eml21:PlaneAngleMeasure': */
class SOAP_CMAC eml21__PlaneAngleMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PlaneAngleUom'
        enum eml21__PlaneAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PlaneAngleMeasure, default initialized and not managed by a soap context
        virtual eml21__PlaneAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PlaneAngleMeasure); }
      public:
        /// Constructor with initializations
        eml21__PlaneAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PlaneAngleMeasure() { }
        /// Friend allocator used by soap_new_eml21__PlaneAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PlaneAngleMeasure * SOAP_FMAC2 soap_instantiate_eml21__PlaneAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1452 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt (422)
/* simple XSD type 'eml21:PlaneAngleMeasureExt': */
class SOAP_CMAC eml21__PlaneAngleMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PlaneAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PlaneAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PlaneAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PlaneAngleMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PlaneAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PlaneAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PlaneAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PlaneAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PlaneAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1455 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure (423)
/* simple XSD type 'eml21:PotentialDifferencePerPowerDropMeasure': */
class SOAP_CMAC eml21__PotentialDifferencePerPowerDropMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PotentialDifferencePerPowerDropUom'
        enum eml21__PotentialDifferencePerPowerDropUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PotentialDifferencePerPowerDropMeasure, default initialized and not managed by a soap context
        virtual eml21__PotentialDifferencePerPowerDropMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PotentialDifferencePerPowerDropMeasure); }
      public:
        /// Constructor with initializations
        eml21__PotentialDifferencePerPowerDropMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PotentialDifferencePerPowerDropMeasure() { }
        /// Friend allocator used by soap_new_eml21__PotentialDifferencePerPowerDropMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PotentialDifferencePerPowerDropMeasure * SOAP_FMAC2 soap_instantiate_eml21__PotentialDifferencePerPowerDropMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1458 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt (424)
/* simple XSD type 'eml21:PotentialDifferencePerPowerDropMeasureExt': */
class SOAP_CMAC eml21__PotentialDifferencePerPowerDropMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PotentialDifferencePerPowerDropUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PotentialDifferencePerPowerDropMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PotentialDifferencePerPowerDropMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PotentialDifferencePerPowerDropMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PotentialDifferencePerPowerDropMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PotentialDifferencePerPowerDropMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PotentialDifferencePerPowerDropMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PotentialDifferencePerPowerDropMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1461 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure (425)
/* simple XSD type 'eml21:PowerMeasure': */
class SOAP_CMAC eml21__PowerMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerUom'
        enum eml21__PowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerMeasure, default initialized and not managed by a soap context
        virtual eml21__PowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PowerMeasure); }
      public:
        /// Constructor with initializations
        eml21__PowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PowerMeasure() { }
        /// Friend allocator used by soap_new_eml21__PowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerMeasure * SOAP_FMAC2 soap_instantiate_eml21__PowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1464 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt (426)
/* simple XSD type 'eml21:PowerMeasureExt': */
class SOAP_CMAC eml21__PowerMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PowerMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PowerMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1467 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure (427)
/* simple XSD type 'eml21:PowerPerAreaMeasure': */
class SOAP_CMAC eml21__PowerPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerAreaUom'
        enum eml21__PowerPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__PowerPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__PowerPerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__PowerPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__PowerPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1470 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt (428)
/* simple XSD type 'eml21:PowerPerAreaMeasureExt': */
class SOAP_CMAC eml21__PowerPerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PowerPerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PowerPerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PowerPerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PowerPerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1473 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure (429)
/* simple XSD type 'eml21:PowerPerPowerMeasure': */
class SOAP_CMAC eml21__PowerPerPowerMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerPowerUom'
        enum eml21__PowerPerPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerPowerMeasure, default initialized and not managed by a soap context
        virtual eml21__PowerPerPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerPowerMeasure); }
      public:
        /// Constructor with initializations
        eml21__PowerPerPowerMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerPowerMeasure() { }
        /// Friend allocator used by soap_new_eml21__PowerPerPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerPowerMeasure * SOAP_FMAC2 soap_instantiate_eml21__PowerPerPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1476 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt (430)
/* simple XSD type 'eml21:PowerPerPowerMeasureExt': */
class SOAP_CMAC eml21__PowerPerPowerMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerPowerUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerPowerMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PowerPerPowerMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerPowerMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PowerPerPowerMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerPowerMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PowerPerPowerMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerPowerMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PowerPerPowerMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1479 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure (431)
/* simple XSD type 'eml21:PowerPerVolumeMeasure': */
class SOAP_CMAC eml21__PowerPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerVolumeUom'
        enum eml21__PowerPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__PowerPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__PowerPerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__PowerPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__PowerPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1482 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt (432)
/* simple XSD type 'eml21:PowerPerVolumeMeasureExt': */
class SOAP_CMAC eml21__PowerPerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PowerPerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PowerPerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PowerPerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PowerPerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PowerPerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PowerPerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PowerPerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PowerPerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PowerPerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1485 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure (433)
/* simple XSD type 'eml21:PressureMeasure': */
class SOAP_CMAC eml21__PressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureUom'
        enum eml21__PressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureMeasure, default initialized and not managed by a soap context
        virtual eml21__PressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1488 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt (434)
/* simple XSD type 'eml21:PressureMeasureExt': */
class SOAP_CMAC eml21__PressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1491 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure (435)
/* simple XSD type 'eml21:PressurePerPressureMeasure': */
class SOAP_CMAC eml21__PressurePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerPressureUom'
        enum eml21__PressurePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__PressurePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressurePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressurePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressurePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1494 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt (436)
/* simple XSD type 'eml21:PressurePerPressureMeasureExt': */
class SOAP_CMAC eml21__PressurePerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressurePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressurePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressurePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressurePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1497 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure (437)
/* simple XSD type 'eml21:PressurePerTimeMeasure': */
class SOAP_CMAC eml21__PressurePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerTimeUom'
        enum eml21__PressurePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__PressurePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressurePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressurePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressurePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1500 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt (438)
/* simple XSD type 'eml21:PressurePerTimeMeasureExt': */
class SOAP_CMAC eml21__PressurePerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressurePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressurePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressurePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressurePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1503 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure (439)
/* simple XSD type 'eml21:PressurePerVolumeMeasure': */
class SOAP_CMAC eml21__PressurePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerVolumeUom'
        enum eml21__PressurePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__PressurePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressurePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressurePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressurePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1506 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt (440)
/* simple XSD type 'eml21:PressurePerVolumeMeasureExt': */
class SOAP_CMAC eml21__PressurePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressurePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressurePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressurePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressurePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressurePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressurePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressurePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressurePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressurePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1509 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure (441)
/* simple XSD type 'eml21:PressureSquaredMeasure': */
class SOAP_CMAC eml21__PressureSquaredMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureSquaredUom'
        enum eml21__PressureSquaredUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureSquaredMeasure, default initialized and not managed by a soap context
        virtual eml21__PressureSquaredMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressureSquaredMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressureSquaredMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressureSquaredMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressureSquaredMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureSquaredMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressureSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1512 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt (442)
/* simple XSD type 'eml21:PressureSquaredMeasureExt': */
class SOAP_CMAC eml21__PressureSquaredMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureSquaredUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureSquaredMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressureSquaredMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressureSquaredMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressureSquaredMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressureSquaredMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressureSquaredMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureSquaredMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressureSquaredMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1515 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure (443)
/* simple XSD type 'eml21:PressureSquaredPerForceTimePerAreaMeasure': */
class SOAP_CMAC eml21__PressureSquaredPerForceTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureSquaredPerForceTimePerAreaUom'
        enum eml21__PressureSquaredPerForceTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureSquaredPerForceTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__PressureSquaredPerForceTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressureSquaredPerForceTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressureSquaredPerForceTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressureSquaredPerForceTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureSquaredPerForceTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1518 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt (444)
/* simple XSD type 'eml21:PressureSquaredPerForceTimePerAreaMeasureExt': */
class SOAP_CMAC eml21__PressureSquaredPerForceTimePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureSquaredPerForceTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureSquaredPerForceTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressureSquaredPerForceTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressureSquaredPerForceTimePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressureSquaredPerForceTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressureSquaredPerForceTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureSquaredPerForceTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressureSquaredPerForceTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1521 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure (445)
/* simple XSD type 'eml21:PressureTimePerVolumeMeasure': */
class SOAP_CMAC eml21__PressureTimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureTimePerVolumeUom'
        enum eml21__PressureTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__PressureTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__PressureTimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__PressureTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__PressureTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__PressureTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__PressureTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1524 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt (446)
/* simple XSD type 'eml21:PressureTimePerVolumeMeasureExt': */
class SOAP_CMAC eml21__PressureTimePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__PressureTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__PressureTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__PressureTimePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__PressureTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__PressureTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__PressureTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__PressureTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__PressureTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1527 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure (447)
/* simple XSD type 'eml21:QuantityOfLightMeasure': */
class SOAP_CMAC eml21__QuantityOfLightMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:QuantityOfLightUom'
        enum eml21__QuantityOfLightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__QuantityOfLightMeasure, default initialized and not managed by a soap context
        virtual eml21__QuantityOfLightMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__QuantityOfLightMeasure); }
      public:
        /// Constructor with initializations
        eml21__QuantityOfLightMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__QuantityOfLightMeasure() { }
        /// Friend allocator used by soap_new_eml21__QuantityOfLightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__QuantityOfLightMeasure * SOAP_FMAC2 soap_instantiate_eml21__QuantityOfLightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1530 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt (448)
/* simple XSD type 'eml21:QuantityOfLightMeasureExt': */
class SOAP_CMAC eml21__QuantityOfLightMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:QuantityOfLightUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__QuantityOfLightMeasureExt, default initialized and not managed by a soap context
        virtual eml21__QuantityOfLightMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__QuantityOfLightMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__QuantityOfLightMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__QuantityOfLightMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__QuantityOfLightMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__QuantityOfLightMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__QuantityOfLightMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1533 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure (449)
/* simple XSD type 'eml21:RadianceMeasure': */
class SOAP_CMAC eml21__RadianceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:RadianceUom'
        enum eml21__RadianceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__RadianceMeasure, default initialized and not managed by a soap context
        virtual eml21__RadianceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__RadianceMeasure); }
      public:
        /// Constructor with initializations
        eml21__RadianceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__RadianceMeasure() { }
        /// Friend allocator used by soap_new_eml21__RadianceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__RadianceMeasure * SOAP_FMAC2 soap_instantiate_eml21__RadianceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1536 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt (450)
/* simple XSD type 'eml21:RadianceMeasureExt': */
class SOAP_CMAC eml21__RadianceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:RadianceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__RadianceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__RadianceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__RadianceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__RadianceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__RadianceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__RadianceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__RadianceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__RadianceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1539 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure (451)
/* simple XSD type 'eml21:RadiantIntensityMeasure': */
class SOAP_CMAC eml21__RadiantIntensityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:RadiantIntensityUom'
        enum eml21__RadiantIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__RadiantIntensityMeasure, default initialized and not managed by a soap context
        virtual eml21__RadiantIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__RadiantIntensityMeasure); }
      public:
        /// Constructor with initializations
        eml21__RadiantIntensityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__RadiantIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml21__RadiantIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__RadiantIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml21__RadiantIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1542 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt (452)
/* simple XSD type 'eml21:RadiantIntensityMeasureExt': */
class SOAP_CMAC eml21__RadiantIntensityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:RadiantIntensityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__RadiantIntensityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__RadiantIntensityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__RadiantIntensityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__RadiantIntensityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__RadiantIntensityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__RadiantIntensityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__RadiantIntensityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__RadiantIntensityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1545 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure (453)
/* simple XSD type 'eml21:ReciprocalAreaMeasure': */
class SOAP_CMAC eml21__ReciprocalAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalAreaUom'
        enum eml21__ReciprocalAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1548 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt (454)
/* simple XSD type 'eml21:ReciprocalAreaMeasureExt': */
class SOAP_CMAC eml21__ReciprocalAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1551 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure (455)
/* simple XSD type 'eml21:ReciprocalElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml21__ReciprocalElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalElectricPotentialDifferenceUom'
        enum eml21__ReciprocalElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalElectricPotentialDifferenceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1554 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt (456)
/* simple XSD type 'eml21:ReciprocalElectricPotentialDifferenceMeasureExt': */
class SOAP_CMAC eml21__ReciprocalElectricPotentialDifferenceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalElectricPotentialDifferenceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalElectricPotentialDifferenceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalElectricPotentialDifferenceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalElectricPotentialDifferenceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalElectricPotentialDifferenceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalElectricPotentialDifferenceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalElectricPotentialDifferenceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalElectricPotentialDifferenceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1557 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure (457)
/* simple XSD type 'eml21:ReciprocalForceMeasure': */
class SOAP_CMAC eml21__ReciprocalForceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalForceUom'
        enum eml21__ReciprocalForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalForceMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalForceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalForceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalForceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalForceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1560 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt (458)
/* simple XSD type 'eml21:ReciprocalForceMeasureExt': */
class SOAP_CMAC eml21__ReciprocalForceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalForceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalForceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalForceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalForceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalForceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalForceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalForceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalForceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalForceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1563 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure (459)
/* simple XSD type 'eml21:ReciprocalLengthMeasure': */
class SOAP_CMAC eml21__ReciprocalLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalLengthUom'
        enum eml21__ReciprocalLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1566 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt (460)
/* simple XSD type 'eml21:ReciprocalLengthMeasureExt': */
class SOAP_CMAC eml21__ReciprocalLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1569 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure (461)
/* simple XSD type 'eml21:ReciprocalMassMeasure': */
class SOAP_CMAC eml21__ReciprocalMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalMassUom'
        enum eml21__ReciprocalMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalMassMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1572 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt (462)
/* simple XSD type 'eml21:ReciprocalMassMeasureExt': */
class SOAP_CMAC eml21__ReciprocalMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1575 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure (463)
/* simple XSD type 'eml21:ReciprocalMassTimeMeasure': */
class SOAP_CMAC eml21__ReciprocalMassTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalMassTimeUom'
        enum eml21__ReciprocalMassTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalMassTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalMassTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalMassTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalMassTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalMassTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalMassTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalMassTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalMassTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1578 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt (464)
/* simple XSD type 'eml21:ReciprocalMassTimeMeasureExt': */
class SOAP_CMAC eml21__ReciprocalMassTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalMassTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalMassTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalMassTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalMassTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalMassTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalMassTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalMassTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalMassTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalMassTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1581 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure (465)
/* simple XSD type 'eml21:ReciprocalPressureMeasure': */
class SOAP_CMAC eml21__ReciprocalPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalPressureUom'
        enum eml21__ReciprocalPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1584 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt (466)
/* simple XSD type 'eml21:ReciprocalPressureMeasureExt': */
class SOAP_CMAC eml21__ReciprocalPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1587 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure (467)
/* simple XSD type 'eml21:ReciprocalTimeMeasure': */
class SOAP_CMAC eml21__ReciprocalTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalTimeUom'
        enum eml21__ReciprocalTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1590 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt (468)
/* simple XSD type 'eml21:ReciprocalTimeMeasureExt': */
class SOAP_CMAC eml21__ReciprocalTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1593 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure (469)
/* simple XSD type 'eml21:ReciprocalVolumeMeasure': */
class SOAP_CMAC eml21__ReciprocalVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalVolumeUom'
        enum eml21__ReciprocalVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__ReciprocalVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1596 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt (470)
/* simple XSD type 'eml21:ReciprocalVolumeMeasureExt': */
class SOAP_CMAC eml21__ReciprocalVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReciprocalVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReciprocalVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReciprocalVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReciprocalVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReciprocalVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReciprocalVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReciprocalVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReciprocalVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReciprocalVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1599 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure (471)
/* simple XSD type 'eml21:ReluctanceMeasure': */
class SOAP_CMAC eml21__ReluctanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReluctanceUom'
        enum eml21__ReluctanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReluctanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ReluctanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ReluctanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ReluctanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ReluctanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ReluctanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReluctanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ReluctanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1602 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt (472)
/* simple XSD type 'eml21:ReluctanceMeasureExt': */
class SOAP_CMAC eml21__ReluctanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ReluctanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReluctanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ReluctanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ReluctanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ReluctanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ReluctanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ReluctanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReluctanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ReluctanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1605 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure (473)
/* simple XSD type 'eml21:SecondMomentOfAreaMeasure': */
class SOAP_CMAC eml21__SecondMomentOfAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SecondMomentOfAreaUom'
        enum eml21__SecondMomentOfAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SecondMomentOfAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__SecondMomentOfAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__SecondMomentOfAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__SecondMomentOfAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__SecondMomentOfAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__SecondMomentOfAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__SecondMomentOfAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__SecondMomentOfAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1608 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt (474)
/* simple XSD type 'eml21:SecondMomentOfAreaMeasureExt': */
class SOAP_CMAC eml21__SecondMomentOfAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SecondMomentOfAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SecondMomentOfAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__SecondMomentOfAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__SecondMomentOfAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__SecondMomentOfAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__SecondMomentOfAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__SecondMomentOfAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__SecondMomentOfAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__SecondMomentOfAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1611 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure (475)
/* simple XSD type 'eml21:SignalingEventPerTimeMeasure': */
class SOAP_CMAC eml21__SignalingEventPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SignalingEventPerTimeUom'
        enum eml21__SignalingEventPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SignalingEventPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__SignalingEventPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__SignalingEventPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__SignalingEventPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__SignalingEventPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__SignalingEventPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__SignalingEventPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__SignalingEventPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1614 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt (476)
/* simple XSD type 'eml21:SignalingEventPerTimeMeasureExt': */
class SOAP_CMAC eml21__SignalingEventPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SignalingEventPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SignalingEventPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__SignalingEventPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__SignalingEventPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__SignalingEventPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__SignalingEventPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__SignalingEventPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__SignalingEventPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__SignalingEventPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1617 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure (477)
/* simple XSD type 'eml21:SolidAngleMeasure': */
class SOAP_CMAC eml21__SolidAngleMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SolidAngleUom'
        enum eml21__SolidAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SolidAngleMeasure, default initialized and not managed by a soap context
        virtual eml21__SolidAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__SolidAngleMeasure); }
      public:
        /// Constructor with initializations
        eml21__SolidAngleMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__SolidAngleMeasure() { }
        /// Friend allocator used by soap_new_eml21__SolidAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__SolidAngleMeasure * SOAP_FMAC2 soap_instantiate_eml21__SolidAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1620 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt (478)
/* simple XSD type 'eml21:SolidAngleMeasureExt': */
class SOAP_CMAC eml21__SolidAngleMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SolidAngleUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SolidAngleMeasureExt, default initialized and not managed by a soap context
        virtual eml21__SolidAngleMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__SolidAngleMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__SolidAngleMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__SolidAngleMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__SolidAngleMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__SolidAngleMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__SolidAngleMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1623 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure (479)
/* simple XSD type 'eml21:SpecificHeatCapacityMeasure': */
class SOAP_CMAC eml21__SpecificHeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SpecificHeatCapacityUom'
        enum eml21__SpecificHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SpecificHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml21__SpecificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__SpecificHeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml21__SpecificHeatCapacityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__SpecificHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml21__SpecificHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__SpecificHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml21__SpecificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1626 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt (480)
/* simple XSD type 'eml21:SpecificHeatCapacityMeasureExt': */
class SOAP_CMAC eml21__SpecificHeatCapacityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:SpecificHeatCapacityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__SpecificHeatCapacityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__SpecificHeatCapacityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__SpecificHeatCapacityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__SpecificHeatCapacityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__SpecificHeatCapacityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__SpecificHeatCapacityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__SpecificHeatCapacityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__SpecificHeatCapacityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1629 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure (481)
/* simple XSD type 'eml21:TemperatureIntervalMeasure': */
class SOAP_CMAC eml21__TemperatureIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalUom'
        enum eml21__TemperatureIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalMeasure, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1632 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt (482)
/* simple XSD type 'eml21:TemperatureIntervalMeasureExt': */
class SOAP_CMAC eml21__TemperatureIntervalMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1635 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure (483)
/* simple XSD type 'eml21:TemperatureIntervalPerLengthMeasure': */
class SOAP_CMAC eml21__TemperatureIntervalPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerLengthUom'
        enum eml21__TemperatureIntervalPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1638 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt (484)
/* simple XSD type 'eml21:TemperatureIntervalPerLengthMeasureExt': */
class SOAP_CMAC eml21__TemperatureIntervalPerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1641 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure (485)
/* simple XSD type 'eml21:TemperatureIntervalPerPressureMeasure': */
class SOAP_CMAC eml21__TemperatureIntervalPerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerPressureUom'
        enum eml21__TemperatureIntervalPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1644 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt (486)
/* simple XSD type 'eml21:TemperatureIntervalPerPressureMeasureExt': */
class SOAP_CMAC eml21__TemperatureIntervalPerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1647 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure (487)
/* simple XSD type 'eml21:TemperatureIntervalPerTimeMeasure': */
class SOAP_CMAC eml21__TemperatureIntervalPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerTimeUom'
        enum eml21__TemperatureIntervalPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1650 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt (488)
/* simple XSD type 'eml21:TemperatureIntervalPerTimeMeasureExt': */
class SOAP_CMAC eml21__TemperatureIntervalPerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TemperatureIntervalPerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TemperatureIntervalPerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TemperatureIntervalPerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TemperatureIntervalPerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TemperatureIntervalPerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TemperatureIntervalPerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TemperatureIntervalPerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TemperatureIntervalPerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TemperatureIntervalPerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1653 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure (489)
/* simple XSD type 'eml21:ThermalConductanceMeasure': */
class SOAP_CMAC eml21__ThermalConductanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalConductanceUom'
        enum eml21__ThermalConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalConductanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermalConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalConductanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermalConductanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermalConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermalConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1656 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt (490)
/* simple XSD type 'eml21:ThermalConductanceMeasureExt': */
class SOAP_CMAC eml21__ThermalConductanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalConductanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalConductanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermalConductanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalConductanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermalConductanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalConductanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermalConductanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalConductanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermalConductanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1659 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure (491)
/* simple XSD type 'eml21:ThermalConductivityMeasure': */
class SOAP_CMAC eml21__ThermalConductivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalConductivityUom'
        enum eml21__ThermalConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalConductivityMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalConductivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermalConductivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermalConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1662 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt (492)
/* simple XSD type 'eml21:ThermalConductivityMeasureExt': */
class SOAP_CMAC eml21__ThermalConductivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalConductivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalConductivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermalConductivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalConductivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermalConductivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalConductivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermalConductivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalConductivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermalConductivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1665 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure (493)
/* simple XSD type 'eml21:ThermalDiffusivityMeasure': */
class SOAP_CMAC eml21__ThermalDiffusivityMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalDiffusivityUom'
        enum eml21__ThermalDiffusivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalDiffusivityMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermalDiffusivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalDiffusivityMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermalDiffusivityMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalDiffusivityMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermalDiffusivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalDiffusivityMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermalDiffusivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1668 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt (494)
/* simple XSD type 'eml21:ThermalDiffusivityMeasureExt': */
class SOAP_CMAC eml21__ThermalDiffusivityMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalDiffusivityUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalDiffusivityMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermalDiffusivityMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalDiffusivityMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermalDiffusivityMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalDiffusivityMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermalDiffusivityMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalDiffusivityMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermalDiffusivityMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1671 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure (495)
/* simple XSD type 'eml21:ThermalInsulanceMeasure': */
class SOAP_CMAC eml21__ThermalInsulanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalInsulanceUom'
        enum eml21__ThermalInsulanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalInsulanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermalInsulanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalInsulanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermalInsulanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalInsulanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermalInsulanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalInsulanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermalInsulanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1674 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt (496)
/* simple XSD type 'eml21:ThermalInsulanceMeasureExt': */
class SOAP_CMAC eml21__ThermalInsulanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalInsulanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalInsulanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermalInsulanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalInsulanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermalInsulanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalInsulanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermalInsulanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalInsulanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermalInsulanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1677 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure (497)
/* simple XSD type 'eml21:ThermalResistanceMeasure': */
class SOAP_CMAC eml21__ThermalResistanceMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalResistanceUom'
        enum eml21__ThermalResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalResistanceMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermalResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalResistanceMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermalResistanceMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermalResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermalResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1680 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt (498)
/* simple XSD type 'eml21:ThermalResistanceMeasureExt': */
class SOAP_CMAC eml21__ThermalResistanceMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermalResistanceUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermalResistanceMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermalResistanceMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermalResistanceMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermalResistanceMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermalResistanceMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermalResistanceMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermalResistanceMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermalResistanceMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1683 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure (499)
/* simple XSD type 'eml21:ThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml21__ThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermodynamicTemperatureUom'
        enum eml21__ThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1686 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt (500)
/* simple XSD type 'eml21:ThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml21__ThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1689 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (501)
/* simple XSD type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureUom'
        enum eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1692 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (502)
/* simple XSD type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt': */
class SOAP_CMAC eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1695 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure (503)
/* simple XSD type 'eml21:TimeMeasure': */
class SOAP_CMAC eml21__TimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimeUom'
        enum eml21__TimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeMeasure, default initialized and not managed by a soap context
        virtual eml21__TimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__TimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__TimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__TimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1698 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt (504)
/* simple XSD type 'eml21:TimeMeasureExt': */
class SOAP_CMAC eml21__TimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1701 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure (505)
/* simple XSD type 'eml21:TimePerLengthMeasure': */
class SOAP_CMAC eml21__TimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerLengthUom'
        enum eml21__TimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__TimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__TimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__TimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__TimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1704 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt (506)
/* simple XSD type 'eml21:TimePerLengthMeasureExt': */
class SOAP_CMAC eml21__TimePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1707 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure (507)
/* simple XSD type 'eml21:TimePerMassMeasure': */
class SOAP_CMAC eml21__TimePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerMassUom'
        enum eml21__TimePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__TimePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__TimePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__TimePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__TimePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1710 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt (508)
/* simple XSD type 'eml21:TimePerMassMeasureExt': */
class SOAP_CMAC eml21__TimePerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TimePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TimePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TimePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TimePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1713 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure (509)
/* simple XSD type 'eml21:TimePerTimeMeasure': */
class SOAP_CMAC eml21__TimePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerTimeUom'
        enum eml21__TimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__TimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__TimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__TimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__TimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1716 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt (510)
/* simple XSD type 'eml21:TimePerTimeMeasureExt': */
class SOAP_CMAC eml21__TimePerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1719 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure (511)
/* simple XSD type 'eml21:TimePerVolumeMeasure': */
class SOAP_CMAC eml21__TimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerVolumeUom'
        enum eml21__TimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__TimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__TimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__TimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__TimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1722 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt (512)
/* simple XSD type 'eml21:TimePerVolumeMeasureExt': */
class SOAP_CMAC eml21__TimePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:TimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__TimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__TimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__TimePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__TimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__TimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__TimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__TimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__TimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1725 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure (513)
/* simple XSD type 'eml21:UnitlessMeasure': */
class SOAP_CMAC eml21__UnitlessMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__UnitlessMeasure, default initialized and not managed by a soap context
        virtual eml21__UnitlessMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__UnitlessMeasure); }
      public:
        /// Constructor with initializations
        eml21__UnitlessMeasure() : __item(), soap() { }
        virtual ~eml21__UnitlessMeasure() { }
        /// Friend allocator used by soap_new_eml21__UnitlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__UnitlessMeasure * SOAP_FMAC2 soap_instantiate_eml21__UnitlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1728 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure (514)
/* simple XSD type 'eml21:VerticalCoordinateMeasure': */
class SOAP_CMAC eml21__VerticalCoordinateMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VerticalCoordinateUom'
        enum eml21__VerticalCoordinateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalCoordinateMeasure, default initialized and not managed by a soap context
        virtual eml21__VerticalCoordinateMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalCoordinateMeasure); }
      public:
        /// Constructor with initializations
        eml21__VerticalCoordinateMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VerticalCoordinateMeasure() { }
        /// Friend allocator used by soap_new_eml21__VerticalCoordinateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalCoordinateMeasure * SOAP_FMAC2 soap_instantiate_eml21__VerticalCoordinateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1731 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt (515)
/* simple XSD type 'eml21:VerticalCoordinateMeasureExt': */
class SOAP_CMAC eml21__VerticalCoordinateMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VerticalCoordinateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VerticalCoordinateMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VerticalCoordinateMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VerticalCoordinateMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VerticalCoordinateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VerticalCoordinateMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VerticalCoordinateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VerticalCoordinateMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VerticalCoordinateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1734 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure (516)
/* simple XSD type 'eml21:VolumeFlowRatePerVolumeFlowRateMeasure': */
class SOAP_CMAC eml21__VolumeFlowRatePerVolumeFlowRateMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumeFlowRatePerVolumeFlowRateUom'
        enum eml21__VolumeFlowRatePerVolumeFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumeFlowRatePerVolumeFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumeFlowRatePerVolumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumeFlowRatePerVolumeFlowRateMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumeFlowRatePerVolumeFlowRateMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumeFlowRatePerVolumeFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumeFlowRatePerVolumeFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1737 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt (517)
/* simple XSD type 'eml21:VolumeFlowRatePerVolumeFlowRateMeasureExt': */
class SOAP_CMAC eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumeFlowRatePerVolumeFlowRateUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1740 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure (518)
/* simple XSD type 'eml21:VolumeMeasure': */
class SOAP_CMAC eml21__VolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumeUom'
        enum eml21__VolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1743 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt (519)
/* simple XSD type 'eml21:VolumeMeasureExt': */
class SOAP_CMAC eml21__VolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1746 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure (520)
/* simple XSD type 'eml21:VolumePerAreaMeasure': */
class SOAP_CMAC eml21__VolumePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerAreaUom'
        enum eml21__VolumePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1749 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt (521)
/* simple XSD type 'eml21:VolumePerAreaMeasureExt': */
class SOAP_CMAC eml21__VolumePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1752 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure (522)
/* simple XSD type 'eml21:VolumePerLengthMeasure': */
class SOAP_CMAC eml21__VolumePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerLengthUom'
        enum eml21__VolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1755 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt (523)
/* simple XSD type 'eml21:VolumePerLengthMeasureExt': */
class SOAP_CMAC eml21__VolumePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1758 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure (524)
/* simple XSD type 'eml21:VolumePerMassMeasure': */
class SOAP_CMAC eml21__VolumePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerMassUom'
        enum eml21__VolumePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerMassMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerMassMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1761 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt (525)
/* simple XSD type 'eml21:VolumePerMassMeasureExt': */
class SOAP_CMAC eml21__VolumePerMassMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerMassUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerMassMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerMassMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerMassMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerMassMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerMassMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerMassMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerMassMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerMassMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1764 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure (526)
/* simple XSD type 'eml21:VolumePerPressureMeasure': */
class SOAP_CMAC eml21__VolumePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerPressureUom'
        enum eml21__VolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1767 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt (527)
/* simple XSD type 'eml21:VolumePerPressureMeasureExt': */
class SOAP_CMAC eml21__VolumePerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1770 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure (528)
/* simple XSD type 'eml21:VolumePerRotationMeasure': */
class SOAP_CMAC eml21__VolumePerRotationMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerRotationUom'
        enum eml21__VolumePerRotationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerRotationMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerRotationMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerRotationMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerRotationMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerRotationMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerRotationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerRotationMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerRotationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1773 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt (529)
/* simple XSD type 'eml21:VolumePerRotationMeasureExt': */
class SOAP_CMAC eml21__VolumePerRotationMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerRotationUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerRotationMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerRotationMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerRotationMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerRotationMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerRotationMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerRotationMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerRotationMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerRotationMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1776 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure (530)
/* simple XSD type 'eml21:VolumePerTimeLengthMeasure': */
class SOAP_CMAC eml21__VolumePerTimeLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimeLengthUom'
        enum eml21__VolumePerTimeLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimeLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimeLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimeLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimeLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimeLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimeLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimeLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimeLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1779 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt (531)
/* simple XSD type 'eml21:VolumePerTimeLengthMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimeLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimeLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimeLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimeLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimeLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimeLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimeLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimeLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimeLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimeLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1782 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure (532)
/* simple XSD type 'eml21:VolumePerTimeMeasure': */
class SOAP_CMAC eml21__VolumePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimeUom'
        enum eml21__VolumePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1785 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt (533)
/* simple XSD type 'eml21:VolumePerTimeMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1788 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure (534)
/* simple XSD type 'eml21:VolumePerTimePerAreaMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerAreaUom'
        enum eml21__VolumePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerAreaMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1791 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt (535)
/* simple XSD type 'eml21:VolumePerTimePerAreaMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerAreaMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerAreaUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerAreaMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerAreaMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerAreaMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerAreaMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerAreaMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerAreaMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerAreaMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerAreaMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1794 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure (536)
/* simple XSD type 'eml21:VolumePerTimePerLengthMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerLengthUom'
        enum eml21__VolumePerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1797 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt (537)
/* simple XSD type 'eml21:VolumePerTimePerLengthMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1800 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure (538)
/* simple XSD type 'eml21:VolumePerTimePerPressureLengthMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerPressureLengthMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerPressureLengthUom'
        enum eml21__VolumePerTimePerPressureLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerPressureLengthMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerPressureLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerPressureLengthMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerPressureLengthMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerPressureLengthMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerPressureLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerPressureLengthMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerPressureLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1803 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt (539)
/* simple XSD type 'eml21:VolumePerTimePerPressureLengthMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerPressureLengthMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerPressureLengthUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerPressureLengthMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerPressureLengthMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerPressureLengthMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerPressureLengthMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerPressureLengthMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerPressureLengthMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerPressureLengthMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1806 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure (540)
/* simple XSD type 'eml21:VolumePerTimePerPressureMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerPressureUom'
        enum eml21__VolumePerTimePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerPressureMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1809 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt (541)
/* simple XSD type 'eml21:VolumePerTimePerPressureMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerPressureMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerPressureUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerPressureMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerPressureMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerPressureMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerPressureMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerPressureMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerPressureMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerPressureMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerPressureMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1812 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure (542)
/* simple XSD type 'eml21:VolumePerTimePerTimeMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerTimeUom'
        enum eml21__VolumePerTimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerTimeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1815 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt (543)
/* simple XSD type 'eml21:VolumePerTimePerTimeMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerTimeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerTimeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerTimeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerTimeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerTimeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerTimeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerTimeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerTimeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerTimeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerTimeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1818 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure (544)
/* simple XSD type 'eml21:VolumePerTimePerVolumeMeasure': */
class SOAP_CMAC eml21__VolumePerTimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerVolumeUom'
        enum eml21__VolumePerTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1821 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt (545)
/* simple XSD type 'eml21:VolumePerTimePerVolumeMeasureExt': */
class SOAP_CMAC eml21__VolumePerTimePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerTimePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerTimePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerTimePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerTimePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerTimePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerTimePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerTimePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerTimePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerTimePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1824 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure (546)
/* simple XSD type 'eml21:VolumePerVolumeMeasure': */
class SOAP_CMAC eml21__VolumePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerVolumeUom'
        enum eml21__VolumePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumePerVolumeMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1827 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt (547)
/* simple XSD type 'eml21:VolumePerVolumeMeasureExt': */
class SOAP_CMAC eml21__VolumePerVolumeMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumePerVolumeUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumePerVolumeMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumePerVolumeMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumePerVolumeMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumePerVolumeMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumePerVolumeMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumePerVolumeMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumePerVolumeMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumePerVolumeMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1830 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure (548)
/* simple XSD type 'eml21:VolumetricHeatTransferCoefficientMeasure': */
class SOAP_CMAC eml21__VolumetricHeatTransferCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumetricHeatTransferCoefficientUom'
        enum eml21__VolumetricHeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumetricHeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumetricHeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumetricHeatTransferCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumetricHeatTransferCoefficientMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumetricHeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumetricHeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumetricHeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumetricHeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1833 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt (549)
/* simple XSD type 'eml21:VolumetricHeatTransferCoefficientMeasureExt': */
class SOAP_CMAC eml21__VolumetricHeatTransferCoefficientMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumetricHeatTransferCoefficientUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumetricHeatTransferCoefficientMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumetricHeatTransferCoefficientMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumetricHeatTransferCoefficientMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumetricHeatTransferCoefficientMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumetricHeatTransferCoefficientMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumetricHeatTransferCoefficientMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumetricHeatTransferCoefficientMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1836 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure (550)
/* simple XSD type 'eml21:VolumetricThermalExpansionMeasure': */
class SOAP_CMAC eml21__VolumetricThermalExpansionMeasure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumetricThermalExpansionUom'
        enum eml21__VolumetricThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumetricThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml21__VolumetricThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__VolumetricThermalExpansionMeasure); }
      public:
        /// Constructor with initializations
        eml21__VolumetricThermalExpansionMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__VolumetricThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml21__VolumetricThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumetricThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml21__VolumetricThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1839 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt (551)
/* simple XSD type 'eml21:VolumetricThermalExpansionMeasureExt': */
class SOAP_CMAC eml21__VolumetricThermalExpansionMeasureExt {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:VolumetricThermalExpansionUomExt'
        std::string uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__VolumetricThermalExpansionMeasureExt, default initialized and not managed by a soap context
        virtual eml21__VolumetricThermalExpansionMeasureExt *soap_alloc(void) const { return SOAP_NEW(eml21__VolumetricThermalExpansionMeasureExt); }
      public:
        /// Constructor with initializations
        eml21__VolumetricThermalExpansionMeasureExt() : __item(), uom(), soap() { }
        virtual ~eml21__VolumetricThermalExpansionMeasureExt() { }
        /// Friend allocator used by soap_new_eml21__VolumetricThermalExpansionMeasureExt(struct soap*, int)
        friend SOAP_FMAC1 eml21__VolumetricThermalExpansionMeasureExt * SOAP_FMAC2 soap_instantiate_eml21__VolumetricThermalExpansionMeasureExt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:1932 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure (582)
/* simple XSD type 'eml21:ReferencePressure': */
class SOAP_CMAC eml21__ReferencePressure {
      public:
        /// Simple content of XSD type 'eml21:AbstractMeasure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml21:PressureUom'
        enum eml21__PressureUom uom;
        /// optional attribute 'referencePressureKind' of XSD type 'eml21:ReferencePressureKind'
        enum eml21__ReferencePressureKind *referencePressureKind;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__ReferencePressure, default initialized and not managed by a soap context
        virtual eml21__ReferencePressure *soap_alloc(void) const { return SOAP_NEW(eml21__ReferencePressure); }
      public:
        /// Constructor with initializations
        eml21__ReferencePressure() : __item(), uom(), referencePressureKind(), soap() { }
        virtual ~eml21__ReferencePressure() { }
        /// Friend allocator used by soap_new_eml21__ReferencePressure(struct soap*, int)
        friend SOAP_FMAC1 eml21__ReferencePressure * SOAP_FMAC2 soap_instantiate_eml21__ReferencePressure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2034 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType (616)
/* Type gml__DefinitionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:DefinitionType': */
class SOAP_CMAC gml__DefinitionType : public gml__DefinitionBaseType {
      public:
        /// Optional element 'gml:remarks' of XSD type 'xsd:string'
        std::string *remarks;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionType, default initialized and not managed by a soap context
        virtual gml__DefinitionType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionType); }
      public:
        /// Constructor with initializations
        gml__DefinitionType() : remarks() { }
        virtual ~gml__DefinitionType() { }
        /// Friend allocator used by soap_new_gml__DefinitionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionType * SOAP_FMAC2 soap_instantiate_gml__DefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2049 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType (621)
/* simple XSD type 'gml:CodeWithAuthorityType': */
class SOAP_CMAC gml__CodeWithAuthorityType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string codeSpace;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeWithAuthorityType, default initialized and not managed by a soap context
        virtual gml__CodeWithAuthorityType *soap_alloc(void) const { return SOAP_NEW(gml__CodeWithAuthorityType); }
      public:
        /// Constructor with initializations
        gml__CodeWithAuthorityType() : __item(), codeSpace(), codeSpace_(), soap() { }
        virtual ~gml__CodeWithAuthorityType() { }
        /// Friend allocator used by soap_new_gml__CodeWithAuthorityType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeWithAuthorityType * SOAP_FMAC2 soap_instantiate_gml__CodeWithAuthorityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2055 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType (623)
/* Type gml__AbstractTimePrimitiveType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractTimePrimitiveType': */
class SOAP_CMAC gml__AbstractTimePrimitiveType : public gml__AbstractTimeObjectType {
      public:
        /// Optional element 'gml:relatedTime' of XSD type 'gml:RelatedTimeType'
        std::vector<gml__RelatedTimeType *> relatedTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimePrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTimePrimitiveType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimePrimitiveType); }
      public:
        /// Constructor with initializations
        gml__AbstractTimePrimitiveType() : relatedTime() { }
        virtual ~gml__AbstractTimePrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimePrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimePrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimePrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2109 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AngleType
#define SOAP_TYPE_gsoap_eml2_1_gml__AngleType (641)
/* Type gml__AngleType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:AngleType': */
class SOAP_CMAC gml__AngleType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AngleType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AngleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AngleType, default initialized and not managed by a soap context
        virtual gml__AngleType *soap_alloc(void) const { return SOAP_NEW(gml__AngleType); }
      public:
        /// Constructor with initializations
        gml__AngleType() { }
        virtual ~gml__AngleType() { }
        /// Friend allocator used by soap_new_gml__AngleType(struct soap*, int)
        friend SOAP_FMAC1 gml__AngleType * SOAP_FMAC2 soap_instantiate_gml__AngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2121 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__LengthType
#define SOAP_TYPE_gsoap_eml2_1_gml__LengthType (645)
/* Type gml__LengthType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:LengthType': */
class SOAP_CMAC gml__LengthType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__LengthType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__LengthType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LengthType, default initialized and not managed by a soap context
        virtual gml__LengthType *soap_alloc(void) const { return SOAP_NEW(gml__LengthType); }
      public:
        /// Constructor with initializations
        gml__LengthType() { }
        virtual ~gml__LengthType() { }
        /// Friend allocator used by soap_new_gml__LengthType(struct soap*, int)
        friend SOAP_FMAC1 gml__LengthType * SOAP_FMAC2 soap_instantiate_gml__LengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2193 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (669)
/* Type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_PositionalAccuracy_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType : public gmd__AbstractDQ_USCOREElement_USCOREType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { }
        virtual ~gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:375 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct (63)
/* simple XSD type 'prodml2:NameStruct': */
class SOAP_CMAC prodml2__NameStruct {
      public:
        /// Simple content of XSD type 'eml21:String64' wrapped by this struct
        std::string __item;
        /// optional attribute 'authority' of XSD type 'eml21:String64'
        std::string *authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type prodml2__NameStruct, default initialized and not managed by a soap context
        virtual prodml2__NameStruct *soap_alloc(void) const { return SOAP_NEW(prodml2__NameStruct); }
      public:
        /// Constructor with initializations
        prodml2__NameStruct() : __item(), authority(), soap() { }
        virtual ~prodml2__NameStruct() { }
        /// Friend allocator used by soap_new_prodml2__NameStruct(struct soap*, int)
        friend SOAP_FMAC1 prodml2__NameStruct * SOAP_FMAC2 soap_instantiate_prodml2__NameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:678 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName (164)
/* simple XSD type 'eml21:AuthorityQualifiedName': */
class SOAP_CMAC eml21__AuthorityQualifiedName {
      public:
        /// Simple content of XSD type 'eml21:String64' wrapped by this struct
        std::string __item;
        /// required attribute 'authority' of XSD type 'eml21:String64'
        std::string authority;
        /// optional attribute 'code' of XSD type 'eml21:String64'
        std::string *code;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__AuthorityQualifiedName, default initialized and not managed by a soap context
        virtual eml21__AuthorityQualifiedName *soap_alloc(void) const { return SOAP_NEW(eml21__AuthorityQualifiedName); }
      public:
        /// Constructor with initializations
        eml21__AuthorityQualifiedName() : __item(), authority(), code(), soap() { }
        virtual ~eml21__AuthorityQualifiedName() { }
        /// Friend allocator used by soap_new_eml21__AuthorityQualifiedName(struct soap*, int)
        friend SOAP_FMAC1 eml21__AuthorityQualifiedName * SOAP_FMAC2 soap_instantiate_eml21__AuthorityQualifiedName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:696 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray (170)
/* Type eml21__FloatingPointConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:FloatingPointConstantArray': */
class SOAP_CMAC eml21__FloatingPointConstantArray : public eml21__AbstractFloatingPointArray {
      public:
        /// Required element 'eml21:Value' of XSD type 'xsd:double'
        double Value;
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FloatingPointConstantArray, default initialized and not managed by a soap context
        virtual eml21__FloatingPointConstantArray *soap_alloc(void) const { return SOAP_NEW(eml21__FloatingPointConstantArray); }
      public:
        /// Constructor with initializations
        eml21__FloatingPointConstantArray() : Value(), Count() { }
        virtual ~eml21__FloatingPointConstantArray() { }
        /// Friend allocator used by soap_new_eml21__FloatingPointConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__FloatingPointConstantArray * SOAP_FMAC2 soap_instantiate_eml21__FloatingPointConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:699 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray (171)
/* Type eml21__FloatingPointExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:FloatingPointExternalArray': */
class SOAP_CMAC eml21__FloatingPointExternalArray : public eml21__AbstractFloatingPointArray {
      public:
        /// Required element 'eml21:Values' of XSD type 'eml21:ExternalDataset'
        eml21__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FloatingPointExternalArray, default initialized and not managed by a soap context
        virtual eml21__FloatingPointExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__FloatingPointExternalArray); }
      public:
        /// Constructor with initializations
        eml21__FloatingPointExternalArray() : Values() { }
        virtual ~eml21__FloatingPointExternalArray() { }
        /// Friend allocator used by soap_new_eml21__FloatingPointExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__FloatingPointExternalArray * SOAP_FMAC2 soap_instantiate_eml21__FloatingPointExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:702 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray (172)
/* Type eml21__FloatingPointLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:FloatingPointLatticeArray': */
class SOAP_CMAC eml21__FloatingPointLatticeArray : public eml21__AbstractFloatingPointArray {
      public:
        /// Required element 'eml21:StartValue' of XSD type 'xsd:double'
        double StartValue;
        /// Required element 'eml21:Offset' of XSD type 'eml21:FloatingPointConstantArray'
        std::vector<eml21__FloatingPointConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FloatingPointLatticeArray, default initialized and not managed by a soap context
        virtual eml21__FloatingPointLatticeArray *soap_alloc(void) const { return SOAP_NEW(eml21__FloatingPointLatticeArray); }
      public:
        /// Constructor with initializations
        eml21__FloatingPointLatticeArray() : StartValue(), Offset() { }
        virtual ~eml21__FloatingPointLatticeArray() { }
        /// Friend allocator used by soap_new_eml21__FloatingPointLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__FloatingPointLatticeArray * SOAP_FMAC2 soap_instantiate_eml21__FloatingPointLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:708 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray (174)
/* Type eml21__IntegerArrayFromBooleanMaskArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerArrayFromBooleanMaskArray': */
class SOAP_CMAC eml21__IntegerArrayFromBooleanMaskArray : public eml21__AbstractIntegerArray {
      public:
        /// Required element 'eml21:TotalIndexCount' of XSD type 'xsd:unsignedLong'
        ULONG64 TotalIndexCount;
        /// Required element 'eml21:Mask' of XSD type 'eml21:AbstractBooleanArray'
        eml21__AbstractBooleanArray *Mask;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerArrayFromBooleanMaskArray, default initialized and not managed by a soap context
        virtual eml21__IntegerArrayFromBooleanMaskArray *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerArrayFromBooleanMaskArray); }
      public:
        /// Constructor with initializations
        eml21__IntegerArrayFromBooleanMaskArray() : TotalIndexCount(), Mask() { }
        virtual ~eml21__IntegerArrayFromBooleanMaskArray() { }
        /// Friend allocator used by soap_new_eml21__IntegerArrayFromBooleanMaskArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerArrayFromBooleanMaskArray * SOAP_FMAC2 soap_instantiate_eml21__IntegerArrayFromBooleanMaskArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:711 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray (175)
/* Type eml21__IntegerConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerConstantArray': */
class SOAP_CMAC eml21__IntegerConstantArray : public eml21__AbstractIntegerArray {
      public:
        /// Required element 'eml21:Value' of XSD type 'xsd:long'
        LONG64 Value;
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerConstantArray, default initialized and not managed by a soap context
        virtual eml21__IntegerConstantArray *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerConstantArray); }
      public:
        /// Constructor with initializations
        eml21__IntegerConstantArray() : Value(), Count() { }
        virtual ~eml21__IntegerConstantArray() { }
        /// Friend allocator used by soap_new_eml21__IntegerConstantArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerConstantArray * SOAP_FMAC2 soap_instantiate_eml21__IntegerConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:714 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray (176)
/* Type eml21__IntegerExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerExternalArray': */
class SOAP_CMAC eml21__IntegerExternalArray : public eml21__AbstractIntegerArray {
      public:
        /// Required element 'eml21:NullValue' of XSD type 'xsd:long'
        LONG64 NullValue;
        /// Required element 'eml21:Values' of XSD type 'eml21:ExternalDataset'
        eml21__ExternalDataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerExternalArray, default initialized and not managed by a soap context
        virtual eml21__IntegerExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerExternalArray); }
      public:
        /// Constructor with initializations
        eml21__IntegerExternalArray() : NullValue(), Values() { }
        virtual ~eml21__IntegerExternalArray() { }
        /// Friend allocator used by soap_new_eml21__IntegerExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerExternalArray * SOAP_FMAC2 soap_instantiate_eml21__IntegerExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:717 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray (177)
/* Type eml21__IntegerLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerLatticeArray': */
class SOAP_CMAC eml21__IntegerLatticeArray : public eml21__AbstractIntegerArray {
      public:
        /// Required element 'eml21:StartValue' of XSD type 'xsd:long'
        LONG64 StartValue;
        /// Required element 'eml21:Offset' of XSD type 'eml21:IntegerConstantArray'
        std::vector<eml21__IntegerConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerLatticeArray, default initialized and not managed by a soap context
        virtual eml21__IntegerLatticeArray *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerLatticeArray); }
      public:
        /// Constructor with initializations
        eml21__IntegerLatticeArray() : StartValue(), Offset() { }
        virtual ~eml21__IntegerLatticeArray() { }
        /// Friend allocator used by soap_new_eml21__IntegerLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerLatticeArray * SOAP_FMAC2 soap_instantiate_eml21__IntegerLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:720 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray (178)
/* Type eml21__IntegerRangeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:IntegerRangeArray': */
class SOAP_CMAC eml21__IntegerRangeArray : public eml21__AbstractIntegerArray {
      public:
        /// Required element 'eml21:Count' of XSD type 'xsd:unsignedLong'
        ULONG64 Count;
        /// Required element 'eml21:Value' of XSD type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__IntegerRangeArray, default initialized and not managed by a soap context
        virtual eml21__IntegerRangeArray *soap_alloc(void) const { return SOAP_NEW(eml21__IntegerRangeArray); }
      public:
        /// Constructor with initializations
        eml21__IntegerRangeArray() : Count(), Value() { }
        virtual ~eml21__IntegerRangeArray() { }
        /// Friend allocator used by soap_new_eml21__IntegerRangeArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__IntegerRangeArray * SOAP_FMAC2 soap_instantiate_eml21__IntegerRangeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:735 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure (183)
/* simple XSD type 'eml21:StringMeasure': */
class SOAP_CMAC eml21__StringMeasure {
      public:
        /// Simple content of XSD type 'eml21:String64' wrapped by this struct
        std::string __item;
        /// optional attribute 'uom' of XSD type 'eml21:UnitOfMeasure'
        enum eml21__UnitOfMeasure *uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__StringMeasure, default initialized and not managed by a soap context
        virtual eml21__StringMeasure *soap_alloc(void) const { return SOAP_NEW(eml21__StringMeasure); }
      public:
        /// Constructor with initializations
        eml21__StringMeasure() : __item(), uom(), soap() { }
        virtual ~eml21__StringMeasure() { }
        /// Friend allocator used by soap_new_eml21__StringMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml21__StringMeasure * SOAP_FMAC2 soap_instantiate_eml21__StringMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2031 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType (615)
/* Type gml__IdentifiedObjectType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:IdentifiedObjectType': */
class SOAP_CMAC gml__IdentifiedObjectType : public gml__DefinitionType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__IdentifiedObjectType, default initialized and not managed by a soap context
        virtual gml__IdentifiedObjectType *soap_alloc(void) const { return SOAP_NEW(gml__IdentifiedObjectType); }
      public:
        /// Constructor with initializations
        gml__IdentifiedObjectType() { }
        virtual ~gml__IdentifiedObjectType() { }
        /// Friend allocator used by soap_new_gml__IdentifiedObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__IdentifiedObjectType * SOAP_FMAC2 soap_instantiate_gml__IdentifiedObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:690 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray (168)
/* Type eml21__DoubleExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:DoubleExternalArray': */
class SOAP_CMAC eml21__DoubleExternalArray : public eml21__FloatingPointExternalArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__DoubleExternalArray, default initialized and not managed by a soap context
        virtual eml21__DoubleExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__DoubleExternalArray); }
      public:
        /// Constructor with initializations
        eml21__DoubleExternalArray() { }
        virtual ~eml21__DoubleExternalArray() { }
        /// Friend allocator used by soap_new_eml21__DoubleExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__DoubleExternalArray * SOAP_FMAC2 soap_instantiate_eml21__DoubleExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:693 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray (169)
/* Type eml21__FloatExternalArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml21:FloatExternalArray': */
class SOAP_CMAC eml21__FloatExternalArray : public eml21__FloatingPointExternalArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml21__FloatExternalArray, default initialized and not managed by a soap context
        virtual eml21__FloatExternalArray *soap_alloc(void) const { return SOAP_NEW(eml21__FloatExternalArray); }
      public:
        /// Constructor with initializations
        eml21__FloatExternalArray() { }
        virtual ~eml21__FloatExternalArray() { }
        /// Friend allocator used by soap_new_eml21__FloatExternalArray(struct soap*, int)
        friend SOAP_FMAC1 eml21__FloatExternalArray * SOAP_FMAC2 soap_instantiate_eml21__FloatExternalArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2028 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType (614)
/* Type gml__AbstractCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCRSType': */
class SOAP_CMAC gml__AbstractCRSType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        std::vector<_gml__domainOfValidity *> domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCRSType); }
      public:
        /// Constructor with initializations
        gml__AbstractCRSType() : domainOfValidity(), scope() { }
        virtual ~gml__AbstractCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2073 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType (629)
/* Type gml__AbstractCoordinateSystemType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCoordinateSystemType': */
class SOAP_CMAC gml__AbstractCoordinateSystemType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:axis' of XSD type 'gml:CoordinateSystemAxisPropertyType'
        std::vector<gml__CoordinateSystemAxisPropertyType *> axis;
        /// optional attribute 'aggregationType' of XSD type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateSystemType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateSystemType); }
      public:
        /// Constructor with initializations
        gml__AbstractCoordinateSystemType() : axis(), aggregationType() { }
        virtual ~gml__AbstractCoordinateSystemType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateSystemType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2079 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType (631)
/* Type gml__CoordinateSystemAxisType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:CoordinateSystemAxisType': */
class SOAP_CMAC gml__CoordinateSystemAxisType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:axisAbbrev' of XSD type 'gml:CodeType'
        gml__CodeType *axisAbbrev;
        /// Required element 'gml:axisDirection' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *axisDirection;
        /// Optional element 'gml:minimumValue' of XSD type 'xsd:double'
        double *minimumValue;
        /// Optional element 'gml:maximumValue' of XSD type 'xsd:double'
        double *maximumValue;
        /// Optional element 'gml:rangeMeaning' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *rangeMeaning;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisType); }
      public:
        /// Constructor with initializations
        gml__CoordinateSystemAxisType() : axisAbbrev(), axisDirection(), minimumValue(), maximumValue(), rangeMeaning() { }
        virtual ~gml__CoordinateSystemAxisType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2100 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType (638)
/* Type gml__AbstractDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractDatumType': */
class SOAP_CMAC gml__AbstractDatumType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:anchorDefinition' of XSD type 'gml:CodeType'
        gml__CodeType *anchorDefinition;
        /// Optional element 'gml:realizationEpoch' of XSD type 'xsd:date'
        std::string *realizationEpoch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractDatumType, default initialized and not managed by a soap context
        virtual gml__AbstractDatumType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractDatumType); }
      public:
        /// Constructor with initializations
        gml__AbstractDatumType() : domainOfValidity(), scope(), anchorDefinition(), realizationEpoch() { }
        virtual ~gml__AbstractDatumType() { }
        /// Friend allocator used by soap_new_gml__AbstractDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractDatumType * SOAP_FMAC2 soap_instantiate_gml__AbstractDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2106 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType (640)
/* Type gml__PrimeMeridianType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:PrimeMeridianType': */
class SOAP_CMAC gml__PrimeMeridianType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:greenwichLongitude' of XSD type 'gml:AngleType'
        gml__AngleType *greenwichLongitude;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianType); }
      public:
        /// Constructor with initializations
        gml__PrimeMeridianType() : greenwichLongitude() { }
        virtual ~gml__PrimeMeridianType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2118 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType (644)
/* Type gml__EllipsoidType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:EllipsoidType': */
class SOAP_CMAC gml__EllipsoidType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:semiMajorAxis' of XSD type 'gml:MeasureType'
        gml__MeasureType *semiMajorAxis;
        /// Required element 'gml:secondDefiningParameter' of XSD type 'gml:secondDefiningParameter'
        _gml__secondDefiningParameter *secondDefiningParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidType, default initialized and not managed by a soap context
        virtual gml__EllipsoidType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidType() : semiMajorAxis(), secondDefiningParameter() { }
        virtual ~gml__EllipsoidType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2136 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType (650)
/* Type gml__AbstractCoordinateOperationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCoordinateOperationType': */
class SOAP_CMAC gml__AbstractCoordinateOperationType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:operationVersion' of XSD type 'xsd:string'
        std::string *operationVersion;
        /// Optional element 'gml:coordinateOperationAccuracy' of XSD type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// Optional element 'gml:sourceCRS' of XSD type 'gml:CRSPropertyType'
        gml__CRSPropertyType *sourceCRS;
        /// Optional element 'gml:targetCRS' of XSD type 'gml:CRSPropertyType'
        gml__CRSPropertyType *targetCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateOperationType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateOperationType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateOperationType); }
      public:
        /// Constructor with initializations
        gml__AbstractCoordinateOperationType() : domainOfValidity(), scope(), operationVersion(), coordinateOperationAccuracy(), sourceCRS(), targetCRS() { }
        virtual ~gml__AbstractCoordinateOperationType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateOperationType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateOperationType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:38492 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_GeodeticCRSType
#define SOAP_TYPE_gsoap_eml2_1__gml__union_GeodeticCRSType (1681)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticCRSType
{
        #define SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_ellipsoidalCS	(1)	/**< union variant selector value for member ellipsoidalCS */
        gml__EllipsoidalCSPropertyType *ellipsoidalCS;
        #define SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_cartesianCS	(2)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_sphericalCS	(3)	/**< union variant selector value for member sphericalCS */
        gml__SphericalCSPropertyType *sphericalCS;
};
#endif

/* eml2_1ForGsoap.h:2025 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType (613)
/* Type gml__GeodeticCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:GeodeticCRSType': */
class SOAP_CMAC gml__GeodeticCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_GeodeticCRSType variant selector __union_GeodeticCRSType set to one of: SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_ellipsoidalCS SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_cartesianCS SOAP_UNION_gsoap_eml2_1__gml__union_GeodeticCRSType_sphericalCS
        int __union_GeodeticCRSType;
        union _gml__union_GeodeticCRSType union_GeodeticCRSType;
        /// Required element 'gml:geodeticDatum' of XSD type 'gml:GeodeticDatumPropertyType'
        gml__GeodeticDatumPropertyType *geodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSType); }
      public:
        /// Constructor with initializations
        gml__GeodeticCRSType() : __union_GeodeticCRSType(), geodeticDatum() { }
        virtual ~gml__GeodeticCRSType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2070 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType (628)
/* Type gml__EllipsoidalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:EllipsoidalCSType': */
class SOAP_CMAC gml__EllipsoidalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidalCSType() { }
        virtual ~gml__EllipsoidalCSType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2085 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType (633)
/* Type gml__CartesianCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:CartesianCSType': */
class SOAP_CMAC gml__CartesianCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSType, default initialized and not managed by a soap context
        virtual gml__CartesianCSType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSType); }
      public:
        /// Constructor with initializations
        gml__CartesianCSType() { }
        virtual ~gml__CartesianCSType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2091 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType (635)
/* Type gml__SphericalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:SphericalCSType': */
class SOAP_CMAC gml__SphericalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSType, default initialized and not managed by a soap context
        virtual gml__SphericalCSType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSType); }
      public:
        /// Constructor with initializations
        gml__SphericalCSType() { }
        virtual ~gml__SphericalCSType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2097 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType (637)
/* Type gml__GeodeticDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:GeodeticDatumType': */
class SOAP_CMAC gml__GeodeticDatumType : public gml__AbstractDatumType {
      public:
        /// Required element 'gml:primeMeridian' of XSD type 'gml:PrimeMeridianPropertyType'
        gml__PrimeMeridianPropertyType *primeMeridian;
        /// Required element 'gml:ellipsoid' of XSD type 'gml:EllipsoidPropertyType'
        gml__EllipsoidPropertyType *ellipsoid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumType); }
      public:
        /// Constructor with initializations
        gml__GeodeticDatumType() : primeMeridian(), ellipsoid() { }
        virtual ~gml__GeodeticDatumType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2127 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType (647)
/* Type gml__AbstractGeneralDerivedCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractGeneralDerivedCRSType': */
class SOAP_CMAC gml__AbstractGeneralDerivedCRSType : public gml__AbstractCRSType {
      public:
        /// Required element 'gml:conversion' of XSD type 'gml:GeneralConversionPropertyType'
        gml__GeneralConversionPropertyType *conversion;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralDerivedCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralDerivedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralDerivedCRSType); }
      public:
        /// Constructor with initializations
        gml__AbstractGeneralDerivedCRSType() : conversion() { }
        virtual ~gml__AbstractGeneralDerivedCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralDerivedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralDerivedCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralDerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2133 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType (649)
/* complex XSD type 'gml:AbstractGeneralConversionType': */
class SOAP_CMAC gml__AbstractGeneralConversionType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional element 'gml:remarks' of XSD type 'xsd:string'
        std::string *remarks;
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:coordinateOperationAccuracy' of XSD type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralConversionType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralConversionType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralConversionType); }
      public:
        /// Constructor with initializations
        gml__AbstractGeneralConversionType() : description(), descriptionReference(), identifier(), name(), remarks(), domainOfValidity(), scope(), coordinateOperationAccuracy(), gml__id(), soap() { }
        virtual ~gml__AbstractGeneralConversionType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralConversionType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralConversionType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2145 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType (653)
/* Type gml__VerticalCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalCRSType': */
class SOAP_CMAC gml__VerticalCRSType : public gml__AbstractCRSType {
      public:
        /// Required element 'gml:verticalCS' of XSD type 'gml:VerticalCSPropertyType'
        gml__VerticalCSPropertyType *verticalCS;
        /// Required element 'gml:verticalDatum' of XSD type 'gml:VerticalDatumPropertyType'
        gml__VerticalDatumPropertyType *verticalDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCRSType, default initialized and not managed by a soap context
        virtual gml__VerticalCRSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCRSType); }
      public:
        /// Constructor with initializations
        gml__VerticalCRSType() : verticalCS(), verticalDatum() { }
        virtual ~gml__VerticalCRSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCRSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2151 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType (655)
/* Type gml__VerticalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalCSType': */
class SOAP_CMAC gml__VerticalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSType, default initialized and not managed by a soap context
        virtual gml__VerticalCSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSType); }
      public:
        /// Constructor with initializations
        gml__VerticalCSType() { }
        virtual ~gml__VerticalCSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:2157 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType (657)
/* Type gml__VerticalDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalDatumType': */
class SOAP_CMAC gml__VerticalDatumType : public gml__AbstractDatumType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumType); }
      public:
        /// Constructor with initializations
        gml__VerticalDatumType() { }
        virtual ~gml__VerticalDatumType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:38967 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__union_ProjectedCRSType
#define SOAP_TYPE_gsoap_eml2_1__gml__union_ProjectedCRSType (1689)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ProjectedCRSType
{
        #define SOAP_UNION_gsoap_eml2_1__gml__union_ProjectedCRSType_baseGeodeticCRS	(1)	/**< union variant selector value for member baseGeodeticCRS */
        gml__GeodeticCRSPropertyType *baseGeodeticCRS;
};
#endif

/* eml2_1ForGsoap.h:2124 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType (646)
/* Type gml__ProjectedCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:ProjectedCRSType': */
class SOAP_CMAC gml__ProjectedCRSType : public gml__AbstractGeneralDerivedCRSType {
      public:
        /// Union with union _gml__union_ProjectedCRSType variant selector __union_ProjectedCRSType set to one of: SOAP_UNION_gsoap_eml2_1__gml__union_ProjectedCRSType_baseGeodeticCRS
        int __union_ProjectedCRSType;
        union _gml__union_ProjectedCRSType union_ProjectedCRSType;
        /// Required element 'gml:cartesianCS' of XSD type 'gml:CartesianCSPropertyType'
        gml__CartesianCSPropertyType *cartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ProjectedCRSType, default initialized and not managed by a soap context
        virtual gml__ProjectedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__ProjectedCRSType); }
      public:
        /// Constructor with initializations
        gml__ProjectedCRSType() : __union_ProjectedCRSType(), cartesianCS() { }
        virtual ~gml__ProjectedCRSType() { }
        /// Friend allocator used by soap_new_gml__ProjectedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__ProjectedCRSType * SOAP_FMAC2 soap_instantiate_gml__ProjectedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* eml2_1ForGsoap.h:40892 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header (1778)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_1ForGsoap.h:40892 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code (1779)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_1ForGsoap.h:40892 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail (1781)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_1ForGsoap.h:40892 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason (1784)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* eml2_1ForGsoap.h:40892 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault (1785)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_1__XML
#define SOAP_TYPE_gsoap_eml2_1__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE_gsoap_eml2_1__QName
#define SOAP_TYPE_gsoap_eml2_1__QName (6)
typedef char *_QName;
#endif

/* eml2_1ForGsoap.h:217 */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__integer
#define SOAP_TYPE_gsoap_eml2_1_xsd__integer (10)
typedef LONG64 xsd__integer;
#endif

/* eml2_1ForGsoap.h:220 */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_1_xsd__nonNegativeInteger (13)
typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* eml2_1ForGsoap.h:223 */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__ID
#define SOAP_TYPE_gsoap_eml2_1_xsd__ID (15)
typedef std::string xsd__ID;
#endif

/* eml2_1ForGsoap.h:226 */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_1_xsd__anyURI (16)
typedef std::string xsd__anyURI;
#endif

/* eml2_1ForGsoap.h:229 */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__date
#define SOAP_TYPE_gsoap_eml2_1_xsd__date (17)
typedef std::string xsd__date;
#endif

/* eml2_1ForGsoap.h:2312 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationTypeExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationTypeExt (706)
typedef std::string prodml2__DasCalibrationTypeExt;
#endif

/* eml2_1ForGsoap.h:2315 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnumExt (707)
typedef std::string prodml2__PlusComponentEnumExt;
#endif

/* eml2_1ForGsoap.h:2318 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnumExt (708)
typedef std::string prodml2__PseudoComponentEnumExt;
#endif

/* eml2_1ForGsoap.h:2321 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnumExt (709)
typedef std::string prodml2__PureComponentEnumExt;
#endif

/* eml2_1ForGsoap.h:2324 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKindExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKindExt (710)
typedef std::string prodml2__ReportingDurationKindExt;
#endif

/* eml2_1ForGsoap.h:2335 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKindExt (711)
typedef std::string eml21__LithologyKindExt;
#endif

/* eml2_1ForGsoap.h:2338 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKindExt (712)
typedef std::string eml21__LithologyQualifierKindExt;
#endif

/* eml2_1ForGsoap.h:2341 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKindExt (713)
typedef std::string eml21__QuantityClassKindExt;
#endif

/* eml2_1ForGsoap.h:2344 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceConditionExt (714)
typedef std::string eml21__ReferenceConditionExt;
#endif

/* eml2_1ForGsoap.h:2347 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasureExt (715)
typedef std::string eml21__UnitOfMeasureExt;
#endif

/* eml2_1ForGsoap.h:2350 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUomExt (716)
typedef std::string eml21__AbsorbedDoseUomExt;
#endif

/* eml2_1ForGsoap.h:2353 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUomExt (717)
typedef std::string eml21__ActivityOfRadioactivityUomExt;
#endif

/* eml2_1ForGsoap.h:2356 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUomExt (718)
typedef std::string eml21__AmountOfSubstancePerAmountOfSubstanceUomExt;
#endif

/* eml2_1ForGsoap.h:2359 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUomExt (719)
typedef std::string eml21__AmountOfSubstancePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2362 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUomExt (720)
typedef std::string eml21__AmountOfSubstancePerTimePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2365 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUomExt (721)
typedef std::string eml21__AmountOfSubstancePerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2368 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUomExt (722)
typedef std::string eml21__AmountOfSubstancePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2371 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUomExt (723)
typedef std::string eml21__AmountOfSubstanceUomExt;
#endif

/* eml2_1ForGsoap.h:2374 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUomExt (724)
typedef std::string eml21__AnglePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2377 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUomExt (725)
typedef std::string eml21__AnglePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2380 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUomExt (726)
typedef std::string eml21__AngularAccelerationUomExt;
#endif

/* eml2_1ForGsoap.h:2383 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUomExt (727)
typedef std::string eml21__AngularVelocityUomExt;
#endif

/* eml2_1ForGsoap.h:2386 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUomExt (728)
typedef std::string eml21__APIGammaRayUomExt;
#endif

/* eml2_1ForGsoap.h:2389 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUomExt (729)
typedef std::string eml21__APIGravityUomExt;
#endif

/* eml2_1ForGsoap.h:2392 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUomExt (730)
typedef std::string eml21__APINeutronUomExt;
#endif

/* eml2_1ForGsoap.h:2395 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUomExt (731)
typedef std::string eml21__AreaPerAmountOfSubstanceUomExt;
#endif

/* eml2_1ForGsoap.h:2398 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUomExt (732)
typedef std::string eml21__AreaPerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2401 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUomExt (733)
typedef std::string eml21__AreaPerCountUomExt;
#endif

/* eml2_1ForGsoap.h:2404 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUomExt (734)
typedef std::string eml21__AreaPerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2407 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUomExt (735)
typedef std::string eml21__AreaPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2410 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUomExt (736)
typedef std::string eml21__AreaPerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2413 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaUomExt (737)
typedef std::string eml21__AreaUomExt;
#endif

/* eml2_1ForGsoap.h:2416 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUomExt (738)
typedef std::string eml21__AttenuationPerFrequencyIntervalUomExt;
#endif

/* eml2_1ForGsoap.h:2419 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUomExt (739)
typedef std::string eml21__CapacitanceUomExt;
#endif

/* eml2_1ForGsoap.h:2422 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUomExt (740)
typedef std::string eml21__CationExchangeCapacityUomExt;
#endif

/* eml2_1ForGsoap.h:2425 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUomExt (741)
typedef std::string eml21__DataTransferSpeedUomExt;
#endif

/* eml2_1ForGsoap.h:2428 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUomExt (742)
typedef std::string eml21__DiffusionCoefficientUomExt;
#endif

/* eml2_1ForGsoap.h:2431 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUomExt (743)
typedef std::string eml21__DiffusiveTimeOfFlightUomExt;
#endif

/* eml2_1ForGsoap.h:2434 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUomExt (744)
typedef std::string eml21__DigitalStorageUomExt;
#endif

/* eml2_1ForGsoap.h:2437 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUomExt (745)
typedef std::string eml21__DimensionlessUomExt;
#endif

/* eml2_1ForGsoap.h:2440 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUomExt (746)
typedef std::string eml21__DipoleMomentUomExt;
#endif

/* eml2_1ForGsoap.h:2443 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUomExt (747)
typedef std::string eml21__DoseEquivalentUomExt;
#endif

/* eml2_1ForGsoap.h:2446 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUomExt (748)
typedef std::string eml21__DynamicViscosityUomExt;
#endif

/* eml2_1ForGsoap.h:2449 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUomExt (749)
typedef std::string eml21__ElectricalResistivityUomExt;
#endif

/* eml2_1ForGsoap.h:2452 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUomExt (750)
typedef std::string eml21__ElectricChargePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2455 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUomExt (751)
typedef std::string eml21__ElectricChargePerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2458 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUomExt (752)
typedef std::string eml21__ElectricChargePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2461 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUomExt (753)
typedef std::string eml21__ElectricChargeUomExt;
#endif

/* eml2_1ForGsoap.h:2464 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUomExt (754)
typedef std::string eml21__ElectricConductanceUomExt;
#endif

/* eml2_1ForGsoap.h:2467 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUomExt (755)
typedef std::string eml21__ElectricConductivityUomExt;
#endif

/* eml2_1ForGsoap.h:2470 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUomExt (756)
typedef std::string eml21__ElectricCurrentDensityUomExt;
#endif

/* eml2_1ForGsoap.h:2473 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUomExt (757)
typedef std::string eml21__ElectricCurrentUomExt;
#endif

/* eml2_1ForGsoap.h:2476 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUomExt (758)
typedef std::string eml21__ElectricFieldStrengthUomExt;
#endif

/* eml2_1ForGsoap.h:2479 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUomExt (759)
typedef std::string eml21__ElectricPotentialDifferenceUomExt;
#endif

/* eml2_1ForGsoap.h:2482 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUomExt (760)
typedef std::string eml21__ElectricResistancePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2485 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUomExt (761)
typedef std::string eml21__ElectricResistanceUomExt;
#endif

/* eml2_1ForGsoap.h:2488 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUomExt (762)
typedef std::string eml21__ElectromagneticMomentUomExt;
#endif

/* eml2_1ForGsoap.h:2491 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUomExt (763)
typedef std::string eml21__EnergyLengthPerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2494 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUomExt (764)
typedef std::string eml21__EnergyLengthPerTimeAreaTemperatureUomExt;
#endif

/* eml2_1ForGsoap.h:2497 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUomExt (765)
typedef std::string eml21__EnergyPerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2500 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUomExt (766)
typedef std::string eml21__EnergyPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2503 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUomExt (767)
typedef std::string eml21__EnergyPerMassPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2506 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUomExt (768)
typedef std::string eml21__EnergyPerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2509 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUomExt (769)
typedef std::string eml21__EnergyPerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2512 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUomExt (770)
typedef std::string eml21__EnergyUomExt;
#endif

/* eml2_1ForGsoap.h:2515 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUomExt (771)
typedef std::string eml21__ForceAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2518 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUomExt (772)
typedef std::string eml21__ForceLengthPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2521 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUomExt (773)
typedef std::string eml21__ForcePerForceUomExt;
#endif

/* eml2_1ForGsoap.h:2524 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUomExt (774)
typedef std::string eml21__ForcePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2527 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUomExt (775)
typedef std::string eml21__ForcePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2530 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceUomExt (776)
typedef std::string eml21__ForceUomExt;
#endif

/* eml2_1ForGsoap.h:2533 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUomExt (777)
typedef std::string eml21__FrequencyIntervalUomExt;
#endif

/* eml2_1ForGsoap.h:2536 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUomExt (778)
typedef std::string eml21__FrequencyUomExt;
#endif

/* eml2_1ForGsoap.h:2539 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUomExt (779)
typedef std::string eml21__HeatCapacityUomExt;
#endif

/* eml2_1ForGsoap.h:2542 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUomExt (780)
typedef std::string eml21__HeatFlowRateUomExt;
#endif

/* eml2_1ForGsoap.h:2545 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUomExt (781)
typedef std::string eml21__HeatTransferCoefficientUomExt;
#endif

/* eml2_1ForGsoap.h:2548 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUomExt (782)
typedef std::string eml21__IlluminanceUomExt;
#endif

/* eml2_1ForGsoap.h:2551 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUomExt (783)
typedef std::string eml21__InductanceUomExt;
#endif

/* eml2_1ForGsoap.h:2554 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUomExt (784)
typedef std::string eml21__IsothermalCompressibilityUomExt;
#endif

/* eml2_1ForGsoap.h:2557 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUomExt (785)
typedef std::string eml21__KinematicViscosityUomExt;
#endif

/* eml2_1ForGsoap.h:2560 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUomExt (786)
typedef std::string eml21__LengthPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2563 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUomExt (787)
typedef std::string eml21__LengthPerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2566 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUomExt (788)
typedef std::string eml21__LengthPerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2569 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUomExt (789)
typedef std::string eml21__LengthPerTemperatureUomExt;
#endif

/* eml2_1ForGsoap.h:2572 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUomExt (790)
typedef std::string eml21__LengthPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2575 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUomExt (791)
typedef std::string eml21__LengthPerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2578 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthUomExt (792)
typedef std::string eml21__LengthUomExt;
#endif

/* eml2_1ForGsoap.h:2581 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUomExt (793)
typedef std::string eml21__LightExposureUomExt;
#endif

/* eml2_1ForGsoap.h:2584 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUomExt (794)
typedef std::string eml21__LinearAccelerationUomExt;
#endif

/* eml2_1ForGsoap.h:2587 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUomExt (795)
typedef std::string eml21__LinearThermalExpansionUomExt;
#endif

/* eml2_1ForGsoap.h:2590 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUomExt (796)
typedef std::string eml21__LogarithmicPowerRatioPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2593 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUomExt (797)
typedef std::string eml21__LogarithmicPowerRatioUomExt;
#endif

/* eml2_1ForGsoap.h:2596 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUomExt (798)
typedef std::string eml21__LuminanceUomExt;
#endif

/* eml2_1ForGsoap.h:2599 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUomExt (799)
typedef std::string eml21__LuminousEfficacyUomExt;
#endif

/* eml2_1ForGsoap.h:2602 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUomExt (800)
typedef std::string eml21__LuminousFluxUomExt;
#endif

/* eml2_1ForGsoap.h:2605 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUomExt (801)
typedef std::string eml21__LuminousIntensityUomExt;
#endif

/* eml2_1ForGsoap.h:2608 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUomExt (802)
typedef std::string eml21__MagneticDipoleMomentUomExt;
#endif

/* eml2_1ForGsoap.h:2611 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUomExt (803)
typedef std::string eml21__MagneticFieldStrengthUomExt;
#endif

/* eml2_1ForGsoap.h:2614 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUomExt (804)
typedef std::string eml21__MagneticFluxDensityPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2617 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUomExt (805)
typedef std::string eml21__MagneticFluxDensityUomExt;
#endif

/* eml2_1ForGsoap.h:2620 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUomExt (806)
typedef std::string eml21__MagneticFluxUomExt;
#endif

/* eml2_1ForGsoap.h:2623 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUomExt (807)
typedef std::string eml21__MagneticPermeabilityUomExt;
#endif

/* eml2_1ForGsoap.h:2626 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUomExt (808)
typedef std::string eml21__MagneticVectorPotentialUomExt;
#endif

/* eml2_1ForGsoap.h:2629 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUomExt (809)
typedef std::string eml21__MassLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2632 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUomExt (810)
typedef std::string eml21__MassPerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2635 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUomExt (811)
typedef std::string eml21__MassPerEnergyUomExt;
#endif

/* eml2_1ForGsoap.h:2638 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUomExt (812)
typedef std::string eml21__MassPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2641 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUomExt (813)
typedef std::string eml21__MassPerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2644 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUomExt (814)
typedef std::string eml21__MassPerTimePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2647 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUomExt (815)
typedef std::string eml21__MassPerTimePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2650 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUomExt (816)
typedef std::string eml21__MassPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2653 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUomExt (817)
typedef std::string eml21__MassPerVolumePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2656 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUomExt (818)
typedef std::string eml21__MassPerVolumePerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2659 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUomExt (819)
typedef std::string eml21__MassPerVolumePerTemperatureUomExt;
#endif

/* eml2_1ForGsoap.h:2662 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUomExt (820)
typedef std::string eml21__MassPerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2665 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassUomExt (821)
typedef std::string eml21__MassUomExt;
#endif

/* eml2_1ForGsoap.h:2668 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUomExt (822)
typedef std::string eml21__MobilityUomExt;
#endif

/* eml2_1ForGsoap.h:2671 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUomExt (823)
typedef std::string eml21__MolarEnergyUomExt;
#endif

/* eml2_1ForGsoap.h:2674 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUomExt (824)
typedef std::string eml21__MolarHeatCapacityUomExt;
#endif

/* eml2_1ForGsoap.h:2677 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUomExt (825)
typedef std::string eml21__MolarVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2680 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUomExt (826)
typedef std::string eml21__MolecularWeightUomExt;
#endif

/* eml2_1ForGsoap.h:2683 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUomExt (827)
typedef std::string eml21__MomentOfForceUomExt;
#endif

/* eml2_1ForGsoap.h:2686 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUomExt (828)
typedef std::string eml21__MomentOfInertiaUomExt;
#endif

/* eml2_1ForGsoap.h:2689 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUomExt (829)
typedef std::string eml21__MomentumUomExt;
#endif

/* eml2_1ForGsoap.h:2692 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUomExt (830)
typedef std::string eml21__NormalizedPowerUomExt;
#endif

/* eml2_1ForGsoap.h:2695 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUomExt (831)
typedef std::string eml21__PermeabilityLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2698 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUomExt (832)
typedef std::string eml21__PermeabilityRockUomExt;
#endif

/* eml2_1ForGsoap.h:2701 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUomExt (833)
typedef std::string eml21__PermittivityUomExt;
#endif

/* eml2_1ForGsoap.h:2704 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUomExt (834)
typedef std::string eml21__PlaneAngleUomExt;
#endif

/* eml2_1ForGsoap.h:2707 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUomExt (835)
typedef std::string eml21__PotentialDifferencePerPowerDropUomExt;
#endif

/* eml2_1ForGsoap.h:2710 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUomExt (836)
typedef std::string eml21__PowerPerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2713 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUomExt (837)
typedef std::string eml21__PowerPerPowerUomExt;
#endif

/* eml2_1ForGsoap.h:2716 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUomExt (838)
typedef std::string eml21__PowerPerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2719 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerUomExt (839)
typedef std::string eml21__PowerUomExt;
#endif

/* eml2_1ForGsoap.h:2722 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUomExt (840)
typedef std::string eml21__PressurePerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2725 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUomExt (841)
typedef std::string eml21__PressurePerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2728 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUomExt (842)
typedef std::string eml21__PressurePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2731 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUomExt (843)
typedef std::string eml21__PressureSquaredPerForceTimePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2734 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUomExt (844)
typedef std::string eml21__PressureSquaredUomExt;
#endif

/* eml2_1ForGsoap.h:2737 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUomExt (845)
typedef std::string eml21__PressureTimePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2740 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureUomExt (846)
typedef std::string eml21__PressureUomExt;
#endif

/* eml2_1ForGsoap.h:2743 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUomExt (847)
typedef std::string eml21__QuantityOfLightUomExt;
#endif

/* eml2_1ForGsoap.h:2746 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUomExt (848)
typedef std::string eml21__RadianceUomExt;
#endif

/* eml2_1ForGsoap.h:2749 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUomExt (849)
typedef std::string eml21__RadiantIntensityUomExt;
#endif

/* eml2_1ForGsoap.h:2752 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUomExt (850)
typedef std::string eml21__ReciprocalAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2755 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUomExt (851)
typedef std::string eml21__ReciprocalElectricPotentialDifferenceUomExt;
#endif

/* eml2_1ForGsoap.h:2758 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUomExt (852)
typedef std::string eml21__ReciprocalForceUomExt;
#endif

/* eml2_1ForGsoap.h:2761 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUomExt (853)
typedef std::string eml21__ReciprocalLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2764 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUomExt (854)
typedef std::string eml21__ReciprocalMassTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2767 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUomExt (855)
typedef std::string eml21__ReciprocalMassUomExt;
#endif

/* eml2_1ForGsoap.h:2770 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUomExt (856)
typedef std::string eml21__ReciprocalPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2773 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUomExt (857)
typedef std::string eml21__ReciprocalTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2776 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUomExt (858)
typedef std::string eml21__ReciprocalVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2779 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUomExt (859)
typedef std::string eml21__ReluctanceUomExt;
#endif

/* eml2_1ForGsoap.h:2782 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUomExt (860)
typedef std::string eml21__SecondMomentOfAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2785 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUomExt (861)
typedef std::string eml21__SignalingEventPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2788 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUomExt (862)
typedef std::string eml21__SolidAngleUomExt;
#endif

/* eml2_1ForGsoap.h:2791 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUomExt (863)
typedef std::string eml21__SpecificHeatCapacityUomExt;
#endif

/* eml2_1ForGsoap.h:2794 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUomExt (864)
typedef std::string eml21__TemperatureIntervalPerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2797 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUomExt (865)
typedef std::string eml21__TemperatureIntervalPerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2800 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUomExt (866)
typedef std::string eml21__TemperatureIntervalPerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2803 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUomExt (867)
typedef std::string eml21__TemperatureIntervalUomExt;
#endif

/* eml2_1ForGsoap.h:2806 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUomExt (868)
typedef std::string eml21__ThermalConductanceUomExt;
#endif

/* eml2_1ForGsoap.h:2809 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUomExt (869)
typedef std::string eml21__ThermalConductivityUomExt;
#endif

/* eml2_1ForGsoap.h:2812 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUomExt (870)
typedef std::string eml21__ThermalDiffusivityUomExt;
#endif

/* eml2_1ForGsoap.h:2815 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUomExt (871)
typedef std::string eml21__ThermalInsulanceUomExt;
#endif

/* eml2_1ForGsoap.h:2818 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUomExt (872)
typedef std::string eml21__ThermalResistanceUomExt;
#endif

/* eml2_1ForGsoap.h:2821 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (873)
typedef std::string eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt;
#endif

/* eml2_1ForGsoap.h:2824 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUomExt (874)
typedef std::string eml21__ThermodynamicTemperatureUomExt;
#endif

/* eml2_1ForGsoap.h:2827 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUomExt (875)
typedef std::string eml21__TimePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2830 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUomExt (876)
typedef std::string eml21__TimePerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2833 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUomExt (877)
typedef std::string eml21__TimePerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2836 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUomExt (878)
typedef std::string eml21__TimePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2839 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeUomExt (879)
typedef std::string eml21__TimeUomExt;
#endif

/* eml2_1ForGsoap.h:2842 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUomExt (880)
typedef std::string eml21__VerticalCoordinateUomExt;
#endif

/* eml2_1ForGsoap.h:2845 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUomExt (881)
typedef std::string eml21__VolumeFlowRatePerVolumeFlowRateUomExt;
#endif

/* eml2_1ForGsoap.h:2848 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUomExt (882)
typedef std::string eml21__VolumePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2851 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUomExt (883)
typedef std::string eml21__VolumePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2854 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUomExt (884)
typedef std::string eml21__VolumePerMassUomExt;
#endif

/* eml2_1ForGsoap.h:2857 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUomExt (885)
typedef std::string eml21__VolumePerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2860 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUomExt (886)
typedef std::string eml21__VolumePerRotationUomExt;
#endif

/* eml2_1ForGsoap.h:2863 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUomExt (887)
typedef std::string eml21__VolumePerTimeLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2866 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUomExt (888)
typedef std::string eml21__VolumePerTimePerAreaUomExt;
#endif

/* eml2_1ForGsoap.h:2869 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUomExt (889)
typedef std::string eml21__VolumePerTimePerLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2872 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUomExt (890)
typedef std::string eml21__VolumePerTimePerPressureLengthUomExt;
#endif

/* eml2_1ForGsoap.h:2875 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUomExt (891)
typedef std::string eml21__VolumePerTimePerPressureUomExt;
#endif

/* eml2_1ForGsoap.h:2878 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUomExt (892)
typedef std::string eml21__VolumePerTimePerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2881 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUomExt (893)
typedef std::string eml21__VolumePerTimePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2884 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUomExt (894)
typedef std::string eml21__VolumePerTimeUomExt;
#endif

/* eml2_1ForGsoap.h:2887 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUomExt (895)
typedef std::string eml21__VolumePerVolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2890 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUomExt (896)
typedef std::string eml21__VolumetricHeatTransferCoefficientUomExt;
#endif

/* eml2_1ForGsoap.h:2893 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUomExt (897)
typedef std::string eml21__VolumetricThermalExpansionUomExt;
#endif

/* eml2_1ForGsoap.h:2896 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUomExt (898)
typedef std::string eml21__VolumeUomExt;
#endif

/* eml2_1ForGsoap.h:2907 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_eml2_1_gml__NilReasonType (899)
typedef std::string gml__NilReasonType;
#endif

/* eml2_1ForGsoap.h:2911 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_eml2_1_gml__NilReasonEnumeration (900)
typedef std::string gml__NilReasonEnumeration;
#endif

/* eml2_1ForGsoap.h:2914 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_eml2_1_gml__UomIdentifier (901)
typedef std::string gml__UomIdentifier;
#endif

/* eml2_1ForGsoap.h:2949 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREType (902)
typedef std::string gco__Date_USCOREType;
#endif

/* eml2_1ForGsoap.h:2965 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarMonth (903)
typedef std::string prodml2__CalendarMonth;
#endif

/* eml2_1ForGsoap.h:2973 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarYear
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarYear (904)
typedef xsd__integer prodml2__CalendarYear;
#endif

/* eml2_1ForGsoap.h:2981 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NonNegativeFraction (906)
typedef float prodml2__NonNegativeFraction;
#endif

/* eml2_1ForGsoap.h:2988 */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProdmlRelativeIdentifier (907)
typedef xsd__anyURI prodml2__ProdmlRelativeIdentifier;
#endif

/* eml2_1ForGsoap.h:3003 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractMeasure (909)
typedef double eml21__AbstractMeasure;
#endif

/* eml2_1ForGsoap.h:3010 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractString
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractString (910)
typedef std::string eml21__AbstractString;
#endif

/* eml2_1ForGsoap.h:3013 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_1_eml21__NonNegativeInteger (911)
typedef ULONG64 eml21__NonNegativeInteger;
#endif

/* eml2_1ForGsoap.h:3015 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PositiveInteger
#define SOAP_TYPE_gsoap_eml2_1_eml21__PositiveInteger (912)
typedef ULONG64 eml21__PositiveInteger;
#endif

/* eml2_1ForGsoap.h:3092 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_eml2_1_gml__UomSymbol (916)
typedef std::string gml__UomSymbol;
#endif

/* eml2_1ForGsoap.h:3102 */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomURI
#define SOAP_TYPE_gsoap_eml2_1_gml__UomURI (917)
typedef std::string gml__UomURI;
#endif

/* eml2_1ForGsoap.h:3201 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnumExtensionPattern (921)
typedef std::string eml21__EnumExtensionPattern;
#endif

/* eml2_1ForGsoap.h:3206 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__String2000
#define SOAP_TYPE_gsoap_eml2_1_eml21__String2000 (922)
typedef std::string eml21__String2000;
#endif

/* eml2_1ForGsoap.h:3211 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__String64
#define SOAP_TYPE_gsoap_eml2_1_eml21__String64 (923)
typedef std::string eml21__String64;
#endif

/* eml2_1ForGsoap.h:3216 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeStamp
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeStamp (924)
typedef std::string eml21__TimeStamp;
#endif

/* eml2_1ForGsoap.h:3225 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UomEnum
#define SOAP_TYPE_gsoap_eml2_1_eml21__UomEnum (925)
typedef std::string eml21__UomEnum;
#endif

/* eml2_1ForGsoap.h:3230 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UuidString
#define SOAP_TYPE_gsoap_eml2_1_eml21__UuidString (926)
typedef std::string eml21__UuidString;
#endif

/* eml2_1ForGsoap.h:4742 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeZone
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeZone (928)
typedef std::string eml21__TimeZone;
#endif

/* eml2_1ForGsoap.h:4749 */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TypeEnum
#define SOAP_TYPE_gsoap_eml2_1_eml21__TypeEnum (929)
typedef eml21__String64 eml21__TypeEnum;
#endif

/* eml2_1ForGsoap.h:38985 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DasAcquisition
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DasAcquisition (1690)
typedef prodml2__DasAcquisition _prodml2__DasAcquisition;
#endif

/* eml2_1ForGsoap.h:38988 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DasInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DasInstrumentBox (1691)
typedef prodml2__DasInstrumentBox _prodml2__DasInstrumentBox;
#endif

/* eml2_1ForGsoap.h:38991 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstrumentBox (1692)
typedef prodml2__DtsInstrumentBox _prodml2__DtsInstrumentBox;
#endif

/* eml2_1ForGsoap.h:38994 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstalledSystem
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstalledSystem (1693)
typedef prodml2__DtsInstalledSystem _prodml2__DtsInstalledSystem;
#endif

/* eml2_1ForGsoap.h:38997 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__ProductVolume
#define SOAP_TYPE_gsoap_eml2_1__prodml2__ProductVolume (1694)
typedef prodml2__ProductVolume _prodml2__ProductVolume;
#endif

/* eml2_1ForGsoap.h:39000 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_1__prodml2__ProductFlowModel (1695)
typedef prodml2__ProductFlowModel _prodml2__ProductFlowModel;
#endif

/* eml2_1ForGsoap.h:39003 */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__FiberOpticalPath
#define SOAP_TYPE_gsoap_eml2_1__prodml2__FiberOpticalPath (1696)
typedef prodml2__FiberOpticalPath _prodml2__FiberOpticalPath;
#endif

/* eml2_1ForGsoap.h:39025 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__AbstractContextualObject
#define SOAP_TYPE_gsoap_eml2_1__eml21__AbstractContextualObject (1697)
typedef eml21__AbstractObject _eml21__AbstractContextualObject;
#endif

/* eml2_1ForGsoap.h:39031 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__AbstractDataObject
#define SOAP_TYPE_gsoap_eml2_1__eml21__AbstractDataObject (1698)
typedef eml21__AbstractObject _eml21__AbstractDataObject;
#endif

/* eml2_1ForGsoap.h:39034 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_1__eml21__EpcExternalPartReference (1699)
typedef eml21__EpcExternalPartReference _eml21__EpcExternalPartReference;
#endif

/* eml2_1ForGsoap.h:39037 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__Activity
#define SOAP_TYPE_gsoap_eml2_1__eml21__Activity (1700)
typedef eml21__Activity _eml21__Activity;
#endif

/* eml2_1ForGsoap.h:39040 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_1__eml21__ActivityTemplate (1701)
typedef eml21__ActivityTemplate _eml21__ActivityTemplate;
#endif

/* eml2_1ForGsoap.h:39043 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKind (1702)
typedef eml21__PropertyKind _eml21__PropertyKind;
#endif

/* eml2_1ForGsoap.h:39046 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKindDictionary (1703)
typedef eml21__PropertyKindDictionary _eml21__PropertyKindDictionary;
#endif

/* eml2_1ForGsoap.h:39049 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__TimeSeries
#define SOAP_TYPE_gsoap_eml2_1__eml21__TimeSeries (1704)
typedef eml21__TimeSeries _eml21__TimeSeries;
#endif

/* eml2_1ForGsoap.h:39052 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_1__eml21__DataAssuranceRecord (1705)
typedef eml21__DataAssuranceRecord _eml21__DataAssuranceRecord;
#endif

/* eml2_1ForGsoap.h:39055 */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_1__eml21__GraphicalInformationSet (1706)
typedef eml21__GraphicalInformationSet _eml21__GraphicalInformationSet;
#endif

/* eml2_1ForGsoap.h:39074 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__GeodeticCRS (1707)
typedef gml__GeodeticCRSType _gml__GeodeticCRS;
#endif

/* eml2_1ForGsoap.h:39080 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__description
#define SOAP_TYPE_gsoap_eml2_1__gml__description (1708)
typedef gml__StringOrRefType _gml__description;
#endif

/* eml2_1ForGsoap.h:39086 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_eml2_1__gml__descriptionReference (1709)
typedef gml__ReferenceType _gml__descriptionReference;
#endif

/* eml2_1ForGsoap.h:39092 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__identifier
#define SOAP_TYPE_gsoap_eml2_1__gml__identifier (1710)
typedef gml__CodeWithAuthorityType _gml__identifier;
#endif

/* eml2_1ForGsoap.h:39098 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__name
#define SOAP_TYPE_gsoap_eml2_1__gml__name (1711)
typedef gml__CodeType _gml__name;
#endif

/* eml2_1ForGsoap.h:39101 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__remarks
#define SOAP_TYPE_gsoap_eml2_1__gml__remarks (1712)
typedef std::string _gml__remarks;
#endif

/* eml2_1ForGsoap.h:39109 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__Definition
#define SOAP_TYPE_gsoap_eml2_1__gml__Definition (1713)
typedef gml__DefinitionType _gml__Definition;
#endif

/* eml2_1ForGsoap.h:39115 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__scope
#define SOAP_TYPE_gsoap_eml2_1__gml__scope (1714)
typedef std::string _gml__scope;
#endif

/* eml2_1ForGsoap.h:39121 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__ellipsoidalCS (1715)
typedef gml__EllipsoidalCSPropertyType _gml__ellipsoidalCS;
#endif

/* eml2_1ForGsoap.h:39127 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__EllipsoidalCS (1716)
typedef gml__EllipsoidalCSType _gml__EllipsoidalCS;
#endif

/* eml2_1ForGsoap.h:39133 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axis
#define SOAP_TYPE_gsoap_eml2_1__gml__axis (1717)
typedef gml__CoordinateSystemAxisPropertyType _gml__axis;
#endif

/* eml2_1ForGsoap.h:39139 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_eml2_1__gml__CoordinateSystemAxis (1718)
typedef gml__CoordinateSystemAxisType _gml__CoordinateSystemAxis;
#endif

/* eml2_1ForGsoap.h:39145 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_eml2_1__gml__axisAbbrev (1719)
typedef gml__CodeType _gml__axisAbbrev;
#endif

/* eml2_1ForGsoap.h:39153 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axisDirection
#define SOAP_TYPE_gsoap_eml2_1__gml__axisDirection (1720)
typedef gml__CodeWithAuthorityType _gml__axisDirection;
#endif

/* eml2_1ForGsoap.h:39159 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__minimumValue
#define SOAP_TYPE_gsoap_eml2_1__gml__minimumValue (1721)
typedef double _gml__minimumValue;
#endif

/* eml2_1ForGsoap.h:39165 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__maximumValue
#define SOAP_TYPE_gsoap_eml2_1__gml__maximumValue (1722)
typedef double _gml__maximumValue;
#endif

/* eml2_1ForGsoap.h:39171 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_eml2_1__gml__rangeMeaning (1723)
typedef gml__CodeWithAuthorityType _gml__rangeMeaning;
#endif

/* eml2_1ForGsoap.h:39177 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_eml2_1__gml__cartesianCS (1724)
typedef gml__CartesianCSPropertyType _gml__cartesianCS;
#endif

/* eml2_1ForGsoap.h:39183 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_eml2_1__gml__CartesianCS (1725)
typedef gml__CartesianCSType _gml__CartesianCS;
#endif

/* eml2_1ForGsoap.h:39189 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__sphericalCS (1726)
typedef gml__SphericalCSPropertyType _gml__sphericalCS;
#endif

/* eml2_1ForGsoap.h:39195 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__SphericalCS (1727)
typedef gml__SphericalCSType _gml__SphericalCS;
#endif

/* eml2_1ForGsoap.h:39201 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__geodeticDatum (1728)
typedef gml__GeodeticDatumPropertyType _gml__geodeticDatum;
#endif

/* eml2_1ForGsoap.h:39207 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__GeodeticDatum (1729)
typedef gml__GeodeticDatumType _gml__GeodeticDatum;
#endif

/* eml2_1ForGsoap.h:39217 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_eml2_1__gml__anchorDefinition (1730)
typedef gml__CodeType _gml__anchorDefinition;
#endif

/* eml2_1ForGsoap.h:39223 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_eml2_1__gml__realizationEpoch (1731)
typedef xsd__date _gml__realizationEpoch;
#endif

/* eml2_1ForGsoap.h:39229 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_eml2_1__gml__primeMeridian (1732)
typedef gml__PrimeMeridianPropertyType _gml__primeMeridian;
#endif

/* eml2_1ForGsoap.h:39235 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_eml2_1__gml__PrimeMeridian (1733)
typedef gml__PrimeMeridianType _gml__PrimeMeridian;
#endif

/* eml2_1ForGsoap.h:39241 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_eml2_1__gml__greenwichLongitude (1734)
typedef gml__AngleType _gml__greenwichLongitude;
#endif

/* eml2_1ForGsoap.h:39247 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_eml2_1__gml__ellipsoid (1735)
typedef gml__EllipsoidPropertyType _gml__ellipsoid;
#endif

/* eml2_1ForGsoap.h:39253 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_eml2_1__gml__Ellipsoid (1736)
typedef gml__EllipsoidType _gml__Ellipsoid;
#endif

/* eml2_1ForGsoap.h:39259 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_eml2_1__gml__semiMajorAxis (1737)
typedef gml__MeasureType _gml__semiMajorAxis;
#endif

/* eml2_1ForGsoap.h:39265 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__ProjectedCRS (1738)
typedef gml__ProjectedCRSType _gml__ProjectedCRS;
#endif

/* eml2_1ForGsoap.h:39271 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__conversion
#define SOAP_TYPE_gsoap_eml2_1__gml__conversion (1739)
typedef gml__GeneralConversionPropertyType _gml__conversion;
#endif

/* eml2_1ForGsoap.h:39277 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__operationVersion
#define SOAP_TYPE_gsoap_eml2_1__gml__operationVersion (1740)
typedef std::string _gml__operationVersion;
#endif

/* eml2_1ForGsoap.h:39283 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__sourceCRS (1741)
typedef gml__CRSPropertyType _gml__sourceCRS;
#endif

/* eml2_1ForGsoap.h:39289 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__targetCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__targetCRS (1742)
typedef gml__CRSPropertyType _gml__targetCRS;
#endif

/* eml2_1ForGsoap.h:39295 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__baseGeodeticCRS (1743)
typedef gml__GeodeticCRSPropertyType _gml__baseGeodeticCRS;
#endif

/* eml2_1ForGsoap.h:39301 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalCRS (1744)
typedef gml__VerticalCRSType _gml__VerticalCRS;
#endif

/* eml2_1ForGsoap.h:39307 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__verticalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__verticalCS (1745)
typedef gml__VerticalCSPropertyType _gml__verticalCS;
#endif

/* eml2_1ForGsoap.h:39313 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalCS (1746)
typedef gml__VerticalCSType _gml__VerticalCS;
#endif

/* eml2_1ForGsoap.h:39319 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__verticalDatum (1747)
typedef gml__VerticalDatumPropertyType _gml__verticalDatum;
#endif

/* eml2_1ForGsoap.h:39325 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalDatum (1748)
typedef gml__VerticalDatumType _gml__VerticalDatum;
#endif

/* eml2_1ForGsoap.h:39339 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__id
#define SOAP_TYPE_gsoap_eml2_1__gml__id (1749)
typedef xsd__ID _gml__id;
#endif

/* eml2_1ForGsoap.h:39358 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__href
#define SOAP_TYPE_gsoap_eml2_1__xlink__href (1750)
typedef xsd__anyURI _xlink__href;
#endif

/* eml2_1ForGsoap.h:39361 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__role
#define SOAP_TYPE_gsoap_eml2_1__xlink__role (1751)
typedef xsd__anyURI _xlink__role;
#endif

/* eml2_1ForGsoap.h:39364 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__arcrole
#define SOAP_TYPE_gsoap_eml2_1__xlink__arcrole (1752)
typedef xsd__anyURI _xlink__arcrole;
#endif

/* eml2_1ForGsoap.h:39367 */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__title
#define SOAP_TYPE_gsoap_eml2_1__xlink__title (1753)
typedef std::string _xlink__title;
#endif

/* eml2_1ForGsoap.h:39378 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREExtent (1754)
typedef gmd__EX_USCOREExtent_USCOREType _gmd__EX_USCOREExtent;
#endif

/* eml2_1ForGsoap.h:39381 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCORETemporalExtent (1755)
typedef gmd__EX_USCORETemporalExtent_USCOREType _gmd__EX_USCORETemporalExtent;
#endif

/* eml2_1ForGsoap.h:39384 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREVerticalExtent (1756)
typedef gmd__EX_USCOREVerticalExtent_USCOREType _gmd__EX_USCOREVerticalExtent;
#endif

/* eml2_1ForGsoap.h:39387 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_eml2_1__gmd__MD_USCOREIdentifier (1757)
typedef gmd__MD_USCOREIdentifier_USCOREType _gmd__MD_USCOREIdentifier;
#endif

/* eml2_1ForGsoap.h:39390 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORECitation (1758)
typedef gmd__CI_USCORECitation_USCOREType _gmd__CI_USCORECitation;
#endif

/* eml2_1ForGsoap.h:39393 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDate (1759)
typedef gmd__CI_USCOREDate_USCOREType _gmd__CI_USCOREDate;
#endif

/* eml2_1ForGsoap.h:39396 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDateTypeCode (1760)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREDateTypeCode;
#endif

/* eml2_1ForGsoap.h:39399 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREResponsibleParty (1761)
typedef gmd__CI_USCOREResponsibleParty_USCOREType _gmd__CI_USCOREResponsibleParty;
#endif

/* eml2_1ForGsoap.h:39402 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREContact (1762)
typedef gmd__CI_USCOREContact_USCOREType _gmd__CI_USCOREContact;
#endif

/* eml2_1ForGsoap.h:39405 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORETelephone (1763)
typedef gmd__CI_USCORETelephone_USCOREType _gmd__CI_USCORETelephone;
#endif

/* eml2_1ForGsoap.h:39408 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREAddress (1764)
typedef gmd__CI_USCOREAddress_USCOREType _gmd__CI_USCOREAddress;
#endif

/* eml2_1ForGsoap.h:39411 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnlineResource (1765)
typedef gmd__CI_USCOREOnlineResource_USCOREType _gmd__CI_USCOREOnlineResource;
#endif

/* eml2_1ForGsoap.h:39414 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__URL
#define SOAP_TYPE_gsoap_eml2_1__gmd__URL (1766)
typedef xsd__anyURI _gmd__URL;
#endif

/* eml2_1ForGsoap.h:39417 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnLineFunctionCode (1767)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREOnLineFunctionCode;
#endif

/* eml2_1ForGsoap.h:39420 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORERoleCode (1768)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCORERoleCode;
#endif

/* eml2_1ForGsoap.h:39423 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREPresentationFormCode (1769)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREPresentationFormCode;
#endif

/* eml2_1ForGsoap.h:39426 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORESeries (1770)
typedef gmd__CI_USCORESeries_USCOREType _gmd__CI_USCORESeries;
#endif

/* eml2_1ForGsoap.h:39429 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__DQ_USCOREEvaluationMethodTypeCode (1771)
typedef gco__CodeListValue_USCOREType _gmd__DQ_USCOREEvaluationMethodTypeCode;
#endif

/* eml2_1ForGsoap.h:39464 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__CharacterString
#define SOAP_TYPE_gsoap_eml2_1__gco__CharacterString (1772)
typedef std::string _gco__CharacterString;
#endif

/* eml2_1ForGsoap.h:39467 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Boolean
#define SOAP_TYPE_gsoap_eml2_1__gco__Boolean (1773)
typedef bool _gco__Boolean;
#endif

/* eml2_1ForGsoap.h:39470 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Real
#define SOAP_TYPE_gsoap_eml2_1__gco__Real (1774)
typedef double _gco__Real;
#endif

/* eml2_1ForGsoap.h:39473 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Date
#define SOAP_TYPE_gsoap_eml2_1__gco__Date (1775)
typedef gco__Date_USCOREType _gco__Date;
#endif

/* eml2_1ForGsoap.h:39476 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__DateTime
#define SOAP_TYPE_gsoap_eml2_1__gco__DateTime (1776)
typedef time_t _gco__DateTime;
#endif

/* eml2_1ForGsoap.h:39487 */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__nilReason
#define SOAP_TYPE_gsoap_eml2_1__gco__nilReason (1777)
typedef gml__NilReasonType _gco__nilReason;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_gsoap_eml2_1_byte
#define SOAP_TYPE_gsoap_eml2_1_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_1_int
#define SOAP_TYPE_gsoap_eml2_1_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_1_long
#define SOAP_TYPE_gsoap_eml2_1_long (8)
#endif

/* prodml2__CalendarYear has binding name 'prodml2__CalendarYear' for type 'prodml2:CalendarYear' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarYear
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarYear (904)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__integer
#define SOAP_TYPE_gsoap_eml2_1_xsd__integer (10)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_1_LONG64
#define SOAP_TYPE_gsoap_eml2_1_LONG64 (9)
#endif

/* prodml2__NonNegativeFraction has binding name 'prodml2__NonNegativeFraction' for type 'prodml2:NonNegativeFraction' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NonNegativeFraction (906)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_gsoap_eml2_1_float
#define SOAP_TYPE_gsoap_eml2_1_float (905)
#endif

/* _gco__Real has binding name '_gco__Real' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Real
#define SOAP_TYPE_gsoap_eml2_1__gco__Real (1774)
#endif

/* _gml__maximumValue has binding name '_gml__maximumValue' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__maximumValue
#define SOAP_TYPE_gsoap_eml2_1__gml__maximumValue (1722)
#endif

/* _gml__minimumValue has binding name '_gml__minimumValue' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__minimumValue
#define SOAP_TYPE_gsoap_eml2_1__gml__minimumValue (1721)
#endif

/* eml21__AbstractMeasure has binding name 'eml21__AbstractMeasure' for type 'eml21:AbstractMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractMeasure (909)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_1_double
#define SOAP_TYPE_gsoap_eml2_1_double (908)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_unsignedInt
#define SOAP_TYPE_gsoap_eml2_1_unsignedInt (11)
#endif

/* eml21__PositiveInteger has binding name 'eml21__PositiveInteger' for type 'eml21:PositiveInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PositiveInteger
#define SOAP_TYPE_gsoap_eml2_1_eml21__PositiveInteger (912)
#endif

/* eml21__NonNegativeInteger has binding name 'eml21__NonNegativeInteger' for type 'eml21:NonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_1_eml21__NonNegativeInteger (911)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_1_xsd__nonNegativeInteger (13)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_eml2_1_ULONG64
#define SOAP_TYPE_gsoap_eml2_1_ULONG64 (12)
#endif

/* _gco__DateTime has binding name '_gco__DateTime' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__DateTime
#define SOAP_TYPE_gsoap_eml2_1__gco__DateTime (1776)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_dateTime
#define SOAP_TYPE_gsoap_eml2_1_dateTime (1228)
#endif

/* _gco__Boolean has binding name '_gco__Boolean' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Boolean
#define SOAP_TYPE_gsoap_eml2_1__gco__Boolean (1773)
#endif

/* enum _gml__RelatedTimeType_relativePosition has binding name '_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_eml2_1__gml__RelatedTimeType_relativePosition (1608)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_1_bool
#define SOAP_TYPE_gsoap_eml2_1_bool (1289)
#endif

/* enum eml21__ReferencePressureKind has binding name 'eml21__ReferencePressureKind' for type 'eml21:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressureKind (1176)
#endif

/* enum eml21__WellStatus has binding name 'eml21__WellStatus' for type 'eml21:WellStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__WellStatus
#define SOAP_TYPE_gsoap_eml2_1_eml21__WellStatus (1175)
#endif

/* enum eml21__WellboreDatumReference has binding name 'eml21__WellboreDatumReference' for type 'eml21:WellboreDatumReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__WellboreDatumReference (1174)
#endif

/* enum eml21__ReferenceCondition has binding name 'eml21__ReferenceCondition' for type 'eml21:ReferenceCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceCondition (1173)
#endif

/* enum eml21__QuantityClassKind has binding name 'eml21__QuantityClassKind' for type 'eml21:QuantityClassKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKind (1172)
#endif

/* enum eml21__MeasureClass has binding name 'eml21__MeasureClass' for type 'eml21:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MeasureClass
#define SOAP_TYPE_gsoap_eml2_1_eml21__MeasureClass (1171)
#endif

/* enum eml21__MatrixCementKind has binding name 'eml21__MatrixCementKind' for type 'eml21:MatrixCementKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MatrixCementKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__MatrixCementKind (1170)
#endif

/* enum eml21__LithostratigraphicRank has binding name 'eml21__LithostratigraphicRank' for type 'eml21:LithostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithostratigraphicRank
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithostratigraphicRank (1169)
#endif

/* enum eml21__LithologyQualifierKind has binding name 'eml21__LithologyQualifierKind' for type 'eml21:LithologyQualifierKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKind (1168)
#endif

/* enum eml21__LithologyKind has binding name 'eml21__LithologyKind' for type 'eml21:LithologyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKind (1167)
#endif

/* enum eml21__GeochronologicalRank has binding name 'eml21__GeochronologicalRank' for type 'eml21:GeochronologicalRank' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeochronologicalRank
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeochronologicalRank (1166)
#endif

/* enum eml21__ExistenceKind has binding name 'eml21__ExistenceKind' for type 'eml21:ExistenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExistenceKind (1165)
#endif

/* enum prodml2__TerminationType has binding name 'prodml2__TerminationType' for type 'prodml2:TerminationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__TerminationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__TerminationType (1164)
#endif

/* enum prodml2__PermanentCableInstallationType has binding name 'prodml2__PermanentCableInstallationType' for type 'prodml2:PermanentCableInstallationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCableInstallationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCableInstallationType (1163)
#endif

/* enum prodml2__PathDefectTypes has binding name 'prodml2__PathDefectTypes' for type 'prodml2:PathDefectTypes' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PathDefectTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PathDefectTypes (1162)
#endif

/* enum prodml2__OTDRReason has binding name 'prodml2__OTDRReason' for type 'prodml2:OTDRReason' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRReason
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRReason (1161)
#endif

/* enum prodml2__OTDRDirection has binding name 'prodml2__OTDRDirection' for type 'prodml2:OTDRDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRDirection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OTDRDirection (1160)
#endif

/* enum prodml2__InterventionConveyanceType has binding name 'prodml2__InterventionConveyanceType' for type 'prodml2:InterventionConveyanceType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyanceType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyanceType (1159)
#endif

/* enum prodml2__FiberSpliceTypes has binding name 'prodml2__FiberSpliceTypes' for type 'prodml2:FiberSpliceTypes' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSpliceTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSpliceTypes (1158)
#endif

/* enum prodml2__FiberEndType has binding name 'prodml2__FiberEndType' for type 'prodml2:FiberEndType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberEndType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberEndType (1157)
#endif

/* enum prodml2__FiberConnectorTypes has binding name 'prodml2__FiberConnectorTypes' for type 'prodml2:FiberConnectorTypes' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnectorTypes
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnectorTypes (1156)
#endif

/* enum prodml2__ControlLineSize has binding name 'prodml2__ControlLineSize' for type 'prodml2:ControlLineSize' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineSize
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineSize (1155)
#endif

/* enum prodml2__ControlLineMaterial has binding name 'prodml2__ControlLineMaterial' for type 'prodml2:ControlLineMaterial' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineMaterial
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineMaterial (1154)
#endif

/* enum prodml2__ControlLineEncapsulationType has binding name 'prodml2__ControlLineEncapsulationType' for type 'prodml2:ControlLineEncapsulationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationType (1153)
#endif

/* enum prodml2__ControlLineEncapsulationSize has binding name 'prodml2__ControlLineEncapsulationSize' for type 'prodml2:ControlLineEncapsulationSize' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationSize
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ControlLineEncapsulationSize (1152)
#endif

/* enum prodml2__CableType has binding name 'prodml2__CableType' for type 'prodml2:CableType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CableType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CableType (1151)
#endif

/* enum prodml2__WellOperationMethod has binding name 'prodml2__WellOperationMethod' for type 'prodml2:WellOperationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellOperationMethod (1150)
#endif

/* enum prodml2__FluidComponentBasis has binding name 'prodml2__FluidComponentBasis' for type 'prodml2:FluidComponentBasis' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentBasis
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentBasis (1149)
#endif

/* enum prodml2__CalculationMethod has binding name 'prodml2__CalculationMethod' for type 'prodml2:CalculationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalculationMethod (1148)
#endif

/* enum prodml2__BalanceFlowPart has binding name 'prodml2__BalanceFlowPart' for type 'prodml2:BalanceFlowPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceFlowPart (1147)
#endif

/* enum prodml2__BalanceEventKind has binding name 'prodml2__BalanceEventKind' for type 'prodml2:BalanceEventKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceEventKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceEventKind (1146)
#endif

/* enum prodml2__BalanceDestinationType has binding name 'prodml2__BalanceDestinationType' for type 'prodml2:BalanceDestinationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BalanceDestinationType (1145)
#endif

/* enum prodml2__WellFluid has binding name 'prodml2__WellFluid' for type 'prodml2:WellFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellFluid
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellFluid (1144)
#endif

/* enum prodml2__WellDirection has binding name 'prodml2__WellDirection' for type 'prodml2:WellDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellDirection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellDirection (1143)
#endif

/* enum prodml2__ValueStatus has binding name 'prodml2__ValueStatus' for type 'prodml2:ValueStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ValueStatus
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ValueStatus (1142)
#endif

/* enum prodml2__TimeSeriesKeyword has binding name 'prodml2__TimeSeriesKeyword' for type 'prodml2:TimeSeriesKeyword' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__TimeSeriesKeyword
#define SOAP_TYPE_gsoap_eml2_1_prodml2__TimeSeriesKeyword (1141)
#endif

/* enum prodml2__ServiceFluidKind has binding name 'prodml2__ServiceFluidKind' for type 'prodml2:ServiceFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ServiceFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ServiceFluidKind (1140)
#endif

/* enum prodml2__SaturationPointKind has binding name 'prodml2__SaturationPointKind' for type 'prodml2:SaturationPointKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__SaturationPointKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__SaturationPointKind (1139)
#endif

/* enum prodml2__SafetyType has binding name 'prodml2__SafetyType' for type 'prodml2:SafetyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__SafetyType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__SafetyType (1138)
#endif

/* enum prodml2__ReservoirFluidKind has binding name 'prodml2__ReservoirFluidKind' for type 'prodml2:ReservoirFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReservoirFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReservoirFluidKind (1137)
#endif

/* enum prodml2__ReportingProduct has binding name 'prodml2__ReportingProduct' for type 'prodml2:ReportingProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingProduct (1136)
#endif

/* enum prodml2__ReportingFlow has binding name 'prodml2__ReportingFlow' for type 'prodml2:ReportingFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFlow (1135)
#endif

/* enum prodml2__ReportingFacility has binding name 'prodml2__ReportingFacility' for type 'prodml2:ReportingFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingFacility (1134)
#endif

/* enum prodml2__ReportingEntityKind has binding name 'prodml2__ReportingEntityKind' for type 'prodml2:ReportingEntityKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingEntityKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingEntityKind (1133)
#endif

/* enum prodml2__ReportingDurationKind has binding name 'prodml2__ReportingDurationKind' for type 'prodml2:ReportingDurationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKind (1132)
#endif

/* enum prodml2__PureComponentEnum has binding name 'prodml2__PureComponentEnum' for type 'prodml2:PureComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnum (1131)
#endif

/* enum prodml2__PseudoComponentEnum has binding name 'prodml2__PseudoComponentEnum' for type 'prodml2:PseudoComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnum (1130)
#endif

/* enum prodml2__ProductFluidKind has binding name 'prodml2__ProductFluidKind' for type 'prodml2:ProductFluidKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFluidKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFluidKind (1129)
#endif

/* enum prodml2__ProductFlowPortType has binding name 'prodml2__ProductFlowPortType' for type 'prodml2:ProductFlowPortType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPortType (1128)
#endif

/* enum prodml2__PlusComponentEnum has binding name 'prodml2__PlusComponentEnum' for type 'prodml2:PlusComponentEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnum (1127)
#endif

/* enum prodml2__PhoneType has binding name 'prodml2__PhoneType' for type 'prodml2:PhoneType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneType (1126)
#endif

/* enum prodml2__GeologyType has binding name 'prodml2__GeologyType' for type 'prodml2:GeologyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyType (1125)
#endif

/* enum prodml2__FlowSubQualifier has binding name 'prodml2__FlowSubQualifier' for type 'prodml2:FlowSubQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FlowSubQualifier (1124)
#endif

/* enum prodml2__FlowQualifier has binding name 'prodml2__FlowQualifier' for type 'prodml2:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FlowQualifier (1123)
#endif

/* enum prodml2__FiberMode has binding name 'prodml2__FiberMode' for type 'prodml2:FiberMode' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberMode
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberMode (1122)
#endif

/* enum prodml2__FacilityParameter has binding name 'prodml2__FacilityParameter' for type 'prodml2:FacilityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParameter
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParameter (1121)
#endif

/* enum prodml2__EndpointQualifierInterval has binding name 'prodml2__EndpointQualifierInterval' for type 'prodml2:EndpointQualifierInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifierInterval
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifierInterval (1120)
#endif

/* enum prodml2__EndpointQualifier has binding name 'prodml2__EndpointQualifier' for type 'prodml2:EndpointQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifier (1119)
#endif

/* enum prodml2__BusinessUnitKind has binding name 'prodml2__BusinessUnitKind' for type 'prodml2:BusinessUnitKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessUnitKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessUnitKind (1118)
#endif

/* enum prodml2__AddressQualifier has binding name 'prodml2__AddressQualifier' for type 'prodml2:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AddressQualifier (1117)
#endif

/* enum prodml2__AddressKindEnum has binding name 'prodml2__AddressKindEnum' for type 'prodml2:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AddressKindEnum (1116)
#endif

/* enum prodml2__FacilityKind has binding name 'prodml2__FacilityKind' for type 'prodml2:FacilityKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityKind
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityKind (1115)
#endif

/* enum prodml2__DasDimensions has binding name 'prodml2__DasDimensions' for type 'prodml2:DasDimensions' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasDimensions
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasDimensions (1114)
#endif

/* enum prodml2__DasCalibrationType has binding name 'prodml2__DasCalibrationType' for type 'prodml2:DasCalibrationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationType (1113)
#endif

/* enum eml21__VolumeUom has binding name 'eml21__VolumeUom' for type 'eml21:VolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUom (1112)
#endif

/* enum eml21__VolumetricThermalExpansionUom has binding name 'eml21__VolumetricThermalExpansionUom' for type 'eml21:VolumetricThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUom (1111)
#endif

/* enum eml21__VolumetricHeatTransferCoefficientUom has binding name 'eml21__VolumetricHeatTransferCoefficientUom' for type 'eml21:VolumetricHeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUom (1110)
#endif

/* enum eml21__VolumePerVolumeUom has binding name 'eml21__VolumePerVolumeUom' for type 'eml21:VolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUom (1109)
#endif

/* enum eml21__VolumePerTimeUom has binding name 'eml21__VolumePerTimeUom' for type 'eml21:VolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUom (1108)
#endif

/* enum eml21__VolumePerTimePerVolumeUom has binding name 'eml21__VolumePerTimePerVolumeUom' for type 'eml21:VolumePerTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUom (1107)
#endif

/* enum eml21__VolumePerTimePerTimeUom has binding name 'eml21__VolumePerTimePerTimeUom' for type 'eml21:VolumePerTimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUom (1106)
#endif

/* enum eml21__VolumePerTimePerPressureUom has binding name 'eml21__VolumePerTimePerPressureUom' for type 'eml21:VolumePerTimePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUom (1105)
#endif

/* enum eml21__VolumePerTimePerPressureLengthUom has binding name 'eml21__VolumePerTimePerPressureLengthUom' for type 'eml21:VolumePerTimePerPressureLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUom (1104)
#endif

/* enum eml21__VolumePerTimePerLengthUom has binding name 'eml21__VolumePerTimePerLengthUom' for type 'eml21:VolumePerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUom (1103)
#endif

/* enum eml21__VolumePerTimePerAreaUom has binding name 'eml21__VolumePerTimePerAreaUom' for type 'eml21:VolumePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUom (1102)
#endif

/* enum eml21__VolumePerTimeLengthUom has binding name 'eml21__VolumePerTimeLengthUom' for type 'eml21:VolumePerTimeLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUom (1101)
#endif

/* enum eml21__VolumePerRotationUom has binding name 'eml21__VolumePerRotationUom' for type 'eml21:VolumePerRotationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUom (1100)
#endif

/* enum eml21__VolumePerPressureUom has binding name 'eml21__VolumePerPressureUom' for type 'eml21:VolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUom (1099)
#endif

/* enum eml21__VolumePerMassUom has binding name 'eml21__VolumePerMassUom' for type 'eml21:VolumePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUom (1098)
#endif

/* enum eml21__VolumePerLengthUom has binding name 'eml21__VolumePerLengthUom' for type 'eml21:VolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUom (1097)
#endif

/* enum eml21__VolumePerAreaUom has binding name 'eml21__VolumePerAreaUom' for type 'eml21:VolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUom (1096)
#endif

/* enum eml21__VolumeFlowRatePerVolumeFlowRateUom has binding name 'eml21__VolumeFlowRatePerVolumeFlowRateUom' for type 'eml21:VolumeFlowRatePerVolumeFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUom (1095)
#endif

/* enum eml21__VerticalCoordinateUom has binding name 'eml21__VerticalCoordinateUom' for type 'eml21:VerticalCoordinateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUom (1094)
#endif

/* enum eml21__TimeUom has binding name 'eml21__TimeUom' for type 'eml21:TimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeUom (1093)
#endif

/* enum eml21__TimePerVolumeUom has binding name 'eml21__TimePerVolumeUom' for type 'eml21:TimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUom (1092)
#endif

/* enum eml21__TimePerTimeUom has binding name 'eml21__TimePerTimeUom' for type 'eml21:TimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUom (1091)
#endif

/* enum eml21__TimePerMassUom has binding name 'eml21__TimePerMassUom' for type 'eml21:TimePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUom (1090)
#endif

/* enum eml21__TimePerLengthUom has binding name 'eml21__TimePerLengthUom' for type 'eml21:TimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUom (1089)
#endif

/* enum eml21__ThermodynamicTemperatureUom has binding name 'eml21__ThermodynamicTemperatureUom' for type 'eml21:ThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUom (1088)
#endif

/* enum eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom has binding name 'eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom' for type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUom (1087)
#endif

/* enum eml21__ThermalResistanceUom has binding name 'eml21__ThermalResistanceUom' for type 'eml21:ThermalResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUom (1086)
#endif

/* enum eml21__ThermalInsulanceUom has binding name 'eml21__ThermalInsulanceUom' for type 'eml21:ThermalInsulanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUom (1085)
#endif

/* enum eml21__ThermalDiffusivityUom has binding name 'eml21__ThermalDiffusivityUom' for type 'eml21:ThermalDiffusivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUom (1084)
#endif

/* enum eml21__ThermalConductivityUom has binding name 'eml21__ThermalConductivityUom' for type 'eml21:ThermalConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUom (1083)
#endif

/* enum eml21__ThermalConductanceUom has binding name 'eml21__ThermalConductanceUom' for type 'eml21:ThermalConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUom (1082)
#endif

/* enum eml21__TemperatureIntervalUom has binding name 'eml21__TemperatureIntervalUom' for type 'eml21:TemperatureIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUom (1081)
#endif

/* enum eml21__TemperatureIntervalPerTimeUom has binding name 'eml21__TemperatureIntervalPerTimeUom' for type 'eml21:TemperatureIntervalPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUom (1080)
#endif

/* enum eml21__TemperatureIntervalPerPressureUom has binding name 'eml21__TemperatureIntervalPerPressureUom' for type 'eml21:TemperatureIntervalPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUom (1079)
#endif

/* enum eml21__TemperatureIntervalPerLengthUom has binding name 'eml21__TemperatureIntervalPerLengthUom' for type 'eml21:TemperatureIntervalPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUom (1078)
#endif

/* enum eml21__SpecificHeatCapacityUom has binding name 'eml21__SpecificHeatCapacityUom' for type 'eml21:SpecificHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUom (1077)
#endif

/* enum eml21__SolidAngleUom has binding name 'eml21__SolidAngleUom' for type 'eml21:SolidAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUom (1076)
#endif

/* enum eml21__SignalingEventPerTimeUom has binding name 'eml21__SignalingEventPerTimeUom' for type 'eml21:SignalingEventPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUom (1075)
#endif

/* enum eml21__SecondMomentOfAreaUom has binding name 'eml21__SecondMomentOfAreaUom' for type 'eml21:SecondMomentOfAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUom (1074)
#endif

/* enum eml21__ReluctanceUom has binding name 'eml21__ReluctanceUom' for type 'eml21:ReluctanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUom (1073)
#endif

/* enum eml21__ReciprocalVolumeUom has binding name 'eml21__ReciprocalVolumeUom' for type 'eml21:ReciprocalVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUom (1072)
#endif

/* enum eml21__ReciprocalTimeUom has binding name 'eml21__ReciprocalTimeUom' for type 'eml21:ReciprocalTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUom (1071)
#endif

/* enum eml21__ReciprocalPressureUom has binding name 'eml21__ReciprocalPressureUom' for type 'eml21:ReciprocalPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUom (1070)
#endif

/* enum eml21__ReciprocalMassUom has binding name 'eml21__ReciprocalMassUom' for type 'eml21:ReciprocalMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUom (1069)
#endif

/* enum eml21__ReciprocalMassTimeUom has binding name 'eml21__ReciprocalMassTimeUom' for type 'eml21:ReciprocalMassTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUom (1068)
#endif

/* enum eml21__ReciprocalLengthUom has binding name 'eml21__ReciprocalLengthUom' for type 'eml21:ReciprocalLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUom (1067)
#endif

/* enum eml21__ReciprocalForceUom has binding name 'eml21__ReciprocalForceUom' for type 'eml21:ReciprocalForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUom (1066)
#endif

/* enum eml21__ReciprocalElectricPotentialDifferenceUom has binding name 'eml21__ReciprocalElectricPotentialDifferenceUom' for type 'eml21:ReciprocalElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUom (1065)
#endif

/* enum eml21__ReciprocalAreaUom has binding name 'eml21__ReciprocalAreaUom' for type 'eml21:ReciprocalAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUom (1064)
#endif

/* enum eml21__RadiantIntensityUom has binding name 'eml21__RadiantIntensityUom' for type 'eml21:RadiantIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUom (1063)
#endif

/* enum eml21__RadianceUom has binding name 'eml21__RadianceUom' for type 'eml21:RadianceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUom (1062)
#endif

/* enum eml21__QuantityOfLightUom has binding name 'eml21__QuantityOfLightUom' for type 'eml21:QuantityOfLightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUom (1061)
#endif

/* enum eml21__PressureUom has binding name 'eml21__PressureUom' for type 'eml21:PressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureUom (1060)
#endif

/* enum eml21__PressureTimePerVolumeUom has binding name 'eml21__PressureTimePerVolumeUom' for type 'eml21:PressureTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUom (1059)
#endif

/* enum eml21__PressureSquaredUom has binding name 'eml21__PressureSquaredUom' for type 'eml21:PressureSquaredUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUom (1058)
#endif

/* enum eml21__PressureSquaredPerForceTimePerAreaUom has binding name 'eml21__PressureSquaredPerForceTimePerAreaUom' for type 'eml21:PressureSquaredPerForceTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUom (1057)
#endif

/* enum eml21__PressurePerVolumeUom has binding name 'eml21__PressurePerVolumeUom' for type 'eml21:PressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUom (1056)
#endif

/* enum eml21__PressurePerTimeUom has binding name 'eml21__PressurePerTimeUom' for type 'eml21:PressurePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUom (1055)
#endif

/* enum eml21__PressurePerPressureUom has binding name 'eml21__PressurePerPressureUom' for type 'eml21:PressurePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUom (1054)
#endif

/* enum eml21__PowerUom has binding name 'eml21__PowerUom' for type 'eml21:PowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerUom (1053)
#endif

/* enum eml21__PowerPerVolumeUom has binding name 'eml21__PowerPerVolumeUom' for type 'eml21:PowerPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUom (1052)
#endif

/* enum eml21__PowerPerPowerUom has binding name 'eml21__PowerPerPowerUom' for type 'eml21:PowerPerPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUom (1051)
#endif

/* enum eml21__PowerPerAreaUom has binding name 'eml21__PowerPerAreaUom' for type 'eml21:PowerPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUom (1050)
#endif

/* enum eml21__PotentialDifferencePerPowerDropUom has binding name 'eml21__PotentialDifferencePerPowerDropUom' for type 'eml21:PotentialDifferencePerPowerDropUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUom (1049)
#endif

/* enum eml21__PlaneAngleUom has binding name 'eml21__PlaneAngleUom' for type 'eml21:PlaneAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUom (1048)
#endif

/* enum eml21__PermittivityUom has binding name 'eml21__PermittivityUom' for type 'eml21:PermittivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUom (1047)
#endif

/* enum eml21__PermeabilityRockUom has binding name 'eml21__PermeabilityRockUom' for type 'eml21:PermeabilityRockUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUom (1046)
#endif

/* enum eml21__PermeabilityLengthUom has binding name 'eml21__PermeabilityLengthUom' for type 'eml21:PermeabilityLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUom (1045)
#endif

/* enum eml21__NormalizedPowerUom has binding name 'eml21__NormalizedPowerUom' for type 'eml21:NormalizedPowerUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUom (1044)
#endif

/* enum eml21__MomentumUom has binding name 'eml21__MomentumUom' for type 'eml21:MomentumUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUom (1043)
#endif

/* enum eml21__MomentOfInertiaUom has binding name 'eml21__MomentOfInertiaUom' for type 'eml21:MomentOfInertiaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUom (1042)
#endif

/* enum eml21__MomentOfForceUom has binding name 'eml21__MomentOfForceUom' for type 'eml21:MomentOfForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUom (1041)
#endif

/* enum eml21__MolecularWeightUom has binding name 'eml21__MolecularWeightUom' for type 'eml21:MolecularWeightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUom (1040)
#endif

/* enum eml21__MolarVolumeUom has binding name 'eml21__MolarVolumeUom' for type 'eml21:MolarVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUom (1039)
#endif

/* enum eml21__MolarHeatCapacityUom has binding name 'eml21__MolarHeatCapacityUom' for type 'eml21:MolarHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUom (1038)
#endif

/* enum eml21__MolarEnergyUom has binding name 'eml21__MolarEnergyUom' for type 'eml21:MolarEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUom (1037)
#endif

/* enum eml21__MobilityUom has binding name 'eml21__MobilityUom' for type 'eml21:MobilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUom (1036)
#endif

/* enum eml21__MassUom has binding name 'eml21__MassUom' for type 'eml21:MassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassUom (1035)
#endif

/* enum eml21__MassPerVolumeUom has binding name 'eml21__MassPerVolumeUom' for type 'eml21:MassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUom (1034)
#endif

/* enum eml21__MassPerVolumePerTemperatureUom has binding name 'eml21__MassPerVolumePerTemperatureUom' for type 'eml21:MassPerVolumePerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUom (1033)
#endif

/* enum eml21__MassPerVolumePerPressureUom has binding name 'eml21__MassPerVolumePerPressureUom' for type 'eml21:MassPerVolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUom (1032)
#endif

/* enum eml21__MassPerVolumePerLengthUom has binding name 'eml21__MassPerVolumePerLengthUom' for type 'eml21:MassPerVolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUom (1031)
#endif

/* enum eml21__MassPerTimeUom has binding name 'eml21__MassPerTimeUom' for type 'eml21:MassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUom (1030)
#endif

/* enum eml21__MassPerTimePerLengthUom has binding name 'eml21__MassPerTimePerLengthUom' for type 'eml21:MassPerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUom (1029)
#endif

/* enum eml21__MassPerTimePerAreaUom has binding name 'eml21__MassPerTimePerAreaUom' for type 'eml21:MassPerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUom (1028)
#endif

/* enum eml21__MassPerMassUom has binding name 'eml21__MassPerMassUom' for type 'eml21:MassPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUom (1027)
#endif

/* enum eml21__MassPerLengthUom has binding name 'eml21__MassPerLengthUom' for type 'eml21:MassPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUom (1026)
#endif

/* enum eml21__MassPerEnergyUom has binding name 'eml21__MassPerEnergyUom' for type 'eml21:MassPerEnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUom (1025)
#endif

/* enum eml21__MassPerAreaUom has binding name 'eml21__MassPerAreaUom' for type 'eml21:MassPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUom (1024)
#endif

/* enum eml21__MassLengthUom has binding name 'eml21__MassLengthUom' for type 'eml21:MassLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUom (1023)
#endif

/* enum eml21__MagneticVectorPotentialUom has binding name 'eml21__MagneticVectorPotentialUom' for type 'eml21:MagneticVectorPotentialUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUom (1022)
#endif

/* enum eml21__MagneticPermeabilityUom has binding name 'eml21__MagneticPermeabilityUom' for type 'eml21:MagneticPermeabilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUom (1021)
#endif

/* enum eml21__MagneticFluxUom has binding name 'eml21__MagneticFluxUom' for type 'eml21:MagneticFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUom (1020)
#endif

/* enum eml21__MagneticFluxDensityUom has binding name 'eml21__MagneticFluxDensityUom' for type 'eml21:MagneticFluxDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUom (1019)
#endif

/* enum eml21__MagneticFluxDensityPerLengthUom has binding name 'eml21__MagneticFluxDensityPerLengthUom' for type 'eml21:MagneticFluxDensityPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUom (1018)
#endif

/* enum eml21__MagneticFieldStrengthUom has binding name 'eml21__MagneticFieldStrengthUom' for type 'eml21:MagneticFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUom (1017)
#endif

/* enum eml21__MagneticDipoleMomentUom has binding name 'eml21__MagneticDipoleMomentUom' for type 'eml21:MagneticDipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUom (1016)
#endif

/* enum eml21__LuminousIntensityUom has binding name 'eml21__LuminousIntensityUom' for type 'eml21:LuminousIntensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUom (1015)
#endif

/* enum eml21__LuminousFluxUom has binding name 'eml21__LuminousFluxUom' for type 'eml21:LuminousFluxUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUom (1014)
#endif

/* enum eml21__LuminousEfficacyUom has binding name 'eml21__LuminousEfficacyUom' for type 'eml21:LuminousEfficacyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUom (1013)
#endif

/* enum eml21__LuminanceUom has binding name 'eml21__LuminanceUom' for type 'eml21:LuminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUom (1012)
#endif

/* enum eml21__LogarithmicPowerRatioUom has binding name 'eml21__LogarithmicPowerRatioUom' for type 'eml21:LogarithmicPowerRatioUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUom (1011)
#endif

/* enum eml21__LogarithmicPowerRatioPerLengthUom has binding name 'eml21__LogarithmicPowerRatioPerLengthUom' for type 'eml21:LogarithmicPowerRatioPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUom (1010)
#endif

/* enum eml21__LinearThermalExpansionUom has binding name 'eml21__LinearThermalExpansionUom' for type 'eml21:LinearThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUom (1009)
#endif

/* enum eml21__LinearAccelerationUom has binding name 'eml21__LinearAccelerationUom' for type 'eml21:LinearAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUom (1008)
#endif

/* enum eml21__LightExposureUom has binding name 'eml21__LightExposureUom' for type 'eml21:LightExposureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUom (1007)
#endif

/* enum eml21__LengthUom has binding name 'eml21__LengthUom' for type 'eml21:LengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthUom (1006)
#endif

/* enum eml21__LengthPerVolumeUom has binding name 'eml21__LengthPerVolumeUom' for type 'eml21:LengthPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUom (1005)
#endif

/* enum eml21__LengthPerTimeUom has binding name 'eml21__LengthPerTimeUom' for type 'eml21:LengthPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUom (1004)
#endif

/* enum eml21__LengthPerTemperatureUom has binding name 'eml21__LengthPerTemperatureUom' for type 'eml21:LengthPerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUom (1003)
#endif

/* enum eml21__LengthPerPressureUom has binding name 'eml21__LengthPerPressureUom' for type 'eml21:LengthPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUom (1002)
#endif

/* enum eml21__LengthPerMassUom has binding name 'eml21__LengthPerMassUom' for type 'eml21:LengthPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUom (1001)
#endif

/* enum eml21__LengthPerLengthUom has binding name 'eml21__LengthPerLengthUom' for type 'eml21:LengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUom (1000)
#endif

/* enum eml21__KinematicViscosityUom has binding name 'eml21__KinematicViscosityUom' for type 'eml21:KinematicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUom (999)
#endif

/* enum eml21__IsothermalCompressibilityUom has binding name 'eml21__IsothermalCompressibilityUom' for type 'eml21:IsothermalCompressibilityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUom (998)
#endif

/* enum eml21__InductanceUom has binding name 'eml21__InductanceUom' for type 'eml21:InductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUom (997)
#endif

/* enum eml21__IlluminanceUom has binding name 'eml21__IlluminanceUom' for type 'eml21:IlluminanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUom (996)
#endif

/* enum eml21__HeatTransferCoefficientUom has binding name 'eml21__HeatTransferCoefficientUom' for type 'eml21:HeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUom (995)
#endif

/* enum eml21__HeatFlowRateUom has binding name 'eml21__HeatFlowRateUom' for type 'eml21:HeatFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUom (994)
#endif

/* enum eml21__HeatCapacityUom has binding name 'eml21__HeatCapacityUom' for type 'eml21:HeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUom (993)
#endif

/* enum eml21__FrequencyUom has binding name 'eml21__FrequencyUom' for type 'eml21:FrequencyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUom (992)
#endif

/* enum eml21__FrequencyIntervalUom has binding name 'eml21__FrequencyIntervalUom' for type 'eml21:FrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUom (991)
#endif

/* enum eml21__ForceUom has binding name 'eml21__ForceUom' for type 'eml21:ForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceUom (990)
#endif

/* enum eml21__ForcePerVolumeUom has binding name 'eml21__ForcePerVolumeUom' for type 'eml21:ForcePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUom (989)
#endif

/* enum eml21__ForcePerLengthUom has binding name 'eml21__ForcePerLengthUom' for type 'eml21:ForcePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUom (988)
#endif

/* enum eml21__ForcePerForceUom has binding name 'eml21__ForcePerForceUom' for type 'eml21:ForcePerForceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUom (987)
#endif

/* enum eml21__ForceLengthPerLengthUom has binding name 'eml21__ForceLengthPerLengthUom' for type 'eml21:ForceLengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUom (986)
#endif

/* enum eml21__ForceAreaUom has binding name 'eml21__ForceAreaUom' for type 'eml21:ForceAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUom (985)
#endif

/* enum eml21__EnergyUom has binding name 'eml21__EnergyUom' for type 'eml21:EnergyUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUom (984)
#endif

/* enum eml21__EnergyPerVolumeUom has binding name 'eml21__EnergyPerVolumeUom' for type 'eml21:EnergyPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUom (983)
#endif

/* enum eml21__EnergyPerMassUom has binding name 'eml21__EnergyPerMassUom' for type 'eml21:EnergyPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUom (982)
#endif

/* enum eml21__EnergyPerMassPerTimeUom has binding name 'eml21__EnergyPerMassPerTimeUom' for type 'eml21:EnergyPerMassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUom (981)
#endif

/* enum eml21__EnergyPerLengthUom has binding name 'eml21__EnergyPerLengthUom' for type 'eml21:EnergyPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUom (980)
#endif

/* enum eml21__EnergyPerAreaUom has binding name 'eml21__EnergyPerAreaUom' for type 'eml21:EnergyPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUom (979)
#endif

/* enum eml21__EnergyLengthPerTimeAreaTemperatureUom has binding name 'eml21__EnergyLengthPerTimeAreaTemperatureUom' for type 'eml21:EnergyLengthPerTimeAreaTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUom (978)
#endif

/* enum eml21__EnergyLengthPerAreaUom has binding name 'eml21__EnergyLengthPerAreaUom' for type 'eml21:EnergyLengthPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUom (977)
#endif

/* enum eml21__ElectromagneticMomentUom has binding name 'eml21__ElectromagneticMomentUom' for type 'eml21:ElectromagneticMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUom (976)
#endif

/* enum eml21__ElectricResistanceUom has binding name 'eml21__ElectricResistanceUom' for type 'eml21:ElectricResistanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUom (975)
#endif

/* enum eml21__ElectricResistancePerLengthUom has binding name 'eml21__ElectricResistancePerLengthUom' for type 'eml21:ElectricResistancePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUom (974)
#endif

/* enum eml21__ElectricPotentialDifferenceUom has binding name 'eml21__ElectricPotentialDifferenceUom' for type 'eml21:ElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUom (973)
#endif

/* enum eml21__ElectricFieldStrengthUom has binding name 'eml21__ElectricFieldStrengthUom' for type 'eml21:ElectricFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUom (972)
#endif

/* enum eml21__ElectricCurrentUom has binding name 'eml21__ElectricCurrentUom' for type 'eml21:ElectricCurrentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUom (971)
#endif

/* enum eml21__ElectricCurrentDensityUom has binding name 'eml21__ElectricCurrentDensityUom' for type 'eml21:ElectricCurrentDensityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUom (970)
#endif

/* enum eml21__ElectricConductivityUom has binding name 'eml21__ElectricConductivityUom' for type 'eml21:ElectricConductivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUom (969)
#endif

/* enum eml21__ElectricConductanceUom has binding name 'eml21__ElectricConductanceUom' for type 'eml21:ElectricConductanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUom (968)
#endif

/* enum eml21__ElectricChargeUom has binding name 'eml21__ElectricChargeUom' for type 'eml21:ElectricChargeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUom (967)
#endif

/* enum eml21__ElectricChargePerVolumeUom has binding name 'eml21__ElectricChargePerVolumeUom' for type 'eml21:ElectricChargePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUom (966)
#endif

/* enum eml21__ElectricChargePerMassUom has binding name 'eml21__ElectricChargePerMassUom' for type 'eml21:ElectricChargePerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUom (965)
#endif

/* enum eml21__ElectricChargePerAreaUom has binding name 'eml21__ElectricChargePerAreaUom' for type 'eml21:ElectricChargePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUom (964)
#endif

/* enum eml21__ElectricalResistivityUom has binding name 'eml21__ElectricalResistivityUom' for type 'eml21:ElectricalResistivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUom (963)
#endif

/* enum eml21__DynamicViscosityUom has binding name 'eml21__DynamicViscosityUom' for type 'eml21:DynamicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUom (962)
#endif

/* enum eml21__DoseEquivalentUom has binding name 'eml21__DoseEquivalentUom' for type 'eml21:DoseEquivalentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUom (961)
#endif

/* enum eml21__DipoleMomentUom has binding name 'eml21__DipoleMomentUom' for type 'eml21:DipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUom (960)
#endif

/* enum eml21__DimensionlessUom has binding name 'eml21__DimensionlessUom' for type 'eml21:DimensionlessUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUom (959)
#endif

/* enum eml21__DigitalStorageUom has binding name 'eml21__DigitalStorageUom' for type 'eml21:DigitalStorageUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUom (958)
#endif

/* enum eml21__DiffusiveTimeOfFlightUom has binding name 'eml21__DiffusiveTimeOfFlightUom' for type 'eml21:DiffusiveTimeOfFlightUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUom (957)
#endif

/* enum eml21__DiffusionCoefficientUom has binding name 'eml21__DiffusionCoefficientUom' for type 'eml21:DiffusionCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUom (956)
#endif

/* enum eml21__DataTransferSpeedUom has binding name 'eml21__DataTransferSpeedUom' for type 'eml21:DataTransferSpeedUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUom (955)
#endif

/* enum eml21__CationExchangeCapacityUom has binding name 'eml21__CationExchangeCapacityUom' for type 'eml21:CationExchangeCapacityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUom (954)
#endif

/* enum eml21__CapacitanceUom has binding name 'eml21__CapacitanceUom' for type 'eml21:CapacitanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUom (953)
#endif

/* enum eml21__AttenuationPerFrequencyIntervalUom has binding name 'eml21__AttenuationPerFrequencyIntervalUom' for type 'eml21:AttenuationPerFrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUom (952)
#endif

/* enum eml21__AreaUom has binding name 'eml21__AreaUom' for type 'eml21:AreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaUom (951)
#endif

/* enum eml21__AreaPerVolumeUom has binding name 'eml21__AreaPerVolumeUom' for type 'eml21:AreaPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUom (950)
#endif

/* enum eml21__AreaPerTimeUom has binding name 'eml21__AreaPerTimeUom' for type 'eml21:AreaPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUom (949)
#endif

/* enum eml21__AreaPerMassUom has binding name 'eml21__AreaPerMassUom' for type 'eml21:AreaPerMassUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUom (948)
#endif

/* enum eml21__AreaPerCountUom has binding name 'eml21__AreaPerCountUom' for type 'eml21:AreaPerCountUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUom (947)
#endif

/* enum eml21__AreaPerAreaUom has binding name 'eml21__AreaPerAreaUom' for type 'eml21:AreaPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUom (946)
#endif

/* enum eml21__AreaPerAmountOfSubstanceUom has binding name 'eml21__AreaPerAmountOfSubstanceUom' for type 'eml21:AreaPerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUom (945)
#endif

/* enum eml21__APINeutronUom has binding name 'eml21__APINeutronUom' for type 'eml21:APINeutronUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUom (944)
#endif

/* enum eml21__APIGravityUom has binding name 'eml21__APIGravityUom' for type 'eml21:APIGravityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUom (943)
#endif

/* enum eml21__APIGammaRayUom has binding name 'eml21__APIGammaRayUom' for type 'eml21:APIGammaRayUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUom (942)
#endif

/* enum eml21__AngularVelocityUom has binding name 'eml21__AngularVelocityUom' for type 'eml21:AngularVelocityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUom (941)
#endif

/* enum eml21__AngularAccelerationUom has binding name 'eml21__AngularAccelerationUom' for type 'eml21:AngularAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUom (940)
#endif

/* enum eml21__AnglePerVolumeUom has binding name 'eml21__AnglePerVolumeUom' for type 'eml21:AnglePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUom (939)
#endif

/* enum eml21__AnglePerLengthUom has binding name 'eml21__AnglePerLengthUom' for type 'eml21:AnglePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUom (938)
#endif

/* enum eml21__AmountOfSubstanceUom has binding name 'eml21__AmountOfSubstanceUom' for type 'eml21:AmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUom (937)
#endif

/* enum eml21__AmountOfSubstancePerVolumeUom has binding name 'eml21__AmountOfSubstancePerVolumeUom' for type 'eml21:AmountOfSubstancePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUom (936)
#endif

/* enum eml21__AmountOfSubstancePerTimeUom has binding name 'eml21__AmountOfSubstancePerTimeUom' for type 'eml21:AmountOfSubstancePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUom (935)
#endif

/* enum eml21__AmountOfSubstancePerTimePerAreaUom has binding name 'eml21__AmountOfSubstancePerTimePerAreaUom' for type 'eml21:AmountOfSubstancePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUom (934)
#endif

/* enum eml21__AmountOfSubstancePerAreaUom has binding name 'eml21__AmountOfSubstancePerAreaUom' for type 'eml21:AmountOfSubstancePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUom (933)
#endif

/* enum eml21__AmountOfSubstancePerAmountOfSubstanceUom has binding name 'eml21__AmountOfSubstancePerAmountOfSubstanceUom' for type 'eml21:AmountOfSubstancePerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUom (932)
#endif

/* enum eml21__ActivityOfRadioactivityUom has binding name 'eml21__ActivityOfRadioactivityUom' for type 'eml21:ActivityOfRadioactivityUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUom (931)
#endif

/* enum eml21__AbsorbedDoseUom has binding name 'eml21__AbsorbedDoseUom' for type 'eml21:AbsorbedDoseUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUom (930)
#endif

/* enum eml21__UnitOfMeasure has binding name 'eml21__UnitOfMeasure' for type 'eml21:UnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasure (927)
#endif

/* enum _xlink__actuate has binding name '_xlink__actuate' for type 'xlink:actuate' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__actuate
#define SOAP_TYPE_gsoap_eml2_1__xlink__actuate (920)
#endif

/* enum _xlink__show has binding name '_xlink__show' for type 'xlink:show' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__show
#define SOAP_TYPE_gsoap_eml2_1__xlink__show (919)
#endif

/* enum gml__AggregationType has binding name 'gml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AggregationType
#define SOAP_TYPE_gsoap_eml2_1_gml__AggregationType (918)
#endif

/* enum eml21__VerticalDirection has binding name 'eml21__VerticalDirection' for type 'eml21:VerticalDirection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalDirection
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalDirection (915)
#endif

/* enum eml21__AxisOrder2d has binding name 'eml21__AxisOrder2d' for type 'eml21:AxisOrder2d' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AxisOrder2d
#define SOAP_TYPE_gsoap_eml2_1_eml21__AxisOrder2d (914)
#endif

/* enum eml21__ParameterKind has binding name 'eml21__ParameterKind' for type 'eml21:ParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ParameterKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__ParameterKind (913)
#endif

/* _gco__nilReason has binding name '_gco__nilReason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__nilReason
#define SOAP_TYPE_gsoap_eml2_1__gco__nilReason (1777)
#endif

/* _gco__Date has binding name '_gco__Date' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__Date
#define SOAP_TYPE_gsoap_eml2_1__gco__Date (1775)
#endif

/* _gco__CharacterString has binding name '_gco__CharacterString' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gco__CharacterString
#define SOAP_TYPE_gsoap_eml2_1__gco__CharacterString (1772)
#endif

/* _gmd__DQ_USCOREEvaluationMethodTypeCode has binding name '_gmd__DQ_USCOREEvaluationMethodTypeCode' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__DQ_USCOREEvaluationMethodTypeCode (1771)
#endif

/* _gmd__CI_USCORESeries has binding name '_gmd__CI_USCORESeries' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORESeries (1770)
#endif

/* _gmd__CI_USCOREPresentationFormCode has binding name '_gmd__CI_USCOREPresentationFormCode' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREPresentationFormCode (1769)
#endif

/* _gmd__CI_USCORERoleCode has binding name '_gmd__CI_USCORERoleCode' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORERoleCode (1768)
#endif

/* _gmd__CI_USCOREOnLineFunctionCode has binding name '_gmd__CI_USCOREOnLineFunctionCode' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnLineFunctionCode (1767)
#endif

/* _gmd__URL has binding name '_gmd__URL' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__URL
#define SOAP_TYPE_gsoap_eml2_1__gmd__URL (1766)
#endif

/* _gmd__CI_USCOREOnlineResource has binding name '_gmd__CI_USCOREOnlineResource' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREOnlineResource (1765)
#endif

/* _gmd__CI_USCOREAddress has binding name '_gmd__CI_USCOREAddress' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREAddress (1764)
#endif

/* _gmd__CI_USCORETelephone has binding name '_gmd__CI_USCORETelephone' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORETelephone (1763)
#endif

/* _gmd__CI_USCOREContact has binding name '_gmd__CI_USCOREContact' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREContact (1762)
#endif

/* _gmd__CI_USCOREResponsibleParty has binding name '_gmd__CI_USCOREResponsibleParty' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREResponsibleParty (1761)
#endif

/* _gmd__CI_USCOREDateTypeCode has binding name '_gmd__CI_USCOREDateTypeCode' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDateTypeCode (1760)
#endif

/* _gmd__CI_USCOREDate has binding name '_gmd__CI_USCOREDate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCOREDate (1759)
#endif

/* _gmd__CI_USCORECitation has binding name '_gmd__CI_USCORECitation' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_eml2_1__gmd__CI_USCORECitation (1758)
#endif

/* _gmd__MD_USCOREIdentifier has binding name '_gmd__MD_USCOREIdentifier' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_eml2_1__gmd__MD_USCOREIdentifier (1757)
#endif

/* _gmd__EX_USCOREVerticalExtent has binding name '_gmd__EX_USCOREVerticalExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREVerticalExtent (1756)
#endif

/* _gmd__EX_USCORETemporalExtent has binding name '_gmd__EX_USCORETemporalExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCORETemporalExtent (1755)
#endif

/* _gmd__EX_USCOREExtent has binding name '_gmd__EX_USCOREExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_eml2_1__gmd__EX_USCOREExtent (1754)
#endif

/* _xlink__title has binding name '_xlink__title' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__title
#define SOAP_TYPE_gsoap_eml2_1__xlink__title (1753)
#endif

/* _xlink__arcrole has binding name '_xlink__arcrole' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__arcrole
#define SOAP_TYPE_gsoap_eml2_1__xlink__arcrole (1752)
#endif

/* _xlink__role has binding name '_xlink__role' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__role
#define SOAP_TYPE_gsoap_eml2_1__xlink__role (1751)
#endif

/* _xlink__href has binding name '_xlink__href' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__xlink__href
#define SOAP_TYPE_gsoap_eml2_1__xlink__href (1750)
#endif

/* _gml__id has binding name '_gml__id' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__id
#define SOAP_TYPE_gsoap_eml2_1__gml__id (1749)
#endif

/* _gml__VerticalDatum has binding name '_gml__VerticalDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalDatum (1748)
#endif

/* _gml__verticalDatum has binding name '_gml__verticalDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__verticalDatum (1747)
#endif

/* _gml__VerticalCS has binding name '_gml__VerticalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalCS (1746)
#endif

/* _gml__verticalCS has binding name '_gml__verticalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__verticalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__verticalCS (1745)
#endif

/* _gml__VerticalCRS has binding name '_gml__VerticalCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__VerticalCRS (1744)
#endif

/* _gml__baseGeodeticCRS has binding name '_gml__baseGeodeticCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__baseGeodeticCRS (1743)
#endif

/* _gml__targetCRS has binding name '_gml__targetCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__targetCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__targetCRS (1742)
#endif

/* _gml__sourceCRS has binding name '_gml__sourceCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__sourceCRS (1741)
#endif

/* _gml__operationVersion has binding name '_gml__operationVersion' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__operationVersion
#define SOAP_TYPE_gsoap_eml2_1__gml__operationVersion (1740)
#endif

/* _gml__conversion has binding name '_gml__conversion' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__conversion
#define SOAP_TYPE_gsoap_eml2_1__gml__conversion (1739)
#endif

/* _gml__ProjectedCRS has binding name '_gml__ProjectedCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__ProjectedCRS (1738)
#endif

/* _gml__semiMajorAxis has binding name '_gml__semiMajorAxis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_eml2_1__gml__semiMajorAxis (1737)
#endif

/* _gml__Ellipsoid has binding name '_gml__Ellipsoid' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_eml2_1__gml__Ellipsoid (1736)
#endif

/* _gml__ellipsoid has binding name '_gml__ellipsoid' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_eml2_1__gml__ellipsoid (1735)
#endif

/* _gml__greenwichLongitude has binding name '_gml__greenwichLongitude' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_eml2_1__gml__greenwichLongitude (1734)
#endif

/* _gml__PrimeMeridian has binding name '_gml__PrimeMeridian' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_eml2_1__gml__PrimeMeridian (1733)
#endif

/* _gml__primeMeridian has binding name '_gml__primeMeridian' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_eml2_1__gml__primeMeridian (1732)
#endif

/* _gml__realizationEpoch has binding name '_gml__realizationEpoch' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_eml2_1__gml__realizationEpoch (1731)
#endif

/* _gml__anchorDefinition has binding name '_gml__anchorDefinition' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_eml2_1__gml__anchorDefinition (1730)
#endif

/* _gml__GeodeticDatum has binding name '_gml__GeodeticDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__GeodeticDatum (1729)
#endif

/* _gml__geodeticDatum has binding name '_gml__geodeticDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_eml2_1__gml__geodeticDatum (1728)
#endif

/* _gml__SphericalCS has binding name '_gml__SphericalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__SphericalCS (1727)
#endif

/* _gml__sphericalCS has binding name '_gml__sphericalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__sphericalCS (1726)
#endif

/* _gml__CartesianCS has binding name '_gml__CartesianCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_eml2_1__gml__CartesianCS (1725)
#endif

/* _gml__cartesianCS has binding name '_gml__cartesianCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_eml2_1__gml__cartesianCS (1724)
#endif

/* _gml__rangeMeaning has binding name '_gml__rangeMeaning' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_eml2_1__gml__rangeMeaning (1723)
#endif

/* _gml__axisDirection has binding name '_gml__axisDirection' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axisDirection
#define SOAP_TYPE_gsoap_eml2_1__gml__axisDirection (1720)
#endif

/* _gml__axisAbbrev has binding name '_gml__axisAbbrev' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_eml2_1__gml__axisAbbrev (1719)
#endif

/* _gml__CoordinateSystemAxis has binding name '_gml__CoordinateSystemAxis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_eml2_1__gml__CoordinateSystemAxis (1718)
#endif

/* _gml__axis has binding name '_gml__axis' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__axis
#define SOAP_TYPE_gsoap_eml2_1__gml__axis (1717)
#endif

/* _gml__EllipsoidalCS has binding name '_gml__EllipsoidalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__EllipsoidalCS (1716)
#endif

/* _gml__ellipsoidalCS has binding name '_gml__ellipsoidalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_eml2_1__gml__ellipsoidalCS (1715)
#endif

/* _gml__scope has binding name '_gml__scope' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__scope
#define SOAP_TYPE_gsoap_eml2_1__gml__scope (1714)
#endif

/* _gml__Definition has binding name '_gml__Definition' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__Definition
#define SOAP_TYPE_gsoap_eml2_1__gml__Definition (1713)
#endif

/* _gml__remarks has binding name '_gml__remarks' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__remarks
#define SOAP_TYPE_gsoap_eml2_1__gml__remarks (1712)
#endif

/* _gml__name has binding name '_gml__name' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__name
#define SOAP_TYPE_gsoap_eml2_1__gml__name (1711)
#endif

/* _gml__identifier has binding name '_gml__identifier' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__identifier
#define SOAP_TYPE_gsoap_eml2_1__gml__identifier (1710)
#endif

/* _gml__descriptionReference has binding name '_gml__descriptionReference' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_eml2_1__gml__descriptionReference (1709)
#endif

/* _gml__description has binding name '_gml__description' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__description
#define SOAP_TYPE_gsoap_eml2_1__gml__description (1708)
#endif

/* _gml__GeodeticCRS has binding name '_gml__GeodeticCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_eml2_1__gml__GeodeticCRS (1707)
#endif

/* _eml21__GraphicalInformationSet has binding name '_eml21__GraphicalInformationSet' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_1__eml21__GraphicalInformationSet (1706)
#endif

/* _eml21__DataAssuranceRecord has binding name '_eml21__DataAssuranceRecord' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_1__eml21__DataAssuranceRecord (1705)
#endif

/* _eml21__TimeSeries has binding name '_eml21__TimeSeries' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__TimeSeries
#define SOAP_TYPE_gsoap_eml2_1__eml21__TimeSeries (1704)
#endif

/* _eml21__PropertyKindDictionary has binding name '_eml21__PropertyKindDictionary' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKindDictionary (1703)
#endif

/* _eml21__PropertyKind has binding name '_eml21__PropertyKind' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1__eml21__PropertyKind (1702)
#endif

/* _eml21__ActivityTemplate has binding name '_eml21__ActivityTemplate' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_1__eml21__ActivityTemplate (1701)
#endif

/* _eml21__Activity has binding name '_eml21__Activity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__Activity
#define SOAP_TYPE_gsoap_eml2_1__eml21__Activity (1700)
#endif

/* _eml21__EpcExternalPartReference has binding name '_eml21__EpcExternalPartReference' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_1__eml21__EpcExternalPartReference (1699)
#endif

/* _eml21__AbstractDataObject has binding name '_eml21__AbstractDataObject' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__AbstractDataObject
#define SOAP_TYPE_gsoap_eml2_1__eml21__AbstractDataObject (1698)
#endif

/* _eml21__AbstractContextualObject has binding name '_eml21__AbstractContextualObject' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__eml21__AbstractContextualObject
#define SOAP_TYPE_gsoap_eml2_1__eml21__AbstractContextualObject (1697)
#endif

/* _prodml2__FiberOpticalPath has binding name '_prodml2__FiberOpticalPath' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__FiberOpticalPath
#define SOAP_TYPE_gsoap_eml2_1__prodml2__FiberOpticalPath (1696)
#endif

/* _prodml2__ProductFlowModel has binding name '_prodml2__ProductFlowModel' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_1__prodml2__ProductFlowModel (1695)
#endif

/* _prodml2__ProductVolume has binding name '_prodml2__ProductVolume' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__ProductVolume
#define SOAP_TYPE_gsoap_eml2_1__prodml2__ProductVolume (1694)
#endif

/* _prodml2__DtsInstalledSystem has binding name '_prodml2__DtsInstalledSystem' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstalledSystem
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstalledSystem (1693)
#endif

/* _prodml2__DtsInstrumentBox has binding name '_prodml2__DtsInstrumentBox' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DtsInstrumentBox (1692)
#endif

/* _prodml2__DasInstrumentBox has binding name '_prodml2__DasInstrumentBox' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DasInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DasInstrumentBox (1691)
#endif

/* _prodml2__DasAcquisition has binding name '_prodml2__DasAcquisition' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__prodml2__DasAcquisition
#define SOAP_TYPE_gsoap_eml2_1__prodml2__DasAcquisition (1690)
#endif

/* eml21__TypeEnum has binding name 'eml21__TypeEnum' for type 'eml21:TypeEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TypeEnum
#define SOAP_TYPE_gsoap_eml2_1_eml21__TypeEnum (929)
#endif

/* eml21__TimeZone has binding name 'eml21__TimeZone' for type 'eml21:TimeZone' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeZone
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeZone (928)
#endif

/* eml21__UuidString has binding name 'eml21__UuidString' for type 'eml21:UuidString' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UuidString
#define SOAP_TYPE_gsoap_eml2_1_eml21__UuidString (926)
#endif

/* eml21__UomEnum has binding name 'eml21__UomEnum' for type 'eml21:UomEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UomEnum
#define SOAP_TYPE_gsoap_eml2_1_eml21__UomEnum (925)
#endif

/* eml21__TimeStamp has binding name 'eml21__TimeStamp' for type 'eml21:TimeStamp' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeStamp
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeStamp (924)
#endif

/* eml21__String64 has binding name 'eml21__String64' for type 'eml21:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__String64
#define SOAP_TYPE_gsoap_eml2_1_eml21__String64 (923)
#endif

/* eml21__String2000 has binding name 'eml21__String2000' for type 'eml21:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__String2000
#define SOAP_TYPE_gsoap_eml2_1_eml21__String2000 (922)
#endif

/* eml21__EnumExtensionPattern has binding name 'eml21__EnumExtensionPattern' for type 'eml21:EnumExtensionPattern' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnumExtensionPattern
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnumExtensionPattern (921)
#endif

/* gml__UomURI has binding name 'gml__UomURI' for type 'gml:UomURI' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomURI
#define SOAP_TYPE_gsoap_eml2_1_gml__UomURI (917)
#endif

/* gml__UomSymbol has binding name 'gml__UomSymbol' for type 'gml:UomSymbol' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_eml2_1_gml__UomSymbol (916)
#endif

/* eml21__AbstractString has binding name 'eml21__AbstractString' for type 'eml21:AbstractString' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractString
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractString (910)
#endif

/* prodml2__ProdmlRelativeIdentifier has binding name 'prodml2__ProdmlRelativeIdentifier' for type 'prodml2:ProdmlRelativeIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProdmlRelativeIdentifier (907)
#endif

/* prodml2__CalendarMonth has binding name 'prodml2__CalendarMonth' for type 'prodml2:CalendarMonth' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalendarMonth (903)
#endif

/* gco__Date_USCOREType has binding name 'gco__Date_USCOREType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREType (902)
#endif

/* gml__UomIdentifier has binding name 'gml__UomIdentifier' for type 'gml:UomIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_eml2_1_gml__UomIdentifier (901)
#endif

/* gml__NilReasonEnumeration has binding name 'gml__NilReasonEnumeration' for type 'gml:NilReasonEnumeration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_eml2_1_gml__NilReasonEnumeration (900)
#endif

/* gml__NilReasonType has binding name 'gml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_eml2_1_gml__NilReasonType (899)
#endif

/* eml21__VolumeUomExt has binding name 'eml21__VolumeUomExt' for type 'eml21:VolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeUomExt (898)
#endif

/* eml21__VolumetricThermalExpansionUomExt has binding name 'eml21__VolumetricThermalExpansionUomExt' for type 'eml21:VolumetricThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionUomExt (897)
#endif

/* eml21__VolumetricHeatTransferCoefficientUomExt has binding name 'eml21__VolumetricHeatTransferCoefficientUomExt' for type 'eml21:VolumetricHeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientUomExt (896)
#endif

/* eml21__VolumePerVolumeUomExt has binding name 'eml21__VolumePerVolumeUomExt' for type 'eml21:VolumePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeUomExt (895)
#endif

/* eml21__VolumePerTimeUomExt has binding name 'eml21__VolumePerTimeUomExt' for type 'eml21:VolumePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeUomExt (894)
#endif

/* eml21__VolumePerTimePerVolumeUomExt has binding name 'eml21__VolumePerTimePerVolumeUomExt' for type 'eml21:VolumePerTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeUomExt (893)
#endif

/* eml21__VolumePerTimePerTimeUomExt has binding name 'eml21__VolumePerTimePerTimeUomExt' for type 'eml21:VolumePerTimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeUomExt (892)
#endif

/* eml21__VolumePerTimePerPressureUomExt has binding name 'eml21__VolumePerTimePerPressureUomExt' for type 'eml21:VolumePerTimePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureUomExt (891)
#endif

/* eml21__VolumePerTimePerPressureLengthUomExt has binding name 'eml21__VolumePerTimePerPressureLengthUomExt' for type 'eml21:VolumePerTimePerPressureLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthUomExt (890)
#endif

/* eml21__VolumePerTimePerLengthUomExt has binding name 'eml21__VolumePerTimePerLengthUomExt' for type 'eml21:VolumePerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthUomExt (889)
#endif

/* eml21__VolumePerTimePerAreaUomExt has binding name 'eml21__VolumePerTimePerAreaUomExt' for type 'eml21:VolumePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaUomExt (888)
#endif

/* eml21__VolumePerTimeLengthUomExt has binding name 'eml21__VolumePerTimeLengthUomExt' for type 'eml21:VolumePerTimeLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthUomExt (887)
#endif

/* eml21__VolumePerRotationUomExt has binding name 'eml21__VolumePerRotationUomExt' for type 'eml21:VolumePerRotationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationUomExt (886)
#endif

/* eml21__VolumePerPressureUomExt has binding name 'eml21__VolumePerPressureUomExt' for type 'eml21:VolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureUomExt (885)
#endif

/* eml21__VolumePerMassUomExt has binding name 'eml21__VolumePerMassUomExt' for type 'eml21:VolumePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassUomExt (884)
#endif

/* eml21__VolumePerLengthUomExt has binding name 'eml21__VolumePerLengthUomExt' for type 'eml21:VolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthUomExt (883)
#endif

/* eml21__VolumePerAreaUomExt has binding name 'eml21__VolumePerAreaUomExt' for type 'eml21:VolumePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaUomExt (882)
#endif

/* eml21__VolumeFlowRatePerVolumeFlowRateUomExt has binding name 'eml21__VolumeFlowRatePerVolumeFlowRateUomExt' for type 'eml21:VolumeFlowRatePerVolumeFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateUomExt (881)
#endif

/* eml21__VerticalCoordinateUomExt has binding name 'eml21__VerticalCoordinateUomExt' for type 'eml21:VerticalCoordinateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateUomExt (880)
#endif

/* eml21__TimeUomExt has binding name 'eml21__TimeUomExt' for type 'eml21:TimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeUomExt (879)
#endif

/* eml21__TimePerVolumeUomExt has binding name 'eml21__TimePerVolumeUomExt' for type 'eml21:TimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeUomExt (878)
#endif

/* eml21__TimePerTimeUomExt has binding name 'eml21__TimePerTimeUomExt' for type 'eml21:TimePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeUomExt (877)
#endif

/* eml21__TimePerMassUomExt has binding name 'eml21__TimePerMassUomExt' for type 'eml21:TimePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassUomExt (876)
#endif

/* eml21__TimePerLengthUomExt has binding name 'eml21__TimePerLengthUomExt' for type 'eml21:TimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthUomExt (875)
#endif

/* eml21__ThermodynamicTemperatureUomExt has binding name 'eml21__ThermodynamicTemperatureUomExt' for type 'eml21:ThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureUomExt (874)
#endif

/* eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt has binding name 'eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' for type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureUomExt (873)
#endif

/* eml21__ThermalResistanceUomExt has binding name 'eml21__ThermalResistanceUomExt' for type 'eml21:ThermalResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceUomExt (872)
#endif

/* eml21__ThermalInsulanceUomExt has binding name 'eml21__ThermalInsulanceUomExt' for type 'eml21:ThermalInsulanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceUomExt (871)
#endif

/* eml21__ThermalDiffusivityUomExt has binding name 'eml21__ThermalDiffusivityUomExt' for type 'eml21:ThermalDiffusivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityUomExt (870)
#endif

/* eml21__ThermalConductivityUomExt has binding name 'eml21__ThermalConductivityUomExt' for type 'eml21:ThermalConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityUomExt (869)
#endif

/* eml21__ThermalConductanceUomExt has binding name 'eml21__ThermalConductanceUomExt' for type 'eml21:ThermalConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceUomExt (868)
#endif

/* eml21__TemperatureIntervalUomExt has binding name 'eml21__TemperatureIntervalUomExt' for type 'eml21:TemperatureIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalUomExt (867)
#endif

/* eml21__TemperatureIntervalPerTimeUomExt has binding name 'eml21__TemperatureIntervalPerTimeUomExt' for type 'eml21:TemperatureIntervalPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeUomExt (866)
#endif

/* eml21__TemperatureIntervalPerPressureUomExt has binding name 'eml21__TemperatureIntervalPerPressureUomExt' for type 'eml21:TemperatureIntervalPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureUomExt (865)
#endif

/* eml21__TemperatureIntervalPerLengthUomExt has binding name 'eml21__TemperatureIntervalPerLengthUomExt' for type 'eml21:TemperatureIntervalPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthUomExt (864)
#endif

/* eml21__SpecificHeatCapacityUomExt has binding name 'eml21__SpecificHeatCapacityUomExt' for type 'eml21:SpecificHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityUomExt (863)
#endif

/* eml21__SolidAngleUomExt has binding name 'eml21__SolidAngleUomExt' for type 'eml21:SolidAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleUomExt (862)
#endif

/* eml21__SignalingEventPerTimeUomExt has binding name 'eml21__SignalingEventPerTimeUomExt' for type 'eml21:SignalingEventPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeUomExt (861)
#endif

/* eml21__SecondMomentOfAreaUomExt has binding name 'eml21__SecondMomentOfAreaUomExt' for type 'eml21:SecondMomentOfAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaUomExt (860)
#endif

/* eml21__ReluctanceUomExt has binding name 'eml21__ReluctanceUomExt' for type 'eml21:ReluctanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceUomExt (859)
#endif

/* eml21__ReciprocalVolumeUomExt has binding name 'eml21__ReciprocalVolumeUomExt' for type 'eml21:ReciprocalVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeUomExt (858)
#endif

/* eml21__ReciprocalTimeUomExt has binding name 'eml21__ReciprocalTimeUomExt' for type 'eml21:ReciprocalTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeUomExt (857)
#endif

/* eml21__ReciprocalPressureUomExt has binding name 'eml21__ReciprocalPressureUomExt' for type 'eml21:ReciprocalPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureUomExt (856)
#endif

/* eml21__ReciprocalMassUomExt has binding name 'eml21__ReciprocalMassUomExt' for type 'eml21:ReciprocalMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassUomExt (855)
#endif

/* eml21__ReciprocalMassTimeUomExt has binding name 'eml21__ReciprocalMassTimeUomExt' for type 'eml21:ReciprocalMassTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeUomExt (854)
#endif

/* eml21__ReciprocalLengthUomExt has binding name 'eml21__ReciprocalLengthUomExt' for type 'eml21:ReciprocalLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthUomExt (853)
#endif

/* eml21__ReciprocalForceUomExt has binding name 'eml21__ReciprocalForceUomExt' for type 'eml21:ReciprocalForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceUomExt (852)
#endif

/* eml21__ReciprocalElectricPotentialDifferenceUomExt has binding name 'eml21__ReciprocalElectricPotentialDifferenceUomExt' for type 'eml21:ReciprocalElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceUomExt (851)
#endif

/* eml21__ReciprocalAreaUomExt has binding name 'eml21__ReciprocalAreaUomExt' for type 'eml21:ReciprocalAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaUomExt (850)
#endif

/* eml21__RadiantIntensityUomExt has binding name 'eml21__RadiantIntensityUomExt' for type 'eml21:RadiantIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityUomExt (849)
#endif

/* eml21__RadianceUomExt has binding name 'eml21__RadianceUomExt' for type 'eml21:RadianceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceUomExt (848)
#endif

/* eml21__QuantityOfLightUomExt has binding name 'eml21__QuantityOfLightUomExt' for type 'eml21:QuantityOfLightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightUomExt (847)
#endif

/* eml21__PressureUomExt has binding name 'eml21__PressureUomExt' for type 'eml21:PressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureUomExt (846)
#endif

/* eml21__PressureTimePerVolumeUomExt has binding name 'eml21__PressureTimePerVolumeUomExt' for type 'eml21:PressureTimePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeUomExt (845)
#endif

/* eml21__PressureSquaredUomExt has binding name 'eml21__PressureSquaredUomExt' for type 'eml21:PressureSquaredUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredUomExt (844)
#endif

/* eml21__PressureSquaredPerForceTimePerAreaUomExt has binding name 'eml21__PressureSquaredPerForceTimePerAreaUomExt' for type 'eml21:PressureSquaredPerForceTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaUomExt (843)
#endif

/* eml21__PressurePerVolumeUomExt has binding name 'eml21__PressurePerVolumeUomExt' for type 'eml21:PressurePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeUomExt (842)
#endif

/* eml21__PressurePerTimeUomExt has binding name 'eml21__PressurePerTimeUomExt' for type 'eml21:PressurePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeUomExt (841)
#endif

/* eml21__PressurePerPressureUomExt has binding name 'eml21__PressurePerPressureUomExt' for type 'eml21:PressurePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureUomExt (840)
#endif

/* eml21__PowerUomExt has binding name 'eml21__PowerUomExt' for type 'eml21:PowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerUomExt (839)
#endif

/* eml21__PowerPerVolumeUomExt has binding name 'eml21__PowerPerVolumeUomExt' for type 'eml21:PowerPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeUomExt (838)
#endif

/* eml21__PowerPerPowerUomExt has binding name 'eml21__PowerPerPowerUomExt' for type 'eml21:PowerPerPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerUomExt (837)
#endif

/* eml21__PowerPerAreaUomExt has binding name 'eml21__PowerPerAreaUomExt' for type 'eml21:PowerPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaUomExt (836)
#endif

/* eml21__PotentialDifferencePerPowerDropUomExt has binding name 'eml21__PotentialDifferencePerPowerDropUomExt' for type 'eml21:PotentialDifferencePerPowerDropUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropUomExt (835)
#endif

/* eml21__PlaneAngleUomExt has binding name 'eml21__PlaneAngleUomExt' for type 'eml21:PlaneAngleUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleUomExt (834)
#endif

/* eml21__PermittivityUomExt has binding name 'eml21__PermittivityUomExt' for type 'eml21:PermittivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityUomExt (833)
#endif

/* eml21__PermeabilityRockUomExt has binding name 'eml21__PermeabilityRockUomExt' for type 'eml21:PermeabilityRockUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockUomExt (832)
#endif

/* eml21__PermeabilityLengthUomExt has binding name 'eml21__PermeabilityLengthUomExt' for type 'eml21:PermeabilityLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthUomExt (831)
#endif

/* eml21__NormalizedPowerUomExt has binding name 'eml21__NormalizedPowerUomExt' for type 'eml21:NormalizedPowerUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerUomExt (830)
#endif

/* eml21__MomentumUomExt has binding name 'eml21__MomentumUomExt' for type 'eml21:MomentumUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumUomExt (829)
#endif

/* eml21__MomentOfInertiaUomExt has binding name 'eml21__MomentOfInertiaUomExt' for type 'eml21:MomentOfInertiaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaUomExt (828)
#endif

/* eml21__MomentOfForceUomExt has binding name 'eml21__MomentOfForceUomExt' for type 'eml21:MomentOfForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceUomExt (827)
#endif

/* eml21__MolecularWeightUomExt has binding name 'eml21__MolecularWeightUomExt' for type 'eml21:MolecularWeightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightUomExt (826)
#endif

/* eml21__MolarVolumeUomExt has binding name 'eml21__MolarVolumeUomExt' for type 'eml21:MolarVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeUomExt (825)
#endif

/* eml21__MolarHeatCapacityUomExt has binding name 'eml21__MolarHeatCapacityUomExt' for type 'eml21:MolarHeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityUomExt (824)
#endif

/* eml21__MolarEnergyUomExt has binding name 'eml21__MolarEnergyUomExt' for type 'eml21:MolarEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyUomExt (823)
#endif

/* eml21__MobilityUomExt has binding name 'eml21__MobilityUomExt' for type 'eml21:MobilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityUomExt (822)
#endif

/* eml21__MassUomExt has binding name 'eml21__MassUomExt' for type 'eml21:MassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassUomExt (821)
#endif

/* eml21__MassPerVolumeUomExt has binding name 'eml21__MassPerVolumeUomExt' for type 'eml21:MassPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeUomExt (820)
#endif

/* eml21__MassPerVolumePerTemperatureUomExt has binding name 'eml21__MassPerVolumePerTemperatureUomExt' for type 'eml21:MassPerVolumePerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureUomExt (819)
#endif

/* eml21__MassPerVolumePerPressureUomExt has binding name 'eml21__MassPerVolumePerPressureUomExt' for type 'eml21:MassPerVolumePerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureUomExt (818)
#endif

/* eml21__MassPerVolumePerLengthUomExt has binding name 'eml21__MassPerVolumePerLengthUomExt' for type 'eml21:MassPerVolumePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthUomExt (817)
#endif

/* eml21__MassPerTimeUomExt has binding name 'eml21__MassPerTimeUomExt' for type 'eml21:MassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeUomExt (816)
#endif

/* eml21__MassPerTimePerLengthUomExt has binding name 'eml21__MassPerTimePerLengthUomExt' for type 'eml21:MassPerTimePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthUomExt (815)
#endif

/* eml21__MassPerTimePerAreaUomExt has binding name 'eml21__MassPerTimePerAreaUomExt' for type 'eml21:MassPerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaUomExt (814)
#endif

/* eml21__MassPerMassUomExt has binding name 'eml21__MassPerMassUomExt' for type 'eml21:MassPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassUomExt (813)
#endif

/* eml21__MassPerLengthUomExt has binding name 'eml21__MassPerLengthUomExt' for type 'eml21:MassPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthUomExt (812)
#endif

/* eml21__MassPerEnergyUomExt has binding name 'eml21__MassPerEnergyUomExt' for type 'eml21:MassPerEnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyUomExt (811)
#endif

/* eml21__MassPerAreaUomExt has binding name 'eml21__MassPerAreaUomExt' for type 'eml21:MassPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaUomExt (810)
#endif

/* eml21__MassLengthUomExt has binding name 'eml21__MassLengthUomExt' for type 'eml21:MassLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthUomExt (809)
#endif

/* eml21__MagneticVectorPotentialUomExt has binding name 'eml21__MagneticVectorPotentialUomExt' for type 'eml21:MagneticVectorPotentialUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialUomExt (808)
#endif

/* eml21__MagneticPermeabilityUomExt has binding name 'eml21__MagneticPermeabilityUomExt' for type 'eml21:MagneticPermeabilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityUomExt (807)
#endif

/* eml21__MagneticFluxUomExt has binding name 'eml21__MagneticFluxUomExt' for type 'eml21:MagneticFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxUomExt (806)
#endif

/* eml21__MagneticFluxDensityUomExt has binding name 'eml21__MagneticFluxDensityUomExt' for type 'eml21:MagneticFluxDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityUomExt (805)
#endif

/* eml21__MagneticFluxDensityPerLengthUomExt has binding name 'eml21__MagneticFluxDensityPerLengthUomExt' for type 'eml21:MagneticFluxDensityPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthUomExt (804)
#endif

/* eml21__MagneticFieldStrengthUomExt has binding name 'eml21__MagneticFieldStrengthUomExt' for type 'eml21:MagneticFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthUomExt (803)
#endif

/* eml21__MagneticDipoleMomentUomExt has binding name 'eml21__MagneticDipoleMomentUomExt' for type 'eml21:MagneticDipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentUomExt (802)
#endif

/* eml21__LuminousIntensityUomExt has binding name 'eml21__LuminousIntensityUomExt' for type 'eml21:LuminousIntensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityUomExt (801)
#endif

/* eml21__LuminousFluxUomExt has binding name 'eml21__LuminousFluxUomExt' for type 'eml21:LuminousFluxUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxUomExt (800)
#endif

/* eml21__LuminousEfficacyUomExt has binding name 'eml21__LuminousEfficacyUomExt' for type 'eml21:LuminousEfficacyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyUomExt (799)
#endif

/* eml21__LuminanceUomExt has binding name 'eml21__LuminanceUomExt' for type 'eml21:LuminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceUomExt (798)
#endif

/* eml21__LogarithmicPowerRatioUomExt has binding name 'eml21__LogarithmicPowerRatioUomExt' for type 'eml21:LogarithmicPowerRatioUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioUomExt (797)
#endif

/* eml21__LogarithmicPowerRatioPerLengthUomExt has binding name 'eml21__LogarithmicPowerRatioPerLengthUomExt' for type 'eml21:LogarithmicPowerRatioPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthUomExt (796)
#endif

/* eml21__LinearThermalExpansionUomExt has binding name 'eml21__LinearThermalExpansionUomExt' for type 'eml21:LinearThermalExpansionUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionUomExt (795)
#endif

/* eml21__LinearAccelerationUomExt has binding name 'eml21__LinearAccelerationUomExt' for type 'eml21:LinearAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationUomExt (794)
#endif

/* eml21__LightExposureUomExt has binding name 'eml21__LightExposureUomExt' for type 'eml21:LightExposureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureUomExt (793)
#endif

/* eml21__LengthUomExt has binding name 'eml21__LengthUomExt' for type 'eml21:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthUomExt (792)
#endif

/* eml21__LengthPerVolumeUomExt has binding name 'eml21__LengthPerVolumeUomExt' for type 'eml21:LengthPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeUomExt (791)
#endif

/* eml21__LengthPerTimeUomExt has binding name 'eml21__LengthPerTimeUomExt' for type 'eml21:LengthPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeUomExt (790)
#endif

/* eml21__LengthPerTemperatureUomExt has binding name 'eml21__LengthPerTemperatureUomExt' for type 'eml21:LengthPerTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureUomExt (789)
#endif

/* eml21__LengthPerPressureUomExt has binding name 'eml21__LengthPerPressureUomExt' for type 'eml21:LengthPerPressureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureUomExt (788)
#endif

/* eml21__LengthPerMassUomExt has binding name 'eml21__LengthPerMassUomExt' for type 'eml21:LengthPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassUomExt (787)
#endif

/* eml21__LengthPerLengthUomExt has binding name 'eml21__LengthPerLengthUomExt' for type 'eml21:LengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthUomExt (786)
#endif

/* eml21__KinematicViscosityUomExt has binding name 'eml21__KinematicViscosityUomExt' for type 'eml21:KinematicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityUomExt (785)
#endif

/* eml21__IsothermalCompressibilityUomExt has binding name 'eml21__IsothermalCompressibilityUomExt' for type 'eml21:IsothermalCompressibilityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityUomExt (784)
#endif

/* eml21__InductanceUomExt has binding name 'eml21__InductanceUomExt' for type 'eml21:InductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceUomExt (783)
#endif

/* eml21__IlluminanceUomExt has binding name 'eml21__IlluminanceUomExt' for type 'eml21:IlluminanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceUomExt (782)
#endif

/* eml21__HeatTransferCoefficientUomExt has binding name 'eml21__HeatTransferCoefficientUomExt' for type 'eml21:HeatTransferCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientUomExt (781)
#endif

/* eml21__HeatFlowRateUomExt has binding name 'eml21__HeatFlowRateUomExt' for type 'eml21:HeatFlowRateUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateUomExt (780)
#endif

/* eml21__HeatCapacityUomExt has binding name 'eml21__HeatCapacityUomExt' for type 'eml21:HeatCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityUomExt (779)
#endif

/* eml21__FrequencyUomExt has binding name 'eml21__FrequencyUomExt' for type 'eml21:FrequencyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyUomExt (778)
#endif

/* eml21__FrequencyIntervalUomExt has binding name 'eml21__FrequencyIntervalUomExt' for type 'eml21:FrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalUomExt (777)
#endif

/* eml21__ForceUomExt has binding name 'eml21__ForceUomExt' for type 'eml21:ForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceUomExt (776)
#endif

/* eml21__ForcePerVolumeUomExt has binding name 'eml21__ForcePerVolumeUomExt' for type 'eml21:ForcePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeUomExt (775)
#endif

/* eml21__ForcePerLengthUomExt has binding name 'eml21__ForcePerLengthUomExt' for type 'eml21:ForcePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthUomExt (774)
#endif

/* eml21__ForcePerForceUomExt has binding name 'eml21__ForcePerForceUomExt' for type 'eml21:ForcePerForceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceUomExt (773)
#endif

/* eml21__ForceLengthPerLengthUomExt has binding name 'eml21__ForceLengthPerLengthUomExt' for type 'eml21:ForceLengthPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthUomExt (772)
#endif

/* eml21__ForceAreaUomExt has binding name 'eml21__ForceAreaUomExt' for type 'eml21:ForceAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaUomExt (771)
#endif

/* eml21__EnergyUomExt has binding name 'eml21__EnergyUomExt' for type 'eml21:EnergyUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyUomExt (770)
#endif

/* eml21__EnergyPerVolumeUomExt has binding name 'eml21__EnergyPerVolumeUomExt' for type 'eml21:EnergyPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeUomExt (769)
#endif

/* eml21__EnergyPerMassUomExt has binding name 'eml21__EnergyPerMassUomExt' for type 'eml21:EnergyPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassUomExt (768)
#endif

/* eml21__EnergyPerMassPerTimeUomExt has binding name 'eml21__EnergyPerMassPerTimeUomExt' for type 'eml21:EnergyPerMassPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeUomExt (767)
#endif

/* eml21__EnergyPerLengthUomExt has binding name 'eml21__EnergyPerLengthUomExt' for type 'eml21:EnergyPerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthUomExt (766)
#endif

/* eml21__EnergyPerAreaUomExt has binding name 'eml21__EnergyPerAreaUomExt' for type 'eml21:EnergyPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaUomExt (765)
#endif

/* eml21__EnergyLengthPerTimeAreaTemperatureUomExt has binding name 'eml21__EnergyLengthPerTimeAreaTemperatureUomExt' for type 'eml21:EnergyLengthPerTimeAreaTemperatureUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureUomExt (764)
#endif

/* eml21__EnergyLengthPerAreaUomExt has binding name 'eml21__EnergyLengthPerAreaUomExt' for type 'eml21:EnergyLengthPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaUomExt (763)
#endif

/* eml21__ElectromagneticMomentUomExt has binding name 'eml21__ElectromagneticMomentUomExt' for type 'eml21:ElectromagneticMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentUomExt (762)
#endif

/* eml21__ElectricResistanceUomExt has binding name 'eml21__ElectricResistanceUomExt' for type 'eml21:ElectricResistanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceUomExt (761)
#endif

/* eml21__ElectricResistancePerLengthUomExt has binding name 'eml21__ElectricResistancePerLengthUomExt' for type 'eml21:ElectricResistancePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthUomExt (760)
#endif

/* eml21__ElectricPotentialDifferenceUomExt has binding name 'eml21__ElectricPotentialDifferenceUomExt' for type 'eml21:ElectricPotentialDifferenceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceUomExt (759)
#endif

/* eml21__ElectricFieldStrengthUomExt has binding name 'eml21__ElectricFieldStrengthUomExt' for type 'eml21:ElectricFieldStrengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthUomExt (758)
#endif

/* eml21__ElectricCurrentUomExt has binding name 'eml21__ElectricCurrentUomExt' for type 'eml21:ElectricCurrentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentUomExt (757)
#endif

/* eml21__ElectricCurrentDensityUomExt has binding name 'eml21__ElectricCurrentDensityUomExt' for type 'eml21:ElectricCurrentDensityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityUomExt (756)
#endif

/* eml21__ElectricConductivityUomExt has binding name 'eml21__ElectricConductivityUomExt' for type 'eml21:ElectricConductivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityUomExt (755)
#endif

/* eml21__ElectricConductanceUomExt has binding name 'eml21__ElectricConductanceUomExt' for type 'eml21:ElectricConductanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceUomExt (754)
#endif

/* eml21__ElectricChargeUomExt has binding name 'eml21__ElectricChargeUomExt' for type 'eml21:ElectricChargeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeUomExt (753)
#endif

/* eml21__ElectricChargePerVolumeUomExt has binding name 'eml21__ElectricChargePerVolumeUomExt' for type 'eml21:ElectricChargePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeUomExt (752)
#endif

/* eml21__ElectricChargePerMassUomExt has binding name 'eml21__ElectricChargePerMassUomExt' for type 'eml21:ElectricChargePerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassUomExt (751)
#endif

/* eml21__ElectricChargePerAreaUomExt has binding name 'eml21__ElectricChargePerAreaUomExt' for type 'eml21:ElectricChargePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaUomExt (750)
#endif

/* eml21__ElectricalResistivityUomExt has binding name 'eml21__ElectricalResistivityUomExt' for type 'eml21:ElectricalResistivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityUomExt (749)
#endif

/* eml21__DynamicViscosityUomExt has binding name 'eml21__DynamicViscosityUomExt' for type 'eml21:DynamicViscosityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityUomExt (748)
#endif

/* eml21__DoseEquivalentUomExt has binding name 'eml21__DoseEquivalentUomExt' for type 'eml21:DoseEquivalentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentUomExt (747)
#endif

/* eml21__DipoleMomentUomExt has binding name 'eml21__DipoleMomentUomExt' for type 'eml21:DipoleMomentUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentUomExt (746)
#endif

/* eml21__DimensionlessUomExt has binding name 'eml21__DimensionlessUomExt' for type 'eml21:DimensionlessUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessUomExt (745)
#endif

/* eml21__DigitalStorageUomExt has binding name 'eml21__DigitalStorageUomExt' for type 'eml21:DigitalStorageUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageUomExt (744)
#endif

/* eml21__DiffusiveTimeOfFlightUomExt has binding name 'eml21__DiffusiveTimeOfFlightUomExt' for type 'eml21:DiffusiveTimeOfFlightUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightUomExt (743)
#endif

/* eml21__DiffusionCoefficientUomExt has binding name 'eml21__DiffusionCoefficientUomExt' for type 'eml21:DiffusionCoefficientUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientUomExt (742)
#endif

/* eml21__DataTransferSpeedUomExt has binding name 'eml21__DataTransferSpeedUomExt' for type 'eml21:DataTransferSpeedUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedUomExt (741)
#endif

/* eml21__CationExchangeCapacityUomExt has binding name 'eml21__CationExchangeCapacityUomExt' for type 'eml21:CationExchangeCapacityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityUomExt (740)
#endif

/* eml21__CapacitanceUomExt has binding name 'eml21__CapacitanceUomExt' for type 'eml21:CapacitanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceUomExt (739)
#endif

/* eml21__AttenuationPerFrequencyIntervalUomExt has binding name 'eml21__AttenuationPerFrequencyIntervalUomExt' for type 'eml21:AttenuationPerFrequencyIntervalUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalUomExt (738)
#endif

/* eml21__AreaUomExt has binding name 'eml21__AreaUomExt' for type 'eml21:AreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaUomExt (737)
#endif

/* eml21__AreaPerVolumeUomExt has binding name 'eml21__AreaPerVolumeUomExt' for type 'eml21:AreaPerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeUomExt (736)
#endif

/* eml21__AreaPerTimeUomExt has binding name 'eml21__AreaPerTimeUomExt' for type 'eml21:AreaPerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeUomExt (735)
#endif

/* eml21__AreaPerMassUomExt has binding name 'eml21__AreaPerMassUomExt' for type 'eml21:AreaPerMassUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassUomExt (734)
#endif

/* eml21__AreaPerCountUomExt has binding name 'eml21__AreaPerCountUomExt' for type 'eml21:AreaPerCountUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountUomExt (733)
#endif

/* eml21__AreaPerAreaUomExt has binding name 'eml21__AreaPerAreaUomExt' for type 'eml21:AreaPerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaUomExt (732)
#endif

/* eml21__AreaPerAmountOfSubstanceUomExt has binding name 'eml21__AreaPerAmountOfSubstanceUomExt' for type 'eml21:AreaPerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceUomExt (731)
#endif

/* eml21__APINeutronUomExt has binding name 'eml21__APINeutronUomExt' for type 'eml21:APINeutronUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronUomExt (730)
#endif

/* eml21__APIGravityUomExt has binding name 'eml21__APIGravityUomExt' for type 'eml21:APIGravityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityUomExt (729)
#endif

/* eml21__APIGammaRayUomExt has binding name 'eml21__APIGammaRayUomExt' for type 'eml21:APIGammaRayUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayUomExt (728)
#endif

/* eml21__AngularVelocityUomExt has binding name 'eml21__AngularVelocityUomExt' for type 'eml21:AngularVelocityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityUomExt (727)
#endif

/* eml21__AngularAccelerationUomExt has binding name 'eml21__AngularAccelerationUomExt' for type 'eml21:AngularAccelerationUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationUomExt (726)
#endif

/* eml21__AnglePerVolumeUomExt has binding name 'eml21__AnglePerVolumeUomExt' for type 'eml21:AnglePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeUomExt (725)
#endif

/* eml21__AnglePerLengthUomExt has binding name 'eml21__AnglePerLengthUomExt' for type 'eml21:AnglePerLengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthUomExt (724)
#endif

/* eml21__AmountOfSubstanceUomExt has binding name 'eml21__AmountOfSubstanceUomExt' for type 'eml21:AmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceUomExt (723)
#endif

/* eml21__AmountOfSubstancePerVolumeUomExt has binding name 'eml21__AmountOfSubstancePerVolumeUomExt' for type 'eml21:AmountOfSubstancePerVolumeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeUomExt (722)
#endif

/* eml21__AmountOfSubstancePerTimeUomExt has binding name 'eml21__AmountOfSubstancePerTimeUomExt' for type 'eml21:AmountOfSubstancePerTimeUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeUomExt (721)
#endif

/* eml21__AmountOfSubstancePerTimePerAreaUomExt has binding name 'eml21__AmountOfSubstancePerTimePerAreaUomExt' for type 'eml21:AmountOfSubstancePerTimePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaUomExt (720)
#endif

/* eml21__AmountOfSubstancePerAreaUomExt has binding name 'eml21__AmountOfSubstancePerAreaUomExt' for type 'eml21:AmountOfSubstancePerAreaUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaUomExt (719)
#endif

/* eml21__AmountOfSubstancePerAmountOfSubstanceUomExt has binding name 'eml21__AmountOfSubstancePerAmountOfSubstanceUomExt' for type 'eml21:AmountOfSubstancePerAmountOfSubstanceUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceUomExt (718)
#endif

/* eml21__ActivityOfRadioactivityUomExt has binding name 'eml21__ActivityOfRadioactivityUomExt' for type 'eml21:ActivityOfRadioactivityUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityUomExt (717)
#endif

/* eml21__AbsorbedDoseUomExt has binding name 'eml21__AbsorbedDoseUomExt' for type 'eml21:AbsorbedDoseUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUomExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseUomExt (716)
#endif

/* eml21__UnitOfMeasureExt has binding name 'eml21__UnitOfMeasureExt' for type 'eml21:UnitOfMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitOfMeasureExt (715)
#endif

/* eml21__ReferenceConditionExt has binding name 'eml21__ReferenceConditionExt' for type 'eml21:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceConditionExt (714)
#endif

/* eml21__QuantityClassKindExt has binding name 'eml21__QuantityClassKindExt' for type 'eml21:QuantityClassKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityClassKindExt (713)
#endif

/* eml21__LithologyQualifierKindExt has binding name 'eml21__LithologyQualifierKindExt' for type 'eml21:LithologyQualifierKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyQualifierKindExt (712)
#endif

/* eml21__LithologyKindExt has binding name 'eml21__LithologyKindExt' for type 'eml21:LithologyKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKindExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LithologyKindExt (711)
#endif

/* prodml2__ReportingDurationKindExt has binding name 'prodml2__ReportingDurationKindExt' for type 'prodml2:ReportingDurationKindExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKindExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReportingDurationKindExt (710)
#endif

/* prodml2__PureComponentEnumExt has binding name 'prodml2__PureComponentEnumExt' for type 'prodml2:PureComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureComponentEnumExt (709)
#endif

/* prodml2__PseudoComponentEnumExt has binding name 'prodml2__PseudoComponentEnumExt' for type 'prodml2:PseudoComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoComponentEnumExt (708)
#endif

/* prodml2__PlusComponentEnumExt has binding name 'prodml2__PlusComponentEnumExt' for type 'prodml2:PlusComponentEnumExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnumExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusComponentEnumExt (707)
#endif

/* prodml2__DasCalibrationTypeExt has binding name 'prodml2__DasCalibrationTypeExt' for type 'prodml2:DasCalibrationTypeExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationTypeExt
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationTypeExt (706)
#endif

/* gsr__SC_USCORECRS_USCOREPropertyType has binding name 'gsr__SC_USCORECRS_USCOREPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gsr__SC_USCORECRS_USCOREPropertyType (705)
#endif

/* gco__DateTime_USCOREPropertyType has binding name 'gco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__DateTime_USCOREPropertyType (704)
#endif

/* gco__CodeListValue_USCOREType has binding name 'gco__CodeListValue_USCOREType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__CodeListValue_USCOREType (703)
#endif

/* gco__Date_USCOREPropertyType has binding name 'gco__Date_USCOREPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Date_USCOREPropertyType (702)
#endif

/* gco__Real_USCOREPropertyType has binding name 'gco__Real_USCOREPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Real_USCOREPropertyType (701)
#endif

/* gco__Boolean_USCOREPropertyType has binding name 'gco__Boolean_USCOREPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__Boolean_USCOREPropertyType (700)
#endif

/* gco__CharacterString_USCOREPropertyType has binding name 'gco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gco__CharacterString_USCOREPropertyType (699)
#endif

/* gco__AbstractObject_USCOREType has binding name 'gco__AbstractObject_USCOREType' for type 'gco:AbstractObject_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gco__AbstractObject_USCOREType (698)
#endif

/* gts__TM_USCOREPrimitive_USCOREPropertyType has binding name 'gts__TM_USCOREPrimitive_USCOREPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gts__TM_USCOREPrimitive_USCOREPropertyType (697)
#endif

/* gmd__AbstractDQ_USCOREResult_USCOREType has binding name 'gmd__AbstractDQ_USCOREResult_USCOREType' for type 'gmd:AbstractDQ_Result_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREResult_USCOREType (696)
#endif

/* gmd__DQ_USCOREResult_USCOREPropertyType has binding name 'gmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREResult_USCOREPropertyType (695)
#endif

/* gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType has binding name 'gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (694)
#endif

/* gmd__CI_USCORESeries_USCOREType has binding name 'gmd__CI_USCORESeries_USCOREType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREType (693)
#endif

/* gmd__CI_USCORESeries_USCOREPropertyType has binding name 'gmd__CI_USCORESeries_USCOREPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORESeries_USCOREPropertyType (692)
#endif

/* gmd__CI_USCOREPresentationFormCode_USCOREPropertyType has binding name 'gmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (691)
#endif

/* gmd__CI_USCORERoleCode_USCOREPropertyType has binding name 'gmd__CI_USCORERoleCode_USCOREPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORERoleCode_USCOREPropertyType (690)
#endif

/* gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType has binding name 'gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (689)
#endif

/* gmd__URL_USCOREPropertyType has binding name 'gmd__URL_USCOREPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__URL_USCOREPropertyType (688)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREType has binding name 'gmd__CI_USCOREOnlineResource_USCOREType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREType (687)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREPropertyType has binding name 'gmd__CI_USCOREOnlineResource_USCOREPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (686)
#endif

/* gmd__CI_USCOREAddress_USCOREType has binding name 'gmd__CI_USCOREAddress_USCOREType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREType (685)
#endif

/* gmd__CI_USCOREAddress_USCOREPropertyType has binding name 'gmd__CI_USCOREAddress_USCOREPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREAddress_USCOREPropertyType (684)
#endif

/* gmd__CI_USCORETelephone_USCOREType has binding name 'gmd__CI_USCORETelephone_USCOREType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREType (683)
#endif

/* gmd__CI_USCORETelephone_USCOREPropertyType has binding name 'gmd__CI_USCORETelephone_USCOREPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORETelephone_USCOREPropertyType (682)
#endif

/* gmd__CI_USCOREContact_USCOREType has binding name 'gmd__CI_USCOREContact_USCOREType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREType (681)
#endif

/* gmd__CI_USCOREContact_USCOREPropertyType has binding name 'gmd__CI_USCOREContact_USCOREPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREContact_USCOREPropertyType (680)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREType has binding name 'gmd__CI_USCOREResponsibleParty_USCOREType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREType (679)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREPropertyType has binding name 'gmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (678)
#endif

/* gmd__CI_USCOREDateTypeCode_USCOREPropertyType has binding name 'gmd__CI_USCOREDateTypeCode_USCOREPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (677)
#endif

/* gmd__CI_USCOREDate_USCOREType has binding name 'gmd__CI_USCOREDate_USCOREType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREType (676)
#endif

/* gmd__CI_USCOREDate_USCOREPropertyType has binding name 'gmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCOREDate_USCOREPropertyType (675)
#endif

/* gmd__CI_USCORECitation_USCOREType has binding name 'gmd__CI_USCORECitation_USCOREType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREType (674)
#endif

/* gmd__CI_USCORECitation_USCOREPropertyType has binding name 'gmd__CI_USCORECitation_USCOREPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__CI_USCORECitation_USCOREPropertyType (673)
#endif

/* gmd__MD_USCOREIdentifier_USCOREType has binding name 'gmd__MD_USCOREIdentifier_USCOREType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREType (672)
#endif

/* gmd__MD_USCOREIdentifier_USCOREPropertyType has binding name 'gmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (671)
#endif

/* gmd__AbstractDQ_USCOREElement_USCOREType has binding name 'gmd__AbstractDQ_USCOREElement_USCOREType' for type 'gmd:AbstractDQ_Element_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREElement_USCOREType (670)
#endif

/* gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType has binding name 'gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType' for type 'gmd:AbstractDQ_PositionalAccuracy_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (669)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREType has binding name 'gmd__EX_USCOREVerticalExtent_USCOREType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREType (668)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREPropertyType has binding name 'gmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (667)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREType has binding name 'gmd__EX_USCORETemporalExtent_USCOREType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREType (666)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREPropertyType has binding name 'gmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (665)
#endif

/* gmd__AbstractEX_USCOREGeographicExtent_USCOREType has binding name 'gmd__AbstractEX_USCOREGeographicExtent_USCOREType' for type 'gmd:AbstractEX_GeographicExtent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (664)
#endif

/* gmd__EX_USCOREGeographicExtent_USCOREPropertyType has binding name 'gmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (663)
#endif

/* gmd__EX_USCOREExtent_USCOREType has binding name 'gmd__EX_USCOREExtent_USCOREType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_gmd__EX_USCOREExtent_USCOREType (662)
#endif

/* _gml__coordinateOperationAccuracy has binding name '_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_eml2_1__gml__coordinateOperationAccuracy (661)
#endif

/* _gml__SecondDefiningParameter has binding name '_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1__gml__SecondDefiningParameter (660)
#endif

/* _gml__secondDefiningParameter has binding name '_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1__gml__secondDefiningParameter (659)
#endif

/* _gml__domainOfValidity has binding name '_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_eml2_1__gml__domainOfValidity (658)
#endif

/* gml__VerticalDatumType has binding name 'gml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumType (657)
#endif

/* gml__VerticalDatumPropertyType has binding name 'gml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalDatumPropertyType (656)
#endif

/* gml__VerticalCSType has binding name 'gml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSType (655)
#endif

/* gml__VerticalCSPropertyType has binding name 'gml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCSPropertyType (654)
#endif

/* gml__VerticalCRSType has binding name 'gml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__VerticalCRSType (653)
#endif

/* gml__GeodeticCRSPropertyType has binding name 'gml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSPropertyType (652)
#endif

/* gml__CRSPropertyType has binding name 'gml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CRSPropertyType (651)
#endif

/* gml__AbstractCoordinateOperationType has binding name 'gml__AbstractCoordinateOperationType' for type 'gml:AbstractCoordinateOperationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateOperationType (650)
#endif

/* gml__AbstractGeneralConversionType has binding name 'gml__AbstractGeneralConversionType' for type 'gml:AbstractGeneralConversionType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralConversionType (649)
#endif

/* gml__GeneralConversionPropertyType has binding name 'gml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeneralConversionPropertyType (648)
#endif

/* gml__AbstractGeneralDerivedCRSType has binding name 'gml__AbstractGeneralDerivedCRSType' for type 'gml:AbstractGeneralDerivedCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGeneralDerivedCRSType (647)
#endif

/* gml__ProjectedCRSType has binding name 'gml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__ProjectedCRSType (646)
#endif

/* gml__LengthType has binding name 'gml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__LengthType
#define SOAP_TYPE_gsoap_eml2_1_gml__LengthType (645)
#endif

/* gml__EllipsoidType has binding name 'gml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidType (644)
#endif

/* gml__EllipsoidPropertyType has binding name 'gml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidPropertyType (643)
#endif

/* gml__MeasureType has binding name 'gml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__MeasureType
#define SOAP_TYPE_gsoap_eml2_1_gml__MeasureType (642)
#endif

/* gml__AngleType has binding name 'gml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AngleType
#define SOAP_TYPE_gsoap_eml2_1_gml__AngleType (641)
#endif

/* gml__PrimeMeridianType has binding name 'gml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianType (640)
#endif

/* gml__PrimeMeridianPropertyType has binding name 'gml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__PrimeMeridianPropertyType (639)
#endif

/* gml__AbstractDatumType has binding name 'gml__AbstractDatumType' for type 'gml:AbstractDatumType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractDatumType (638)
#endif

/* gml__GeodeticDatumType has binding name 'gml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumType (637)
#endif

/* gml__GeodeticDatumPropertyType has binding name 'gml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticDatumPropertyType (636)
#endif

/* gml__SphericalCSType has binding name 'gml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSType (635)
#endif

/* gml__SphericalCSPropertyType has binding name 'gml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__SphericalCSPropertyType (634)
#endif

/* gml__CartesianCSType has binding name 'gml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSType (633)
#endif

/* gml__CartesianCSPropertyType has binding name 'gml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CartesianCSPropertyType (632)
#endif

/* gml__CoordinateSystemAxisType has binding name 'gml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisType (631)
#endif

/* gml__CoordinateSystemAxisPropertyType has binding name 'gml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__CoordinateSystemAxisPropertyType (630)
#endif

/* gml__AbstractCoordinateSystemType has binding name 'gml__AbstractCoordinateSystemType' for type 'gml:AbstractCoordinateSystemType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCoordinateSystemType (629)
#endif

/* gml__EllipsoidalCSType has binding name 'gml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSType (628)
#endif

/* gml__EllipsoidalCSPropertyType has binding name 'gml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__EllipsoidalCSPropertyType (627)
#endif

/* gml__TimePrimitivePropertyType has binding name 'gml__TimePrimitivePropertyType' for type 'gml:TimePrimitivePropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_eml2_1_gml__TimePrimitivePropertyType (626)
#endif

/* gml__RelatedTimeType has binding name 'gml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_eml2_1_gml__RelatedTimeType (625)
#endif

/* gml__AbstractTimeObjectType has binding name 'gml__AbstractTimeObjectType' for type 'gml:AbstractTimeObjectType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimeObjectType (624)
#endif

/* gml__AbstractTimePrimitiveType has binding name 'gml__AbstractTimePrimitiveType' for type 'gml:AbstractTimePrimitiveType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractTimePrimitiveType (623)
#endif

/* gml__CodeType has binding name 'gml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CodeType
#define SOAP_TYPE_gsoap_eml2_1_gml__CodeType (622)
#endif

/* gml__CodeWithAuthorityType has binding name 'gml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_eml2_1_gml__CodeWithAuthorityType (621)
#endif

/* gml__ReferenceType has binding name 'gml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_eml2_1_gml__ReferenceType (620)
#endif

/* gml__StringOrRefType has binding name 'gml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_eml2_1_gml__StringOrRefType (619)
#endif

/* gml__AbstractGMLType has binding name 'gml__AbstractGMLType' for type 'gml:AbstractGMLType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractGMLType (618)
#endif

/* gml__DefinitionBaseType has binding name 'gml__DefinitionBaseType' for type 'gml:DefinitionBaseType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_eml2_1_gml__DefinitionBaseType (617)
#endif

/* gml__DefinitionType has binding name 'gml__DefinitionType' for type 'gml:DefinitionType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_eml2_1_gml__DefinitionType (616)
#endif

/* gml__IdentifiedObjectType has binding name 'gml__IdentifiedObjectType' for type 'gml:IdentifiedObjectType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_eml2_1_gml__IdentifiedObjectType (615)
#endif

/* gml__AbstractCRSType has binding name 'gml__AbstractCRSType' for type 'gml:AbstractCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__AbstractCRSType (614)
#endif

/* gml__GeodeticCRSType has binding name 'gml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_eml2_1_gml__GeodeticCRSType (613)
#endif

/* eml21__GraphicalInformationSet has binding name 'eml21__GraphicalInformationSet' for type 'eml21:GraphicalInformationSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet
#define SOAP_TYPE_gsoap_eml2_1_eml21__GraphicalInformationSet (612)
#endif

/* eml21__AbstractGraphicalInformation has binding name 'eml21__AbstractGraphicalInformation' for type 'eml21:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGraphicalInformation (611)
#endif

/* eml21__IndexRange has binding name 'eml21__IndexRange' for type 'eml21:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange
#define SOAP_TYPE_gsoap_eml2_1_eml21__IndexRange (610)
#endif

/* eml21__FailingRule has binding name 'eml21__FailingRule' for type 'eml21:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule
#define SOAP_TYPE_gsoap_eml2_1_eml21__FailingRule (609)
#endif

/* eml21__DataAssuranceRecord has binding name 'eml21__DataAssuranceRecord' for type 'eml21:DataAssuranceRecord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataAssuranceRecord (608)
#endif

/* eml21__VerticalWktCrs has binding name 'eml21__VerticalWktCrs' for type 'eml21:VerticalWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalWktCrs (607)
#endif

/* eml21__VerticalUnknownCrs has binding name 'eml21__VerticalUnknownCrs' for type 'eml21:VerticalUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalUnknownCrs (606)
#endif

/* eml21__VerticalLocalAuthorityCrs has binding name 'eml21__VerticalLocalAuthorityCrs' for type 'eml21:VerticalLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalLocalAuthorityCrs (605)
#endif

/* eml21__VerticalGmlCrs has binding name 'eml21__VerticalGmlCrs' for type 'eml21:VerticalGmlCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalGmlCrs (604)
#endif

/* eml21__VerticalEpsgCrs has binding name 'eml21__VerticalEpsgCrs' for type 'eml21:VerticalEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalEpsgCrs (603)
#endif

/* eml21__VerticalCrs has binding name 'eml21__VerticalCrs' for type 'eml21:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCrs (602)
#endif

/* eml21__ProjectedWktCrs has binding name 'eml21__ProjectedWktCrs' for type 'eml21:ProjectedWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedWktCrs (601)
#endif

/* eml21__ProjectedUnknownCrs has binding name 'eml21__ProjectedUnknownCrs' for type 'eml21:ProjectedUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedUnknownCrs (600)
#endif

/* eml21__ProjectedLocalAuthorityCrs has binding name 'eml21__ProjectedLocalAuthorityCrs' for type 'eml21:ProjectedLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedLocalAuthorityCrs (599)
#endif

/* eml21__ProjectedGmlCrs has binding name 'eml21__ProjectedGmlCrs' for type 'eml21:ProjectedGmlCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedGmlCrs (598)
#endif

/* eml21__ProjectedEpsgCrs has binding name 'eml21__ProjectedEpsgCrs' for type 'eml21:ProjectedEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedEpsgCrs (597)
#endif

/* eml21__ProjectedCrs has binding name 'eml21__ProjectedCrs' for type 'eml21:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__ProjectedCrs (596)
#endif

/* eml21__GeodeticWktCrs has binding name 'eml21__GeodeticWktCrs' for type 'eml21:GeodeticWktCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticWktCrs (595)
#endif

/* eml21__GeodeticUnknownCrs has binding name 'eml21__GeodeticUnknownCrs' for type 'eml21:GeodeticUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticUnknownCrs (594)
#endif

/* eml21__GeodeticLocalAuthorityCrs has binding name 'eml21__GeodeticLocalAuthorityCrs' for type 'eml21:GeodeticLocalAuthorityCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticLocalAuthorityCrs (593)
#endif

/* eml21__GeodeticGmlCrs has binding name 'eml21__GeodeticGmlCrs' for type 'eml21:GeodeticGmlCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticGmlCrs (592)
#endif

/* eml21__GeodeticEpsgCrs has binding name 'eml21__GeodeticEpsgCrs' for type 'eml21:GeodeticEpsgCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticEpsgCrs (591)
#endif

/* eml21__GeodeticCrs has binding name 'eml21__GeodeticCrs' for type 'eml21:GeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeodeticCrs (590)
#endif

/* eml21__AbstractVerticalCrs has binding name 'eml21__AbstractVerticalCrs' for type 'eml21:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractVerticalCrs (589)
#endif

/* eml21__AbstractProjectedCrs has binding name 'eml21__AbstractProjectedCrs' for type 'eml21:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractProjectedCrs (588)
#endif

/* eml21__AbstractGeodeticCrs has binding name 'eml21__AbstractGeodeticCrs' for type 'eml21:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractGeodeticCrs (587)
#endif

/* eml21__VolumeValue has binding name 'eml21__VolumeValue' for type 'eml21:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeValue (586)
#endif

/* eml21__TemperaturePressure has binding name 'eml21__TemperaturePressure' for type 'eml21:TemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperaturePressure (585)
#endif

/* eml21__RelativePressure has binding name 'eml21__RelativePressure' for type 'eml21:RelativePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RelativePressure (584)
#endif

/* eml21__ReferenceTemperaturePressure has binding name 'eml21__ReferenceTemperaturePressure' for type 'eml21:ReferenceTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferenceTemperaturePressure (583)
#endif

/* eml21__ReferencePressure has binding name 'eml21__ReferencePressure' for type 'eml21:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReferencePressure (582)
#endif

/* eml21__PressureValue has binding name 'eml21__PressureValue' for type 'eml21:PressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureValue (581)
#endif

/* eml21__GaugePressure has binding name 'eml21__GaugePressure' for type 'eml21:GaugePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__GaugePressure (580)
#endif

/* eml21__FlowRateValue has binding name 'eml21__FlowRateValue' for type 'eml21:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__FlowRateValue (579)
#endif

/* eml21__DensityValue has binding name 'eml21__DensityValue' for type 'eml21:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__DensityValue (578)
#endif

/* eml21__AbstractTemperaturePressure has binding name 'eml21__AbstractTemperaturePressure' for type 'eml21:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractTemperaturePressure (577)
#endif

/* eml21__AbstractPressureValue has binding name 'eml21__AbstractPressureValue' for type 'eml21:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractPressureValue (576)
#endif

/* eml21__AbsolutePressure has binding name 'eml21__AbsolutePressure' for type 'eml21:AbsolutePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsolutePressure (575)
#endif

/* eml21__TimeSeriesParentage has binding name 'eml21__TimeSeriesParentage' for type 'eml21:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeriesParentage (574)
#endif

/* eml21__TimeSeries has binding name 'eml21__TimeSeries' for type 'eml21:TimeSeries' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeSeries (573)
#endif

/* eml21__TimeIndices has binding name 'eml21__TimeIndices' for type 'eml21:TimeIndices' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndices (572)
#endif

/* eml21__TimeIndex has binding name 'eml21__TimeIndex' for type 'eml21:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndex (571)
#endif

/* eml21__PropertyKindDictionary has binding name 'eml21__PropertyKindDictionary' for type 'eml21:PropertyKindDictionary' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary
#define SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKindDictionary (570)
#endif

/* eml21__PropertyKind has binding name 'eml21__PropertyKind' for type 'eml21:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1_eml21__PropertyKind (569)
#endif

/* eml21__GeologicTime has binding name 'eml21__GeologicTime' for type 'eml21:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime
#define SOAP_TYPE_gsoap_eml2_1_eml21__GeologicTime (568)
#endif

/* eml21__TimeIndexParameterKey has binding name 'eml21__TimeIndexParameterKey' for type 'eml21:TimeIndexParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameterKey (567)
#endif

/* eml21__TimeIndexParameter has binding name 'eml21__TimeIndexParameter' for type 'eml21:TimeIndexParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeIndexParameter (566)
#endif

/* eml21__StringParameter has binding name 'eml21__StringParameter' for type 'eml21:StringParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringParameter (565)
#endif

/* eml21__ParameterTemplate has binding name 'eml21__ParameterTemplate' for type 'eml21:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_1_eml21__ParameterTemplate (564)
#endif

/* eml21__ObjectParameterKey has binding name 'eml21__ObjectParameterKey' for type 'eml21:ObjectParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__ObjectParameterKey (563)
#endif

/* eml21__IntegerQuantityParameter has binding name 'eml21__IntegerQuantityParameter' for type 'eml21:IntegerQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerQuantityParameter (562)
#endif

/* eml21__DoubleQuantityParameter has binding name 'eml21__DoubleQuantityParameter' for type 'eml21:DoubleQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoubleQuantityParameter (561)
#endif

/* eml21__DataObjectParameter has binding name 'eml21__DataObjectParameter' for type 'eml21:DataObjectParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectParameter (560)
#endif

/* eml21__ActivityTemplate has binding name 'eml21__ActivityTemplate' for type 'eml21:ActivityTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityTemplate (559)
#endif

/* eml21__Activity has binding name 'eml21__Activity' for type 'eml21:Activity' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__Activity
#define SOAP_TYPE_gsoap_eml2_1_eml21__Activity (558)
#endif

/* eml21__AbstractParameterKey has binding name 'eml21__AbstractParameterKey' for type 'eml21:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractParameterKey (557)
#endif

/* eml21__AbstractActivityParameter has binding name 'eml21__AbstractActivityParameter' for type 'eml21:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractActivityParameter (556)
#endif

/* eml21__ExternalDatasetPart has binding name 'eml21__ExternalDatasetPart' for type 'eml21:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDatasetPart (555)
#endif

/* eml21__ExternalDataset has binding name 'eml21__ExternalDataset' for type 'eml21:ExternalDataset' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExternalDataset (554)
#endif

/* eml21__EpcExternalPartReference has binding name 'eml21__EpcExternalPartReference' for type 'eml21:EpcExternalPartReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__EpcExternalPartReference (553)
#endif

/* eml21__DataObjectReference has binding name 'eml21__DataObjectReference' for type 'eml21:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataObjectReference (552)
#endif

/* eml21__VolumetricThermalExpansionMeasureExt has binding name 'eml21__VolumetricThermalExpansionMeasureExt' for type 'eml21:VolumetricThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasureExt (551)
#endif

/* eml21__VolumetricThermalExpansionMeasure has binding name 'eml21__VolumetricThermalExpansionMeasure' for type 'eml21:VolumetricThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricThermalExpansionMeasure (550)
#endif

/* eml21__VolumetricHeatTransferCoefficientMeasureExt has binding name 'eml21__VolumetricHeatTransferCoefficientMeasureExt' for type 'eml21:VolumetricHeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasureExt (549)
#endif

/* eml21__VolumetricHeatTransferCoefficientMeasure has binding name 'eml21__VolumetricHeatTransferCoefficientMeasure' for type 'eml21:VolumetricHeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumetricHeatTransferCoefficientMeasure (548)
#endif

/* eml21__VolumePerVolumeMeasureExt has binding name 'eml21__VolumePerVolumeMeasureExt' for type 'eml21:VolumePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasureExt (547)
#endif

/* eml21__VolumePerVolumeMeasure has binding name 'eml21__VolumePerVolumeMeasure' for type 'eml21:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerVolumeMeasure (546)
#endif

/* eml21__VolumePerTimePerVolumeMeasureExt has binding name 'eml21__VolumePerTimePerVolumeMeasureExt' for type 'eml21:VolumePerTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasureExt (545)
#endif

/* eml21__VolumePerTimePerVolumeMeasure has binding name 'eml21__VolumePerTimePerVolumeMeasure' for type 'eml21:VolumePerTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerVolumeMeasure (544)
#endif

/* eml21__VolumePerTimePerTimeMeasureExt has binding name 'eml21__VolumePerTimePerTimeMeasureExt' for type 'eml21:VolumePerTimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasureExt (543)
#endif

/* eml21__VolumePerTimePerTimeMeasure has binding name 'eml21__VolumePerTimePerTimeMeasure' for type 'eml21:VolumePerTimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerTimeMeasure (542)
#endif

/* eml21__VolumePerTimePerPressureMeasureExt has binding name 'eml21__VolumePerTimePerPressureMeasureExt' for type 'eml21:VolumePerTimePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasureExt (541)
#endif

/* eml21__VolumePerTimePerPressureMeasure has binding name 'eml21__VolumePerTimePerPressureMeasure' for type 'eml21:VolumePerTimePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureMeasure (540)
#endif

/* eml21__VolumePerTimePerPressureLengthMeasureExt has binding name 'eml21__VolumePerTimePerPressureLengthMeasureExt' for type 'eml21:VolumePerTimePerPressureLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasureExt (539)
#endif

/* eml21__VolumePerTimePerPressureLengthMeasure has binding name 'eml21__VolumePerTimePerPressureLengthMeasure' for type 'eml21:VolumePerTimePerPressureLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerPressureLengthMeasure (538)
#endif

/* eml21__VolumePerTimePerLengthMeasureExt has binding name 'eml21__VolumePerTimePerLengthMeasureExt' for type 'eml21:VolumePerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasureExt (537)
#endif

/* eml21__VolumePerTimePerLengthMeasure has binding name 'eml21__VolumePerTimePerLengthMeasure' for type 'eml21:VolumePerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerLengthMeasure (536)
#endif

/* eml21__VolumePerTimePerAreaMeasureExt has binding name 'eml21__VolumePerTimePerAreaMeasureExt' for type 'eml21:VolumePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasureExt (535)
#endif

/* eml21__VolumePerTimePerAreaMeasure has binding name 'eml21__VolumePerTimePerAreaMeasure' for type 'eml21:VolumePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimePerAreaMeasure (534)
#endif

/* eml21__VolumePerTimeMeasureExt has binding name 'eml21__VolumePerTimeMeasureExt' for type 'eml21:VolumePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasureExt (533)
#endif

/* eml21__VolumePerTimeMeasure has binding name 'eml21__VolumePerTimeMeasure' for type 'eml21:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeMeasure (532)
#endif

/* eml21__VolumePerTimeLengthMeasureExt has binding name 'eml21__VolumePerTimeLengthMeasureExt' for type 'eml21:VolumePerTimeLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasureExt (531)
#endif

/* eml21__VolumePerTimeLengthMeasure has binding name 'eml21__VolumePerTimeLengthMeasure' for type 'eml21:VolumePerTimeLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerTimeLengthMeasure (530)
#endif

/* eml21__VolumePerRotationMeasureExt has binding name 'eml21__VolumePerRotationMeasureExt' for type 'eml21:VolumePerRotationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasureExt (529)
#endif

/* eml21__VolumePerRotationMeasure has binding name 'eml21__VolumePerRotationMeasure' for type 'eml21:VolumePerRotationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerRotationMeasure (528)
#endif

/* eml21__VolumePerPressureMeasureExt has binding name 'eml21__VolumePerPressureMeasureExt' for type 'eml21:VolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasureExt (527)
#endif

/* eml21__VolumePerPressureMeasure has binding name 'eml21__VolumePerPressureMeasure' for type 'eml21:VolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerPressureMeasure (526)
#endif

/* eml21__VolumePerMassMeasureExt has binding name 'eml21__VolumePerMassMeasureExt' for type 'eml21:VolumePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasureExt (525)
#endif

/* eml21__VolumePerMassMeasure has binding name 'eml21__VolumePerMassMeasure' for type 'eml21:VolumePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerMassMeasure (524)
#endif

/* eml21__VolumePerLengthMeasureExt has binding name 'eml21__VolumePerLengthMeasureExt' for type 'eml21:VolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasureExt (523)
#endif

/* eml21__VolumePerLengthMeasure has binding name 'eml21__VolumePerLengthMeasure' for type 'eml21:VolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerLengthMeasure (522)
#endif

/* eml21__VolumePerAreaMeasureExt has binding name 'eml21__VolumePerAreaMeasureExt' for type 'eml21:VolumePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasureExt (521)
#endif

/* eml21__VolumePerAreaMeasure has binding name 'eml21__VolumePerAreaMeasure' for type 'eml21:VolumePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumePerAreaMeasure (520)
#endif

/* eml21__VolumeMeasureExt has binding name 'eml21__VolumeMeasureExt' for type 'eml21:VolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasureExt (519)
#endif

/* eml21__VolumeMeasure has binding name 'eml21__VolumeMeasure' for type 'eml21:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeMeasure (518)
#endif

/* eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt has binding name 'eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt' for type 'eml21:VolumeFlowRatePerVolumeFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasureExt (517)
#endif

/* eml21__VolumeFlowRatePerVolumeFlowRateMeasure has binding name 'eml21__VolumeFlowRatePerVolumeFlowRateMeasure' for type 'eml21:VolumeFlowRatePerVolumeFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VolumeFlowRatePerVolumeFlowRateMeasure (516)
#endif

/* eml21__VerticalCoordinateMeasureExt has binding name 'eml21__VerticalCoordinateMeasureExt' for type 'eml21:VerticalCoordinateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasureExt (515)
#endif

/* eml21__VerticalCoordinateMeasure has binding name 'eml21__VerticalCoordinateMeasure' for type 'eml21:VerticalCoordinateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__VerticalCoordinateMeasure (514)
#endif

/* eml21__UnitlessMeasure has binding name 'eml21__UnitlessMeasure' for type 'eml21:UnitlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__UnitlessMeasure (513)
#endif

/* eml21__TimePerVolumeMeasureExt has binding name 'eml21__TimePerVolumeMeasureExt' for type 'eml21:TimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasureExt (512)
#endif

/* eml21__TimePerVolumeMeasure has binding name 'eml21__TimePerVolumeMeasure' for type 'eml21:TimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerVolumeMeasure (511)
#endif

/* eml21__TimePerTimeMeasureExt has binding name 'eml21__TimePerTimeMeasureExt' for type 'eml21:TimePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasureExt (510)
#endif

/* eml21__TimePerTimeMeasure has binding name 'eml21__TimePerTimeMeasure' for type 'eml21:TimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerTimeMeasure (509)
#endif

/* eml21__TimePerMassMeasureExt has binding name 'eml21__TimePerMassMeasureExt' for type 'eml21:TimePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasureExt (508)
#endif

/* eml21__TimePerMassMeasure has binding name 'eml21__TimePerMassMeasure' for type 'eml21:TimePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerMassMeasure (507)
#endif

/* eml21__TimePerLengthMeasureExt has binding name 'eml21__TimePerLengthMeasureExt' for type 'eml21:TimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasureExt (506)
#endif

/* eml21__TimePerLengthMeasure has binding name 'eml21__TimePerLengthMeasure' for type 'eml21:TimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimePerLengthMeasure (505)
#endif

/* eml21__TimeMeasureExt has binding name 'eml21__TimeMeasureExt' for type 'eml21:TimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasureExt (504)
#endif

/* eml21__TimeMeasure has binding name 'eml21__TimeMeasure' for type 'eml21:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TimeMeasure (503)
#endif

/* eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt has binding name 'eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' for type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasureExt (502)
#endif

/* eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure has binding name 'eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' for type 'eml21:ThermodynamicTemperaturePerThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperaturePerThermodynamicTemperatureMeasure (501)
#endif

/* eml21__ThermodynamicTemperatureMeasureExt has binding name 'eml21__ThermodynamicTemperatureMeasureExt' for type 'eml21:ThermodynamicTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasureExt (500)
#endif

/* eml21__ThermodynamicTemperatureMeasure has binding name 'eml21__ThermodynamicTemperatureMeasure' for type 'eml21:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermodynamicTemperatureMeasure (499)
#endif

/* eml21__ThermalResistanceMeasureExt has binding name 'eml21__ThermalResistanceMeasureExt' for type 'eml21:ThermalResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasureExt (498)
#endif

/* eml21__ThermalResistanceMeasure has binding name 'eml21__ThermalResistanceMeasure' for type 'eml21:ThermalResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalResistanceMeasure (497)
#endif

/* eml21__ThermalInsulanceMeasureExt has binding name 'eml21__ThermalInsulanceMeasureExt' for type 'eml21:ThermalInsulanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasureExt (496)
#endif

/* eml21__ThermalInsulanceMeasure has binding name 'eml21__ThermalInsulanceMeasure' for type 'eml21:ThermalInsulanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalInsulanceMeasure (495)
#endif

/* eml21__ThermalDiffusivityMeasureExt has binding name 'eml21__ThermalDiffusivityMeasureExt' for type 'eml21:ThermalDiffusivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasureExt (494)
#endif

/* eml21__ThermalDiffusivityMeasure has binding name 'eml21__ThermalDiffusivityMeasure' for type 'eml21:ThermalDiffusivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalDiffusivityMeasure (493)
#endif

/* eml21__ThermalConductivityMeasureExt has binding name 'eml21__ThermalConductivityMeasureExt' for type 'eml21:ThermalConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasureExt (492)
#endif

/* eml21__ThermalConductivityMeasure has binding name 'eml21__ThermalConductivityMeasure' for type 'eml21:ThermalConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductivityMeasure (491)
#endif

/* eml21__ThermalConductanceMeasureExt has binding name 'eml21__ThermalConductanceMeasureExt' for type 'eml21:ThermalConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasureExt (490)
#endif

/* eml21__ThermalConductanceMeasure has binding name 'eml21__ThermalConductanceMeasure' for type 'eml21:ThermalConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ThermalConductanceMeasure (489)
#endif

/* eml21__TemperatureIntervalPerTimeMeasureExt has binding name 'eml21__TemperatureIntervalPerTimeMeasureExt' for type 'eml21:TemperatureIntervalPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasureExt (488)
#endif

/* eml21__TemperatureIntervalPerTimeMeasure has binding name 'eml21__TemperatureIntervalPerTimeMeasure' for type 'eml21:TemperatureIntervalPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerTimeMeasure (487)
#endif

/* eml21__TemperatureIntervalPerPressureMeasureExt has binding name 'eml21__TemperatureIntervalPerPressureMeasureExt' for type 'eml21:TemperatureIntervalPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasureExt (486)
#endif

/* eml21__TemperatureIntervalPerPressureMeasure has binding name 'eml21__TemperatureIntervalPerPressureMeasure' for type 'eml21:TemperatureIntervalPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerPressureMeasure (485)
#endif

/* eml21__TemperatureIntervalPerLengthMeasureExt has binding name 'eml21__TemperatureIntervalPerLengthMeasureExt' for type 'eml21:TemperatureIntervalPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasureExt (484)
#endif

/* eml21__TemperatureIntervalPerLengthMeasure has binding name 'eml21__TemperatureIntervalPerLengthMeasure' for type 'eml21:TemperatureIntervalPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalPerLengthMeasure (483)
#endif

/* eml21__TemperatureIntervalMeasureExt has binding name 'eml21__TemperatureIntervalMeasureExt' for type 'eml21:TemperatureIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasureExt (482)
#endif

/* eml21__TemperatureIntervalMeasure has binding name 'eml21__TemperatureIntervalMeasure' for type 'eml21:TemperatureIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__TemperatureIntervalMeasure (481)
#endif

/* eml21__SpecificHeatCapacityMeasureExt has binding name 'eml21__SpecificHeatCapacityMeasureExt' for type 'eml21:SpecificHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasureExt (480)
#endif

/* eml21__SpecificHeatCapacityMeasure has binding name 'eml21__SpecificHeatCapacityMeasure' for type 'eml21:SpecificHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SpecificHeatCapacityMeasure (479)
#endif

/* eml21__SolidAngleMeasureExt has binding name 'eml21__SolidAngleMeasureExt' for type 'eml21:SolidAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasureExt (478)
#endif

/* eml21__SolidAngleMeasure has binding name 'eml21__SolidAngleMeasure' for type 'eml21:SolidAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SolidAngleMeasure (477)
#endif

/* eml21__SignalingEventPerTimeMeasureExt has binding name 'eml21__SignalingEventPerTimeMeasureExt' for type 'eml21:SignalingEventPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasureExt (476)
#endif

/* eml21__SignalingEventPerTimeMeasure has binding name 'eml21__SignalingEventPerTimeMeasure' for type 'eml21:SignalingEventPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SignalingEventPerTimeMeasure (475)
#endif

/* eml21__SecondMomentOfAreaMeasureExt has binding name 'eml21__SecondMomentOfAreaMeasureExt' for type 'eml21:SecondMomentOfAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasureExt (474)
#endif

/* eml21__SecondMomentOfAreaMeasure has binding name 'eml21__SecondMomentOfAreaMeasure' for type 'eml21:SecondMomentOfAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__SecondMomentOfAreaMeasure (473)
#endif

/* eml21__ReluctanceMeasureExt has binding name 'eml21__ReluctanceMeasureExt' for type 'eml21:ReluctanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasureExt (472)
#endif

/* eml21__ReluctanceMeasure has binding name 'eml21__ReluctanceMeasure' for type 'eml21:ReluctanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReluctanceMeasure (471)
#endif

/* eml21__ReciprocalVolumeMeasureExt has binding name 'eml21__ReciprocalVolumeMeasureExt' for type 'eml21:ReciprocalVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasureExt (470)
#endif

/* eml21__ReciprocalVolumeMeasure has binding name 'eml21__ReciprocalVolumeMeasure' for type 'eml21:ReciprocalVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalVolumeMeasure (469)
#endif

/* eml21__ReciprocalTimeMeasureExt has binding name 'eml21__ReciprocalTimeMeasureExt' for type 'eml21:ReciprocalTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasureExt (468)
#endif

/* eml21__ReciprocalTimeMeasure has binding name 'eml21__ReciprocalTimeMeasure' for type 'eml21:ReciprocalTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalTimeMeasure (467)
#endif

/* eml21__ReciprocalPressureMeasureExt has binding name 'eml21__ReciprocalPressureMeasureExt' for type 'eml21:ReciprocalPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasureExt (466)
#endif

/* eml21__ReciprocalPressureMeasure has binding name 'eml21__ReciprocalPressureMeasure' for type 'eml21:ReciprocalPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalPressureMeasure (465)
#endif

/* eml21__ReciprocalMassTimeMeasureExt has binding name 'eml21__ReciprocalMassTimeMeasureExt' for type 'eml21:ReciprocalMassTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasureExt (464)
#endif

/* eml21__ReciprocalMassTimeMeasure has binding name 'eml21__ReciprocalMassTimeMeasure' for type 'eml21:ReciprocalMassTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassTimeMeasure (463)
#endif

/* eml21__ReciprocalMassMeasureExt has binding name 'eml21__ReciprocalMassMeasureExt' for type 'eml21:ReciprocalMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasureExt (462)
#endif

/* eml21__ReciprocalMassMeasure has binding name 'eml21__ReciprocalMassMeasure' for type 'eml21:ReciprocalMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalMassMeasure (461)
#endif

/* eml21__ReciprocalLengthMeasureExt has binding name 'eml21__ReciprocalLengthMeasureExt' for type 'eml21:ReciprocalLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasureExt (460)
#endif

/* eml21__ReciprocalLengthMeasure has binding name 'eml21__ReciprocalLengthMeasure' for type 'eml21:ReciprocalLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalLengthMeasure (459)
#endif

/* eml21__ReciprocalForceMeasureExt has binding name 'eml21__ReciprocalForceMeasureExt' for type 'eml21:ReciprocalForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasureExt (458)
#endif

/* eml21__ReciprocalForceMeasure has binding name 'eml21__ReciprocalForceMeasure' for type 'eml21:ReciprocalForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalForceMeasure (457)
#endif

/* eml21__ReciprocalElectricPotentialDifferenceMeasureExt has binding name 'eml21__ReciprocalElectricPotentialDifferenceMeasureExt' for type 'eml21:ReciprocalElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasureExt (456)
#endif

/* eml21__ReciprocalElectricPotentialDifferenceMeasure has binding name 'eml21__ReciprocalElectricPotentialDifferenceMeasure' for type 'eml21:ReciprocalElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalElectricPotentialDifferenceMeasure (455)
#endif

/* eml21__ReciprocalAreaMeasureExt has binding name 'eml21__ReciprocalAreaMeasureExt' for type 'eml21:ReciprocalAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasureExt (454)
#endif

/* eml21__ReciprocalAreaMeasure has binding name 'eml21__ReciprocalAreaMeasure' for type 'eml21:ReciprocalAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ReciprocalAreaMeasure (453)
#endif

/* eml21__RadiantIntensityMeasureExt has binding name 'eml21__RadiantIntensityMeasureExt' for type 'eml21:RadiantIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasureExt (452)
#endif

/* eml21__RadiantIntensityMeasure has binding name 'eml21__RadiantIntensityMeasure' for type 'eml21:RadiantIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadiantIntensityMeasure (451)
#endif

/* eml21__RadianceMeasureExt has binding name 'eml21__RadianceMeasureExt' for type 'eml21:RadianceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasureExt (450)
#endif

/* eml21__RadianceMeasure has binding name 'eml21__RadianceMeasure' for type 'eml21:RadianceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__RadianceMeasure (449)
#endif

/* eml21__QuantityOfLightMeasureExt has binding name 'eml21__QuantityOfLightMeasureExt' for type 'eml21:QuantityOfLightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasureExt (448)
#endif

/* eml21__QuantityOfLightMeasure has binding name 'eml21__QuantityOfLightMeasure' for type 'eml21:QuantityOfLightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__QuantityOfLightMeasure (447)
#endif

/* eml21__PressureTimePerVolumeMeasureExt has binding name 'eml21__PressureTimePerVolumeMeasureExt' for type 'eml21:PressureTimePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasureExt (446)
#endif

/* eml21__PressureTimePerVolumeMeasure has binding name 'eml21__PressureTimePerVolumeMeasure' for type 'eml21:PressureTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureTimePerVolumeMeasure (445)
#endif

/* eml21__PressureSquaredPerForceTimePerAreaMeasureExt has binding name 'eml21__PressureSquaredPerForceTimePerAreaMeasureExt' for type 'eml21:PressureSquaredPerForceTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasureExt (444)
#endif

/* eml21__PressureSquaredPerForceTimePerAreaMeasure has binding name 'eml21__PressureSquaredPerForceTimePerAreaMeasure' for type 'eml21:PressureSquaredPerForceTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredPerForceTimePerAreaMeasure (443)
#endif

/* eml21__PressureSquaredMeasureExt has binding name 'eml21__PressureSquaredMeasureExt' for type 'eml21:PressureSquaredMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasureExt (442)
#endif

/* eml21__PressureSquaredMeasure has binding name 'eml21__PressureSquaredMeasure' for type 'eml21:PressureSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureSquaredMeasure (441)
#endif

/* eml21__PressurePerVolumeMeasureExt has binding name 'eml21__PressurePerVolumeMeasureExt' for type 'eml21:PressurePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasureExt (440)
#endif

/* eml21__PressurePerVolumeMeasure has binding name 'eml21__PressurePerVolumeMeasure' for type 'eml21:PressurePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerVolumeMeasure (439)
#endif

/* eml21__PressurePerTimeMeasureExt has binding name 'eml21__PressurePerTimeMeasureExt' for type 'eml21:PressurePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasureExt (438)
#endif

/* eml21__PressurePerTimeMeasure has binding name 'eml21__PressurePerTimeMeasure' for type 'eml21:PressurePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerTimeMeasure (437)
#endif

/* eml21__PressurePerPressureMeasureExt has binding name 'eml21__PressurePerPressureMeasureExt' for type 'eml21:PressurePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasureExt (436)
#endif

/* eml21__PressurePerPressureMeasure has binding name 'eml21__PressurePerPressureMeasure' for type 'eml21:PressurePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressurePerPressureMeasure (435)
#endif

/* eml21__PressureMeasureExt has binding name 'eml21__PressureMeasureExt' for type 'eml21:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasureExt (434)
#endif

/* eml21__PressureMeasure has binding name 'eml21__PressureMeasure' for type 'eml21:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PressureMeasure (433)
#endif

/* eml21__PowerPerVolumeMeasureExt has binding name 'eml21__PowerPerVolumeMeasureExt' for type 'eml21:PowerPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasureExt (432)
#endif

/* eml21__PowerPerVolumeMeasure has binding name 'eml21__PowerPerVolumeMeasure' for type 'eml21:PowerPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerVolumeMeasure (431)
#endif

/* eml21__PowerPerPowerMeasureExt has binding name 'eml21__PowerPerPowerMeasureExt' for type 'eml21:PowerPerPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasureExt (430)
#endif

/* eml21__PowerPerPowerMeasure has binding name 'eml21__PowerPerPowerMeasure' for type 'eml21:PowerPerPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerPowerMeasure (429)
#endif

/* eml21__PowerPerAreaMeasureExt has binding name 'eml21__PowerPerAreaMeasureExt' for type 'eml21:PowerPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasureExt (428)
#endif

/* eml21__PowerPerAreaMeasure has binding name 'eml21__PowerPerAreaMeasure' for type 'eml21:PowerPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerPerAreaMeasure (427)
#endif

/* eml21__PowerMeasureExt has binding name 'eml21__PowerMeasureExt' for type 'eml21:PowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasureExt (426)
#endif

/* eml21__PowerMeasure has binding name 'eml21__PowerMeasure' for type 'eml21:PowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PowerMeasure (425)
#endif

/* eml21__PotentialDifferencePerPowerDropMeasureExt has binding name 'eml21__PotentialDifferencePerPowerDropMeasureExt' for type 'eml21:PotentialDifferencePerPowerDropMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasureExt (424)
#endif

/* eml21__PotentialDifferencePerPowerDropMeasure has binding name 'eml21__PotentialDifferencePerPowerDropMeasure' for type 'eml21:PotentialDifferencePerPowerDropMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PotentialDifferencePerPowerDropMeasure (423)
#endif

/* eml21__PlaneAngleMeasureExt has binding name 'eml21__PlaneAngleMeasureExt' for type 'eml21:PlaneAngleMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasureExt (422)
#endif

/* eml21__PlaneAngleMeasure has binding name 'eml21__PlaneAngleMeasure' for type 'eml21:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PlaneAngleMeasure (421)
#endif

/* eml21__PermittivityMeasureExt has binding name 'eml21__PermittivityMeasureExt' for type 'eml21:PermittivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasureExt (420)
#endif

/* eml21__PermittivityMeasure has binding name 'eml21__PermittivityMeasure' for type 'eml21:PermittivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermittivityMeasure (419)
#endif

/* eml21__PermeabilityRockMeasureExt has binding name 'eml21__PermeabilityRockMeasureExt' for type 'eml21:PermeabilityRockMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasureExt (418)
#endif

/* eml21__PermeabilityRockMeasure has binding name 'eml21__PermeabilityRockMeasure' for type 'eml21:PermeabilityRockMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityRockMeasure (417)
#endif

/* eml21__PermeabilityLengthMeasureExt has binding name 'eml21__PermeabilityLengthMeasureExt' for type 'eml21:PermeabilityLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasureExt (416)
#endif

/* eml21__PermeabilityLengthMeasure has binding name 'eml21__PermeabilityLengthMeasure' for type 'eml21:PermeabilityLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__PermeabilityLengthMeasure (415)
#endif

/* eml21__NormalizedPowerMeasureExt has binding name 'eml21__NormalizedPowerMeasureExt' for type 'eml21:NormalizedPowerMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasureExt (414)
#endif

/* eml21__NormalizedPowerMeasure has binding name 'eml21__NormalizedPowerMeasure' for type 'eml21:NormalizedPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__NormalizedPowerMeasure (413)
#endif

/* eml21__MomentumMeasureExt has binding name 'eml21__MomentumMeasureExt' for type 'eml21:MomentumMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasureExt (412)
#endif

/* eml21__MomentumMeasure has binding name 'eml21__MomentumMeasure' for type 'eml21:MomentumMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentumMeasure (411)
#endif

/* eml21__MomentOfInertiaMeasureExt has binding name 'eml21__MomentOfInertiaMeasureExt' for type 'eml21:MomentOfInertiaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasureExt (410)
#endif

/* eml21__MomentOfInertiaMeasure has binding name 'eml21__MomentOfInertiaMeasure' for type 'eml21:MomentOfInertiaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfInertiaMeasure (409)
#endif

/* eml21__MomentOfForceMeasureExt has binding name 'eml21__MomentOfForceMeasureExt' for type 'eml21:MomentOfForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasureExt (408)
#endif

/* eml21__MomentOfForceMeasure has binding name 'eml21__MomentOfForceMeasure' for type 'eml21:MomentOfForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MomentOfForceMeasure (407)
#endif

/* eml21__MolecularWeightMeasureExt has binding name 'eml21__MolecularWeightMeasureExt' for type 'eml21:MolecularWeightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasureExt (406)
#endif

/* eml21__MolecularWeightMeasure has binding name 'eml21__MolecularWeightMeasure' for type 'eml21:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolecularWeightMeasure (405)
#endif

/* eml21__MolarVolumeMeasureExt has binding name 'eml21__MolarVolumeMeasureExt' for type 'eml21:MolarVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasureExt (404)
#endif

/* eml21__MolarVolumeMeasure has binding name 'eml21__MolarVolumeMeasure' for type 'eml21:MolarVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarVolumeMeasure (403)
#endif

/* eml21__MolarHeatCapacityMeasureExt has binding name 'eml21__MolarHeatCapacityMeasureExt' for type 'eml21:MolarHeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasureExt (402)
#endif

/* eml21__MolarHeatCapacityMeasure has binding name 'eml21__MolarHeatCapacityMeasure' for type 'eml21:MolarHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarHeatCapacityMeasure (401)
#endif

/* eml21__MolarEnergyMeasureExt has binding name 'eml21__MolarEnergyMeasureExt' for type 'eml21:MolarEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasureExt (400)
#endif

/* eml21__MolarEnergyMeasure has binding name 'eml21__MolarEnergyMeasure' for type 'eml21:MolarEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MolarEnergyMeasure (399)
#endif

/* eml21__MobilityMeasureExt has binding name 'eml21__MobilityMeasureExt' for type 'eml21:MobilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasureExt (398)
#endif

/* eml21__MobilityMeasure has binding name 'eml21__MobilityMeasure' for type 'eml21:MobilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MobilityMeasure (397)
#endif

/* eml21__MassPerVolumePerTemperatureMeasureExt has binding name 'eml21__MassPerVolumePerTemperatureMeasureExt' for type 'eml21:MassPerVolumePerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasureExt (396)
#endif

/* eml21__MassPerVolumePerTemperatureMeasure has binding name 'eml21__MassPerVolumePerTemperatureMeasure' for type 'eml21:MassPerVolumePerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerTemperatureMeasure (395)
#endif

/* eml21__MassPerVolumePerPressureMeasureExt has binding name 'eml21__MassPerVolumePerPressureMeasureExt' for type 'eml21:MassPerVolumePerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasureExt (394)
#endif

/* eml21__MassPerVolumePerPressureMeasure has binding name 'eml21__MassPerVolumePerPressureMeasure' for type 'eml21:MassPerVolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerPressureMeasure (393)
#endif

/* eml21__MassPerVolumePerLengthMeasureExt has binding name 'eml21__MassPerVolumePerLengthMeasureExt' for type 'eml21:MassPerVolumePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasureExt (392)
#endif

/* eml21__MassPerVolumePerLengthMeasure has binding name 'eml21__MassPerVolumePerLengthMeasure' for type 'eml21:MassPerVolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumePerLengthMeasure (391)
#endif

/* eml21__MassPerVolumeMeasureExt has binding name 'eml21__MassPerVolumeMeasureExt' for type 'eml21:MassPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasureExt (390)
#endif

/* eml21__MassPerVolumeMeasure has binding name 'eml21__MassPerVolumeMeasure' for type 'eml21:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerVolumeMeasure (389)
#endif

/* eml21__MassPerTimePerLengthMeasureExt has binding name 'eml21__MassPerTimePerLengthMeasureExt' for type 'eml21:MassPerTimePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasureExt (388)
#endif

/* eml21__MassPerTimePerLengthMeasure has binding name 'eml21__MassPerTimePerLengthMeasure' for type 'eml21:MassPerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerLengthMeasure (387)
#endif

/* eml21__MassPerTimePerAreaMeasureExt has binding name 'eml21__MassPerTimePerAreaMeasureExt' for type 'eml21:MassPerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasureExt (386)
#endif

/* eml21__MassPerTimePerAreaMeasure has binding name 'eml21__MassPerTimePerAreaMeasure' for type 'eml21:MassPerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimePerAreaMeasure (385)
#endif

/* eml21__MassPerTimeMeasureExt has binding name 'eml21__MassPerTimeMeasureExt' for type 'eml21:MassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasureExt (384)
#endif

/* eml21__MassPerTimeMeasure has binding name 'eml21__MassPerTimeMeasure' for type 'eml21:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerTimeMeasure (383)
#endif

/* eml21__MassPerMassMeasureExt has binding name 'eml21__MassPerMassMeasureExt' for type 'eml21:MassPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasureExt (382)
#endif

/* eml21__MassPerMassMeasure has binding name 'eml21__MassPerMassMeasure' for type 'eml21:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerMassMeasure (381)
#endif

/* eml21__MassPerLengthMeasureExt has binding name 'eml21__MassPerLengthMeasureExt' for type 'eml21:MassPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasureExt (380)
#endif

/* eml21__MassPerLengthMeasure has binding name 'eml21__MassPerLengthMeasure' for type 'eml21:MassPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerLengthMeasure (379)
#endif

/* eml21__MassPerEnergyMeasureExt has binding name 'eml21__MassPerEnergyMeasureExt' for type 'eml21:MassPerEnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasureExt (378)
#endif

/* eml21__MassPerEnergyMeasure has binding name 'eml21__MassPerEnergyMeasure' for type 'eml21:MassPerEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerEnergyMeasure (377)
#endif

/* eml21__MassPerAreaMeasureExt has binding name 'eml21__MassPerAreaMeasureExt' for type 'eml21:MassPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasureExt (376)
#endif

/* eml21__MassPerAreaMeasure has binding name 'eml21__MassPerAreaMeasure' for type 'eml21:MassPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassPerAreaMeasure (375)
#endif

/* eml21__MassMeasureExt has binding name 'eml21__MassMeasureExt' for type 'eml21:MassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasureExt (374)
#endif

/* eml21__MassMeasure has binding name 'eml21__MassMeasure' for type 'eml21:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassMeasure (373)
#endif

/* eml21__MassLengthMeasureExt has binding name 'eml21__MassLengthMeasureExt' for type 'eml21:MassLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasureExt (372)
#endif

/* eml21__MassLengthMeasure has binding name 'eml21__MassLengthMeasure' for type 'eml21:MassLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MassLengthMeasure (371)
#endif

/* eml21__MagneticVectorPotentialMeasureExt has binding name 'eml21__MagneticVectorPotentialMeasureExt' for type 'eml21:MagneticVectorPotentialMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasureExt (370)
#endif

/* eml21__MagneticVectorPotentialMeasure has binding name 'eml21__MagneticVectorPotentialMeasure' for type 'eml21:MagneticVectorPotentialMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticVectorPotentialMeasure (369)
#endif

/* eml21__MagneticPermeabilityMeasureExt has binding name 'eml21__MagneticPermeabilityMeasureExt' for type 'eml21:MagneticPermeabilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasureExt (368)
#endif

/* eml21__MagneticPermeabilityMeasure has binding name 'eml21__MagneticPermeabilityMeasure' for type 'eml21:MagneticPermeabilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticPermeabilityMeasure (367)
#endif

/* eml21__MagneticFluxMeasureExt has binding name 'eml21__MagneticFluxMeasureExt' for type 'eml21:MagneticFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasureExt (366)
#endif

/* eml21__MagneticFluxMeasure has binding name 'eml21__MagneticFluxMeasure' for type 'eml21:MagneticFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxMeasure (365)
#endif

/* eml21__MagneticFluxDensityPerLengthMeasureExt has binding name 'eml21__MagneticFluxDensityPerLengthMeasureExt' for type 'eml21:MagneticFluxDensityPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasureExt (364)
#endif

/* eml21__MagneticFluxDensityPerLengthMeasure has binding name 'eml21__MagneticFluxDensityPerLengthMeasure' for type 'eml21:MagneticFluxDensityPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityPerLengthMeasure (363)
#endif

/* eml21__MagneticFluxDensityMeasureExt has binding name 'eml21__MagneticFluxDensityMeasureExt' for type 'eml21:MagneticFluxDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasureExt (362)
#endif

/* eml21__MagneticFluxDensityMeasure has binding name 'eml21__MagneticFluxDensityMeasure' for type 'eml21:MagneticFluxDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFluxDensityMeasure (361)
#endif

/* eml21__MagneticFieldStrengthMeasureExt has binding name 'eml21__MagneticFieldStrengthMeasureExt' for type 'eml21:MagneticFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasureExt (360)
#endif

/* eml21__MagneticFieldStrengthMeasure has binding name 'eml21__MagneticFieldStrengthMeasure' for type 'eml21:MagneticFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticFieldStrengthMeasure (359)
#endif

/* eml21__MagneticDipoleMomentMeasureExt has binding name 'eml21__MagneticDipoleMomentMeasureExt' for type 'eml21:MagneticDipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasureExt (358)
#endif

/* eml21__MagneticDipoleMomentMeasure has binding name 'eml21__MagneticDipoleMomentMeasure' for type 'eml21:MagneticDipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__MagneticDipoleMomentMeasure (357)
#endif

/* eml21__LuminousIntensityMeasureExt has binding name 'eml21__LuminousIntensityMeasureExt' for type 'eml21:LuminousIntensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasureExt (356)
#endif

/* eml21__LuminousIntensityMeasure has binding name 'eml21__LuminousIntensityMeasure' for type 'eml21:LuminousIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousIntensityMeasure (355)
#endif

/* eml21__LuminousFluxMeasureExt has binding name 'eml21__LuminousFluxMeasureExt' for type 'eml21:LuminousFluxMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasureExt (354)
#endif

/* eml21__LuminousFluxMeasure has binding name 'eml21__LuminousFluxMeasure' for type 'eml21:LuminousFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousFluxMeasure (353)
#endif

/* eml21__LuminousEfficacyMeasureExt has binding name 'eml21__LuminousEfficacyMeasureExt' for type 'eml21:LuminousEfficacyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasureExt (352)
#endif

/* eml21__LuminousEfficacyMeasure has binding name 'eml21__LuminousEfficacyMeasure' for type 'eml21:LuminousEfficacyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminousEfficacyMeasure (351)
#endif

/* eml21__LuminanceMeasureExt has binding name 'eml21__LuminanceMeasureExt' for type 'eml21:LuminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasureExt (350)
#endif

/* eml21__LuminanceMeasure has binding name 'eml21__LuminanceMeasure' for type 'eml21:LuminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LuminanceMeasure (349)
#endif

/* eml21__LogarithmicPowerRatioPerLengthMeasureExt has binding name 'eml21__LogarithmicPowerRatioPerLengthMeasureExt' for type 'eml21:LogarithmicPowerRatioPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasureExt (348)
#endif

/* eml21__LogarithmicPowerRatioPerLengthMeasure has binding name 'eml21__LogarithmicPowerRatioPerLengthMeasure' for type 'eml21:LogarithmicPowerRatioPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioPerLengthMeasure (347)
#endif

/* eml21__LogarithmicPowerRatioMeasureExt has binding name 'eml21__LogarithmicPowerRatioMeasureExt' for type 'eml21:LogarithmicPowerRatioMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasureExt (346)
#endif

/* eml21__LogarithmicPowerRatioMeasure has binding name 'eml21__LogarithmicPowerRatioMeasure' for type 'eml21:LogarithmicPowerRatioMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LogarithmicPowerRatioMeasure (345)
#endif

/* eml21__LinearThermalExpansionMeasureExt has binding name 'eml21__LinearThermalExpansionMeasureExt' for type 'eml21:LinearThermalExpansionMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasureExt (344)
#endif

/* eml21__LinearThermalExpansionMeasure has binding name 'eml21__LinearThermalExpansionMeasure' for type 'eml21:LinearThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearThermalExpansionMeasure (343)
#endif

/* eml21__LinearAccelerationMeasureExt has binding name 'eml21__LinearAccelerationMeasureExt' for type 'eml21:LinearAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasureExt (342)
#endif

/* eml21__LinearAccelerationMeasure has binding name 'eml21__LinearAccelerationMeasure' for type 'eml21:LinearAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LinearAccelerationMeasure (341)
#endif

/* eml21__LightExposureMeasureExt has binding name 'eml21__LightExposureMeasureExt' for type 'eml21:LightExposureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasureExt (340)
#endif

/* eml21__LightExposureMeasure has binding name 'eml21__LightExposureMeasure' for type 'eml21:LightExposureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LightExposureMeasure (339)
#endif

/* eml21__LengthPerVolumeMeasureExt has binding name 'eml21__LengthPerVolumeMeasureExt' for type 'eml21:LengthPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasureExt (338)
#endif

/* eml21__LengthPerVolumeMeasure has binding name 'eml21__LengthPerVolumeMeasure' for type 'eml21:LengthPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerVolumeMeasure (337)
#endif

/* eml21__LengthPerTimeMeasureExt has binding name 'eml21__LengthPerTimeMeasureExt' for type 'eml21:LengthPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasureExt (336)
#endif

/* eml21__LengthPerTimeMeasure has binding name 'eml21__LengthPerTimeMeasure' for type 'eml21:LengthPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTimeMeasure (335)
#endif

/* eml21__LengthPerTemperatureMeasureExt has binding name 'eml21__LengthPerTemperatureMeasureExt' for type 'eml21:LengthPerTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasureExt (334)
#endif

/* eml21__LengthPerTemperatureMeasure has binding name 'eml21__LengthPerTemperatureMeasure' for type 'eml21:LengthPerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerTemperatureMeasure (333)
#endif

/* eml21__LengthPerPressureMeasureExt has binding name 'eml21__LengthPerPressureMeasureExt' for type 'eml21:LengthPerPressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasureExt (332)
#endif

/* eml21__LengthPerPressureMeasure has binding name 'eml21__LengthPerPressureMeasure' for type 'eml21:LengthPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerPressureMeasure (331)
#endif

/* eml21__LengthPerMassMeasureExt has binding name 'eml21__LengthPerMassMeasureExt' for type 'eml21:LengthPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasureExt (330)
#endif

/* eml21__LengthPerMassMeasure has binding name 'eml21__LengthPerMassMeasure' for type 'eml21:LengthPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerMassMeasure (329)
#endif

/* eml21__LengthPerLengthMeasureExt has binding name 'eml21__LengthPerLengthMeasureExt' for type 'eml21:LengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasureExt (328)
#endif

/* eml21__LengthPerLengthMeasure has binding name 'eml21__LengthPerLengthMeasure' for type 'eml21:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthPerLengthMeasure (327)
#endif

/* eml21__LengthMeasureExt has binding name 'eml21__LengthMeasureExt' for type 'eml21:LengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasureExt (326)
#endif

/* eml21__LengthMeasure has binding name 'eml21__LengthMeasure' for type 'eml21:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__LengthMeasure (325)
#endif

/* eml21__KinematicViscosityMeasureExt has binding name 'eml21__KinematicViscosityMeasureExt' for type 'eml21:KinematicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasureExt (324)
#endif

/* eml21__KinematicViscosityMeasure has binding name 'eml21__KinematicViscosityMeasure' for type 'eml21:KinematicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__KinematicViscosityMeasure (323)
#endif

/* eml21__IsothermalCompressibilityMeasureExt has binding name 'eml21__IsothermalCompressibilityMeasureExt' for type 'eml21:IsothermalCompressibilityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasureExt (322)
#endif

/* eml21__IsothermalCompressibilityMeasure has binding name 'eml21__IsothermalCompressibilityMeasure' for type 'eml21:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__IsothermalCompressibilityMeasure (321)
#endif

/* eml21__InductanceMeasureExt has binding name 'eml21__InductanceMeasureExt' for type 'eml21:InductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasureExt (320)
#endif

/* eml21__InductanceMeasure has binding name 'eml21__InductanceMeasure' for type 'eml21:InductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__InductanceMeasure (319)
#endif

/* eml21__IlluminanceMeasureExt has binding name 'eml21__IlluminanceMeasureExt' for type 'eml21:IlluminanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasureExt (318)
#endif

/* eml21__IlluminanceMeasure has binding name 'eml21__IlluminanceMeasure' for type 'eml21:IlluminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__IlluminanceMeasure (317)
#endif

/* eml21__HeatTransferCoefficientMeasureExt has binding name 'eml21__HeatTransferCoefficientMeasureExt' for type 'eml21:HeatTransferCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasureExt (316)
#endif

/* eml21__HeatTransferCoefficientMeasure has binding name 'eml21__HeatTransferCoefficientMeasure' for type 'eml21:HeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatTransferCoefficientMeasure (315)
#endif

/* eml21__HeatFlowRateMeasureExt has binding name 'eml21__HeatFlowRateMeasureExt' for type 'eml21:HeatFlowRateMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasureExt (314)
#endif

/* eml21__HeatFlowRateMeasure has binding name 'eml21__HeatFlowRateMeasure' for type 'eml21:HeatFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatFlowRateMeasure (313)
#endif

/* eml21__HeatCapacityMeasureExt has binding name 'eml21__HeatCapacityMeasureExt' for type 'eml21:HeatCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasureExt (312)
#endif

/* eml21__HeatCapacityMeasure has binding name 'eml21__HeatCapacityMeasure' for type 'eml21:HeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__HeatCapacityMeasure (311)
#endif

/* eml21__FrequencyMeasureExt has binding name 'eml21__FrequencyMeasureExt' for type 'eml21:FrequencyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasureExt (310)
#endif

/* eml21__FrequencyMeasure has binding name 'eml21__FrequencyMeasure' for type 'eml21:FrequencyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyMeasure (309)
#endif

/* eml21__FrequencyIntervalMeasureExt has binding name 'eml21__FrequencyIntervalMeasureExt' for type 'eml21:FrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasureExt (308)
#endif

/* eml21__FrequencyIntervalMeasure has binding name 'eml21__FrequencyIntervalMeasure' for type 'eml21:FrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__FrequencyIntervalMeasure (307)
#endif

/* eml21__ForcePerVolumeMeasureExt has binding name 'eml21__ForcePerVolumeMeasureExt' for type 'eml21:ForcePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasureExt (306)
#endif

/* eml21__ForcePerVolumeMeasure has binding name 'eml21__ForcePerVolumeMeasure' for type 'eml21:ForcePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerVolumeMeasure (305)
#endif

/* eml21__ForcePerLengthMeasureExt has binding name 'eml21__ForcePerLengthMeasureExt' for type 'eml21:ForcePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasureExt (304)
#endif

/* eml21__ForcePerLengthMeasure has binding name 'eml21__ForcePerLengthMeasure' for type 'eml21:ForcePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerLengthMeasure (303)
#endif

/* eml21__ForcePerForceMeasureExt has binding name 'eml21__ForcePerForceMeasureExt' for type 'eml21:ForcePerForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasureExt (302)
#endif

/* eml21__ForcePerForceMeasure has binding name 'eml21__ForcePerForceMeasure' for type 'eml21:ForcePerForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForcePerForceMeasure (301)
#endif

/* eml21__ForceMeasureExt has binding name 'eml21__ForceMeasureExt' for type 'eml21:ForceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasureExt (300)
#endif

/* eml21__ForceMeasure has binding name 'eml21__ForceMeasure' for type 'eml21:ForceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceMeasure (299)
#endif

/* eml21__ForceLengthPerLengthMeasureExt has binding name 'eml21__ForceLengthPerLengthMeasureExt' for type 'eml21:ForceLengthPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasureExt (298)
#endif

/* eml21__ForceLengthPerLengthMeasure has binding name 'eml21__ForceLengthPerLengthMeasure' for type 'eml21:ForceLengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceLengthPerLengthMeasure (297)
#endif

/* eml21__ForceAreaMeasureExt has binding name 'eml21__ForceAreaMeasureExt' for type 'eml21:ForceAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasureExt (296)
#endif

/* eml21__ForceAreaMeasure has binding name 'eml21__ForceAreaMeasure' for type 'eml21:ForceAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ForceAreaMeasure (295)
#endif

/* eml21__EnergyPerVolumeMeasureExt has binding name 'eml21__EnergyPerVolumeMeasureExt' for type 'eml21:EnergyPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasureExt (294)
#endif

/* eml21__EnergyPerVolumeMeasure has binding name 'eml21__EnergyPerVolumeMeasure' for type 'eml21:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerVolumeMeasure (293)
#endif

/* eml21__EnergyPerMassPerTimeMeasureExt has binding name 'eml21__EnergyPerMassPerTimeMeasureExt' for type 'eml21:EnergyPerMassPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasureExt (292)
#endif

/* eml21__EnergyPerMassPerTimeMeasure has binding name 'eml21__EnergyPerMassPerTimeMeasure' for type 'eml21:EnergyPerMassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassPerTimeMeasure (291)
#endif

/* eml21__EnergyPerMassMeasureExt has binding name 'eml21__EnergyPerMassMeasureExt' for type 'eml21:EnergyPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasureExt (290)
#endif

/* eml21__EnergyPerMassMeasure has binding name 'eml21__EnergyPerMassMeasure' for type 'eml21:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerMassMeasure (289)
#endif

/* eml21__EnergyPerLengthMeasureExt has binding name 'eml21__EnergyPerLengthMeasureExt' for type 'eml21:EnergyPerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasureExt (288)
#endif

/* eml21__EnergyPerLengthMeasure has binding name 'eml21__EnergyPerLengthMeasure' for type 'eml21:EnergyPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerLengthMeasure (287)
#endif

/* eml21__EnergyPerAreaMeasureExt has binding name 'eml21__EnergyPerAreaMeasureExt' for type 'eml21:EnergyPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasureExt (286)
#endif

/* eml21__EnergyPerAreaMeasure has binding name 'eml21__EnergyPerAreaMeasure' for type 'eml21:EnergyPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyPerAreaMeasure (285)
#endif

/* eml21__EnergyMeasureExt has binding name 'eml21__EnergyMeasureExt' for type 'eml21:EnergyMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasureExt (284)
#endif

/* eml21__EnergyMeasure has binding name 'eml21__EnergyMeasure' for type 'eml21:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyMeasure (283)
#endif

/* eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt has binding name 'eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt' for type 'eml21:EnergyLengthPerTimeAreaTemperatureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasureExt (282)
#endif

/* eml21__EnergyLengthPerTimeAreaTemperatureMeasure has binding name 'eml21__EnergyLengthPerTimeAreaTemperatureMeasure' for type 'eml21:EnergyLengthPerTimeAreaTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerTimeAreaTemperatureMeasure (281)
#endif

/* eml21__EnergyLengthPerAreaMeasureExt has binding name 'eml21__EnergyLengthPerAreaMeasureExt' for type 'eml21:EnergyLengthPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasureExt (280)
#endif

/* eml21__EnergyLengthPerAreaMeasure has binding name 'eml21__EnergyLengthPerAreaMeasure' for type 'eml21:EnergyLengthPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__EnergyLengthPerAreaMeasure (279)
#endif

/* eml21__ElectromagneticMomentMeasureExt has binding name 'eml21__ElectromagneticMomentMeasureExt' for type 'eml21:ElectromagneticMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasureExt (278)
#endif

/* eml21__ElectromagneticMomentMeasure has binding name 'eml21__ElectromagneticMomentMeasure' for type 'eml21:ElectromagneticMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectromagneticMomentMeasure (277)
#endif

/* eml21__ElectricResistancePerLengthMeasureExt has binding name 'eml21__ElectricResistancePerLengthMeasureExt' for type 'eml21:ElectricResistancePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasureExt (276)
#endif

/* eml21__ElectricResistancePerLengthMeasure has binding name 'eml21__ElectricResistancePerLengthMeasure' for type 'eml21:ElectricResistancePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistancePerLengthMeasure (275)
#endif

/* eml21__ElectricResistanceMeasureExt has binding name 'eml21__ElectricResistanceMeasureExt' for type 'eml21:ElectricResistanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasureExt (274)
#endif

/* eml21__ElectricResistanceMeasure has binding name 'eml21__ElectricResistanceMeasure' for type 'eml21:ElectricResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricResistanceMeasure (273)
#endif

/* eml21__ElectricPotentialDifferenceMeasureExt has binding name 'eml21__ElectricPotentialDifferenceMeasureExt' for type 'eml21:ElectricPotentialDifferenceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasureExt (272)
#endif

/* eml21__ElectricPotentialDifferenceMeasure has binding name 'eml21__ElectricPotentialDifferenceMeasure' for type 'eml21:ElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricPotentialDifferenceMeasure (271)
#endif

/* eml21__ElectricFieldStrengthMeasureExt has binding name 'eml21__ElectricFieldStrengthMeasureExt' for type 'eml21:ElectricFieldStrengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasureExt (270)
#endif

/* eml21__ElectricFieldStrengthMeasure has binding name 'eml21__ElectricFieldStrengthMeasure' for type 'eml21:ElectricFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricFieldStrengthMeasure (269)
#endif

/* eml21__ElectricCurrentMeasureExt has binding name 'eml21__ElectricCurrentMeasureExt' for type 'eml21:ElectricCurrentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasureExt (268)
#endif

/* eml21__ElectricCurrentMeasure has binding name 'eml21__ElectricCurrentMeasure' for type 'eml21:ElectricCurrentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentMeasure (267)
#endif

/* eml21__ElectricCurrentDensityMeasureExt has binding name 'eml21__ElectricCurrentDensityMeasureExt' for type 'eml21:ElectricCurrentDensityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasureExt (266)
#endif

/* eml21__ElectricCurrentDensityMeasure has binding name 'eml21__ElectricCurrentDensityMeasure' for type 'eml21:ElectricCurrentDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricCurrentDensityMeasure (265)
#endif

/* eml21__ElectricConductivityMeasureExt has binding name 'eml21__ElectricConductivityMeasureExt' for type 'eml21:ElectricConductivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasureExt (264)
#endif

/* eml21__ElectricConductivityMeasure has binding name 'eml21__ElectricConductivityMeasure' for type 'eml21:ElectricConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductivityMeasure (263)
#endif

/* eml21__ElectricConductanceMeasureExt has binding name 'eml21__ElectricConductanceMeasureExt' for type 'eml21:ElectricConductanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasureExt (262)
#endif

/* eml21__ElectricConductanceMeasure has binding name 'eml21__ElectricConductanceMeasure' for type 'eml21:ElectricConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricConductanceMeasure (261)
#endif

/* eml21__ElectricChargePerVolumeMeasureExt has binding name 'eml21__ElectricChargePerVolumeMeasureExt' for type 'eml21:ElectricChargePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasureExt (260)
#endif

/* eml21__ElectricChargePerVolumeMeasure has binding name 'eml21__ElectricChargePerVolumeMeasure' for type 'eml21:ElectricChargePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerVolumeMeasure (259)
#endif

/* eml21__ElectricChargePerMassMeasureExt has binding name 'eml21__ElectricChargePerMassMeasureExt' for type 'eml21:ElectricChargePerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasureExt (258)
#endif

/* eml21__ElectricChargePerMassMeasure has binding name 'eml21__ElectricChargePerMassMeasure' for type 'eml21:ElectricChargePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerMassMeasure (257)
#endif

/* eml21__ElectricChargePerAreaMeasureExt has binding name 'eml21__ElectricChargePerAreaMeasureExt' for type 'eml21:ElectricChargePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasureExt (256)
#endif

/* eml21__ElectricChargePerAreaMeasure has binding name 'eml21__ElectricChargePerAreaMeasure' for type 'eml21:ElectricChargePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargePerAreaMeasure (255)
#endif

/* eml21__ElectricChargeMeasureExt has binding name 'eml21__ElectricChargeMeasureExt' for type 'eml21:ElectricChargeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasureExt (254)
#endif

/* eml21__ElectricChargeMeasure has binding name 'eml21__ElectricChargeMeasure' for type 'eml21:ElectricChargeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricChargeMeasure (253)
#endif

/* eml21__ElectricalResistivityMeasureExt has binding name 'eml21__ElectricalResistivityMeasureExt' for type 'eml21:ElectricalResistivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasureExt (252)
#endif

/* eml21__ElectricalResistivityMeasure has binding name 'eml21__ElectricalResistivityMeasure' for type 'eml21:ElectricalResistivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ElectricalResistivityMeasure (251)
#endif

/* eml21__DynamicViscosityMeasureExt has binding name 'eml21__DynamicViscosityMeasureExt' for type 'eml21:DynamicViscosityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasureExt (250)
#endif

/* eml21__DynamicViscosityMeasure has binding name 'eml21__DynamicViscosityMeasure' for type 'eml21:DynamicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DynamicViscosityMeasure (249)
#endif

/* eml21__DoseEquivalentMeasureExt has binding name 'eml21__DoseEquivalentMeasureExt' for type 'eml21:DoseEquivalentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasureExt (248)
#endif

/* eml21__DoseEquivalentMeasure has binding name 'eml21__DoseEquivalentMeasure' for type 'eml21:DoseEquivalentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoseEquivalentMeasure (247)
#endif

/* eml21__DipoleMomentMeasureExt has binding name 'eml21__DipoleMomentMeasureExt' for type 'eml21:DipoleMomentMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasureExt (246)
#endif

/* eml21__DipoleMomentMeasure has binding name 'eml21__DipoleMomentMeasure' for type 'eml21:DipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DipoleMomentMeasure (245)
#endif

/* eml21__DimensionlessMeasureExt has binding name 'eml21__DimensionlessMeasureExt' for type 'eml21:DimensionlessMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasureExt (244)
#endif

/* eml21__DimensionlessMeasure has binding name 'eml21__DimensionlessMeasure' for type 'eml21:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DimensionlessMeasure (243)
#endif

/* eml21__DigitalStorageMeasureExt has binding name 'eml21__DigitalStorageMeasureExt' for type 'eml21:DigitalStorageMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasureExt (242)
#endif

/* eml21__DigitalStorageMeasure has binding name 'eml21__DigitalStorageMeasure' for type 'eml21:DigitalStorageMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DigitalStorageMeasure (241)
#endif

/* eml21__DiffusiveTimeOfFlightMeasureExt has binding name 'eml21__DiffusiveTimeOfFlightMeasureExt' for type 'eml21:DiffusiveTimeOfFlightMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasureExt (240)
#endif

/* eml21__DiffusiveTimeOfFlightMeasure has binding name 'eml21__DiffusiveTimeOfFlightMeasure' for type 'eml21:DiffusiveTimeOfFlightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusiveTimeOfFlightMeasure (239)
#endif

/* eml21__DiffusionCoefficientMeasureExt has binding name 'eml21__DiffusionCoefficientMeasureExt' for type 'eml21:DiffusionCoefficientMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasureExt (238)
#endif

/* eml21__DiffusionCoefficientMeasure has binding name 'eml21__DiffusionCoefficientMeasure' for type 'eml21:DiffusionCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DiffusionCoefficientMeasure (237)
#endif

/* eml21__DataTransferSpeedMeasureExt has binding name 'eml21__DataTransferSpeedMeasureExt' for type 'eml21:DataTransferSpeedMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasureExt (236)
#endif

/* eml21__DataTransferSpeedMeasure has binding name 'eml21__DataTransferSpeedMeasure' for type 'eml21:DataTransferSpeedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__DataTransferSpeedMeasure (235)
#endif

/* eml21__CationExchangeCapacityMeasureExt has binding name 'eml21__CationExchangeCapacityMeasureExt' for type 'eml21:CationExchangeCapacityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasureExt (234)
#endif

/* eml21__CationExchangeCapacityMeasure has binding name 'eml21__CationExchangeCapacityMeasure' for type 'eml21:CationExchangeCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__CationExchangeCapacityMeasure (233)
#endif

/* eml21__CapacitanceMeasureExt has binding name 'eml21__CapacitanceMeasureExt' for type 'eml21:CapacitanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasureExt (232)
#endif

/* eml21__CapacitanceMeasure has binding name 'eml21__CapacitanceMeasure' for type 'eml21:CapacitanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__CapacitanceMeasure (231)
#endif

/* eml21__AttenuationPerFrequencyIntervalMeasureExt has binding name 'eml21__AttenuationPerFrequencyIntervalMeasureExt' for type 'eml21:AttenuationPerFrequencyIntervalMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasureExt (230)
#endif

/* eml21__AttenuationPerFrequencyIntervalMeasure has binding name 'eml21__AttenuationPerFrequencyIntervalMeasure' for type 'eml21:AttenuationPerFrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AttenuationPerFrequencyIntervalMeasure (229)
#endif

/* eml21__AreaPerVolumeMeasureExt has binding name 'eml21__AreaPerVolumeMeasureExt' for type 'eml21:AreaPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasureExt (228)
#endif

/* eml21__AreaPerVolumeMeasure has binding name 'eml21__AreaPerVolumeMeasure' for type 'eml21:AreaPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerVolumeMeasure (227)
#endif

/* eml21__AreaPerTimeMeasureExt has binding name 'eml21__AreaPerTimeMeasureExt' for type 'eml21:AreaPerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasureExt (226)
#endif

/* eml21__AreaPerTimeMeasure has binding name 'eml21__AreaPerTimeMeasure' for type 'eml21:AreaPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerTimeMeasure (225)
#endif

/* eml21__AreaPerMassMeasureExt has binding name 'eml21__AreaPerMassMeasureExt' for type 'eml21:AreaPerMassMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasureExt (224)
#endif

/* eml21__AreaPerMassMeasure has binding name 'eml21__AreaPerMassMeasure' for type 'eml21:AreaPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerMassMeasure (223)
#endif

/* eml21__AreaPerCountMeasureExt has binding name 'eml21__AreaPerCountMeasureExt' for type 'eml21:AreaPerCountMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasureExt (222)
#endif

/* eml21__AreaPerCountMeasure has binding name 'eml21__AreaPerCountMeasure' for type 'eml21:AreaPerCountMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerCountMeasure (221)
#endif

/* eml21__AreaPerAreaMeasureExt has binding name 'eml21__AreaPerAreaMeasureExt' for type 'eml21:AreaPerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasureExt (220)
#endif

/* eml21__AreaPerAreaMeasure has binding name 'eml21__AreaPerAreaMeasure' for type 'eml21:AreaPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAreaMeasure (219)
#endif

/* eml21__AreaPerAmountOfSubstanceMeasureExt has binding name 'eml21__AreaPerAmountOfSubstanceMeasureExt' for type 'eml21:AreaPerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasureExt (218)
#endif

/* eml21__AreaPerAmountOfSubstanceMeasure has binding name 'eml21__AreaPerAmountOfSubstanceMeasure' for type 'eml21:AreaPerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaPerAmountOfSubstanceMeasure (217)
#endif

/* eml21__AreaMeasureExt has binding name 'eml21__AreaMeasureExt' for type 'eml21:AreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasureExt (216)
#endif

/* eml21__AreaMeasure has binding name 'eml21__AreaMeasure' for type 'eml21:AreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AreaMeasure (215)
#endif

/* eml21__APINeutronMeasureExt has binding name 'eml21__APINeutronMeasureExt' for type 'eml21:APINeutronMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasureExt (214)
#endif

/* eml21__APINeutronMeasure has binding name 'eml21__APINeutronMeasure' for type 'eml21:APINeutronMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APINeutronMeasure (213)
#endif

/* eml21__APIGravityMeasureExt has binding name 'eml21__APIGravityMeasureExt' for type 'eml21:APIGravityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasureExt (212)
#endif

/* eml21__APIGravityMeasure has binding name 'eml21__APIGravityMeasure' for type 'eml21:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGravityMeasure (211)
#endif

/* eml21__APIGammaRayMeasureExt has binding name 'eml21__APIGammaRayMeasureExt' for type 'eml21:APIGammaRayMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasureExt (210)
#endif

/* eml21__APIGammaRayMeasure has binding name 'eml21__APIGammaRayMeasure' for type 'eml21:APIGammaRayMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__APIGammaRayMeasure (209)
#endif

/* eml21__AngularVelocityMeasureExt has binding name 'eml21__AngularVelocityMeasureExt' for type 'eml21:AngularVelocityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasureExt (208)
#endif

/* eml21__AngularVelocityMeasure has binding name 'eml21__AngularVelocityMeasure' for type 'eml21:AngularVelocityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularVelocityMeasure (207)
#endif

/* eml21__AngularAccelerationMeasureExt has binding name 'eml21__AngularAccelerationMeasureExt' for type 'eml21:AngularAccelerationMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasureExt (206)
#endif

/* eml21__AngularAccelerationMeasure has binding name 'eml21__AngularAccelerationMeasure' for type 'eml21:AngularAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AngularAccelerationMeasure (205)
#endif

/* eml21__AnglePerVolumeMeasureExt has binding name 'eml21__AnglePerVolumeMeasureExt' for type 'eml21:AnglePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasureExt (204)
#endif

/* eml21__AnglePerVolumeMeasure has binding name 'eml21__AnglePerVolumeMeasure' for type 'eml21:AnglePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerVolumeMeasure (203)
#endif

/* eml21__AnglePerLengthMeasureExt has binding name 'eml21__AnglePerLengthMeasureExt' for type 'eml21:AnglePerLengthMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasureExt (202)
#endif

/* eml21__AnglePerLengthMeasure has binding name 'eml21__AnglePerLengthMeasure' for type 'eml21:AnglePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AnglePerLengthMeasure (201)
#endif

/* eml21__AmountOfSubstancePerVolumeMeasureExt has binding name 'eml21__AmountOfSubstancePerVolumeMeasureExt' for type 'eml21:AmountOfSubstancePerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasureExt (200)
#endif

/* eml21__AmountOfSubstancePerVolumeMeasure has binding name 'eml21__AmountOfSubstancePerVolumeMeasure' for type 'eml21:AmountOfSubstancePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerVolumeMeasure (199)
#endif

/* eml21__AmountOfSubstancePerTimePerAreaMeasureExt has binding name 'eml21__AmountOfSubstancePerTimePerAreaMeasureExt' for type 'eml21:AmountOfSubstancePerTimePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasureExt (198)
#endif

/* eml21__AmountOfSubstancePerTimePerAreaMeasure has binding name 'eml21__AmountOfSubstancePerTimePerAreaMeasure' for type 'eml21:AmountOfSubstancePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimePerAreaMeasure (197)
#endif

/* eml21__AmountOfSubstancePerTimeMeasureExt has binding name 'eml21__AmountOfSubstancePerTimeMeasureExt' for type 'eml21:AmountOfSubstancePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasureExt (196)
#endif

/* eml21__AmountOfSubstancePerTimeMeasure has binding name 'eml21__AmountOfSubstancePerTimeMeasure' for type 'eml21:AmountOfSubstancePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerTimeMeasure (195)
#endif

/* eml21__AmountOfSubstancePerAreaMeasureExt has binding name 'eml21__AmountOfSubstancePerAreaMeasureExt' for type 'eml21:AmountOfSubstancePerAreaMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasureExt (194)
#endif

/* eml21__AmountOfSubstancePerAreaMeasure has binding name 'eml21__AmountOfSubstancePerAreaMeasure' for type 'eml21:AmountOfSubstancePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAreaMeasure (193)
#endif

/* eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt has binding name 'eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt' for type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasureExt (192)
#endif

/* eml21__AmountOfSubstancePerAmountOfSubstanceMeasure has binding name 'eml21__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstancePerAmountOfSubstanceMeasure (191)
#endif

/* eml21__AmountOfSubstanceMeasureExt has binding name 'eml21__AmountOfSubstanceMeasureExt' for type 'eml21:AmountOfSubstanceMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasureExt (190)
#endif

/* eml21__AmountOfSubstanceMeasure has binding name 'eml21__AmountOfSubstanceMeasure' for type 'eml21:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AmountOfSubstanceMeasure (189)
#endif

/* eml21__ActivityOfRadioactivityMeasureExt has binding name 'eml21__ActivityOfRadioactivityMeasureExt' for type 'eml21:ActivityOfRadioactivityMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasureExt (188)
#endif

/* eml21__ActivityOfRadioactivityMeasure has binding name 'eml21__ActivityOfRadioactivityMeasure' for type 'eml21:ActivityOfRadioactivityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__ActivityOfRadioactivityMeasure (187)
#endif

/* eml21__AbsorbedDoseMeasureExt has binding name 'eml21__AbsorbedDoseMeasureExt' for type 'eml21:AbsorbedDoseMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasureExt (186)
#endif

/* eml21__AbsorbedDoseMeasure has binding name 'eml21__AbsorbedDoseMeasure' for type 'eml21:AbsorbedDoseMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbsorbedDoseMeasure (185)
#endif

/* eml21__TvdInterval has binding name 'eml21__TvdInterval' for type 'eml21:TvdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval
#define SOAP_TYPE_gsoap_eml2_1_eml21__TvdInterval (184)
#endif

/* eml21__StringMeasure has binding name 'eml21__StringMeasure' for type 'eml21:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringMeasure (183)
#endif

/* eml21__StringExternalArray has binding name 'eml21__StringExternalArray' for type 'eml21:StringExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringExternalArray (182)
#endif

/* eml21__StringConstantArray has binding name 'eml21__StringConstantArray' for type 'eml21:StringConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__StringConstantArray (181)
#endif

/* eml21__MdInterval has binding name 'eml21__MdInterval' for type 'eml21:MdInterval' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval
#define SOAP_TYPE_gsoap_eml2_1_eml21__MdInterval (180)
#endif

/* eml21__JaggedArray has binding name 'eml21__JaggedArray' for type 'eml21:JaggedArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__JaggedArray (179)
#endif

/* eml21__IntegerRangeArray has binding name 'eml21__IntegerRangeArray' for type 'eml21:IntegerRangeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerRangeArray (178)
#endif

/* eml21__IntegerLatticeArray has binding name 'eml21__IntegerLatticeArray' for type 'eml21:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerLatticeArray (177)
#endif

/* eml21__IntegerExternalArray has binding name 'eml21__IntegerExternalArray' for type 'eml21:IntegerExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerExternalArray (176)
#endif

/* eml21__IntegerConstantArray has binding name 'eml21__IntegerConstantArray' for type 'eml21:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerConstantArray (175)
#endif

/* eml21__IntegerArrayFromBooleanMaskArray has binding name 'eml21__IntegerArrayFromBooleanMaskArray' for type 'eml21:IntegerArrayFromBooleanMaskArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__IntegerArrayFromBooleanMaskArray (174)
#endif

/* eml21__GenericMeasure has binding name 'eml21__GenericMeasure' for type 'eml21:GenericMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure
#define SOAP_TYPE_gsoap_eml2_1_eml21__GenericMeasure (173)
#endif

/* eml21__FloatingPointLatticeArray has binding name 'eml21__FloatingPointLatticeArray' for type 'eml21:FloatingPointLatticeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointLatticeArray (172)
#endif

/* eml21__FloatingPointExternalArray has binding name 'eml21__FloatingPointExternalArray' for type 'eml21:FloatingPointExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointExternalArray (171)
#endif

/* eml21__FloatingPointConstantArray has binding name 'eml21__FloatingPointConstantArray' for type 'eml21:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatingPointConstantArray (170)
#endif

/* eml21__FloatExternalArray has binding name 'eml21__FloatExternalArray' for type 'eml21:FloatExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__FloatExternalArray (169)
#endif

/* eml21__DoubleExternalArray has binding name 'eml21__DoubleExternalArray' for type 'eml21:DoubleExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__DoubleExternalArray (168)
#endif

/* eml21__BooleanExternalArray has binding name 'eml21__BooleanExternalArray' for type 'eml21:BooleanExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanExternalArray (167)
#endif

/* eml21__BooleanConstantArray has binding name 'eml21__BooleanConstantArray' for type 'eml21:BooleanConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanConstantArray (166)
#endif

/* eml21__BooleanArrayFromIndexArray has binding name 'eml21__BooleanArrayFromIndexArray' for type 'eml21:BooleanArrayFromIndexArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__BooleanArrayFromIndexArray (165)
#endif

/* eml21__AuthorityQualifiedName has binding name 'eml21__AuthorityQualifiedName' for type 'eml21:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_1_eml21__AuthorityQualifiedName (164)
#endif

/* eml21__AbstractValueArray has binding name 'eml21__AbstractValueArray' for type 'eml21:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractValueArray (163)
#endif

/* eml21__AbstractStringArray has binding name 'eml21__AbstractStringArray' for type 'eml21:AbstractStringArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractStringArray (162)
#endif

/* eml21__AbstractNumericArray has binding name 'eml21__AbstractNumericArray' for type 'eml21:AbstractNumericArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractNumericArray (161)
#endif

/* eml21__AbstractIntegerArray has binding name 'eml21__AbstractIntegerArray' for type 'eml21:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractIntegerArray (160)
#endif

/* eml21__AbstractFloatingPointArray has binding name 'eml21__AbstractFloatingPointArray' for type 'eml21:AbstractFloatingPointArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractFloatingPointArray (159)
#endif

/* eml21__AbstractBooleanArray has binding name 'eml21__AbstractBooleanArray' for type 'eml21:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractBooleanArray (158)
#endif

/* eml21__ObjectAlias has binding name 'eml21__ObjectAlias' for type 'eml21:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_1_eml21__ObjectAlias (157)
#endif

/* eml21__ExtensionNameValue has binding name 'eml21__ExtensionNameValue' for type 'eml21:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_1_eml21__ExtensionNameValue (156)
#endif

/* eml21__CustomData has binding name 'eml21__CustomData' for type 'eml21:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__CustomData
#define SOAP_TYPE_gsoap_eml2_1_eml21__CustomData (155)
#endif

/* eml21__Citation has binding name 'eml21__Citation' for type 'eml21:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__Citation
#define SOAP_TYPE_gsoap_eml2_1_eml21__Citation (154)
#endif

/* eml21__AbstractObject has binding name 'eml21__AbstractObject' for type 'eml21:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject
#define SOAP_TYPE_gsoap_eml2_1_eml21__AbstractObject (153)
#endif

/* prodml2__WaveLength has binding name 'prodml2__WaveLength' for type 'prodml2:WaveLength' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WaveLength (152)
#endif

/* prodml2__PermanentCable has binding name 'prodml2__PermanentCable' for type 'prodml2:PermanentCable' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PermanentCable (151)
#endif

/* prodml2__InterventionConveyance has binding name 'prodml2__InterventionConveyance' for type 'prodml2:InterventionConveyance' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance
#define SOAP_TYPE_gsoap_eml2_1_prodml2__InterventionConveyance (150)
#endif

/* prodml2__Frequency has binding name 'prodml2__Frequency' for type 'prodml2:Frequency' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Frequency (149)
#endif

/* prodml2__FiberTurnaround has binding name 'prodml2__FiberTurnaround' for type 'prodml2:FiberTurnaround' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTurnaround (148)
#endif

/* prodml2__FiberTerminator has binding name 'prodml2__FiberTerminator' for type 'prodml2:FiberTerminator' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberTerminator (147)
#endif

/* prodml2__FiberSplice has binding name 'prodml2__FiberSplice' for type 'prodml2:FiberSplice' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberSplice (146)
#endif

/* prodml2__FiberRefractiveIndex has binding name 'prodml2__FiberRefractiveIndex' for type 'prodml2:FiberRefractiveIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberRefractiveIndex (145)
#endif

/* prodml2__FiberPumpActivity has binding name 'prodml2__FiberPumpActivity' for type 'prodml2:FiberPumpActivity' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPumpActivity (144)
#endif

/* prodml2__FiberPathDefect has binding name 'prodml2__FiberPathDefect' for type 'prodml2:FiberPathDefect' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberPathDefect (143)
#endif

/* prodml2__FiberOTDRInstrumentBox has binding name 'prodml2__FiberOTDRInstrumentBox' for type 'prodml2:FiberOTDRInstrumentBox' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDRInstrumentBox (142)
#endif

/* prodml2__FiberOTDR has binding name 'prodml2__FiberOTDR' for type 'prodml2:FiberOTDR' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOTDR (141)
#endif

/* prodml2__FiberOpticalPathSegment has binding name 'prodml2__FiberOpticalPathSegment' for type 'prodml2:FiberOpticalPathSegment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathSegment (140)
#endif

/* prodml2__FiberOpticalPathNetwork has binding name 'prodml2__FiberOpticalPathNetwork' for type 'prodml2:FiberOpticalPathNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathNetwork (139)
#endif

/* prodml2__FiberOpticalPathInventory has binding name 'prodml2__FiberOpticalPathInventory' for type 'prodml2:FiberOpticalPathInventory' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPathInventory (138)
#endif

/* prodml2__FiberOpticalPath has binding name 'prodml2__FiberOpticalPath' for type 'prodml2:FiberOpticalPath' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOpticalPath (137)
#endif

/* prodml2__FiberOneWayAttenuation has binding name 'prodml2__FiberOneWayAttenuation' for type 'prodml2:FiberOneWayAttenuation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberOneWayAttenuation (136)
#endif

/* prodml2__FiberFacilityWell has binding name 'prodml2__FiberFacilityWell' for type 'prodml2:FiberFacilityWell' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityWell (135)
#endif

/* prodml2__FiberFacilityPipeline has binding name 'prodml2__FiberFacilityPipeline' for type 'prodml2:FiberFacilityPipeline' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityPipeline (134)
#endif

/* prodml2__FiberFacilityMappingPart has binding name 'prodml2__FiberFacilityMappingPart' for type 'prodml2:FiberFacilityMappingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMappingPart (133)
#endif

/* prodml2__FiberFacilityMapping has binding name 'prodml2__FiberFacilityMapping' for type 'prodml2:FiberFacilityMapping' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityMapping (132)
#endif

/* prodml2__FiberFacilityGeneric has binding name 'prodml2__FiberFacilityGeneric' for type 'prodml2:FiberFacilityGeneric' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberFacilityGeneric (131)
#endif

/* prodml2__FiberConveyance has binding name 'prodml2__FiberConveyance' for type 'prodml2:FiberConveyance' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConveyance (130)
#endif

/* prodml2__FiberControlLine has binding name 'prodml2__FiberControlLine' for type 'prodml2:FiberControlLine' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberControlLine (129)
#endif

/* prodml2__FiberConnection has binding name 'prodml2__FiberConnection' for type 'prodml2:FiberConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberConnection (128)
#endif

/* prodml2__FiberCommon has binding name 'prodml2__FiberCommon' for type 'prodml2:FiberCommon' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FiberCommon (127)
#endif

/* prodml2__AbstractFiberFacility has binding name 'prodml2__AbstractFiberFacility' for type 'prodml2:AbstractFiberFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFiberFacility (126)
#endif

/* prodml2__AbstractCable has binding name 'prodml2__AbstractCable' for type 'prodml2:AbstractCable' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractCable (125)
#endif

/* prodml2__AbstractAttenuationMeasure has binding name 'prodml2__AbstractAttenuationMeasure' for type 'prodml2:AbstractAttenuationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractAttenuationMeasure (124)
#endif

/* prodml2__RelativeCoordinate has binding name 'prodml2__RelativeCoordinate' for type 'prodml2:RelativeCoordinate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__RelativeCoordinate (123)
#endif

/* prodml2__Qualifier has binding name 'prodml2__Qualifier' for type 'prodml2:Qualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Qualifier (122)
#endif

/* prodml2__ProductFlowUnit has binding name 'prodml2__ProductFlowUnit' for type 'prodml2:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowUnit (121)
#endif

/* prodml2__ProductFlowQualifierExpected has binding name 'prodml2__ProductFlowQualifierExpected' for type 'prodml2:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowQualifierExpected (120)
#endif

/* prodml2__ProductFlowPort has binding name 'prodml2__ProductFlowPort' for type 'prodml2:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowPort (119)
#endif

/* prodml2__ProductFlowNetworkPlan has binding name 'prodml2__ProductFlowNetworkPlan' for type 'prodml2:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetworkPlan (118)
#endif

/* prodml2__ProductFlowModel has binding name 'prodml2__ProductFlowModel' for type 'prodml2:ProductFlowModel' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowModel (117)
#endif

/* prodml2__ProductFlowExternalPort has binding name 'prodml2__ProductFlowExternalPort' for type 'prodml2:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalPort (116)
#endif

/* prodml2__ProductFlowExpectedUnitProperty has binding name 'prodml2__ProductFlowExpectedUnitProperty' for type 'prodml2:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExpectedUnitProperty (115)
#endif

/* prodml2__ProductFlowChangeLog has binding name 'prodml2__ProductFlowChangeLog' for type 'prodml2:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowChangeLog (114)
#endif

/* prodml2__ExpectedFlowQualifier has binding name 'prodml2__ExpectedFlowQualifier' for type 'prodml2:ExpectedFlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ExpectedFlowQualifier (113)
#endif

/* prodml2__ConnectedNode has binding name 'prodml2__ConnectedNode' for type 'prodml2:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ConnectedNode (112)
#endif

/* prodml2__StringData has binding name 'prodml2__StringData' for type 'prodml2:StringData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StringData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StringData (111)
#endif

/* prodml2__ReferenceFlow has binding name 'prodml2__ReferenceFlow' for type 'prodml2:ReferenceFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ReferenceFlow (110)
#endif

/* prodml2__ProductVolumeRelatedFacility has binding name 'prodml2__ProductVolumeRelatedFacility' for type 'prodml2:ProductVolumeRelatedFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeRelatedFacility (109)
#endif

/* prodml2__ProductVolumeProduct has binding name 'prodml2__ProductVolumeProduct' for type 'prodml2:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeProduct (108)
#endif

/* prodml2__ProductVolumePortDifference has binding name 'prodml2__ProductVolumePortDifference' for type 'prodml2:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePortDifference (107)
#endif

/* prodml2__ProductVolumePeriod has binding name 'prodml2__ProductVolumePeriod' for type 'prodml2:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumePeriod (106)
#endif

/* prodml2__ProductVolumeParameterValue has binding name 'prodml2__ProductVolumeParameterValue' for type 'prodml2:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterValue (105)
#endif

/* prodml2__ProductVolumeParameterSet has binding name 'prodml2__ProductVolumeParameterSet' for type 'prodml2:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeParameterSet (104)
#endif

/* prodml2__ProductVolumeFlow has binding name 'prodml2__ProductVolumeFlow' for type 'prodml2:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFlow (103)
#endif

/* prodml2__ProductVolumeFacility has binding name 'prodml2__ProductVolumeFacility' for type 'prodml2:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeFacility (102)
#endif

/* prodml2__ProductVolumeDestination has binding name 'prodml2__ProductVolumeDestination' for type 'prodml2:ProductVolumeDestination' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeDestination (101)
#endif

/* prodml2__ProductVolumeComponentContent has binding name 'prodml2__ProductVolumeComponentContent' for type 'prodml2:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeComponentContent (100)
#endif

/* prodml2__ProductVolumeBusinessUnit has binding name 'prodml2__ProductVolumeBusinessUnit' for type 'prodml2:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessUnit (99)
#endif

/* prodml2__ProductVolumeBusinessSubUnit has binding name 'prodml2__ProductVolumeBusinessSubUnit' for type 'prodml2:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBusinessSubUnit (98)
#endif

/* prodml2__ProductVolumeBalanceSet has binding name 'prodml2__ProductVolumeBalanceSet' for type 'prodml2:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceSet (97)
#endif

/* prodml2__ProductVolumeBalanceEvent has binding name 'prodml2__ProductVolumeBalanceEvent' for type 'prodml2:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceEvent (96)
#endif

/* prodml2__ProductVolumeBalanceDetail has binding name 'prodml2__ProductVolumeBalanceDetail' for type 'prodml2:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeBalanceDetail (95)
#endif

/* prodml2__ProductVolumeAlert has binding name 'prodml2__ProductVolumeAlert' for type 'prodml2:ProductVolumeAlert' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolumeAlert (94)
#endif

/* prodml2__ProductVolume has binding name 'prodml2__ProductVolume' for type 'prodml2:ProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductVolume (93)
#endif

/* prodml2__Parentfacility has binding name 'prodml2__Parentfacility' for type 'prodml2:Parentfacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Parentfacility (92)
#endif

/* prodml2__OwnershipBusinessAcct has binding name 'prodml2__OwnershipBusinessAcct' for type 'prodml2:OwnershipBusinessAcct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OwnershipBusinessAcct (91)
#endif

/* prodml2__IntegerData has binding name 'prodml2__IntegerData' for type 'prodml2:IntegerData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerData (90)
#endif

/* prodml2__FacilityUnitPort has binding name 'prodml2__FacilityUnitPort' for type 'prodml2:FacilityUnitPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityUnitPort (89)
#endif

/* prodml2__FacilityParent has binding name 'prodml2__FacilityParent' for type 'prodml2:FacilityParent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityParent (88)
#endif

/* prodml2__CurveDefinition has binding name 'prodml2__CurveDefinition' for type 'prodml2:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CurveDefinition (87)
#endif

/* prodml2__CurveData has binding name 'prodml2__CurveData' for type 'prodml2:CurveData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CurveData (86)
#endif

/* prodml2__AbstractRelatedFacilityObject has binding name 'prodml2__AbstractRelatedFacilityObject' for type 'prodml2:AbstractRelatedFacilityObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRelatedFacilityObject (85)
#endif

/* prodml2__AbstractRefProductFlow has binding name 'prodml2__AbstractRefProductFlow' for type 'prodml2:AbstractRefProductFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractRefProductFlow (84)
#endif

/* prodml2__AbstractMeasureDataType has binding name 'prodml2__AbstractMeasureDataType' for type 'prodml2:AbstractMeasureDataType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractMeasureDataType (83)
#endif

/* prodml2__CommonPropertiesProductVolume has binding name 'prodml2__CommonPropertiesProductVolume' for type 'prodml2:CommonPropertiesProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CommonPropertiesProductVolume (82)
#endif

/* prodml2__WellVerticalDepthCoord has binding name 'prodml2__WellVerticalDepthCoord' for type 'prodml2:WellVerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellVerticalDepthCoord (81)
#endif

/* prodml2__WellElevationCoord has binding name 'prodml2__WellElevationCoord' for type 'prodml2:WellElevationCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__WellElevationCoord (80)
#endif

/* prodml2__VolumeQualifiedMeasure has binding name 'prodml2__VolumeQualifiedMeasure' for type 'prodml2:VolumeQualifiedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__VolumeQualifiedMeasure (79)
#endif

/* prodml2__VaporComposition has binding name 'prodml2__VaporComposition' for type 'prodml2:VaporComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__VaporComposition (78)
#endif

/* prodml2__StockTankOil has binding name 'prodml2__StockTankOil' for type 'prodml2:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StockTankOil (77)
#endif

/* prodml2__StartEndTime has binding name 'prodml2__StartEndTime' for type 'prodml2:StartEndTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndTime (76)
#endif

/* prodml2__StartEndDate has binding name 'prodml2__StartEndDate' for type 'prodml2:StartEndDate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__StartEndDate (75)
#endif

/* prodml2__PureFluidComponent has binding name 'prodml2__PureFluidComponent' for type 'prodml2:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PureFluidComponent (74)
#endif

/* prodml2__PseudoFluidComponent has binding name 'prodml2__PseudoFluidComponent' for type 'prodml2:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PseudoFluidComponent (73)
#endif

/* prodml2__ProductFlowNetwork has binding name 'prodml2__ProductFlowNetwork' for type 'prodml2:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowNetwork (72)
#endif

/* prodml2__ProductFlowExternalReference has binding name 'prodml2__ProductFlowExternalReference' for type 'prodml2:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_1_prodml2__ProductFlowExternalReference (71)
#endif

/* prodml2__PlusFluidComponent has binding name 'prodml2__PlusFluidComponent' for type 'prodml2:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PlusFluidComponent (70)
#endif

/* prodml2__PhoneNumberStruct has binding name 'prodml2__PhoneNumberStruct' for type 'prodml2:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PhoneNumberStruct (69)
#endif

/* prodml2__PersonName has binding name 'prodml2__PersonName' for type 'prodml2:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName
#define SOAP_TYPE_gsoap_eml2_1_prodml2__PersonName (68)
#endif

/* prodml2__OverallComposition has binding name 'prodml2__OverallComposition' for type 'prodml2:OverallComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OverallComposition (67)
#endif

/* prodml2__OffshoreLocation has binding name 'prodml2__OffshoreLocation' for type 'prodml2:OffshoreLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_1_prodml2__OffshoreLocation (66)
#endif

/* prodml2__NorthSeaOffshore has binding name 'prodml2__NorthSeaOffshore' for type 'prodml2:NorthSeaOffshore' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NorthSeaOffshore (65)
#endif

/* prodml2__NaturalGas has binding name 'prodml2__NaturalGas' for type 'prodml2:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NaturalGas (64)
#endif

/* prodml2__NameStruct has binding name 'prodml2__NameStruct' for type 'prodml2:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__NameStruct (63)
#endif

/* prodml2__MeasureOrQuantity has binding name 'prodml2__MeasureOrQuantity' for type 'prodml2:MeasureOrQuantity' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity
#define SOAP_TYPE_gsoap_eml2_1_prodml2__MeasureOrQuantity (62)
#endif

/* prodml2__MeasuredDepthCoord has binding name 'prodml2__MeasuredDepthCoord' for type 'prodml2:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__MeasuredDepthCoord (61)
#endif

/* prodml2__LiquidComposition has binding name 'prodml2__LiquidComposition' for type 'prodml2:LiquidComposition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__LiquidComposition (60)
#endif

/* prodml2__KindQualifiedString has binding name 'prodml2__KindQualifiedString' for type 'prodml2:KindQualifiedString' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_1_prodml2__KindQualifiedString (59)
#endif

/* prodml2__KeywordValueStruct has binding name 'prodml2__KeywordValueStruct' for type 'prodml2:KeywordValueStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__KeywordValueStruct (58)
#endif

/* prodml2__IntegerQualifiedCount has binding name 'prodml2__IntegerQualifiedCount' for type 'prodml2:IntegerQualifiedCount' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IntegerQualifiedCount (57)
#endif

/* prodml2__IndexedObject has binding name 'prodml2__IndexedObject' for type 'prodml2:IndexedObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject
#define SOAP_TYPE_gsoap_eml2_1_prodml2__IndexedObject (56)
#endif

/* prodml2__GeologyFeature has binding name 'prodml2__GeologyFeature' for type 'prodml2:GeologyFeature' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeologyFeature (55)
#endif

/* prodml2__GeographicContext has binding name 'prodml2__GeographicContext' for type 'prodml2:GeographicContext' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeographicContext (54)
#endif

/* prodml2__GeneralQualifiedMeasure has binding name 'prodml2__GeneralQualifiedMeasure' for type 'prodml2:GeneralQualifiedMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralQualifiedMeasure (53)
#endif

/* prodml2__GeneralMeasureType has binding name 'prodml2__GeneralMeasureType' for type 'prodml2:GeneralMeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralMeasureType (52)
#endif

/* prodml2__GeneralAddress has binding name 'prodml2__GeneralAddress' for type 'prodml2:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_1_prodml2__GeneralAddress (51)
#endif

/* prodml2__FormationWater has binding name 'prodml2__FormationWater' for type 'prodml2:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FormationWater (50)
#endif

/* prodml2__FluidComponentCatalog has binding name 'prodml2__FluidComponentCatalog' for type 'prodml2:FluidComponentCatalog' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponentCatalog (49)
#endif

/* prodml2__FluidComponent has binding name 'prodml2__FluidComponent' for type 'prodml2:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FluidComponent (48)
#endif

/* prodml2__FacilityIdentifierStruct has binding name 'prodml2__FacilityIdentifierStruct' for type 'prodml2:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifierStruct (47)
#endif

/* prodml2__FacilityIdentifier has binding name 'prodml2__FacilityIdentifier' for type 'prodml2:FacilityIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier
#define SOAP_TYPE_gsoap_eml2_1_prodml2__FacilityIdentifier (46)
#endif

/* prodml2__EndpointQualifiedDateTime has binding name 'prodml2__EndpointQualifiedDateTime' for type 'prodml2:EndpointQualifiedDateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDateTime (45)
#endif

/* prodml2__EndpointQualifiedDate has binding name 'prodml2__EndpointQualifiedDate' for type 'prodml2:EndpointQualifiedDate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EndpointQualifiedDate (44)
#endif

/* prodml2__EmailQualifierStruct has binding name 'prodml2__EmailQualifierStruct' for type 'prodml2:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_1_prodml2__EmailQualifierStruct (43)
#endif

/* prodml2__DatedComment has binding name 'prodml2__DatedComment' for type 'prodml2:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DatedComment (42)
#endif

/* prodml2__CalibrationParameter has binding name 'prodml2__CalibrationParameter' for type 'prodml2:CalibrationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_1_prodml2__CalibrationParameter (41)
#endif

/* prodml2__BusinessAssociate has binding name 'prodml2__BusinessAssociate' for type 'prodml2:BusinessAssociate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_1_prodml2__BusinessAssociate (40)
#endif

/* prodml2__AbstractFluidComponent has binding name 'prodml2__AbstractFluidComponent' for type 'prodml2:AbstractFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractFluidComponent (39)
#endif

/* prodml2__AbstractDateTimeClass has binding name 'prodml2__AbstractDateTimeClass' for type 'prodml2:AbstractDateTimeClass' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDateTimeClass (38)
#endif

/* prodml2__DtsInstalledSystem has binding name 'prodml2__DtsInstalledSystem' for type 'prodml2:DtsInstalledSystem' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstalledSystem (37)
#endif

/* prodml2__DtsCalibration has binding name 'prodml2__DtsCalibration' for type 'prodml2:DtsCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsCalibration (36)
#endif

/* prodml2__Instrument has binding name 'prodml2__Instrument' for type 'prodml2:Instrument' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument
#define SOAP_TYPE_gsoap_eml2_1_prodml2__Instrument (35)
#endif

/* prodml2__DtsPatchCord has binding name 'prodml2__DtsPatchCord' for type 'prodml2:DtsPatchCord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsPatchCord (34)
#endif

/* prodml2__DtsInstrumentBox has binding name 'prodml2__DtsInstrumentBox' for type 'prodml2:DtsInstrumentBox' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DtsInstrumentBox (33)
#endif

/* prodml2__AbstractDtsEquipment has binding name 'prodml2__AbstractDtsEquipment' for type 'prodml2:AbstractDtsEquipment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment
#define SOAP_TYPE_gsoap_eml2_1_prodml2__AbstractDtsEquipment (32)
#endif

/* prodml2__DasTimeArray has binding name 'prodml2__DasTimeArray' for type 'prodml2:DasTimeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasTimeArray (31)
#endif

/* prodml2__DasSpectraData has binding name 'prodml2__DasSpectraData' for type 'prodml2:DasSpectraData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectraData (30)
#endif

/* prodml2__DasSpectra has binding name 'prodml2__DasSpectra' for type 'prodml2:DasSpectra' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasSpectra (29)
#endif

/* prodml2__DasRawData has binding name 'prodml2__DasRawData' for type 'prodml2:DasRawData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasRawData (28)
#endif

/* prodml2__DasRaw has binding name 'prodml2__DasRaw' for type 'prodml2:DasRaw' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasRaw (27)
#endif

/* prodml2__DasProcessed has binding name 'prodml2__DasProcessed' for type 'prodml2:DasProcessed' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasProcessed (26)
#endif

/* prodml2__DasInstrumentBox has binding name 'prodml2__DasInstrumentBox' for type 'prodml2:DasInstrumentBox' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasInstrumentBox (25)
#endif

/* prodml2__DasFbeData has binding name 'prodml2__DasFbeData' for type 'prodml2:DasFbeData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbeData (24)
#endif

/* prodml2__DasFbe has binding name 'prodml2__DasFbe' for type 'prodml2:DasFbe' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasFbe (23)
#endif

/* prodml2__DasExternalDatasetPart has binding name 'prodml2__DasExternalDatasetPart' for type 'prodml2:DasExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasExternalDatasetPart (22)
#endif

/* prodml2__DasCustom has binding name 'prodml2__DasCustom' for type 'prodml2:DasCustom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCustom (21)
#endif

/* prodml2__DasCalibrationPoint has binding name 'prodml2__DasCalibrationPoint' for type 'prodml2:DasCalibrationPoint' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibrationPoint (20)
#endif

/* prodml2__DasCalibration has binding name 'prodml2__DasCalibration' for type 'prodml2:DasCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasCalibration (19)
#endif

/* prodml2__DasAcquisition has binding name 'prodml2__DasAcquisition' for type 'prodml2:DasAcquisition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition
#define SOAP_TYPE_gsoap_eml2_1_prodml2__DasAcquisition (18)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__date
#define SOAP_TYPE_gsoap_eml2_1_xsd__date (17)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__anyURI
#define SOAP_TYPE_gsoap_eml2_1_xsd__anyURI (16)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_gsoap_eml2_1_xsd__ID
#define SOAP_TYPE_gsoap_eml2_1_xsd__ID (15)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__string
#define SOAP_TYPE_gsoap_eml2_1_std__string (14)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Fault (1785)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Reason (1784)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Detail (1781)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Code (1779)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_eml2_1_SOAP_ENV__Header (1778)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Reason (1787)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Detail (1786)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Code
#define SOAP_TYPE_gsoap_eml2_1_PointerToSOAP_ENV__Code (1780)
#endif

/* gml__GeodeticCRSPropertyType * has binding name 'PointerTogml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticCRSPropertyType (1688)
#endif

/* gml__VerticalDatumPropertyType * has binding name 'PointerTogml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalDatumPropertyType (1687)
#endif

/* gml__VerticalCSPropertyType * has binding name 'PointerTogml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCSPropertyType (1686)
#endif

/* gml__GeneralConversionPropertyType * has binding name 'PointerTogml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeneralConversionPropertyType (1685)
#endif

/* gml__EllipsoidPropertyType * has binding name 'PointerTogml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidPropertyType (1684)
#endif

/* gml__PrimeMeridianPropertyType * has binding name 'PointerTogml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__PrimeMeridianPropertyType (1683)
#endif

/* gml__GeodeticDatumPropertyType * has binding name 'PointerTogml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticDatumPropertyType (1682)
#endif

/* gml__SphericalCSPropertyType * has binding name 'PointerTogml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__SphericalCSPropertyType (1680)
#endif

/* gml__CartesianCSPropertyType * has binding name 'PointerTogml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CartesianCSPropertyType (1679)
#endif

/* gml__EllipsoidalCSPropertyType * has binding name 'PointerTogml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidalCSPropertyType (1678)
#endif

/* gml__CRSPropertyType * has binding name 'PointerTogml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CRSPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CRSPropertyType (1677)
#endif

/* _gml__coordinateOperationAccuracy * has binding name 'PointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__coordinateOperationAccuracy (1675)
#endif

/* _gml__secondDefiningParameter * has binding name 'PointerTo_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__secondDefiningParameter (1674)
#endif

/* gml__AngleType * has binding name 'PointerTogml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__AngleType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__AngleType (1673)
#endif

/* enum gml__AggregationType * has binding name 'PointerTogml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__AggregationType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__AggregationType (1672)
#endif

/* gml__CoordinateSystemAxisPropertyType * has binding name 'PointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CoordinateSystemAxisPropertyType (1670)
#endif

/* _gml__domainOfValidity * has binding name 'PointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__domainOfValidity
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__domainOfValidity (1667)
#endif

/* enum eml21__UnitOfMeasure * has binding name 'PointerToeml21__UnitOfMeasure' for type 'eml21:UnitOfMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UnitOfMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UnitOfMeasure (1666)
#endif

/* eml21__IntegerConstantArray * has binding name 'PointerToeml21__IntegerConstantArray' for type 'eml21:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IntegerConstantArray (1664)
#endif

/* eml21__AbstractBooleanArray * has binding name 'PointerToeml21__AbstractBooleanArray' for type 'eml21:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractBooleanArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractBooleanArray (1663)
#endif

/* eml21__FloatingPointConstantArray * has binding name 'PointerToeml21__FloatingPointConstantArray' for type 'eml21:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FloatingPointConstantArray (1661)
#endif

/* gml__RelatedTimeType * has binding name 'PointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__RelatedTimeType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__RelatedTimeType (1659)
#endif

/* enum eml21__ReferencePressureKind * has binding name 'PointerToeml21__ReferencePressureKind' for type 'eml21:ReferencePressureKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferencePressureKind
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferencePressureKind (1658)
#endif

/* eml21__ExternalDataset * has binding name 'PointerToeml21__ExternalDataset' for type 'eml21:ExternalDataset' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExternalDataset
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExternalDataset (1657)
#endif

/* enum eml21__PlaneAngleUom * has binding name 'PointerToeml21__PlaneAngleUom' for type 'eml21:PlaneAngleUom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PlaneAngleUom
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PlaneAngleUom (1656)
#endif

/* prodml2__FiberOneWayAttenuation * has binding name 'PointerToprodml2__FiberOneWayAttenuation' for type 'prodml2:FiberOneWayAttenuation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOneWayAttenuation
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOneWayAttenuation (1654)
#endif

/* prodml2__FiberConveyance * has binding name 'PointerToprodml2__FiberConveyance' for type 'prodml2:FiberConveyance' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberConveyance
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberConveyance (1653)
#endif

/* prodml2__FiberRefractiveIndex * has binding name 'PointerToprodml2__FiberRefractiveIndex' for type 'prodml2:FiberRefractiveIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberRefractiveIndex
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberRefractiveIndex (1651)
#endif

/* enum prodml2__CableType * has binding name 'PointerToprodml2__CableType' for type 'prodml2:CableType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CableType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CableType (1650)
#endif

/* enum prodml2__FiberMode * has binding name 'PointerToprodml2__FiberMode' for type 'prodml2:FiberMode' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberMode
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberMode (1649)
#endif

/* enum prodml2__FiberEndType * has binding name 'PointerToprodml2__FiberEndType' for type 'prodml2:FiberEndType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberEndType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberEndType (1647)
#endif

/* gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (1645)
#endif

/* gmd__URL_USCOREPropertyType * has binding name 'PointerTogmd__URL_USCOREPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__URL_USCOREPropertyType (1644)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType (1643)
#endif

/* gmd__CI_USCOREAddress_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREAddress_USCOREPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREAddress_USCOREPropertyType (1642)
#endif

/* gmd__CI_USCORETelephone_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORETelephone_USCOREPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORETelephone_USCOREPropertyType (1641)
#endif

/* gmd__CI_USCORERoleCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORERoleCode_USCOREPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORERoleCode_USCOREPropertyType (1640)
#endif

/* gmd__CI_USCOREContact_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREContact_USCOREPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREContact_USCOREPropertyType (1639)
#endif

/* gmd__CI_USCOREDateTypeCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType (1638)
#endif

/* gmd__CI_USCORESeries_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORESeries_USCOREPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORESeries_USCOREPropertyType (1637)
#endif

/* gmd__CI_USCOREPresentationFormCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType (1635)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType (1633)
#endif

/* gco__Date_USCOREPropertyType * has binding name 'PointerTogco__Date_USCOREPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__Date_USCOREPropertyType (1631)
#endif

/* gmd__CI_USCOREDate_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDate_USCOREPropertyType (1629)
#endif

/* gmd__DQ_USCOREResult_USCOREPropertyType * has binding name 'PointerTogmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__DQ_USCOREResult_USCOREPropertyType (1627)
#endif

/* gco__DateTime_USCOREPropertyType * has binding name 'PointerTogco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__DateTime_USCOREPropertyType (1625)
#endif

/* gmd__CI_USCORECitation_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORECitation_USCOREPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORECitation_USCOREPropertyType (1624)
#endif

/* gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType * has binding name 'PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (1623)
#endif

/* gmd__MD_USCOREIdentifier_USCOREPropertyType * has binding name 'PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType (1622)
#endif

/* gsr__SC_USCORECRS_USCOREPropertyType * has binding name 'PointerTogsr__SC_USCORECRS_USCOREPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogsr__SC_USCORECRS_USCOREPropertyType (1620)
#endif

/* gco__Real_USCOREPropertyType * has binding name 'PointerTogco__Real_USCOREPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__Real_USCOREPropertyType (1619)
#endif

/* gts__TM_USCOREPrimitive_USCOREPropertyType * has binding name 'PointerTogts__TM_USCOREPrimitive_USCOREPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogts__TM_USCOREPrimitive_USCOREPropertyType (1618)
#endif

/* gco__Boolean_USCOREPropertyType * has binding name 'PointerTogco__Boolean_USCOREPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__Boolean_USCOREPropertyType (1617)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType (1615)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType (1613)
#endif

/* gmd__EX_USCOREGeographicExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType (1611)
#endif

/* gco__CharacterString_USCOREPropertyType * has binding name 'PointerTogco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__CharacterString_USCOREPropertyType (1610)
#endif

/* enum _gml__RelatedTimeType_relativePosition * has binding name 'PointerTo_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__RelatedTimeType_relativePosition (1609)
#endif

/* eml21__AbstractGraphicalInformation * has binding name 'PointerToeml21__AbstractGraphicalInformation' for type 'eml21:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractGraphicalInformation (1606)
#endif

/* eml21__IndexRange * has binding name 'PointerToeml21__IndexRange' for type 'eml21:IndexRange' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IndexRange
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IndexRange (1605)
#endif

/* eml21__FailingRule * has binding name 'PointerToeml21__FailingRule' for type 'eml21:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FailingRule
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FailingRule (1603)
#endif

/* gml__VerticalCRSType * has binding name 'PointerTogml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCRSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCRSType (1602)
#endif

/* eml21__AbstractVerticalCrs * has binding name 'PointerToeml21__AbstractVerticalCrs' for type 'eml21:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractVerticalCrs (1601)
#endif

/* gml__ProjectedCRSType * has binding name 'PointerTogml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__ProjectedCRSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__ProjectedCRSType (1600)
#endif

/* std::string * has binding name 'PointerToeml21__LengthUomExt' for type 'eml21:LengthUomExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthUomExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthUomExt (1599)
#endif

/* eml21__AbstractProjectedCrs * has binding name 'PointerToeml21__AbstractProjectedCrs' for type 'eml21:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractProjectedCrs (1598)
#endif

/* eml21__AuthorityQualifiedName * has binding name 'PointerToeml21__AuthorityQualifiedName' for type 'eml21:AuthorityQualifiedName' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AuthorityQualifiedName
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AuthorityQualifiedName (1597)
#endif

/* eml21__AbstractGeodeticCrs * has binding name 'PointerToeml21__AbstractGeodeticCrs' for type 'eml21:AbstractGeodeticCrs' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractGeodeticCrs
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractGeodeticCrs (1596)
#endif

/* std::string * has binding name 'PointerToeml21__ReferenceConditionExt' for type 'eml21:ReferenceConditionExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferenceConditionExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferenceConditionExt (1594)
#endif

/* eml21__ReferencePressure * has binding name 'PointerToeml21__ReferencePressure' for type 'eml21:ReferencePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferencePressure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferencePressure (1593)
#endif

/* eml21__PressureMeasureExt * has binding name 'PointerToeml21__PressureMeasureExt' for type 'eml21:PressureMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PressureMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PressureMeasureExt (1592)
#endif

/* eml21__TimeSeriesParentage * has binding name 'PointerToeml21__TimeSeriesParentage' for type 'eml21:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeSeriesParentage
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeSeriesParentage (1591)
#endif

/* eml21__GeologicTime * has binding name 'PointerToeml21__GeologicTime' for type 'eml21:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__GeologicTime
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__GeologicTime (1589)
#endif

/* eml21__PropertyKind * has binding name 'PointerToeml21__PropertyKind' for type 'eml21:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PropertyKind (1587)
#endif

/* eml21__ParameterTemplate * has binding name 'PointerToeml21__ParameterTemplate' for type 'eml21:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ParameterTemplate (1585)
#endif

/* prodml2__FiberOTDR * has binding name 'PointerToprodml2__FiberOTDR' for type 'prodml2:FiberOTDR' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOTDR
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOTDR (1583)
#endif

/* prodml2__FiberPathDefect * has binding name 'PointerToprodml2__FiberPathDefect' for type 'prodml2:FiberPathDefect' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberPathDefect
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberPathDefect (1581)
#endif

/* prodml2__FiberFacilityMapping * has binding name 'PointerToprodml2__FiberFacilityMapping' for type 'prodml2:FiberFacilityMapping' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberFacilityMapping
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberFacilityMapping (1579)
#endif

/* prodml2__FiberOpticalPathNetwork * has binding name 'PointerToprodml2__FiberOpticalPathNetwork' for type 'prodml2:FiberOpticalPathNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathNetwork
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathNetwork (1577)
#endif

/* prodml2__FiberOpticalPathInventory * has binding name 'PointerToprodml2__FiberOpticalPathInventory' for type 'prodml2:FiberOpticalPathInventory' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathInventory
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathInventory (1576)
#endif

/* prodml2__FiberPumpActivity * has binding name 'PointerToprodml2__FiberPumpActivity' for type 'prodml2:FiberPumpActivity' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberPumpActivity
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberPumpActivity (1574)
#endif

/* prodml2__KindQualifiedString * has binding name 'PointerToprodml2__KindQualifiedString' for type 'prodml2:KindQualifiedString' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__KindQualifiedString
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__KindQualifiedString (1572)
#endif

/* __prodml2__ReferenceFlow_sequence * has binding name 'PointerTo__prodml2__ReferenceFlow_sequence' for type '-prodml2:ReferenceFlow-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__ReferenceFlow_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__ReferenceFlow_sequence (1571)
#endif

/* prodml2__ProductVolumeFacility * has binding name 'PointerToprodml2__ProductVolumeFacility' for type 'prodml2:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeFacility (1567)
#endif

/* enum eml21__ReferenceCondition * has binding name 'PointerToeml21__ReferenceCondition' for type 'eml21:ReferenceCondition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferenceCondition
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ReferenceCondition (1566)
#endif

/* enum prodml2__CalculationMethod * has binding name 'PointerToprodml2__CalculationMethod' for type 'prodml2:CalculationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalculationMethod
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalculationMethod (1565)
#endif

/* prodml2__IntegerQualifiedCount * has binding name 'PointerToprodml2__IntegerQualifiedCount' for type 'prodml2:IntegerQualifiedCount' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__IntegerQualifiedCount
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__IntegerQualifiedCount (1564)
#endif

/* __prodml2__FacilityUnitPort_sequence * has binding name 'PointerTo__prodml2__FacilityUnitPort_sequence' for type '-prodml2:FacilityUnitPort-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__FacilityUnitPort_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__FacilityUnitPort_sequence (1563)
#endif

/* __prodml2__FacilityParent_sequence * has binding name 'PointerTo__prodml2__FacilityParent_sequence' for type '-prodml2:FacilityParent-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__FacilityParent_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__FacilityParent_sequence (1561)
#endif

/* eml21__APIGravityMeasure * has binding name 'PointerToeml21__APIGravityMeasure' for type 'eml21:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__APIGravityMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__APIGravityMeasure (1557)
#endif

/* __prodml2__PureFluidComponent_sequence * has binding name 'PointerTo__prodml2__PureFluidComponent_sequence' for type '-prodml2:PureFluidComponent-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PureFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PureFluidComponent_sequence (1556)
#endif

/* __prodml2__PseudoFluidComponent_sequence * has binding name 'PointerTo__prodml2__PseudoFluidComponent_sequence' for type '-prodml2:PseudoFluidComponent-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PseudoFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PseudoFluidComponent_sequence (1554)
#endif

/* __prodml2__PlusFluidComponent_sequence * has binding name 'PointerTo__prodml2__PlusFluidComponent_sequence' for type '-prodml2:PlusFluidComponent-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PlusFluidComponent_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__PlusFluidComponent_sequence (1552)
#endif

/* eml21__EnergyPerMassMeasure * has binding name 'PointerToeml21__EnergyPerMassMeasure' for type 'eml21:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyPerMassMeasure (1550)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTodouble
#define SOAP_TYPE_gsoap_eml2_1_PointerTodouble (1549)
#endif

/* prodml2__DtsCalibration * has binding name 'PointerToprodml2__DtsCalibration' for type 'prodml2:DtsCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DtsCalibration
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DtsCalibration (1547)
#endif

/* prodml2__DtsPatchCord * has binding name 'PointerToprodml2__DtsPatchCord' for type 'prodml2:DtsPatchCord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DtsPatchCord
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DtsPatchCord (1546)
#endif

/* prodml2__Instrument * has binding name 'PointerToprodml2__Instrument' for type 'prodml2:Instrument' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__Instrument
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__Instrument (1545)
#endif

/* prodml2__FacilityIdentifier * has binding name 'PointerToprodml2__FacilityIdentifier' for type 'prodml2:FacilityIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityIdentifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityIdentifier (1544)
#endif

/* prodml2__IndexedObject * has binding name 'PointerToprodml2__IndexedObject' for type 'prodml2:IndexedObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__IndexedObject
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__IndexedObject (1542)
#endif

/* __prodml2__DasExternalDatasetPart_sequence * has binding name 'PointerTo__prodml2__DasExternalDatasetPart_sequence' for type '-prodml2:DasExternalDatasetPart-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DasExternalDatasetPart_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DasExternalDatasetPart_sequence (1541)
#endif

/* prodml2__DasProcessed * has binding name 'PointerToprodml2__DasProcessed' for type 'prodml2:DasProcessed' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasProcessed
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasProcessed (1539)
#endif

/* prodml2__DasCalibration * has binding name 'PointerToprodml2__DasCalibration' for type 'prodml2:DasCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibration
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibration (1537)
#endif

/* prodml2__DasRaw * has binding name 'PointerToprodml2__DasRaw' for type 'prodml2:DasRaw' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasRaw
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasRaw (1535)
#endif

/* __gsr__SC_USCORECRS_USCOREPropertyType_sequence * has binding name 'PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence' for type '-gsr:SC_CRS_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence (1534)
#endif

/* __gco__DateTime_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__DateTime_USCOREPropertyType_sequence' for type '-gco:DateTime_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__DateTime_USCOREPropertyType_sequence (1531)
#endif

/* std::string * has binding name 'PointerTogco__Date_USCOREType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__Date_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__Date_USCOREType (1528)
#endif

/* __gco__Real_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__Real_USCOREPropertyType_sequence' for type '-gco:Real_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__Real_USCOREPropertyType_sequence (1527)
#endif

/* __gco__Boolean_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__Boolean_USCOREPropertyType_sequence' for type '-gco:Boolean_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__Boolean_USCOREPropertyType_sequence (1525)
#endif

/* __gco__CharacterString_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__CharacterString_USCOREPropertyType_sequence' for type '-gco:CharacterString_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gco__CharacterString_USCOREPropertyType_sequence (1523)
#endif

/* std::string * has binding name 'PointerToxsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToxsd__ID
#define SOAP_TYPE_gsoap_eml2_1_PointerToxsd__ID (1520)
#endif

/* __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence * has binding name 'PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence' for type '-gts:TM_Primitive_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (1519)
#endif

/* __gmd__DQ_USCOREResult_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence' for type '-gmd:DQ_Result_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence (1516)
#endif

/* __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence' for type '-gmd:DQ_EvaluationMethodTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (1513)
#endif

/* __gmd__CI_USCORESeries_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence' for type '-gmd:CI_Series_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence (1511)
#endif

/* gmd__CI_USCORESeries_USCOREType * has binding name 'PointerTogmd__CI_USCORESeries_USCOREType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORESeries_USCOREType (1510)
#endif

/* __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence' for type '-gmd:CI_PresentationFormCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (1508)
#endif

/* __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence' for type '-gmd:CI_RoleCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (1506)
#endif

/* __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence' for type '-gmd:CI_OnLineFunctionCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (1504)
#endif

/* __gmd__URL_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__URL_USCOREPropertyType_sequence' for type '-gmd:URL_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__URL_USCOREPropertyType_sequence (1502)
#endif

/* __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence' for type '-gmd:CI_OnlineResource_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (1500)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREType * has binding name 'PointerTogmd__CI_USCOREOnlineResource_USCOREType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREOnlineResource_USCOREType (1499)
#endif

/* __gmd__CI_USCOREAddress_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence' for type '-gmd:CI_Address_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence (1497)
#endif

/* gmd__CI_USCOREAddress_USCOREType * has binding name 'PointerTogmd__CI_USCOREAddress_USCOREType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREAddress_USCOREType (1496)
#endif

/* __gmd__CI_USCORETelephone_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence' for type '-gmd:CI_Telephone_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence (1494)
#endif

/* gmd__CI_USCORETelephone_USCOREType * has binding name 'PointerTogmd__CI_USCORETelephone_USCOREType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORETelephone_USCOREType (1493)
#endif

/* __gmd__CI_USCOREContact_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence' for type '-gmd:CI_Contact_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence (1491)
#endif

/* gmd__CI_USCOREContact_USCOREType * has binding name 'PointerTogmd__CI_USCOREContact_USCOREType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREContact_USCOREType (1490)
#endif

/* __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence' for type '-gmd:CI_ResponsibleParty_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (1488)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREType * has binding name 'PointerTogmd__CI_USCOREResponsibleParty_USCOREType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREType (1487)
#endif

/* __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence' for type '-gmd:CI_DateTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (1485)
#endif

/* gco__CodeListValue_USCOREType * has binding name 'PointerTogco__CodeListValue_USCOREType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogco__CodeListValue_USCOREType (1484)
#endif

/* __gmd__CI_USCOREDate_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence' for type '-gmd:CI_Date_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence (1482)
#endif

/* gmd__CI_USCOREDate_USCOREType * has binding name 'PointerTogmd__CI_USCOREDate_USCOREType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCOREDate_USCOREType (1481)
#endif

/* __gmd__CI_USCORECitation_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence' for type '-gmd:CI_Citation_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence (1479)
#endif

/* gmd__CI_USCORECitation_USCOREType * has binding name 'PointerTogmd__CI_USCORECitation_USCOREType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__CI_USCORECitation_USCOREType (1478)
#endif

/* __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence' for type '-gmd:MD_Identifier_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (1476)
#endif

/* gmd__MD_USCOREIdentifier_USCOREType * has binding name 'PointerTogmd__MD_USCOREIdentifier_USCOREType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__MD_USCOREIdentifier_USCOREType (1475)
#endif

/* __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence' for type '-gmd:EX_VerticalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (1473)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREType * has binding name 'PointerTogmd__EX_USCOREVerticalExtent_USCOREType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREType (1472)
#endif

/* __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence' for type '-gmd:EX_TemporalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (1470)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREType * has binding name 'PointerTogmd__EX_USCORETemporalExtent_USCOREType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCORETemporalExtent_USCOREType (1469)
#endif

/* __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence' for type '-gmd:EX_GeographicExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (1467)
#endif

/* __gml__coordinateOperationAccuracy_sequence * has binding name 'PointerTo__gml__coordinateOperationAccuracy_sequence' for type '-gml:coordinateOperationAccuracy-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__coordinateOperationAccuracy_sequence (1464)
#endif

/* gml__LengthType * has binding name 'PointerTogml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__LengthType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__LengthType (1460)
#endif

/* gml__MeasureType * has binding name 'PointerTogml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__MeasureType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__MeasureType (1459)
#endif

/* _gml__SecondDefiningParameter * has binding name 'PointerTo_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_gml__SecondDefiningParameter (1458)
#endif

/* __gml__domainOfValidity_sequence * has binding name 'PointerTo__gml__domainOfValidity_sequence' for type '-gml:domainOfValidity-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__domainOfValidity_sequence (1457)
#endif

/* gmd__EX_USCOREExtent_USCOREType * has binding name 'PointerTogmd__EX_USCOREExtent_USCOREType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogmd__EX_USCOREExtent_USCOREType (1456)
#endif

/* __gml__VerticalDatumPropertyType_sequence * has binding name 'PointerTo__gml__VerticalDatumPropertyType_sequence' for type '-gml:VerticalDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__VerticalDatumPropertyType_sequence (1454)
#endif

/* gml__VerticalDatumType * has binding name 'PointerTogml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalDatumType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalDatumType (1453)
#endif

/* __gml__VerticalCSPropertyType_sequence * has binding name 'PointerTo__gml__VerticalCSPropertyType_sequence' for type '-gml:VerticalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__VerticalCSPropertyType_sequence (1451)
#endif

/* gml__VerticalCSType * has binding name 'PointerTogml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__VerticalCSType (1450)
#endif

/* __gml__GeodeticCRSPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticCRSPropertyType_sequence' for type '-gml:GeodeticCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeodeticCRSPropertyType_sequence (1448)
#endif

/* gml__GeodeticCRSType * has binding name 'PointerTogml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticCRSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticCRSType (1447)
#endif

/* __gml__CRSPropertyType_sequence * has binding name 'PointerTo__gml__CRSPropertyType_sequence' for type '-gml:CRSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CRSPropertyType_sequence (1445)
#endif

/* __gml__GeneralConversionPropertyType_sequence * has binding name 'PointerTo__gml__GeneralConversionPropertyType_sequence' for type '-gml:GeneralConversionPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeneralConversionPropertyType_sequence (1442)
#endif

/* __gml__EllipsoidPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidPropertyType_sequence' for type '-gml:EllipsoidPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__EllipsoidPropertyType_sequence (1439)
#endif

/* gml__EllipsoidType * has binding name 'PointerTogml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidType (1438)
#endif

/* __gml__PrimeMeridianPropertyType_sequence * has binding name 'PointerTo__gml__PrimeMeridianPropertyType_sequence' for type '-gml:PrimeMeridianPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__PrimeMeridianPropertyType_sequence (1436)
#endif

/* gml__PrimeMeridianType * has binding name 'PointerTogml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__PrimeMeridianType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__PrimeMeridianType (1435)
#endif

/* __gml__GeodeticDatumPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticDatumPropertyType_sequence' for type '-gml:GeodeticDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__GeodeticDatumPropertyType_sequence (1433)
#endif

/* gml__GeodeticDatumType * has binding name 'PointerTogml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticDatumType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__GeodeticDatumType (1432)
#endif

/* __gml__SphericalCSPropertyType_sequence * has binding name 'PointerTo__gml__SphericalCSPropertyType_sequence' for type '-gml:SphericalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__SphericalCSPropertyType_sequence (1430)
#endif

/* gml__SphericalCSType * has binding name 'PointerTogml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__SphericalCSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__SphericalCSType (1429)
#endif

/* __gml__CartesianCSPropertyType_sequence * has binding name 'PointerTo__gml__CartesianCSPropertyType_sequence' for type '-gml:CartesianCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CartesianCSPropertyType_sequence (1427)
#endif

/* gml__CartesianCSType * has binding name 'PointerTogml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CartesianCSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CartesianCSType (1426)
#endif

/* __gml__CoordinateSystemAxisPropertyType_sequence * has binding name 'PointerTo__gml__CoordinateSystemAxisPropertyType_sequence' for type '-gml:CoordinateSystemAxisPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence (1424)
#endif

/* gml__CoordinateSystemAxisType * has binding name 'PointerTogml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CoordinateSystemAxisType (1423)
#endif

/* __gml__EllipsoidalCSPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidalCSPropertyType_sequence' for type '-gml:EllipsoidalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__EllipsoidalCSPropertyType_sequence (1421)
#endif

/* gml__EllipsoidalCSType * has binding name 'PointerTogml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__EllipsoidalCSType (1420)
#endif

/* __gml__TimePrimitivePropertyType_sequence * has binding name 'PointerTo__gml__TimePrimitivePropertyType_sequence' for type '-gml:TimePrimitivePropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__gml__TimePrimitivePropertyType_sequence (1418)
#endif

/* enum _xlink__actuate * has binding name 'PointerTo_xlink__actuate' for type 'xlink:actuate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_xlink__actuate
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_xlink__actuate (1415)
#endif

/* enum _xlink__show * has binding name 'PointerTo_xlink__show' for type 'xlink:show' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo_xlink__show
#define SOAP_TYPE_gsoap_eml2_1_PointerTo_xlink__show (1414)
#endif

/* std::string * has binding name 'PointerTogml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__NilReasonType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__NilReasonType (1413)
#endif

/* gml__CodeType * has binding name 'PointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CodeType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CodeType (1411)
#endif

/* gml__CodeWithAuthorityType * has binding name 'PointerTogml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__CodeWithAuthorityType (1410)
#endif

/* gml__ReferenceType * has binding name 'PointerTogml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__ReferenceType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__ReferenceType (1409)
#endif

/* gml__StringOrRefType * has binding name 'PointerTogml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTogml__StringOrRefType
#define SOAP_TYPE_gsoap_eml2_1_PointerTogml__StringOrRefType (1408)
#endif

/* eml21__VolumeMeasureExt * has binding name 'PointerToeml21__VolumeMeasureExt' for type 'eml21:VolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeMeasureExt (1407)
#endif

/* eml21__AbstractPressureValue * has binding name 'PointerToeml21__AbstractPressureValue' for type 'eml21:AbstractPressureValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractPressureValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractPressureValue (1406)
#endif

/* eml21__VolumePerTimeMeasureExt * has binding name 'PointerToeml21__VolumePerTimeMeasureExt' for type 'eml21:VolumePerTimeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumePerTimeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumePerTimeMeasureExt (1405)
#endif

/* eml21__AbstractTemperaturePressure * has binding name 'PointerToeml21__AbstractTemperaturePressure' for type 'eml21:AbstractTemperaturePressure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractTemperaturePressure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractTemperaturePressure (1404)
#endif

/* eml21__MassPerVolumeMeasureExt * has binding name 'PointerToeml21__MassPerVolumeMeasureExt' for type 'eml21:MassPerVolumeMeasureExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerVolumeMeasureExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerVolumeMeasureExt (1403)
#endif

/* eml21__TimeIndex * has binding name 'PointerToeml21__TimeIndex' for type 'eml21:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeIndex
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeIndex (1401)
#endif

/* eml21__AbstractActivityParameter * has binding name 'PointerToeml21__AbstractActivityParameter' for type 'eml21:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractActivityParameter (1399)
#endif

/* eml21__AbstractParameterKey * has binding name 'PointerToeml21__AbstractParameterKey' for type 'eml21:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractParameterKey (1395)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToLONG64
#define SOAP_TYPE_gsoap_eml2_1_PointerToLONG64 (1394)
#endif

/* eml21__DataObjectReference * has binding name 'PointerToeml21__DataObjectReference' for type 'eml21:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DataObjectReference
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DataObjectReference (1393)
#endif

/* eml21__ExternalDatasetPart * has binding name 'PointerToeml21__ExternalDatasetPart' for type 'eml21:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExternalDatasetPart (1391)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToxsd__anyURI
#define SOAP_TYPE_gsoap_eml2_1_PointerToxsd__anyURI (1390)
#endif

/* eml21__AbstractIntegerArray * has binding name 'PointerToeml21__AbstractIntegerArray' for type 'eml21:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractIntegerArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractIntegerArray (1389)
#endif

/* eml21__AbstractValueArray * has binding name 'PointerToeml21__AbstractValueArray' for type 'eml21:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractValueArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractValueArray (1388)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToint
#define SOAP_TYPE_gsoap_eml2_1_PointerToint (1387)
#endif

/* eml21__StringMeasure * has binding name 'PointerToeml21__StringMeasure' for type 'eml21:StringMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__StringMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__StringMeasure (1386)
#endif

/* enum eml21__ExistenceKind * has binding name 'PointerToeml21__ExistenceKind' for type 'eml21:ExistenceKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExistenceKind
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExistenceKind (1384)
#endif

/* eml21__CustomData * has binding name 'PointerToeml21__CustomData' for type 'eml21:CustomData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__CustomData
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__CustomData (1383)
#endif

/* eml21__Citation * has binding name 'PointerToeml21__Citation' for type 'eml21:Citation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__Citation
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__Citation (1382)
#endif

/* eml21__ObjectAlias * has binding name 'PointerToeml21__ObjectAlias' for type 'eml21:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ObjectAlias (1380)
#endif

/* prodml2__FiberOTDRInstrumentBox * has binding name 'PointerToprodml2__FiberOTDRInstrumentBox' for type 'prodml2:FiberOTDRInstrumentBox' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOTDRInstrumentBox
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOTDRInstrumentBox (1377)
#endif

/* enum prodml2__OTDRReason * has binding name 'PointerToprodml2__OTDRReason' for type 'prodml2:OTDRReason' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OTDRReason
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OTDRReason (1376)
#endif

/* prodml2__ProductFlowNetwork * has binding name 'PointerToprodml2__ProductFlowNetwork' for type 'prodml2:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowNetwork (1374)
#endif

/* prodml2__ProductFlowExternalReference * has binding name 'PointerToprodml2__ProductFlowExternalReference' for type 'prodml2:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExternalReference (1372)
#endif

/* prodml2__EndpointQualifiedDateTime * has binding name 'PointerToprodml2__EndpointQualifiedDateTime' for type 'prodml2:EndpointQualifiedDateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EndpointQualifiedDateTime
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EndpointQualifiedDateTime (1371)
#endif

/* prodml2__FiberSplice * has binding name 'PointerToprodml2__FiberSplice' for type 'prodml2:FiberSplice' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberSplice
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberSplice (1369)
#endif

/* prodml2__FiberTerminator * has binding name 'PointerToprodml2__FiberTerminator' for type 'prodml2:FiberTerminator' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberTerminator
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberTerminator (1368)
#endif

/* prodml2__FiberOpticalPathSegment * has binding name 'PointerToprodml2__FiberOpticalPathSegment' for type 'prodml2:FiberOpticalPathSegment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathSegment
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberOpticalPathSegment (1366)
#endif

/* prodml2__FiberTurnaround * has binding name 'PointerToprodml2__FiberTurnaround' for type 'prodml2:FiberTurnaround' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberTurnaround
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberTurnaround (1364)
#endif

/* prodml2__FiberConnection * has binding name 'PointerToprodml2__FiberConnection' for type 'prodml2:FiberConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberConnection
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberConnection (1362)
#endif

/* prodml2__AbstractAttenuationMeasure * has binding name 'PointerToprodml2__AbstractAttenuationMeasure' for type 'prodml2:AbstractAttenuationMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractAttenuationMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractAttenuationMeasure (1361)
#endif

/* eml21__LogarithmicPowerRatioPerLengthMeasure * has binding name 'PointerToeml21__LogarithmicPowerRatioPerLengthMeasure' for type 'eml21:LogarithmicPowerRatioPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LogarithmicPowerRatioPerLengthMeasure (1360)
#endif

/* prodml2__AbstractFiberFacility * has binding name 'PointerToprodml2__AbstractFiberFacility' for type 'prodml2:AbstractFiberFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractFiberFacility
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractFiberFacility (1359)
#endif

/* prodml2__FiberFacilityMappingPart * has binding name 'PointerToprodml2__FiberFacilityMappingPart' for type 'prodml2:FiberFacilityMappingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberFacilityMappingPart
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FiberFacilityMappingPart (1357)
#endif

/* prodml2__AbstractCable * has binding name 'PointerToprodml2__AbstractCable' for type 'prodml2:AbstractCable' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractCable
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractCable (1356)
#endif

/* prodml2__RelativeCoordinate * has binding name 'PointerToprodml2__RelativeCoordinate' for type 'prodml2:RelativeCoordinate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__RelativeCoordinate
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__RelativeCoordinate (1355)
#endif

/* prodml2__ProductFlowPort * has binding name 'PointerToprodml2__ProductFlowPort' for type 'prodml2:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowPort (1353)
#endif

/* prodml2__ConnectedNode * has binding name 'PointerToprodml2__ConnectedNode' for type 'prodml2:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ConnectedNode (1350)
#endif

/* prodml2__ProductFlowExpectedUnitProperty * has binding name 'PointerToprodml2__ProductFlowExpectedUnitProperty' for type 'prodml2:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExpectedUnitProperty (1348)
#endif

/* prodml2__ProductFlowQualifierExpected * has binding name 'PointerToprodml2__ProductFlowQualifierExpected' for type 'prodml2:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowQualifierExpected (1346)
#endif

/* prodml2__ExpectedFlowQualifier * has binding name 'PointerToprodml2__ExpectedFlowQualifier' for type 'prodml2:ExpectedFlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ExpectedFlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ExpectedFlowQualifier (1345)
#endif

/* prodml2__GeneralMeasureType * has binding name 'PointerToprodml2__GeneralMeasureType' for type 'prodml2:GeneralMeasureType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeneralMeasureType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeneralMeasureType (1344)
#endif

/* __prodml2__ProductVolumeRelatedFacility_sequence * has binding name 'PointerTo__prodml2__ProductVolumeRelatedFacility_sequence' for type '-prodml2:ProductVolumeRelatedFacility-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__ProductVolumeRelatedFacility_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__ProductVolumeRelatedFacility_sequence (1343)
#endif

/* prodml2__AbstractRelatedFacilityObject * has binding name 'PointerToprodml2__AbstractRelatedFacilityObject' for type 'prodml2:AbstractRelatedFacilityObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractRelatedFacilityObject
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractRelatedFacilityObject (1342)
#endif

/* prodml2__ProductVolumePeriod * has binding name 'PointerToprodml2__ProductVolumePeriod' for type 'prodml2:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumePeriod (1339)
#endif

/* prodml2__AbstractRefProductFlow * has binding name 'PointerToprodml2__AbstractRefProductFlow' for type 'prodml2:AbstractRefProductFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractRefProductFlow
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractRefProductFlow (1338)
#endif

/* float * has binding name 'PointerToprodml2__NonNegativeFraction' for type 'prodml2:NonNegativeFraction' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NonNegativeFraction
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NonNegativeFraction (1337)
#endif

/* eml21__LengthPerLengthMeasure * has binding name 'PointerToeml21__LengthPerLengthMeasure' for type 'eml21:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthPerLengthMeasure (1336)
#endif

/* prodml2__AbstractDateTimeClass * has binding name 'PointerToprodml2__AbstractDateTimeClass' for type 'prodml2:AbstractDateTimeClass' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractDateTimeClass
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractDateTimeClass (1335)
#endif

/* prodml2__ProductVolumeBalanceSet * has binding name 'PointerToprodml2__ProductVolumeBalanceSet' for type 'prodml2:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceSet (1333)
#endif

/* prodml2__AbstractMeasureDataType * has binding name 'PointerToprodml2__AbstractMeasureDataType' for type 'prodml2:AbstractMeasureDataType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractMeasureDataType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AbstractMeasureDataType (1331)
#endif

/* prodml2__ProductVolumeAlert * has binding name 'PointerToprodml2__ProductVolumeAlert' for type 'prodml2:ProductVolumeAlert' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeAlert
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeAlert (1330)
#endif

/* prodml2__CurveDefinition * has binding name 'PointerToprodml2__CurveDefinition' for type 'prodml2:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CurveDefinition (1328)
#endif

/* prodml2__ProductVolumeParameterValue * has binding name 'PointerToprodml2__ProductVolumeParameterValue' for type 'prodml2:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeParameterValue (1326)
#endif

/* enum prodml2__ReportingDurationKind * has binding name 'PointerToprodml2__ReportingDurationKind' for type 'prodml2:ReportingDurationKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingDurationKind
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingDurationKind (1325)
#endif

/* enum eml21__MeasureClass * has binding name 'PointerToeml21__MeasureClass' for type 'eml21:MeasureClass' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MeasureClass
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MeasureClass (1324)
#endif

/* std::string * has binding name 'PointerToprodml2__ProdmlRelativeIdentifier' for type 'prodml2:ProdmlRelativeIdentifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProdmlRelativeIdentifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProdmlRelativeIdentifier (1323)
#endif

/* prodml2__ProductVolumeProduct * has binding name 'PointerToprodml2__ProductVolumeProduct' for type 'prodml2:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeProduct (1321)
#endif

/* prodml2__ProductVolumeRelatedFacility * has binding name 'PointerToprodml2__ProductVolumeRelatedFacility' for type 'prodml2:ProductVolumeRelatedFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeRelatedFacility
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeRelatedFacility (1320)
#endif

/* enum prodml2__FlowSubQualifier * has binding name 'PointerToprodml2__FlowSubQualifier' for type 'prodml2:FlowSubQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FlowSubQualifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FlowSubQualifier (1319)
#endif

/* enum prodml2__FlowQualifier * has binding name 'PointerToprodml2__FlowQualifier' for type 'prodml2:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FlowQualifier (1318)
#endif

/* enum prodml2__ProductFlowPortType * has binding name 'PointerToprodml2__ProductFlowPortType' for type 'prodml2:ProductFlowPortType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowPortType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowPortType (1317)
#endif

/* prodml2__DatedComment * has binding name 'PointerToprodml2__DatedComment' for type 'prodml2:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DatedComment
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DatedComment (1315)
#endif

/* prodml2__ProductVolumeParameterSet * has binding name 'PointerToprodml2__ProductVolumeParameterSet' for type 'prodml2:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeParameterSet (1313)
#endif

/* prodml2__ProductVolumeFlow * has binding name 'PointerToprodml2__ProductVolumeFlow' for type 'prodml2:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeFlow (1311)
#endif

/* eml21__TimeMeasure * has binding name 'PointerToeml21__TimeMeasure' for type 'eml21:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeMeasure (1310)
#endif

/* eml21__VolumeMeasure * has binding name 'PointerToeml21__VolumeMeasure' for type 'eml21:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeMeasure (1309)
#endif

/* enum prodml2__WellOperationMethod * has binding name 'PointerToprodml2__WellOperationMethod' for type 'prodml2:WellOperationMethod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellOperationMethod
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellOperationMethod (1308)
#endif

/* enum prodml2__WellFluid * has binding name 'PointerToprodml2__WellFluid' for type 'prodml2:WellFluid' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellFluid
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellFluid (1307)
#endif

/* enum eml21__WellStatus * has binding name 'PointerToeml21__WellStatus' for type 'eml21:WellStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__WellStatus
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__WellStatus (1306)
#endif

/* enum prodml2__BalanceDestinationType * has binding name 'PointerToprodml2__BalanceDestinationType' for type 'prodml2:BalanceDestinationType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BalanceDestinationType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BalanceDestinationType (1305)
#endif

/* prodml2__CommonPropertiesProductVolume * has binding name 'PointerToprodml2__CommonPropertiesProductVolume' for type 'prodml2:CommonPropertiesProductVolume' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CommonPropertiesProductVolume
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CommonPropertiesProductVolume (1304)
#endif

/* enum prodml2__ReportingProduct * has binding name 'PointerToprodml2__ReportingProduct' for type 'prodml2:ReportingProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingProduct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingProduct (1303)
#endif

/* prodml2__ProductVolumeBusinessSubUnit * has binding name 'PointerToprodml2__ProductVolumeBusinessSubUnit' for type 'prodml2:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBusinessSubUnit (1301)
#endif

/* prodml2__OwnershipBusinessAcct * has binding name 'PointerToprodml2__OwnershipBusinessAcct' for type 'prodml2:OwnershipBusinessAcct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OwnershipBusinessAcct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OwnershipBusinessAcct (1300)
#endif

/* prodml2__ProductVolumeDestination * has binding name 'PointerToprodml2__ProductVolumeDestination' for type 'prodml2:ProductVolumeDestination' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeDestination
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeDestination (1299)
#endif

/* prodml2__ProductVolumeBalanceDetail * has binding name 'PointerToprodml2__ProductVolumeBalanceDetail' for type 'prodml2:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceDetail (1297)
#endif

/* enum prodml2__BalanceFlowPart * has binding name 'PointerToprodml2__BalanceFlowPart' for type 'prodml2:BalanceFlowPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BalanceFlowPart
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BalanceFlowPart (1296)
#endif

/* prodml2__ProductVolumeBalanceEvent * has binding name 'PointerToprodml2__ProductVolumeBalanceEvent' for type 'prodml2:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBalanceEvent (1294)
#endif

/* prodml2__ProductVolumeComponentContent * has binding name 'PointerToprodml2__ProductVolumeComponentContent' for type 'prodml2:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeComponentContent (1292)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTobool
#define SOAP_TYPE_gsoap_eml2_1_PointerTobool (1290)
#endif

/* prodml2__FacilityParent * has binding name 'PointerToprodml2__FacilityParent' for type 'prodml2:FacilityParent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityParent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityParent (1288)
#endif

/* eml21__FlowRateValue * has binding name 'PointerToeml21__FlowRateValue' for type 'eml21:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FlowRateValue (1284)
#endif

/* eml21__VolumeValue * has binding name 'PointerToeml21__VolumeValue' for type 'eml21:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumeValue (1282)
#endif

/* prodml2__ProductVolumePortDifference * has binding name 'PointerToprodml2__ProductVolumePortDifference' for type 'prodml2:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumePortDifference (1280)
#endif

/* eml21__DensityValue * has binding name 'PointerToeml21__DensityValue' for type 'eml21:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DensityValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DensityValue (1278)
#endif

/* eml21__MassPerVolumeMeasure * has binding name 'PointerToeml21__MassPerVolumeMeasure' for type 'eml21:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerVolumeMeasure (1277)
#endif

/* eml21__EnergyPerVolumeMeasure * has binding name 'PointerToeml21__EnergyPerVolumeMeasure' for type 'eml21:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyPerVolumeMeasure (1276)
#endif

/* eml21__IsothermalCompressibilityMeasure * has binding name 'PointerToeml21__IsothermalCompressibilityMeasure' for type 'eml21:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IsothermalCompressibilityMeasure (1275)
#endif

/* eml21__DimensionlessMeasure * has binding name 'PointerToeml21__DimensionlessMeasure' for type 'eml21:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DimensionlessMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__DimensionlessMeasure (1274)
#endif

/* eml21__AmountOfSubstanceMeasure * has binding name 'PointerToeml21__AmountOfSubstanceMeasure' for type 'eml21:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AmountOfSubstanceMeasure (1273)
#endif

/* eml21__MolecularWeightMeasure * has binding name 'PointerToeml21__MolecularWeightMeasure' for type 'eml21:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MolecularWeightMeasure (1272)
#endif

/* eml21__MassPerTimeMeasure * has binding name 'PointerToeml21__MassPerTimeMeasure' for type 'eml21:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerTimeMeasure (1271)
#endif

/* eml21__EnergyMeasure * has binding name 'PointerToeml21__EnergyMeasure' for type 'eml21:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__EnergyMeasure (1270)
#endif

/* eml21__MassMeasure * has binding name 'PointerToeml21__MassMeasure' for type 'eml21:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassMeasure (1269)
#endif

/* eml21__ThermodynamicTemperatureMeasure * has binding name 'PointerToeml21__ThermodynamicTemperatureMeasure' for type 'eml21:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ThermodynamicTemperatureMeasure (1268)
#endif

/* eml21__PressureMeasure * has binding name 'PointerToeml21__PressureMeasure' for type 'eml21:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PressureMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__PressureMeasure (1267)
#endif

/* eml21__VolumePerVolumeMeasure * has binding name 'PointerToeml21__VolumePerVolumeMeasure' for type 'eml21:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__VolumePerVolumeMeasure (1266)
#endif

/* enum prodml2__ValueStatus * has binding name 'PointerToprodml2__ValueStatus' for type 'prodml2:ValueStatus' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ValueStatus
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ValueStatus (1265)
#endif

/* prodml2__ProductFlowUnit * has binding name 'PointerToprodml2__ProductFlowUnit' for type 'prodml2:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowUnit (1263)
#endif

/* prodml2__ProductFlowChangeLog * has binding name 'PointerToprodml2__ProductFlowChangeLog' for type 'prodml2:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowChangeLog (1261)
#endif

/* prodml2__ProductFlowNetworkPlan * has binding name 'PointerToprodml2__ProductFlowNetworkPlan' for type 'prodml2:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowNetworkPlan (1259)
#endif

/* prodml2__ProductFlowExternalPort * has binding name 'PointerToprodml2__ProductFlowExternalPort' for type 'prodml2:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductFlowExternalPort (1257)
#endif

/* prodml2__NorthSeaOffshore * has binding name 'PointerToprodml2__NorthSeaOffshore' for type 'prodml2:NorthSeaOffshore' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NorthSeaOffshore
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NorthSeaOffshore (1256)
#endif

/* prodml2__FluidComponent * has binding name 'PointerToprodml2__FluidComponent' for type 'prodml2:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FluidComponent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FluidComponent (1254)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTostd__string
#define SOAP_TYPE_gsoap_eml2_1_PointerTostd__string (1253)
#endif

/* prodml2__WellVerticalDepthCoord * has binding name 'PointerToprodml2__WellVerticalDepthCoord' for type 'prodml2:WellVerticalDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellVerticalDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__WellVerticalDepthCoord (1252)
#endif

/* prodml2__MeasuredDepthCoord * has binding name 'PointerToprodml2__MeasuredDepthCoord' for type 'prodml2:MeasuredDepthCoord' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__MeasuredDepthCoord
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__MeasuredDepthCoord (1251)
#endif

/* enum prodml2__GeologyType * has binding name 'PointerToprodml2__GeologyType' for type 'prodml2:GeologyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeologyType
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeologyType (1250)
#endif

/* prodml2__OffshoreLocation * has binding name 'PointerToprodml2__OffshoreLocation' for type 'prodml2:OffshoreLocation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OffshoreLocation
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__OffshoreLocation (1249)
#endif

/* enum prodml2__AddressKindEnum * has binding name 'PointerToprodml2__AddressKindEnum' for type 'prodml2:AddressKindEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AddressKindEnum
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AddressKindEnum (1248)
#endif

/* prodml2__PlusFluidComponent * has binding name 'PointerToprodml2__PlusFluidComponent' for type 'prodml2:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PlusFluidComponent (1246)
#endif

/* prodml2__PseudoFluidComponent * has binding name 'PointerToprodml2__PseudoFluidComponent' for type 'prodml2:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PseudoFluidComponent (1244)
#endif

/* prodml2__PureFluidComponent * has binding name 'PointerToprodml2__PureFluidComponent' for type 'prodml2:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PureFluidComponent (1242)
#endif

/* prodml2__FormationWater * has binding name 'PointerToprodml2__FormationWater' for type 'prodml2:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FormationWater
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FormationWater (1240)
#endif

/* prodml2__NaturalGas * has binding name 'PointerToprodml2__NaturalGas' for type 'prodml2:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NaturalGas
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NaturalGas (1238)
#endif

/* prodml2__StockTankOil * has binding name 'PointerToprodml2__StockTankOil' for type 'prodml2:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__StockTankOil
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__StockTankOil (1236)
#endif

/* enum prodml2__ReportingFacility * has binding name 'PointerToprodml2__ReportingFacility' for type 'prodml2:ReportingFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingFacility
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ReportingFacility (1235)
#endif

/* prodml2__GeographicContext * has binding name 'PointerToprodml2__GeographicContext' for type 'prodml2:GeographicContext' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeographicContext
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeographicContext (1234)
#endif

/* prodml2__ProductVolumeBusinessUnit * has binding name 'PointerToprodml2__ProductVolumeBusinessUnit' for type 'prodml2:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__ProductVolumeBusinessUnit (1233)
#endif

/* prodml2__FacilityIdentifierStruct * has binding name 'PointerToprodml2__FacilityIdentifierStruct' for type 'prodml2:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__FacilityIdentifierStruct (1232)
#endif

/* enum prodml2__EndpointQualifier * has binding name 'PointerToprodml2__EndpointQualifier' for type 'prodml2:EndpointQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EndpointQualifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EndpointQualifier (1231)
#endif

/* enum prodml2__AddressQualifier * has binding name 'PointerToprodml2__AddressQualifier' for type 'prodml2:AddressQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AddressQualifier
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__AddressQualifier (1230)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTodateTime
#define SOAP_TYPE_gsoap_eml2_1_PointerTodateTime (1229)
#endif

/* std::string * has binding name 'PointerToeml21__UomEnum' for type 'eml21:UomEnum' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UomEnum
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UomEnum (1227)
#endif

/* prodml2__PersonName * has binding name 'PointerToprodml2__PersonName' for type 'prodml2:PersonName' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PersonName
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PersonName (1226)
#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_eml2_1_PointerToxsd__nonNegativeInteger (1225)
#endif

/* prodml2__EmailQualifierStruct * has binding name 'PointerToprodml2__EmailQualifierStruct' for type 'prodml2:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__EmailQualifierStruct (1222)
#endif

/* prodml2__PhoneNumberStruct * has binding name 'PointerToprodml2__PhoneNumberStruct' for type 'prodml2:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__PhoneNumberStruct (1220)
#endif

/* prodml2__GeneralAddress * has binding name 'PointerToprodml2__GeneralAddress' for type 'prodml2:GeneralAddress' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeneralAddress
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__GeneralAddress (1219)
#endif

/* prodml2__NameStruct * has binding name 'PointerToprodml2__NameStruct' for type 'prodml2:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NameStruct
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__NameStruct (1217)
#endif

/* eml21__AmountOfSubstancePerAmountOfSubstanceMeasure * has binding name 'PointerToeml21__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml21:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AmountOfSubstancePerAmountOfSubstanceMeasure (1216)
#endif

/* eml21__MassPerMassMeasure * has binding name 'PointerToeml21__MassPerMassMeasure' for type 'eml21:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerMassMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__MassPerMassMeasure (1215)
#endif

/* __prodml2__AbstractDateTimeClass_sequence * has binding name 'PointerTo__prodml2__AbstractDateTimeClass_sequence' for type '-prodml2:AbstractDateTimeClass-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__AbstractDateTimeClass_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__AbstractDateTimeClass_sequence (1214)
#endif

/* std::string * has binding name 'PointerToprodml2__CalendarMonth' for type 'prodml2:CalendarMonth' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalendarMonth
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalendarMonth (1213)
#endif

/* eml21__ExtensionNameValue * has binding name 'PointerToeml21__ExtensionNameValue' for type 'eml21:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__ExtensionNameValue (1210)
#endif

/* prodml2__CalibrationParameter * has binding name 'PointerToprodml2__CalibrationParameter' for type 'prodml2:CalibrationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__CalibrationParameter (1208)
#endif

/* __prodml2__DtsPatchCord_sequence * has binding name 'PointerTo__prodml2__DtsPatchCord_sequence' for type '-prodml2:DtsPatchCord-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DtsPatchCord_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DtsPatchCord_sequence (1207)
#endif

/* prodml2__BusinessAssociate * has binding name 'PointerToprodml2__BusinessAssociate' for type 'prodml2:BusinessAssociate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BusinessAssociate
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__BusinessAssociate (1205)
#endif

/* std::string * has binding name 'PointerToxsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToxsd__date
#define SOAP_TYPE_gsoap_eml2_1_PointerToxsd__date (1204)
#endif

/* __prodml2__DasTimeArray_sequence * has binding name 'PointerTo__prodml2__DasTimeArray_sequence' for type '-prodml2:DasTimeArray-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DasTimeArray_sequence
#define SOAP_TYPE_gsoap_eml2_1_PointerTo__prodml2__DasTimeArray_sequence (1203)
#endif

/* eml21__IntegerExternalArray * has binding name 'PointerToeml21__IntegerExternalArray' for type 'eml21:IntegerExternalArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IntegerExternalArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__IntegerExternalArray (1202)
#endif

/* std::string * has binding name 'PointerToeml21__TimeStamp' for type 'eml21:TimeStamp' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeStamp
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__TimeStamp (1201)
#endif

/* prodml2__DasSpectraData * has binding name 'PointerToprodml2__DasSpectraData' for type 'prodml2:DasSpectraData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasSpectraData
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasSpectraData (1199)
#endif

/* prodml2__DasRawData * has binding name 'PointerToprodml2__DasRawData' for type 'prodml2:DasRawData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasRawData
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasRawData (1198)
#endif

/* prodml2__DasSpectra * has binding name 'PointerToprodml2__DasSpectra' for type 'prodml2:DasSpectra' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasSpectra
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasSpectra (1196)
#endif

/* prodml2__DasFbe * has binding name 'PointerToprodml2__DasFbe' for type 'prodml2:DasFbe' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasFbe
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasFbe (1194)
#endif

/* eml21__AbstractNumericArray * has binding name 'PointerToeml21__AbstractNumericArray' for type 'eml21:AbstractNumericArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractNumericArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__AbstractNumericArray (1193)
#endif

/* prodml2__DasCustom * has binding name 'PointerToprodml2__DasCustom' for type 'prodml2:DasCustom' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCustom
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCustom (1191)
#endif

/* prodml2__DasTimeArray * has binding name 'PointerToprodml2__DasTimeArray' for type 'prodml2:DasTimeArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasTimeArray
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasTimeArray (1190)
#endif

/* prodml2__DasFbeData * has binding name 'PointerToprodml2__DasFbeData' for type 'prodml2:DasFbeData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasFbeData
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasFbeData (1188)
#endif

/* std::string * has binding name 'PointerToeml21__UuidString' for type 'eml21:UuidString' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UuidString
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__UuidString (1187)
#endif

/* eml21__FrequencyMeasure * has binding name 'PointerToeml21__FrequencyMeasure' for type 'eml21:FrequencyMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FrequencyMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__FrequencyMeasure (1186)
#endif

/* std::string * has binding name 'PointerToprodml2__DasCalibrationTypeExt' for type 'prodml2:DasCalibrationTypeExt' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibrationTypeExt
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibrationTypeExt (1185)
#endif

/* eml21__LengthMeasure * has binding name 'PointerToeml21__LengthMeasure' for type 'eml21:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthMeasure
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__LengthMeasure (1184)
#endif

/* prodml2__DasCalibrationPoint * has binding name 'PointerToprodml2__DasCalibrationPoint' for type 'prodml2:DasCalibrationPoint' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibrationPoint
#define SOAP_TYPE_gsoap_eml2_1_PointerToprodml2__DasCalibrationPoint (1181)
#endif

/* enum eml21__WellboreDatumReference * has binding name 'PointerToeml21__WellboreDatumReference' for type 'eml21:WellboreDatumReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__WellboreDatumReference
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__WellboreDatumReference (1180)
#endif

/* std::string * has binding name 'PointerToeml21__String64' for type 'eml21:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__String64
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__String64 (1179)
#endif

/* std::string * has binding name 'PointerToeml21__String2000' for type 'eml21:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToeml21__String2000
#define SOAP_TYPE_gsoap_eml2_1_PointerToeml21__String2000 (1178)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_eml2_1_PointerToULONG64
#define SOAP_TYPE_gsoap_eml2_1_PointerToULONG64 (1177)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_gsoap_eml2_1__QName
#define SOAP_TYPE_gsoap_eml2_1__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1__XML
#define SOAP_TYPE_gsoap_eml2_1__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_1_string
#define SOAP_TYPE_gsoap_eml2_1_string (4)
#endif

/* std::vector<_gml__coordinateOperationAccuracy *>  has binding name 'std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy (1676)
#endif

/* std::vector<gml__CoordinateSystemAxisPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType (1671)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfstd__string
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfstd__string (1669)
#endif

/* std::vector<_gml__domainOfValidity *>  has binding name 'std__vectorTemplateOfPointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTo_gml__domainOfValidity
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTo_gml__domainOfValidity (1668)
#endif

/* std::vector<eml21__IntegerConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml21__IntegerConstantArray' for type 'eml21:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__IntegerConstantArray
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__IntegerConstantArray (1665)
#endif

/* std::vector<eml21__FloatingPointConstantArray *>  has binding name 'std__vectorTemplateOfPointerToeml21__FloatingPointConstantArray' for type 'eml21:FloatingPointConstantArray' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FloatingPointConstantArray
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FloatingPointConstantArray (1662)
#endif

/* std::vector<gml__RelatedTimeType *>  has binding name 'std__vectorTemplateOfPointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__RelatedTimeType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__RelatedTimeType (1660)
#endif

/* std::vector<prodml2__FiberOneWayAttenuation *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberOneWayAttenuation' for type 'prodml2:FiberOneWayAttenuation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOneWayAttenuation
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOneWayAttenuation (1655)
#endif

/* std::vector<prodml2__FiberRefractiveIndex *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberRefractiveIndex' for type 'prodml2:FiberRefractiveIndex' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberRefractiveIndex
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberRefractiveIndex (1652)
#endif

/* std::vector<__prodml2__FiberConnection_sequence>  has binding name 'std__vectorTemplateOf__prodml2__FiberConnection_sequence' for type '-prodml2:FiberConnection-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf__prodml2__FiberConnection_sequence
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf__prodml2__FiberConnection_sequence (1648)
#endif

/* std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType (1636)
#endif

/* std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType (1634)
#endif

/* std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType (1632)
#endif

/* std::vector<gmd__CI_USCOREDate_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType (1630)
#endif

/* std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType (1628)
#endif

/* std::vector<gco__DateTime_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType (1626)
#endif

/* std::vector<gco__CharacterString_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType (1621)
#endif

/* std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType (1616)
#endif

/* std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType (1614)
#endif

/* std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType (1612)
#endif

/* std::vector<eml21__AbstractGraphicalInformation *>  has binding name 'std__vectorTemplateOfPointerToeml21__AbstractGraphicalInformation' for type 'eml21:AbstractGraphicalInformation' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractGraphicalInformation
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractGraphicalInformation (1607)
#endif

/* std::vector<eml21__FailingRule *>  has binding name 'std__vectorTemplateOfPointerToeml21__FailingRule' for type 'eml21:FailingRule' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FailingRule
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FailingRule (1604)
#endif

/* std::vector<eml21__GeologicTime *>  has binding name 'std__vectorTemplateOfPointerToeml21__GeologicTime' for type 'eml21:GeologicTime' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__GeologicTime
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__GeologicTime (1590)
#endif

/* std::vector<eml21__PropertyKind *>  has binding name 'std__vectorTemplateOfPointerToeml21__PropertyKind' for type 'eml21:PropertyKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__PropertyKind
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__PropertyKind (1588)
#endif

/* std::vector<eml21__ParameterTemplate *>  has binding name 'std__vectorTemplateOfPointerToeml21__ParameterTemplate' for type 'eml21:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ParameterTemplate
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ParameterTemplate (1586)
#endif

/* std::vector<prodml2__FiberOTDR *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberOTDR' for type 'prodml2:FiberOTDR' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOTDR
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOTDR (1584)
#endif

/* std::vector<prodml2__FiberPathDefect *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberPathDefect' for type 'prodml2:FiberPathDefect' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberPathDefect
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberPathDefect (1582)
#endif

/* std::vector<prodml2__FiberFacilityMapping *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberFacilityMapping' for type 'prodml2:FiberFacilityMapping' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberFacilityMapping
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberFacilityMapping (1580)
#endif

/* std::vector<prodml2__FiberOpticalPathNetwork *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberOpticalPathNetwork' for type 'prodml2:FiberOpticalPathNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOpticalPathNetwork
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOpticalPathNetwork (1578)
#endif

/* std::vector<prodml2__FiberPumpActivity *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberPumpActivity' for type 'prodml2:FiberPumpActivity' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberPumpActivity
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberPumpActivity (1575)
#endif

/* std::vector<enum prodml2__FlowQualifier>  has binding name 'std__vectorTemplateOfprodml2__FlowQualifier' for type 'prodml2:FlowQualifier' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfprodml2__FlowQualifier
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfprodml2__FlowQualifier (1573)
#endif

/* std::vector<prodml2__ProductVolumeBusinessUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessUnit' for type 'prodml2:ProductVolumeBusinessUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessUnit
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessUnit (1569)
#endif

/* std::vector<prodml2__ProductVolumeFacility *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeFacility' for type 'prodml2:ProductVolumeFacility' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeFacility
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeFacility (1568)
#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfdouble
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfdouble (1559)
#endif

/* std::vector<ULONG64>  has binding name 'std__vectorTemplateOfULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfULONG64
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfULONG64 (1558)
#endif

/* std::vector<prodml2__DtsCalibration *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DtsCalibration' for type 'prodml2:DtsCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DtsCalibration
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DtsCalibration (1548)
#endif

/* std::vector<prodml2__IndexedObject *>  has binding name 'std__vectorTemplateOfPointerToprodml2__IndexedObject' for type 'prodml2:IndexedObject' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__IndexedObject
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__IndexedObject (1543)
#endif

/* std::vector<prodml2__DasCalibration *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasCalibration' for type 'prodml2:DasCalibration' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasCalibration
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasCalibration (1538)
#endif

/* std::vector<prodml2__DasRaw *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasRaw' for type 'prodml2:DasRaw' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasRaw
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasRaw (1536)
#endif

/* std::vector<gml__CodeType *>  has binding name 'std__vectorTemplateOfPointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__CodeType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerTogml__CodeType (1412)
#endif

/* std::vector<eml21__AbstractActivityParameter *>  has binding name 'std__vectorTemplateOfPointerToeml21__AbstractActivityParameter' for type 'eml21:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractActivityParameter
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractActivityParameter (1400)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml21__String2000' for type 'eml21:String2000' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__String2000
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__String2000 (1398)
#endif

/* std::vector<enum eml21__ParameterKind>  has binding name 'std__vectorTemplateOfeml21__ParameterKind' for type 'eml21:ParameterKind' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__ParameterKind
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__ParameterKind (1397)
#endif

/* std::vector<eml21__AbstractParameterKey *>  has binding name 'std__vectorTemplateOfPointerToeml21__AbstractParameterKey' for type 'eml21:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractParameterKey
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__AbstractParameterKey (1396)
#endif

/* std::vector<eml21__ExternalDatasetPart *>  has binding name 'std__vectorTemplateOfPointerToeml21__ExternalDatasetPart' for type 'eml21:ExternalDatasetPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ExternalDatasetPart
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ExternalDatasetPart (1392)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf_XML
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf_XML (1385)
#endif

/* std::vector<eml21__ObjectAlias *>  has binding name 'std__vectorTemplateOfPointerToeml21__ObjectAlias' for type 'eml21:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ObjectAlias
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ObjectAlias (1381)
#endif

/* std::vector<__prodml2__FiberPathDefect_sequence>  has binding name 'std__vectorTemplateOf__prodml2__FiberPathDefect_sequence' for type '-prodml2:FiberPathDefect-sequence' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf__prodml2__FiberPathDefect_sequence
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOf__prodml2__FiberPathDefect_sequence (1379)
#endif

/* std::vector<prodml2__ProductFlowNetwork *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowNetwork' for type 'prodml2:ProductFlowNetwork' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowNetwork
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowNetwork (1375)
#endif

/* std::vector<prodml2__ProductFlowExternalReference *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowExternalReference' for type 'prodml2:ProductFlowExternalReference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExternalReference
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExternalReference (1373)
#endif

/* std::vector<prodml2__FiberSplice *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberSplice' for type 'prodml2:FiberSplice' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberSplice
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberSplice (1370)
#endif

/* std::vector<prodml2__FiberOpticalPathSegment *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberOpticalPathSegment' for type 'prodml2:FiberOpticalPathSegment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOpticalPathSegment
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberOpticalPathSegment (1367)
#endif

/* std::vector<prodml2__FiberTurnaround *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberTurnaround' for type 'prodml2:FiberTurnaround' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberTurnaround
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberTurnaround (1365)
#endif

/* std::vector<prodml2__FiberConnection *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberConnection' for type 'prodml2:FiberConnection' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberConnection
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberConnection (1363)
#endif

/* std::vector<prodml2__FiberFacilityMappingPart *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FiberFacilityMappingPart' for type 'prodml2:FiberFacilityMappingPart' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberFacilityMappingPart
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FiberFacilityMappingPart (1358)
#endif

/* std::vector<prodml2__ProductFlowPort *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowPort' for type 'prodml2:ProductFlowPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowPort
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowPort (1354)
#endif

/* std::vector<prodml2__FacilityIdentifierStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FacilityIdentifierStruct' for type 'prodml2:FacilityIdentifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FacilityIdentifierStruct
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FacilityIdentifierStruct (1352)
#endif

/* std::vector<prodml2__ConnectedNode *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ConnectedNode' for type 'prodml2:ConnectedNode' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ConnectedNode
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ConnectedNode (1351)
#endif

/* std::vector<prodml2__ProductFlowExpectedUnitProperty *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowExpectedUnitProperty' for type 'prodml2:ProductFlowExpectedUnitProperty' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExpectedUnitProperty
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExpectedUnitProperty (1349)
#endif

/* std::vector<prodml2__ProductFlowQualifierExpected *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowQualifierExpected' for type 'prodml2:ProductFlowQualifierExpected' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowQualifierExpected
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowQualifierExpected (1347)
#endif

/* std::vector<prodml2__ProductVolumePeriod *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumePeriod' for type 'prodml2:ProductVolumePeriod' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumePeriod
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumePeriod (1340)
#endif

/* std::vector<prodml2__ProductVolumeBalanceSet *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceSet' for type 'prodml2:ProductVolumeBalanceSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceSet
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceSet (1334)
#endif

/* std::vector<prodml2__AbstractMeasureDataType *>  has binding name 'std__vectorTemplateOfPointerToprodml2__AbstractMeasureDataType' for type 'prodml2:AbstractMeasureDataType' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__AbstractMeasureDataType
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__AbstractMeasureDataType (1332)
#endif

/* std::vector<prodml2__CurveDefinition *>  has binding name 'std__vectorTemplateOfPointerToprodml2__CurveDefinition' for type 'prodml2:CurveDefinition' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__CurveDefinition
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__CurveDefinition (1329)
#endif

/* std::vector<prodml2__ProductVolumeParameterValue *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterValue' for type 'prodml2:ProductVolumeParameterValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterValue
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterValue (1327)
#endif

/* std::vector<prodml2__ProductVolumeProduct *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeProduct' for type 'prodml2:ProductVolumeProduct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeProduct
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeProduct (1322)
#endif

/* std::vector<prodml2__DatedComment *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DatedComment' for type 'prodml2:DatedComment' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DatedComment
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DatedComment (1316)
#endif

/* std::vector<prodml2__ProductVolumeParameterSet *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterSet' for type 'prodml2:ProductVolumeParameterSet' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterSet
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeParameterSet (1314)
#endif

/* std::vector<prodml2__ProductVolumeFlow *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeFlow' for type 'prodml2:ProductVolumeFlow' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeFlow
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeFlow (1312)
#endif

/* std::vector<prodml2__ProductVolumeBusinessSubUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessSubUnit' for type 'prodml2:ProductVolumeBusinessSubUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessSubUnit
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBusinessSubUnit (1302)
#endif

/* std::vector<prodml2__ProductVolumeBalanceDetail *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceDetail' for type 'prodml2:ProductVolumeBalanceDetail' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceDetail
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceDetail (1298)
#endif

/* std::vector<prodml2__ProductVolumeBalanceEvent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceEvent' for type 'prodml2:ProductVolumeBalanceEvent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceEvent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeBalanceEvent (1295)
#endif

/* std::vector<prodml2__ProductVolumeComponentContent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumeComponentContent' for type 'prodml2:ProductVolumeComponentContent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeComponentContent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumeComponentContent (1293)
#endif

/* std::vector<eml21__FlowRateValue *>  has binding name 'std__vectorTemplateOfPointerToeml21__FlowRateValue' for type 'eml21:FlowRateValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FlowRateValue
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__FlowRateValue (1285)
#endif

/* std::vector<eml21__VolumeValue *>  has binding name 'std__vectorTemplateOfPointerToeml21__VolumeValue' for type 'eml21:VolumeValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__VolumeValue
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__VolumeValue (1283)
#endif

/* std::vector<prodml2__ProductVolumePortDifference *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductVolumePortDifference' for type 'prodml2:ProductVolumePortDifference' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumePortDifference
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductVolumePortDifference (1281)
#endif

/* std::vector<eml21__DensityValue *>  has binding name 'std__vectorTemplateOfPointerToeml21__DensityValue' for type 'eml21:DensityValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__DensityValue
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__DensityValue (1279)
#endif

/* std::vector<prodml2__ProductFlowUnit *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowUnit' for type 'prodml2:ProductFlowUnit' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowUnit
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowUnit (1264)
#endif

/* std::vector<prodml2__ProductFlowChangeLog *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowChangeLog' for type 'prodml2:ProductFlowChangeLog' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowChangeLog
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowChangeLog (1262)
#endif

/* std::vector<prodml2__ProductFlowNetworkPlan *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowNetworkPlan' for type 'prodml2:ProductFlowNetworkPlan' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowNetworkPlan
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowNetworkPlan (1260)
#endif

/* std::vector<prodml2__ProductFlowExternalPort *>  has binding name 'std__vectorTemplateOfPointerToprodml2__ProductFlowExternalPort' for type 'prodml2:ProductFlowExternalPort' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExternalPort
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__ProductFlowExternalPort (1258)
#endif

/* std::vector<prodml2__FluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FluidComponent' for type 'prodml2:FluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FluidComponent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FluidComponent (1255)
#endif

/* std::vector<prodml2__PlusFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__PlusFluidComponent' for type 'prodml2:PlusFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PlusFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PlusFluidComponent (1247)
#endif

/* std::vector<prodml2__PseudoFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__PseudoFluidComponent' for type 'prodml2:PseudoFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PseudoFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PseudoFluidComponent (1245)
#endif

/* std::vector<prodml2__PureFluidComponent *>  has binding name 'std__vectorTemplateOfPointerToprodml2__PureFluidComponent' for type 'prodml2:PureFluidComponent' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PureFluidComponent
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PureFluidComponent (1243)
#endif

/* std::vector<prodml2__FormationWater *>  has binding name 'std__vectorTemplateOfPointerToprodml2__FormationWater' for type 'prodml2:FormationWater' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FormationWater
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__FormationWater (1241)
#endif

/* std::vector<prodml2__NaturalGas *>  has binding name 'std__vectorTemplateOfPointerToprodml2__NaturalGas' for type 'prodml2:NaturalGas' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__NaturalGas
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__NaturalGas (1239)
#endif

/* std::vector<prodml2__StockTankOil *>  has binding name 'std__vectorTemplateOfPointerToprodml2__StockTankOil' for type 'prodml2:StockTankOil' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__StockTankOil
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__StockTankOil (1237)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfeml21__String64' for type 'eml21:String64' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__String64
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfeml21__String64 (1224)
#endif

/* std::vector<prodml2__EmailQualifierStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml2__EmailQualifierStruct' for type 'prodml2:EmailQualifierStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__EmailQualifierStruct
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__EmailQualifierStruct (1223)
#endif

/* std::vector<prodml2__PhoneNumberStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml2__PhoneNumberStruct' for type 'prodml2:PhoneNumberStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PhoneNumberStruct
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__PhoneNumberStruct (1221)
#endif

/* std::vector<prodml2__NameStruct *>  has binding name 'std__vectorTemplateOfPointerToprodml2__NameStruct' for type 'prodml2:NameStruct' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__NameStruct
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__NameStruct (1218)
#endif

/* std::vector<eml21__ExtensionNameValue *>  has binding name 'std__vectorTemplateOfPointerToeml21__ExtensionNameValue' for type 'eml21:ExtensionNameValue' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ExtensionNameValue
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToeml21__ExtensionNameValue (1211)
#endif

/* std::vector<prodml2__CalibrationParameter *>  has binding name 'std__vectorTemplateOfPointerToprodml2__CalibrationParameter' for type 'prodml2:CalibrationParameter' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__CalibrationParameter
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__CalibrationParameter (1209)
#endif

/* std::vector<prodml2__DasSpectra *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasSpectra' for type 'prodml2:DasSpectra' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasSpectra
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasSpectra (1197)
#endif

/* std::vector<prodml2__DasFbe *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasFbe' for type 'prodml2:DasFbe' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasFbe
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasFbe (1195)
#endif

/* std::vector<enum prodml2__DasDimensions>  has binding name 'std__vectorTemplateOfprodml2__DasDimensions' for type 'prodml2:DasDimensions' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfprodml2__DasDimensions
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfprodml2__DasDimensions (1192)
#endif

/* std::vector<prodml2__DasFbeData *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasFbeData' for type 'prodml2:DasFbeData' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasFbeData
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasFbeData (1189)
#endif

/* std::vector<prodml2__DasCalibrationPoint *>  has binding name 'std__vectorTemplateOfPointerToprodml2__DasCalibrationPoint' for type 'prodml2:DasCalibrationPoint' */
#ifndef SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasCalibrationPoint
#define SOAP_TYPE_gsoap_eml2_1_std__vectorTemplateOfPointerToprodml2__DasCalibrationPoint (1182)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_eml2_1


#endif

/* End of gsoap_eml2_1Stub.h */

